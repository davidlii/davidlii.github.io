<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"> 
  
  <title>
    
      SDWebImage | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Davidli</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Davidli</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>SDWebImage</h2>
  <p class="post-date">2018-01-28</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="一、导入-SD库："><a href="#一、导入-SD库：" class="headerlink" title="一、导入 SD库："></a>一、导入 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SD库</a>：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;10.0&apos;</span><br><span class="line">//ASDF替换为自己项目的target名</span><br><span class="line">target ‘ASDF’ do</span><br><span class="line">pod &apos;SDWebImage&apos;, &apos;~&gt; 3.7.3&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="二、下载类的实现"><a href="#二、下载类的实现" class="headerlink" title="二、下载类的实现"></a>二、下载类的实现</h3><p>以常用的<code>UIImageView</code>设置图片为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url </span><br><span class="line">          placeholderImage:(UIImage *)placeholder </span><br><span class="line">                   options:(SDWebImageOptions)options </span><br><span class="line">                  progress:(SDWebImageDownloaderProgressBlock)progressBlock </span><br><span class="line">                 completed:(SDWebImageCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>url为图片地址。</li>
<li>placeholder为占位图。</li>
<li>progressBlock为进度。</li>
<li>completedBlock下载完成或有缓存时的回调。</li>
<li>options为额外选项，一般使用 SDWebImageRetryFailed | SDWebImageLowPriority，具体如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line"></span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,    //下载失败了会再次尝试下载(默认情况下失败的图片链接不会再重新下载)</span><br><span class="line">    WebImageLowPriority = 1 &lt;&lt; 1,      //UIScrollView等正在滚动时延迟下载图片（默认情况下不延迟，立刻开始）</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//只缓存到内存中</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,// 图片会边下边显示</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4, //强制重新请求图片并刷新缓存，将硬盘缓存交给系统自带的NSURLCache去处理</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,//后台下载</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6, //处理cookie，请求的request.HTTPShouldHandleCookies 会被置为 YES;</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,// 允许不受信任的SSL证书</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,  //优先下载，下载任务的优先级为高</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,//延迟占位符</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,//改变动画形象</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-UIImageView-WebCache"><a href="#2-1-UIImageView-WebCache" class="headerlink" title="2.1.UIImageView+WebCache"></a>2.1.UIImageView+WebCache</h4><p>主要负责对外暴露设置图片的接口，本类中具体处理的事项包括：</p>
<ul>
<li>step.1 在新的图片加载前，取消本视图上一个正在进行的下载任务；</li>
<li>step.2 交由 SDWebImageManager 处理真正的图片下载逻辑；</li>
<li>step.3 保存此次下载操作；</li>
<li>step.4 图片下载成功或失败，回到主线程回调数据并给视图设置图片；</li>
</ul>
<p>源码摘要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// UIImageView+WebCache.m</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(NSURL *)url</span><br><span class="line">placeholderImage:(UIImage *)placeholder</span><br><span class="line">options:(SDWebImageOptions)options</span><br><span class="line">progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">completed:(SDWebImageCompletionBlock)completedBlock</span><br><span class="line">&#123;</span><br><span class="line">    //step.1 取消之前正在下载的操作</span><br><span class="line">    [self sd_cancelCurrentImageLoad];</span><br><span class="line">    //保存该视图用到的图片URL</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    /*...*/</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        //step.2 由SDWebImageManager下载图片</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager</span><br><span class="line">        downloadImageWithURL:url</span><br><span class="line">        options:options</span><br><span class="line">        progress:progressBlock</span><br><span class="line">        completed:^(UIImage *image,</span><br><span class="line">        NSError *error, SDImageCacheType cacheType,</span><br><span class="line">        BOOL finished, NSURL *imageURL)</span><br><span class="line">        &#123;</span><br><span class="line">            /*step.4 图片下载结果返回，回到主线层*/</span><br><span class="line">        &#125;];</span><br><span class="line">        //step.3 保存此次下载操作</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现细节：</p>
<ul>
<li>1、创建下载任务</li>
</ul>
<p>图片的下载任务是由 SDWebImageManager 执行的，它的实现细节后面会讲，这里只需要知道下载的操作经过两次封装，最终被封装到 SDWebImageCombinedOperation 对象中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel; // 只定义了这么一个取消的方法~~</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, getter = isCancelled) BOOL cancelled;</span><br><span class="line">@property (copy, nonatomic) SDWebImageNoParamsBlock cancelBlock; // 在创建任务时会被赋值</span><br><span class="line">@property (strong, nonatomic) NSOperation *cacheOperation; // 真正执行下载任务的类</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在视图的分类中调用 SDWebImageManager 进行下载时，会返回一个 SDWebImageCombinedOperation 任务对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageManager.m</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock&#123;</span><br><span class="line">                                       </span><br><span class="line">                        __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">                        // 略...</span><br><span class="line">                        return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2、保存下载任务</li>
</ul>
<p>上面返回的 SDWebImageCombinedOperation 任务对象会被保存到当前视图的对象中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// UIImageView+WebCache.m</span><br><span class="line">[self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br></pre></td></tr></table></figure>
<p>保存接口的具体逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 属性Getter</span><br><span class="line">- (NSMutableDictionary *)operationDictionary &#123;</span><br><span class="line">    // 如果关联对象存在，则返回它</span><br><span class="line">    NSMutableDictionary *operations = objc_getAssociatedObject(self, &amp;loadOperationKey);</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        return operations;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果关联对象不存在，则创建一个新的并返回它</span><br><span class="line">    operations = [NSMutableDictionary dictionary];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    return operations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 保存任务</span><br><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    // 如果同一个视图之前有下载任务，则先取消之前的任务</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载任务会被保存到当前分类中的 operationDictionary 字典属性中，此属性使用了对象关联技术提供了Getter和Setter的实现。</p>
<ul>
<li>3、取消上一个正在进行的下载任务；</li>
</ul>
<p>场景：cell 被重用时上一张图片尚未加载完，需要取消上一次的加载任务并加载新的图片。<br>&emsp;</p>
<p>当前视图中所有的下载任务都保存在<code>operationDictionary</code>中，取消任务时要先从此字典中取出之前的任务，再执行取消方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_cancelCurrentImageLoad &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    // Cancel in progress downloader from queue</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    // 取出任务</span><br><span class="line">    id operations = [operationDictionary objectForKey:key];</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel]; // 取消</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel]; // 取消</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];  //从字典中移除上一个任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消操作调用的是 SDWebImageCombinedOperation 对象 的 cancel 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    self.cancelled = YES;</span><br><span class="line">    if (self.cacheOperation) &#123;</span><br><span class="line">        [self.cacheOperation cancel];</span><br><span class="line">        self.cacheOperation = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.cancelBlock) &#123;</span><br><span class="line">        self.cancelBlock();</span><br><span class="line">        </span><br><span class="line">        // TODO: this is a temporary fix to #809.</span><br><span class="line">        // Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span><br><span class="line">//        self.cancelBlock = nil;</span><br><span class="line">        _cancelBlock = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，最终取消的是真正的图片下载任务<code>cacheOperation</code>对象，这是一个 NSOperation 实例。</p>
<h4 id="2-2-SDWebImageManager"><a href="#2-2-SDWebImageManager" class="headerlink" title="2.2.SDWebImageManager"></a>2.2.SDWebImageManager</h4><p>上面视图分类中只简单的取消和保存了任务的实例，具体的下载任务交给了<code>SDWebImageManager</code>。本章节就来讲解此类的具体业务：<br>&emsp;</p>
<p>此类主要用来做具体下载前的各项检测和准备以及处理图片下载成功后的变换、缓存等：</p>
<ul>
<li>step.1 检测URL之前是否下载失败（失效过的链接不再重复下载）；</li>
<li>step.2 根据URL生成对应的key查询缓存，有缓存且不要求强制刷新缓存时直接使用缓存图片；</li>
<li>step.3 没有缓存时，交给 SDWebImageDownloader，封装请求并创建任务和队列，发起网络请求；</li>
<li>step.4 下载完成后对图片做变换、缓存图片、返回主线程；</li>
</ul>
<p>源码摘要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageManager.m</span><br><span class="line"></span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">options:(SDWebImageOptions)options</span><br><span class="line">progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">completed:(SDWebImageCompletionWithFinishedBlock)completedBlock</span><br><span class="line">&#123;</span><br><span class="line">    /*...*/</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line"></span><br><span class="line">    //step.1 检测URL之前是否下载失败</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //URL错误或之前下载失败过，则不再重复下载失效的URL</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error = ...;</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将当前下载 operation 加入到数组中</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //step.2 根据URL生成对应的key查询缓存 没有缓存则开始下载</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key</span><br><span class="line">                                                done:^(UIImage *image, SDImageCacheType cacheType)&#123;</span><br><span class="line">    /*...*/</span><br><span class="line">    if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp;</span><br><span class="line">    (![self.delegate respondsToSelector:</span><br><span class="line">    @selector(imageManager:shouldDownloadImageForURL:)] ||</span><br><span class="line">    [self.delegate imageManager:self shouldDownloadImageForURL:url]))</span><br><span class="line">    &#123;</span><br><span class="line">        /*如果有缓存但采用了 RefreshCached 策略，</span><br><span class="line">        则执行回调并继续下载，以便让服务器刷新 NSURLCache 里的内容。*/</span><br><span class="line">        if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*...*/</span><br><span class="line">        //step.4 使用imageDownloader开启网络下载</span><br><span class="line">        id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader</span><br><span class="line">        downloadImageWithURL:url</span><br><span class="line">        options:downloaderOptions</span><br><span class="line">        progress:progressBlock</span><br><span class="line">        completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished)</span><br><span class="line">        &#123;</span><br><span class="line">            //step.5 图片下载完成，根据设置进行图片转换和缓存</span><br><span class="line">            /.../</span><br><span class="line">            if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                //step.5 图片下载完成，不需要转换时，将图片保存到缓存中并返回主线程</span><br><span class="line">                [self.imageCache storeImage:downloadedImage</span><br><span class="line">                recalculateFromImage:NO</span><br><span class="line">                imageData:data</span><br><span class="line">                forKey:key</span><br><span class="line">                toDisk:cacheOnDisk];</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">    else if (image) &#123;</span><br><span class="line">        //step.3 有缓存且不要求强制刷新缓存时，在缓存中找到图片，直接返回</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            if (!weakOperation.isCancelled) &#123;</span><br><span class="line">                completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致的实现逻辑已在上面的代码中标明，图片下载完成后所做的转换和缓存，其具体实现逻辑会在后面讲到。</p>
<h4 id="2-3-SDWebImageDownloader"><a href="#2-3-SDWebImageDownloader" class="headerlink" title="2.3.SDWebImageDownloader"></a>2.3.SDWebImageDownloader</h4><p>主要业务：</p>
<ul>
<li>step.1 设置 URLRequest。</li>
<li>step.2 创建下载任务 SDWebImageDownloaderOperation，加入到最大并发数=6的 Queue 中，开始下载任务。</li>
<li>step.3 下载成功，调用 CompletedBlock。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloader.m</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        _shouldDecompressImages = YES; //默认解压缩下载到的图片</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6; //最大下载并发数</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        // 省略。。。</span><br><span class="line">        _HTTPHeaders = headerDictionary;</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(1);</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line"></span><br><span class="line">        [self createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)createNewSessionWithConfiguration:(NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    [self cancelAllDownloads];</span><br><span class="line"></span><br><span class="line">    if (self.session) &#123;</span><br><span class="line">        [self.session invalidateAndCancel];</span><br><span class="line">    &#125;</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:self</span><br><span class="line">                                            delegateQueue:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">&#123;</span><br><span class="line">    /*...*/</span><br><span class="line">    //step.1 设置request</span><br><span class="line">    NSMutableURLRequest *request = [[NSMutableURLRequest alloc]</span><br><span class="line">                                    initWithURL:url</span><br><span class="line">                                    cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ?</span><br><span class="line">    NSURLRequestUseProtocolCachePolicy :NSURLRequestReloadIgnoringLocalCacheData)</span><br><span class="line">                                timeoutInterval:timeoutInterval];</span><br><span class="line"></span><br><span class="line">    request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">    request.HTTPShouldUsePipelining = YES;</span><br><span class="line">    request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line"></span><br><span class="line">    //step.2 创建下载 Operation</span><br><span class="line">    operation = [[SDWebImageDownloaderOperation alloc] initWithRequest:request</span><br><span class="line">        options:options</span><br><span class="line">        progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;...&#125;</span><br><span class="line">        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">        </span><br><span class="line">        SDWebImageDownloader *sself = wself;</span><br><span class="line">        if (!sself) return;</span><br><span class="line">        //step.3 下载成功，执行完成的callback</span><br><span class="line">        __block NSArray *callbacksForURL;</span><br><span class="line">        dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">            callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">            if (finished) &#123;</span><br><span class="line">                [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">            SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">            if (callback)</span><br><span class="line">            callback(image, data, error, finished);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        cancelled:^&#123;...&#125;];</span><br><span class="line"></span><br><span class="line">    operation.shouldDecompressImages = wself.shouldDecompressImages;//是否需要解码</span><br><span class="line">    //设置任务优先级</span><br><span class="line">    if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">        operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">    &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">        operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">    &#125;</span><br><span class="line">    //任务加到队列中</span><br><span class="line">    [wself.downloadQueue addOperation:operation];</span><br><span class="line">    if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        //如果设置了后进的任务先执行，则添加依赖关系，前一个任务依赖当前任务</span><br><span class="line">        [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">        wself.lastAddedOperation = operation;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-任务和请求"><a href="#2-4-任务和请求" class="headerlink" title="2.4.任务和请求"></a>2.4.任务和请求</h4><p>SDWebImageDownloaderOperation，这是真正执行图片下载任务的地方。</p>
<ul>
<li>重写了<code>start</code>函数；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span><br><span class="line">        Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">        BOOL hasApplication = UIApplicationClass &amp;&amp; </span><br><span class="line">                        [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">        </span><br><span class="line">        // 进入后台时，开启后台模式</span><br><span class="line">        if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">            __weak __typeof__ (self) wself = self;</span><br><span class="line">            UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">            self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">                __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">                if (sself) &#123;</span><br><span class="line">                    [sself cancel];</span><br><span class="line"></span><br><span class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">                    sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        // 创建下载请求</span><br><span class="line">        self.executing = YES;</span><br><span class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request </span><br><span class="line">                                                          delegate:self startImmediately:NO];</span><br><span class="line">        self.thread = [NSThread currentThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 启动</span><br><span class="line">    [self.connection start];</span><br><span class="line"></span><br><span class="line">    if (self.connection) &#123;</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:</span><br><span class="line">            SDWebImageDownloadStartNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 在默认模式下运行当前runlooprun，直到调用CFRunLoopStop停止运行</span><br><span class="line">        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) &#123;</span><br><span class="line">            // Make sure to run the runloop in our background thread so it can process downloaded data</span><br><span class="line">            // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span><br><span class="line">            // not waking up the runloop, leading to dead threads</span><br><span class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            CFRunLoopRun();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!self.isFinished) &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">            [self connection:self.connection didFailWithError:</span><br><span class="line">            [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut </span><br><span class="line">            userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (self.completedBlock) &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain </span><br><span class="line">                code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123;</span><br><span class="line">        UIApplication * app = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">        [app endBackgroundTask:self.backgroundTaskId];</span><br><span class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>收到数据的回调</li>
</ul>
<p>下载过程中，通过代理-connection: didReceiveData:接收数据并保存到一个 NSMutableData 对象中。如果设置了“边下载边显示”，那么这里会渐进式的绘制图片、缩放图片，默认情况下还会对图片进行解码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">[self.imageData appendData:data];</span><br><span class="line">...</span><br><span class="line">//绘制图片</span><br><span class="line">CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);</span><br><span class="line">...</span><br><span class="line">CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);</span><br><span class="line">...</span><br><span class="line">//图片缩放</span><br><span class="line">UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];</span><br><span class="line">NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">UIImage *scaledImage = [self scaledImageForKey:key image:image];</span><br><span class="line"></span><br><span class="line">//图片解码</span><br><span class="line">if (self.shouldDecompressImages) &#123;</span><br><span class="line">image = [UIImage decodedImageWithImage:scaledImage];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">image = scaledImage;</span><br><span class="line">&#125;</span><br><span class="line">CGImageRelease(partialImageRef);</span><br><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">if (self.completedBlock) &#123;</span><br><span class="line">self.completedBlock(image, nil, nil, NO);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图片下载完成的回调</li>
</ul>
<p>下载完成后，在代理-connectionDidFinishLoading中完成图片的缩放、解码并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection &#123;</span><br><span class="line">SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock;</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">UIImage *image = [UIImage sd_imageWithData:self.imageData];</span><br><span class="line"></span><br><span class="line">NSString *key = [[SDWebImageManager sharedManager]</span><br><span class="line">cacheKeyForURL:self.request.URL];</span><br><span class="line">image = [self scaledImageForKey:key image:image];</span><br><span class="line"></span><br><span class="line">// Do not force decoding animated GIFs</span><br><span class="line">if (!image.images) &#123;</span><br><span class="line">if (self.shouldDecompressImages) &#123;</span><br><span class="line">image = [UIImage decodedImageWithImage:image];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (CGSizeEqualToSize(image.size, CGSizeZero)) &#123;</span><br><span class="line">completionBlock(nil, nil, [NSError...], YES);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">completionBlock(image, self.imageData, nil, YES);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">self.completionBlock = nil;</span><br><span class="line">[self done];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-图片缩放与解码"><a href="#2-5-图片缩放与解码" class="headerlink" title="2.5.图片缩放与解码"></a>2.5.图片缩放与解码</h4><ul>
<li>图片缩放</li>
</ul>
<p>上面两个下载的回调中调用了一个共同的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)scaledImageForKey:(NSString *)key image:(UIImage *)image &#123;</span><br><span class="line">    return SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：根据图片URL字符串推断图片的scale，按此scale绘制一张新图。<br>&emsp;</p>
<p>为啥要做这个操作呢？这里要提到三个关于图片尺寸信息的概念：<br>&emsp;</p>
<p>1、<strong>pixel dimensions</strong><br>&emsp;</p>
<p>这是指图片的<code>实际像素尺寸</code>，就是在文件夹中显示的真实图片尺寸。比如@1x图的尺寸是40*40，那么@2x的实际尺寸就是80*80，@3x的实际尺寸就是120*120。图片的清晰度只和图片本身的像素尺寸有关，实际尺寸越大则图片显示越清晰。<br>&emsp;</p>
<p>2、<strong>size</strong><br>&emsp;</p>
<p><a href="https://developer.apple.com/documentation/uikit/uiimage/1624105-size" target="_blank" rel="noopener">官方文档</a>中是这么描述的：</p>
<blockquote>
<p>The logical dimensions of the image, measured in points.</p>
</blockquote>
<p>This value reflects the logical size of the image and takes the image’s current orientation into account. Multiply the size values by the value in the scale property to get the pixel dimensions of the image.<br>&emsp;</p>
<p>size 是图片的<code>逻辑尺寸</code>，而图片的实际尺寸要在size对应字段的基础上再乘以scale，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实际宽度 = size.width * scale;</span><br><span class="line">size.width = 实际宽度 / scale;</span><br></pre></td></tr></table></figure>
<p>根据上面的公式，图片的size需要在实际像素尺寸的基础上除以其scale。如果@1x图的实际尺寸是40*40，则其size为40*40；@2x图的实际尺寸是80*80，则其size也为40*40；@3x图的实际尺寸是120*120，则其size还是40*40；这样，如果设置了imageview的frame自适应其素材的大小，就能保证在不同分辨率的设备上imageview.frame.size的一致性。<br>&emsp;</p>
<p>3、<strong>scale</strong><br>&emsp;</p>
<p><a href="https://developer.apple.com/documentation/uikit/uiimage/1624110-scale" target="_blank" rel="noopener">官方文档</a>中是这么描述的：</p>
<blockquote>
<p>The scale factor of the image.</p>
</blockquote>
<p>If you load an image from a file whose name includes the @2x modifier, the scale is set to 2.0. You can also specify an explicit scale factor when initializing an image from a Core Graphics image. All other images are assumed to have a scale factor of 1.0.<br>If you multiply the logical size of the image (stored in the size property) by the value in this property, you get the dimensions of the image in pixels.</p>
<p>&emsp;</p>
<p>这是图片的缩放比例，是一个CGFloat数值，依图片本身的命名而定。如果图片名为 park@2x.png 则图片的scale就是2；如果图片名为 park@3x.png 则图片的scale就是3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIImage *p1 = [UIImage imageNamed:@&quot;park@2x&quot;];</span><br><span class="line">UIImage *p2 = [UIImage imageNamed:@&quot;park@3x&quot;];</span><br><span class="line">NSLog(@&quot;+++@2x.scale:%.0f, @3x.scale:%.0f&quot;,p1.scale,p2.scale);</span><br><span class="line">// 日志：+++@2x.scale:2, @3x.scale:3</span><br></pre></td></tr></table></figure>
<p>需要注意的是：<strong>除以@2x和@3x命名的图片外，其他所有图片的scale都是1.0</strong>。这里标了粗体，因为这句话很重要，这意味着我们以 park.png 命名，或者<strong>从网络上下载的图片，它们的scale默认都是1.0</strong> ！！！这也正是SD库中下载完图片或者从缓存中取出图片后，执行上面的方法重置图片scale属性的原因所在~<br>&emsp;</p>
<p>为了适配不同尺寸的iPhone，我们的素材需要提供三个版本，park.png，park@2x.png，part@3x.png。使用素材时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIImage *img = [UIImage imageNamed:@&quot;park&quot;];</span><br></pre></td></tr></table></figure>
<p>系统会自动根据当前屏幕的scale选择对应后缀的图片素材。在4/4s之后的手机上系统会自动加载以@2x为后缀的图片；在6p 之后的plus版本手机上系统会自动加载以@3x为后缀的图片。<br>&emsp;</p>
<p>问题来了，从网络上下载的图片其scale默认是1.0，而其实际尺寸是确定的。根据公式：<code>size</code> = <code>实际尺寸</code> / <code>scale</code>，<strong>同一张图，scale越小其size就越大</strong>。如果设置了imageview自适应素材的大小，则本该使用@2x或@3x素材的视图，其frame.size会比预想的要大，所以为了效果的准确性，还是需要正确设置图片的scale参数。<br>&emsp;</p>
<p>SD中重置图片scale的具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">inline UIImage *SDScaledImageForKey(NSString *key, UIImage *image) &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //数组不空，则返回一个动图</span><br><span class="line">    if ([image.images count] &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *scaledImages = [NSMutableArray array];</span><br><span class="line">        for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line">        return [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">    &#125;</span><br><span class="line">    //根据图片URL，判断图片比例，重新绘制新图并返回</span><br><span class="line">    else &#123;</span><br><span class="line">        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">            CGFloat scale = [UIScreen mainScreen].scale;</span><br><span class="line">            </span><br><span class="line">            // &quot;@2x.png&quot; 或者 &quot;@2x.png&quot; 字符串的长度=7，加上@符号之前的名字，必定&gt;=8</span><br><span class="line">            if (key.length &gt;= 8) &#123;</span><br><span class="line">                NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;//URL包含@2x，推测为2倍图</span><br><span class="line">                    scale = 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">                range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;//URL包含@3x，推测为3倍图</span><br><span class="line">                    scale = 3.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage </span><br><span class="line">                                                              scale:scale </span><br><span class="line">                                                              orientation:image.imageOrientation];</span><br><span class="line">            image = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图片解码</li>
</ul>
<p>默认情况下，SD会对下载的图片执行<code>[UIImage decodedImageWithImage:scaledImage]</code>，即图片解码（动图除外）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage *)decodedImageWithImage:(UIImage *)image &#123;</span><br><span class="line">    // while downloading huge amount of images</span><br><span class="line">    // autorelease the bitmap context</span><br><span class="line">    // and all vars to help system to free memory</span><br><span class="line">    // when there are memory warning.</span><br><span class="line">    // on iOS7, do not forget to call</span><br><span class="line">    // [[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        // do not decode animated images</span><br><span class="line">        if (image.images) &#123; return image; &#125;</span><br><span class="line">    </span><br><span class="line">        CGImageRef imageRef = image.CGImage;</span><br><span class="line">    </span><br><span class="line">        //图片如果有alpha通道，就返回原始image，因为jpg图片有alpha的话，就不压缩</span><br><span class="line">        CGImageAlphaInfo alpha = CGImageGetAlphaInfo(imageRef);</span><br><span class="line">        BOOL anyAlpha = (alpha == kCGImageAlphaFirst ||</span><br><span class="line">                         alpha == kCGImageAlphaLast ||</span><br><span class="line">                         alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">                         alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">    </span><br><span class="line">        if (anyAlpha) &#123; return image; &#125;</span><br><span class="line">    </span><br><span class="line">        size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">    </span><br><span class="line">        // current</span><br><span class="line">        CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(CGImageGetColorSpace(imageRef));</span><br><span class="line">        CGColorSpaceRef colorspaceRef = CGImageGetColorSpace(imageRef);</span><br><span class="line">        </span><br><span class="line">        bool unsupportedColorSpace = (imageColorSpaceModel == 0 || </span><br><span class="line">                                    imageColorSpaceModel == -1 || </span><br><span class="line">                                    imageColorSpaceModel == kCGColorSpaceModelCMYK || </span><br><span class="line">                                    imageColorSpaceModel == kCGColorSpaceModelIndexed);</span><br><span class="line">        if (unsupportedColorSpace)//如果属于上述不支持的ColorSpace，则ColorSpace就使用RGB</span><br><span class="line">            colorspaceRef = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    </span><br><span class="line">        CGContextRef context = CGBitmapContextCreate(NULL, width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     CGImageGetBitsPerComponent(imageRef),</span><br><span class="line">                                                     0,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     kCGBitmapByteOrderDefault | </span><br><span class="line">                                                     kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    </span><br><span class="line">        // Draw the image into the context and retrieve the new image, which will now have an alpha layer</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">        CGImageRef imageRefWithAlpha = CGBitmapContextCreateImage(context);</span><br><span class="line">        UIImage *imageWithAlpha = [UIImage imageWithCGImage:imageRefWithAlpha </span><br><span class="line">                                                      scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">    </span><br><span class="line">        if (unsupportedColorSpace)</span><br><span class="line">            CGColorSpaceRelease(colorspaceRef);</span><br><span class="line">        </span><br><span class="line">        CGContextRelease(context);</span><br><span class="line">        CGImageRelease(imageRefWithAlpha);</span><br><span class="line">        </span><br><span class="line">        return imageWithAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SD为啥“多此一举”呢？<a href="https://www.cnblogs.com/chmhml/p/6817383.html" target="_blank" rel="noopener">这里</a> 有种解释：</p>
<blockquote>
<p>一般下载的图片或者我们手动拖进主 bundle 的图片都是 PNG 或者 JPG 格式的图片，这些图片都是经过编码压缩后的图片数据，并不是控件可以直接显示的位图。如果我们直接使用 “[UIImage imageNamed:]” 来加载图片，系统默认会在主线程立即进行图片的解码工作，这个过程就是把图片数据解码成可供控件直接显示的位图数据。由于这个解码操作比较耗时，并且默认是在主线程进行，所以当在主线程大量调用时就会产生卡顿。同时由于位图体积较大，所以在磁盘缓存中不会直接缓存位图数据，而是编码压缩过的PNG 或者 JPG 数据。</p>
</blockquote>
<p>这里更准确的说，[UIImage imageNamed:] 加载图片时，不是立即解码的，而是在图片设置到<code>UIImageView</code>或者<code>CALayer.contents</code>中，并且 CALayer 被提交到GPU进行渲染前才会解码。另外，使用这种方式加载图片时，系统会自动缓存一份该图片，后面再使用此图时会直接从缓存中取，不再次解码。即使如此，使用这种方式加载图片时，最后的解码部分仍然时在主线程中进行的，所以当大量加载图片时，仍然有可能会出现卡顿现象。<br>&emsp;</p>
<p>SD 这里所做的正是对图片进行解码，而且是在异步线程里。SD缓存图片到内存时保存的是解码后的图片，缓存是通过 NSCache 实现的。这一步的目的是提高加载图片的速度和效率，需要注意的是，它在解码时会占用相当一部分内存，是典型的空间换时间。如果你遇到了内存问题，可以尝试禁止自动解码或者清空缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[SDImageCache sharedImageCache] setShouldDecompressImages:NO];</span><br><span class="line">[[SDWebImageDownloader sharedDownloader] setShouldDecompressImages:NO];</span><br><span class="line">[[SDImageCache sharedImageCache] clearMemory];</span><br></pre></td></tr></table></figure>
<h3 id="三、缓存类的实现"><a href="#三、缓存类的实现" class="headerlink" title="三、缓存类的实现"></a>三、缓存类的实现</h3><p>写这篇文章时最新sd版本为3.7.3，缓存相关功能主要由 SDImageCache 类提供。这里的缓存包括了内存和磁盘两种方式。其中，内存缓存使用的是继承自 NSCache 的 AutoPurgeCache 类；磁盘缓存的操作被单独放在一个串行队列 ioQueue 中。这个类中主要的方法及实现如下：</p>
<h4 id="3-1-查询图片缓存"><a href="#3-1-查询图片缓存" class="headerlink" title="3.1.查询图片缓存"></a>3.1.查询图片缓存</h4><ul>
<li>step.1 从内存中检测；</li>
<li>step.2 从磁盘中检测（异步+串行队列）；</li>
<li>step.3 磁盘中检测到缓存后，根据需要缓存到内存中；</li>
<li>step.4 返回结果；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key</span><br><span class="line">done:(SDWebImageQueryCompletedBlock)doneBlock</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    //step.1 先从内存中检测</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //step.2 内存中没有再从磁盘中检测</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            //step.3 磁盘中检测到缓存后 根据需要缓存到内存中</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key &#123;</span><br><span class="line">    return [self.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)diskImageForKey:(NSString *)key &#123;</span><br><span class="line">    NSData *data = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        UIImage *image = [UIImage sd_imageWithData:data];</span><br><span class="line">         // 重置图片scale</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        if (self.shouldDecompressImages) &#123;</span><br><span class="line">            // 图片解码</span><br><span class="line">            image = [UIImage decodedImageWithImage:image];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-保存图片"><a href="#3-2-保存图片" class="headerlink" title="3.2.保存图片"></a>3.2.保存图片</h4><p>图片下载成功后，默认会保存到内存中。保存到磁盘时，会先检测图片的格式，文件名为URL对应的MD5值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (void)storeImage:(UIImage *)image</span><br><span class="line">recalculateFromImage:(BOOL)recalculate</span><br><span class="line">         imageData:(NSData *)imageData</span><br><span class="line">            forKey:(NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    //保存到内存 NSCache，cost为像素值</span><br><span class="line">    if (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            NSData *data = imageData;</span><br><span class="line"></span><br><span class="line">            if (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line">            #if TARGET_OS_IPHONE</span><br><span class="line"></span><br><span class="line">                int alphaInfo = CGImageGetAlphaInfo(image.CGImage);</span><br><span class="line">                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">                BOOL imageIsPng = hasAlpha;</span><br><span class="line"></span><br><span class="line">                //检测 图片data 的前缀是否是 PNG 格式</span><br><span class="line">                if ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (imageIsPng) &#123;</span><br><span class="line">                    data = UIImagePNGRepresentation(image);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);</span><br><span class="line">                &#125;</span><br><span class="line">            #else</span><br><span class="line">                data = [NSBitmapImageRep representationOfImageRepsInArray:</span><br><span class="line">                image.representations</span><br><span class="line">                usingType: NSJPEGFileType properties:nil];</span><br><span class="line">            #endif</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // get cache Path for image key</span><br><span class="line">            NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">            // transform to NSUrl</span><br><span class="line">            NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line">            // 保存到磁盘中</span><br><span class="line">            [_fileManager createFileAtPath:cachePathForKey contents:data attributes:nil];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存到磁盘时，图片的命名规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)cachedFileNameForKey:(NSString *)key &#123;</span><br><span class="line">    const char *str = [key UTF8String];</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:</span><br><span class="line">    @&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">    r[0], r[1], r[2], r[3], r[4], r[5],</span><br><span class="line">    r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">    r[11], r[12], r[13], r[14], r[15],</span><br><span class="line">    [[key pathExtension] isEqualToString:@&quot;&quot;] ?</span><br><span class="line">    @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;,</span><br><span class="line">    [key pathExtension]]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-清除缓存"><a href="#3-3-清除缓存" class="headerlink" title="3.3.清除缓存"></a>3.3.清除缓存</h4><p>程序出现内存警告时会清除内存中的缓存；退出应用、进入后台时则根据下面的策略清除相关磁盘缓存：</p>
<ul>
<li>清除过期的文件，默认一星期;</li>
<li>如果设置了最大缓存，且当前缓存文件超过了此限制，则删除最旧的文件，直到当前缓存文件的大小为最大缓存大小的一半;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        /*...*/</span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:</span><br><span class="line">        -self.maxCacheAge];</span><br><span class="line">        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line"></span><br><span class="line">        //遍历缓存目录中的所有文件</span><br><span class="line">        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys</span><br><span class="line">            error:NULL];</span><br><span class="line">            /*...*/</span><br><span class="line">            // 删除过期的文件</span><br><span class="line">            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">            if ([[modificationDate laterDate:expirationDate]</span><br><span class="line">            isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            /*...*/</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果剩下的磁盘缓存超过最大限制，再次删掉最老的文件，</span><br><span class="line">        //直到当前缓存文件的大小为最大缓存大小的一半;</span><br><span class="line">        if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) &#123;</span><br><span class="line">            const NSUInteger desiredCacheSize = self.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">            NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:</span><br><span class="line">            NSSortConcurrent</span><br><span class="line">            usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                return [obj1[NSURLContentModificationDateKey]</span><br><span class="line">                compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">            &#125;];</span><br><span class="line"></span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([_fileManager removeItemAtURL:fileURL error:nil])&#123;</span><br><span class="line">                    NSDictionary *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize =</span><br><span class="line">                    resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、后记"><a href="#四、后记" class="headerlink" title="四、后记"></a>四、后记</h3><p>SD 是一个优秀的网络图片下载库，它使在按钮等视图中加载网络图片或本地缓存变得异常轻松，有很多值得学习的地方：</p>
<ul>
<li>库中各类职责清晰；</li>
<li>网络图片的下载、解码及缓存等都使用异步的方式进行，保证了主线程的流畅性；</li>
<li>大量使用了 NSOperation 和 GCD，为我们在多线程中执行任务和处理线程同步问题提供了范例；</li>
<li>图片加载前，先在异步线程中解码成位图，为我们优化图片加载提供了灵感；</li>
<li>设计良好的缓存策略，提高了应用的性能表现；</li>
</ul>
<p>本文是根据原项目中使用的 3.7.3 版本来分析的，目前SD的最新版本号为 4.4.1。大致看了下最新的版本，网络下载部分已经使用了 URLSession，也新增了很多新的类，后面有时间会继续研究一下~</p>
<hr>
<p>相关参考：</p>
<p>#<a href="https://developer.apple.com/documentation/uikit/uiimage#//apple_ref/occ/instp/UIImage/scale" target="_blank" rel="noopener">©AppleDev-UIImage</a></p>
<p>#<a href="https://www.cnblogs.com/chmhml/p/6817383.html" target="_blank" rel="noopener">©CHM-SD图片解码</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#源码">
    <span class="tag-code">源码</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/01/27/compile.html">
        <span class="nav-arrow">← </span>
        
          编译器、代码编译过程、Xcode Build过程
        
      </a>
    
    
      <a class="nav-right" href="/2018/01/31/source_code_afn.html">
        
          AFNetworking
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#一、导入-SD库："><span class="toc-nav-text">一、导入 SD库：</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#二、下载类的实现"><span class="toc-nav-text">二、下载类的实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-UIImageView-WebCache"><span class="toc-nav-text">2.1.UIImageView+WebCache</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-SDWebImageManager"><span class="toc-nav-text">2.2.SDWebImageManager</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-SDWebImageDownloader"><span class="toc-nav-text">2.3.SDWebImageDownloader</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-4-任务和请求"><span class="toc-nav-text">2.4.任务和请求</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-5-图片缩放与解码"><span class="toc-nav-text">2.5.图片缩放与解码</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#三、缓存类的实现"><span class="toc-nav-text">三、缓存类的实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-查询图片缓存"><span class="toc-nav-text">3.1.查询图片缓存</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-保存图片"><span class="toc-nav-text">3.2.保存图片</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-清除缓存"><span class="toc-nav-text">3.3.清除缓存</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#四、后记"><span class="toc-nav-text">四、后记</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/01/28/source_code_sd.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "SDWebImage",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>