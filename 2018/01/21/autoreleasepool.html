<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"/> 
  
  <title>
    
      OC中的内存管理 | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>OC中的内存管理</h2>
  <p class="post-date">2018-01-21</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="1-MRC"><a href="#1-MRC" class="headerlink" title="1.MRC"></a>1.MRC</h3><h4 id="1-1-retain-release"><a href="#1-1-retain-release" class="headerlink" title="1.1.retain/release"></a>1.1.retain/release</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSObject</span><br><span class="line">//...</span><br><span class="line">- (instancetype)retain OBJC_ARC_UNAVAILABLE;</span><br><span class="line">- (oneway void)release OBJC_ARC_UNAVAILABLE;</span><br><span class="line">- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;</span><br><span class="line">- (NSUInteger)retainCount OBJC_ARC_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">- (struct _NSZone *)zone OBJC_ARC_UNAVAILABLE;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在MRC时代，对象的生命周期是通过引用计数来管理的，我们需要通过频繁地手动添加<code>retain</code>来引用计数 +1，通过<code>release</code>来使引用计数 -1，当对象的引用计数为 0 时，对象会被销毁。<br>&emsp;</p>
<p>#示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)newName</span><br><span class="line">&#123;</span><br><span class="line">    if (_name != newName) &#123;</span><br><span class="line">        [newName retain]//引用计数+1，强引用新值</span><br><span class="line">        [_name release];//引用计数-1，释放旧值</span><br><span class="line">        _name = newName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的管理方式不仅比较繁琐，而且可能会因为疏忽大意而导致内存泄露或过度释放情况的发生。比如示例1中，我们是先通过<code>retain</code>强引用<code>newName</code>，再通过<code>release</code>释放旧值。如果这两者顺序颠倒，则就可能出问题。假设<code>newName</code>和_name 的旧值是同一个对象，那么先<code>release</code>旧值就会使旧值的引用计数为0，从而导致对象被提前释放，后面再赋值给_name 就无效。</p>
<h4 id="1-2-自动释放池"><a href="#1-2-自动释放池" class="headerlink" title="1.2.自动释放池"></a>1.2.自动释放池</h4><p>与<code>release</code>相比，<code>autorelease</code>是一种延迟对象释放时间的方式。它需要配合 autorelease pool(自动释放池)使用，我们只需要将对象标记为<code>autorelease</code>，这样对象就会被自动加入到自动释放池中；当对自动释放池执行<code>drain</code>方法时，自动释放池就会销毁；销毁前会向其内部的这些对象发送<code>release</code>消息，从而使对象的引用计数-1；当引用计数为 0 时，对象就会被销毁和释放。一个对象可以被多次放入到同一个自动释放池内，并且每次放入池内时都会调用一次<code>release</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *dic = [[[NSDictionary alloc] init] autorelease];</span><br></pre></td></tr></table></figure>
<p>自动释放池在 MRC 和 ARC 中有不同的形式和使用方法：</p>
<ul>
<li>MRC 中的 NSAutoreleasePool</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];</span><br><span class="line">// Code benefitting from a local autorelease pool.</span><br><span class="line">[pool release];</span><br></pre></td></tr></table></figure>
<ul>
<li>ARC 中的 @autoreleasepool{}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    // Code benefitting from a local autorelease pool.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ARC环境下，我们不能直接使用 NSAutoreleasePool 对象，而要使用后者。根据 <a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=objc" target="_blank" rel="noopener">开发文档</a> 的描述，后者的效率更高。</p>
<h4 id="1-3-pool的创建"><a href="#1-3-pool的创建" class="headerlink" title="1.3.pool的创建"></a>1.3.pool的创建</h4><h5 id="1-3-1-自动创建"><a href="#1-3-1-自动创建" class="headerlink" title="1.3.1.自动创建"></a>1.3.1.自动创建</h5><p>大部分情况下，系统已经为我们创建了自动释放池，并不需要我们自己创建。那么系统是什么时候帮我们创建的自动释放池呢。。。？这就要结合 runloop 来分析，下面这段内容是应用执行到didFinishLaunchingWithOptions时，通过 po [NSRunLoop currentRunLoop] 打印的当前runloop的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">po [NSRunLoop currentRunLoop]</span><br><span class="line">&lt;CFRunLoop 0x600001cb0100 [0x10bee2b68]&gt;&#123;wakeup port = 0x1f07, stopped = false, ignoreWakeUps = false, </span><br><span class="line">current mode = kCFRunLoopDefaultMode,</span><br><span class="line">common modes = &lt;CFBasicHash 0x600002ef2910 [0x10bee2b68]&gt;&#123;type = mutable set, count = 2,</span><br><span class="line">entries =&gt;</span><br><span class="line">    0 : &lt;CFString 0x116ab9be0 [0x10bee2b68]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</span><br><span class="line">    2 : &lt;CFString 0x10bef8168 [0x10bee2b68]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">common mode items = &lt;CFBasicHash 0x600002e81da0 [0x10bee2b68]&gt;&#123;type = mutable set, count = 13,</span><br><span class="line">entries =&gt;</span><br><span class="line">    0 : &lt;CFRunLoopSource 0x6000015b5e00 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x110820188)&#125;&#125;</span><br><span class="line">    1 : &lt;CFRunLoopSource 0x6000015b0540 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000015b5080, callout = __handleEventQueue (0x116270912)&#125;&#125;</span><br><span class="line">    2 : &lt;CFRunLoopSource 0x6000015b1f80 [0x10bee2b68]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000004b1680, callout = FBSSerialQueueRunLoopSourceHandler (0x118c99f0b)&#125;&#125;</span><br><span class="line">    3 : &lt;CFRunLoopObserver 0x6000011b0c80 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x1161aedfc), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;</span><br><span class="line">    4 : &lt;CFRunLoopObserver 0x6000011b0be0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (</span><br><span class="line">    0 : &lt;0x7ffe6c009058&gt;</span><br><span class="line">)&#125;&#125;</span><br><span class="line">    5 : &lt;CFRunLoopObserver 0x6000011b0b40 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x1161aee75), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;</span><br><span class="line">    6 : &lt;CFRunLoopObserver 0x6000011b0aa0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (</span><br><span class="line">    0 : &lt;0x7ffe6c009058&gt;</span><br><span class="line">)&#125;&#125;</span><br><span class="line">    7 : &lt;CFRunLoopSource 0x6000015b0cc0 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2f03, callout = PurpleEventCallback (0x110820194)&#125;&#125;</span><br><span class="line">    13 : &lt;CFRunLoopSource 0x6000015b0e40 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 13583, subsystem = 0x116a53448, context = 0x0&#125;&#125;</span><br><span class="line">    14 : &lt;CFRunLoopSource 0x6000015b0480 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x600002e81830, callout = __handleHIDEventFetcherDrain (0x11627091e)&#125;&#125;</span><br><span class="line">    15 : &lt;CFRunLoopObserver 0x6000011b05a0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x1117046ae), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;</span><br><span class="line">    18 : &lt;CFRunLoopSource 0x6000015b4480 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 42499, subsystem = 0x116a654b0, context = 0x6000020acb80&#125;&#125;</span><br><span class="line">    21 : &lt;CFRunLoopObserver 0x6000011b4640 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x115d51473), context = &lt;CFRunLoopObserver context 0x600000bb5a40&gt;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">modes = &lt;CFBasicHash 0x600002ef2850 [0x10bee2b68]&gt;&#123;type = mutable set, count = 4,</span><br><span class="line">entries =&gt;</span><br><span class="line">    2 : &lt;CFRunLoopMode 0x600001bb4270 [0x10bee2b68]&gt;&#123;name = UITrackingRunLoopMode, port set = 0x5103, queue = 0x600000eb5500, source = 0x600000eb5600 (not fired), timer port = 0x5003, </span><br><span class="line">    sources0 = &lt;CFBasicHash 0x600002e81e30 [0x10bee2b68]&gt;&#123;type = mutable set, count = 4,</span><br><span class="line">entries =&gt;</span><br><span class="line">    0 : &lt;CFRunLoopSource 0x6000015b5e00 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x110820188)&#125;&#125;</span><br><span class="line">    4 : &lt;CFRunLoopSource 0x6000015b0540 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000015b5080, callout = __handleEventQueue (0x116270912)&#125;&#125;</span><br><span class="line">    5 : &lt;CFRunLoopSource 0x6000015b1f80 [0x10bee2b68]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000004b1680, callout = FBSSerialQueueRunLoopSourceHandler (0x118c99f0b)&#125;&#125;</span><br><span class="line">    6 : &lt;CFRunLoopSource 0x6000015b0480 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x600002e81830, callout = __handleHIDEventFetcherDrain (0x11627091e)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">    sources1 = &lt;CFBasicHash 0x600002e81e60 [0x10bee2b68]&gt;&#123;type = mutable set, count = 3,</span><br><span class="line">entries =&gt;</span><br><span class="line">    0 : &lt;CFRunLoopSource 0x6000015b0e40 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 13583, subsystem = 0x116a53448, context = 0x0&#125;&#125;</span><br><span class="line">    1 : &lt;CFRunLoopSource 0x6000015b4480 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 42499, subsystem = 0x116a654b0, context = 0x6000020acb80&#125;&#125;</span><br><span class="line">    2 : &lt;CFRunLoopSource 0x6000015b0cc0 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2f03, callout = PurpleEventCallback (0x110820194)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">    observers = (</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0be0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffe6c009058&gt;\n)&#125;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b4640 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x115d51473), context = &lt;CFRunLoopObserver context 0x600000bb5a40&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0c80 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x1161aedfc), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b05a0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x1117046ae), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0b40 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x1161aee75), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0aa0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffe6c009058&gt;\n)&#125;&#125;&quot;</span><br><span class="line">),</span><br><span class="line">    timers = (null),</span><br><span class="line">    currently 563029792 (7903325957143) / soft deadline in: 1.84467362e+10 sec (@ -1) / hard deadline in: 1.84467362e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">    3 : &lt;CFRunLoopMode 0x600001bb4340 [0x10bee2b68]&gt;&#123;name = GSEventReceiveRunLoopMode, port set = 0x2e03, queue = 0x600000eb5680, source = 0x600000eb5780 (not fired), timer port = 0x4e03, </span><br><span class="line">    sources0 = &lt;CFBasicHash 0x600002e81ef0 [0x10bee2b68]&gt;&#123;type = mutable set, count = 1,</span><br><span class="line">entries =&gt;</span><br><span class="line">    0 : &lt;CFRunLoopSource 0x6000015b5e00 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x110820188)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">    sources1 = &lt;CFBasicHash 0x600002e81f20 [0x10bee2b68]&gt;&#123;type = mutable set, count = 1,</span><br><span class="line">entries =&gt;</span><br><span class="line">    2 : &lt;CFRunLoopSource 0x6000015b0f00 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2f03, callout = PurpleEventCallback (0x110820194)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">    observers = (null),</span><br><span class="line">    timers = (null),</span><br><span class="line">    currently 563029792 (7903327601583) / soft deadline in: 1.84467362e+10 sec (@ -1) / hard deadline in: 1.84467362e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">    4 : &lt;CFRunLoopMode 0x600001bb04e0 [0x10bee2b68]&gt;&#123;name = kCFRunLoopDefaultMode, port set = 0x210b, queue = 0x600000eb1500, source = 0x600000eb1600 (not fired), timer port = 0x1d07, </span><br><span class="line">    sources0 = &lt;CFBasicHash 0x600002e81e90 [0x10bee2b68]&gt;&#123;type = mutable set, count = 4,</span><br><span class="line">entries =&gt;</span><br><span class="line">    0 : &lt;CFRunLoopSource 0x6000015b5e00 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x110820188)&#125;&#125;</span><br><span class="line">    4 : &lt;CFRunLoopSource 0x6000015b0540 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000015b5080, callout = __handleEventQueue (0x116270912)&#125;&#125;</span><br><span class="line">    5 : &lt;CFRunLoopSource 0x6000015b1f80 [0x10bee2b68]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000004b1680, callout = FBSSerialQueueRunLoopSourceHandler (0x118c99f0b)&#125;&#125;</span><br><span class="line">    6 : &lt;CFRunLoopSource 0x6000015b0480 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x600002e81830, callout = __handleHIDEventFetcherDrain (0x11627091e)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">    sources1 = &lt;CFBasicHash 0x600002e81ec0 [0x10bee2b68]&gt;&#123;type = mutable set, count = 3,</span><br><span class="line">entries =&gt;</span><br><span class="line">    0 : &lt;CFRunLoopSource 0x6000015b0e40 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 13583, subsystem = 0x116a53448, context = 0x0&#125;&#125;</span><br><span class="line">    1 : &lt;CFRunLoopSource 0x6000015b4480 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;CFRunLoopSource MIG Server&gt; &#123;port = 42499, subsystem = 0x116a654b0, context = 0x6000020acb80&#125;&#125;</span><br><span class="line">    2 : &lt;CFRunLoopSource 0x6000015b0cc0 [0x10bee2b68]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x2f03, callout = PurpleEventCallback (0x110820194)&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">,</span><br><span class="line">    observers = (</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0be0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffe6c009058&gt;\n)&#125;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b4640 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x115d51473), context = &lt;CFRunLoopObserver context 0x600000bb5a40&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0c80 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x1161aedfc), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b05a0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x1117046ae), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0b40 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x1161aee75), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0aa0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffe6c009058&gt;\n)&#125;&#125;&quot;</span><br><span class="line">),</span><br><span class="line">    timers = &lt;CFArray 0x6000004b7360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (</span><br><span class="line">    0 : &lt;CFRunLoopTimer 0x6000015b5440 [0x10bee2b68]&gt;&#123;valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 563029756 (-36.444778 @ 7866885955998), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (0x10ac9327d / 0x115810fb9) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore), context = &lt;CFRunLoopTimer context 0x6000035f3a40&gt;&#125;</span><br><span class="line">)&#125;,</span><br><span class="line">    currently 563029792 (7903327672130) / soft deadline in: 1.8446744e+10 sec (@ 7866885955998) / hard deadline in: 1.8446744e+10 sec (@ 7866885955998)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">    5 : &lt;CFRunLoopMode 0x600001bb08f0 [0x10bee2b68]&gt;&#123;name = kCFRunLoopCommonModes, port set = 0x3e0f, queue = 0x600000ebc400, source = 0x600000ebc500 (not fired), timer port = 0xa803, </span><br><span class="line">    sources0 = (null),</span><br><span class="line">    sources1 = (null),</span><br><span class="line">    observers = (null),</span><br><span class="line">    timers = (null),</span><br><span class="line">    currently 563029792 (7903329641921) / soft deadline in: 1.84467362e+10 sec (@ -1) / hard deadline in: 1.84467362e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是摘要，显示的是启动后系统在主线程的 Runloop 中自动添加的观察者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">observers = (</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0be0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffe6c009058&gt;\n)&#125;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b4640 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x115d51473), context = &lt;CFRunLoopObserver context 0x600000bb5a40&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0c80 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x1161aedfc), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b05a0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x1117046ae), context = &lt;CFRunLoopObserver context 0x0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0b40 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x1161aee75), context = &lt;CFRunLoopObserver context 0x7ffe6b7018e0&gt;&#125;&quot;,</span><br><span class="line">    &quot;&lt;CFRunLoopObserver 0x6000011b0aa0 [0x10bee2b68]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x11617f1b1), context = &lt;CFArray 0x600002efc360 [0x10bee2b68]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffe6c009058&gt;\n)&#125;&#125;&quot;</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>其中第1和第6个观察者，回调都是_wrapRunLoopWithAutoreleasePoolHandler，两者的<code>activities</code>分别是<code>0x1</code>和<code>0xa0</code>。下面是 CFRunloop.h 中 activities 的枚举值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">    kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">    kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">    kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">    kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>activities = 0x1，对应的就是kCFRunLoopEntry；activities = 0xa0，对应的就是kCFRunLoopBeforeWaiting | kCFRunLoopExit。</p>
</blockquote>
<p>关于_wrapRunLoopWithAutoreleasePoolHandler，目前我尚未查到其源码，它具体怎么实现自动释放池的创建和销毁暂不能一探究竟。按照网上各大博主的说法：</p>
<ul>
<li>在进入runloop时（kCFRunLoopEntry），观察者回调中会调用 objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li>
<li>在runloop即将休眠时（kCFRunLoopBeforeWaiting），观察者回调中会调用 objc_autoreleasePoolPop() 和 objc_autoreleasePoolPush() 释放旧的池并创建新池；</li>
<li>在runloop退出时（kCFRunLoopExit），观察者回调中会调用 objc_autoreleasePoolPop() 来释放自动释放池。这个观察者的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li>
</ul>
<p><strong>小结：</strong>系统提供的自动释放池，其创建发生在两个时机：runloop启动时 和 runloop即将休眠时。</p>
<h5 id="1-3-2-手动创建"><a href="#1-3-2-手动创建" class="headerlink" title="1.3.2.手动创建"></a>1.3.2.手动创建</h5><p>绝大多数情况下，系统会帮我们自动创建和销毁自动释放池。但是，根据 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-SW5" target="_blank" rel="noopener">开发文档</a> 的描述，以下场景下我们需要自己创建自动释放池：</p>
<ul>
<li>If you are writing a program that is not based on a UI framework, such as a command-line tool.</li>
</ul>
<p>如果你的项目不是基于UI framework的，比如命令行工具，则你需要自己创建自动释放池管理对象的生命周期。</p>
<ul>
<li>If you write a loop that creates many temporary objects.</li>
</ul>
<blockquote>
<p>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</p>
</blockquote>
<p>就是说，当你的循环体内创建了大量的临时对象时，你需要在循环体内创建一个自动释放池，这样临时对象会被标记为 autorelease 并在下次循环之前销毁。 在循环体内使用自动释放池可以降低内存峰值。<br>&emsp;</p>
<p>#示例2：在一个模态弹出的界面的<code>viewDidLoad</code>方法中模拟一个循环体内大量创建临时变量的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            NSString *string = [NSString stringWithFormat:@&quot;ADFAFDSFNKFNASFSKJFNSFSDAFAOSJDSAFASFJDSJFIOWJFIOKALNFJASFASLKFLSAJFSLAFK&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是<strong>不使用</strong>自动释放池，反复弹出界面时的内存峰值状况图：</p>
<p><img src="http://pc7lkjphf.bkt.clouddn.com/pic/WithoutPool.png" alt="不使用释放池"></p>
<p>这是<strong>使用</strong>自动释放池，反复弹出界面时的内存峰值状况图：</p>
<p><img src="http://pc7lkjphf.bkt.clouddn.com/pic/WithPool.png" alt="使用释放池"></p>
<p>通过对比，可以清楚的看到，使用自动释放池时，即使创建了大量的临时对象，对象都能及时释放，内存的峰值也几乎没变化~</p>
<ul>
<li>If you spawn a secondary thread.</li>
</ul>
<blockquote>
<p>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects.</p>
</blockquote>
<p>当你创建了一个子线程时，也需要在线程启动时主动创建一个自动释放池，否则会产生内存泄露。这是官网开发文档中的说法，但实际上目前的版本中，我们在子线程中创建新的对象后，该变量是能自动释放的。<br>&emsp;</p>
<p>#示例3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation AppDelegate</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(onHandleThread) object:nil];</span><br><span class="line">    [thread start];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)onHandleThread</span><br><span class="line">&#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    person.name = @&quot;IOI&quot;;</span><br><span class="line">    NSLog(@&quot;+++++子线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;++++PERSON IS DEALLOCED~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+++++子线程:&lt;NSThread: 0x600002bf8180&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++PERSON IS DEALLOCED~</span><br></pre></td></tr></table></figure>
<p>可以看到，在子线程中创建了 Person 的实例对象，并且没有主动在子线程中添加释放池，但 person 对象最后确实销毁了。<br>&emsp;</p>
<p>那么这为啥与开发文档中的说法不一致呢？StackOverflow 的 <a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">这篇帖子</a> 中有一种解释：</p>
<blockquote>
<p>The latest version of the runtime (646, which shipped with OS X 10.10 and iOS 8) does indeed add a pool if you perform an autorelease without a pool on the current thread. The previous version of the runtime (551.1, which came with OS X 10.9 and iOS 7), also did this.</p>
</blockquote>
<p>从 OSX 10.9 和 iOS7 开始，如果我们在线程中没有使用 autorelease pool，那么苹果会自动帮我们创建一个 pool 来释放对象，避免了内存泄露。我瞄了一眼这份<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/RevisionHistory.html#//apple_ref/doc/uid/20001607-CJBGIAGF" target="_blank" rel="noopener">开发文档</a>的更新日志，上次更新时间竟是 2012-07-17！那么确实有可能是苹果已经更改了实现，但文档未及时更新。</p>
<h4 id="1-4-pool的销毁"><a href="#1-4-pool的销毁" class="headerlink" title="1.4.pool的销毁"></a>1.4.pool的销毁</h4><p>在1.3.1小节中讲过，自动释放池的销毁时机主要有两个：runloop即将进入休眠时 和 runloop退出时~</p>
<ul>
<li>AppKit 与自动释放池</li>
</ul>
<blockquote>
<p>AppKit and UIKit frameworks process each event-loop iteration (such as a mouse down event or a tap) within an autorelease pool block. Therefore you typically do not have to create an autorelease pool block yourself, or even see the code that is used to create one.</p>
</blockquote>
<p>在事件循环(event loop)开始时，AppKit 和 UIKit 会在主线程中创建一个自动释放池，不需要我们手动创建。当事件循环结束时，自动释放池会执行 drain 并销毁。</p>
<ul>
<li>线程与自动释放池</li>
</ul>
<p>每个线程(包括主线程)都维护着自己的<code>自动释放池栈</code>，新创建的 pool 会被 push 到栈顶，当 pool 销毁时它会 pop 出栈。当前线程中被标记为 autorelease 的对象会被加入到栈顶的 pool 内。当线程销毁时，与之相关的 pool 也都会通过 drain 自动销毁。</p>
<h4 id="1-5-pool的实现"><a href="#1-5-pool的实现" class="headerlink" title="1.5.pool的实现"></a>1.5.pool的实现</h4><blockquote>
<p>这部分内容转载自<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">sunnyxx</a>的博客~</p>
</blockquote>
<p>ARC下我们使用 <code>@autoreleasepool{}</code>来使用一个 <code>AutoreleasePool</code>，编译后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *context = objc_autoreleasePoolPush();</span><br><span class="line">//用户代码，所有接收到 autorelease 消息的对象都被加到此autoreleasepool中</span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure>
<p>autoreleasepool 其实是一个保存着指针的栈，其中指针指向的是需要 release 的对象或哨兵对象。而它能够释放的原因是系统在每个 runloop 迭代中都加入了autoreleasePoolPush 和 Pop。<br>&emsp;</p>
<p>这两个函数都是对 AutoreleasePoolPage 的简单封装，AutoreleasePoolPage 是一个C++实现的类：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj2ugt21wj20f109m3zl.jpg" alt="image"></p>
<ul>
<li>thread 指针指向当前线程，AutoreleasePool 是按线程一一对应的；</li>
<li>id *next 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置。</li>
</ul>
<p><code>AutoreleasePool</code> 并没有单独的结构，而是由若干个 <code>AutoreleasePoolPage</code> 以双向链表的形式组合而成。当一个 <code>AutoreleasePoolPage</code> 的空间被占满时，会新建一个 <code>AutoreleasePoolPage</code> 对象连接链表，后面的 <code>autorelease</code> 对象会 add 到新的 <code>page</code> 中。<br>&emsp;</p>
<p>线程中只有一个<code>AutoreleasePoolPage</code>对象并记录了多个<code>autorelease</code>对象时，其内存如下：</p>
<p><img src="http://ww2.sinaimg.cn/mw690/51530583gw1elj5gvphtqj20dy0cx756.jpg" alt="image"></p>
<p>图中的情况，这一页再加入一个<code>autorelease</code>对象就要满了（也就是<code>next</code>指针马上指向栈顶），这时就要执行上面说的操作，建立下一页<code>page</code>对象，与这一页链表连接完成后，新<code>page</code>的<code>next</code>指针被初始化在栈底（<code>begin</code>的位置），然后继续向栈顶添加新对象。<br>&emsp;</p>
<p>向一个对象发送<code>-autorelease</code>消息，就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈中<code>next</code>指针指向的位置。</p>
<h4 id="1-6-释放的过程"><a href="#1-6-释放的过程" class="headerlink" title="1.6.释放的过程"></a>1.6.释放的过程</h4><p>每次调用<code>objc_autoreleasePoolPush</code>时，runtime 都会向当前<code>AutoreleasePoolPage</code>中插入一个哨兵对象，值为0（空对象）。<code>objc_autoreleasePoolPush</code> 的返回值正是这个哨兵对象的地址，被 <code>objc_autoreleasePoolPop</code>(哨兵对象) 作为入参：</p>
<p><img src="http://ww2.sinaimg.cn/large/51530583gw1elj5z7hawej20ji0dewff.jpg" alt="image"></p>
<p>释放的流程：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的 page。</li>
<li>向当前 page 中晚于哨兵对象插入的所有 autorelease 对象发送 -release 消息。</li>
<li>回头移动 next 指针到正确位置。</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page。</li>
</ol>
<p>objc_autoreleasePoolPop 执行后，最终变成了下面的样子：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/51530583gw1elj6u2i3fyj20dz0bqdgi.jpg" alt="image"></p>
<h3 id="2-ARC"><a href="#2-ARC" class="headerlink" title="2.ARC"></a>2.ARC</h3><p>ARC，自动引用计数是苹果在 iOS5 之后推出的新技术。使用ARC时，我们不再需要手动添加<code>retain</code>、<code>release</code>、<code>autorelease</code>这样的内存管理代码，编译器会在编译代码时自动帮我们添加。这样不仅节省了开发者的时间，还避免了因为疏忽而导致的内存泄露或者过度释放的问题，我们只需要专注于自己的业务。</p>
<blockquote>
<p>ARC differs from tracing garbage collection in that there is no background process that deallocates the objects asynchronously at runtime.[3] Unlike garbage collection, ARC does not handle reference cycles automatically. This means that as long as there are “strong” references to an object, it will not be deallocated. Strong cross-references can accordingly create deadlocks and memory leaks. It is up to the developer to break cycles by using weak references.</p>
</blockquote>
<p>ARC并不是垃圾回收机制，它只是 LLVM 3.0 编译器的新特性，主要工作是在代码编译时帮我们将对象标记为    retain、release、autorelease。</p>
<h4 id="2-1-变量修饰符"><a href="#2-1-变量修饰符" class="headerlink" title="2.1.变量修饰符"></a>2.1.变量修饰符</h4><p>ARC下的四个变量修饰符：</p>
<ul>
<li>__strong</li>
</ul>
<p>对应属性修饰符中的<code>strong</code>，强引用，表示指针指向并拥有某个对象（引用计数+1）。这是声明对象时默认的修饰符，如果想释放强引用的对象，则将指针置为nil即可。ARC下当没有任何一个强引用指向对象时，对象才会销毁。</p>
<ul>
<li>__weak</li>
</ul>
<p>对应属性修饰符中的<code>weak</code>，弱引用，表示指向但不拥有某个对象（引用计数不变）。__weak 不会影响对象的释放，即只要没有强引用指向对象，即使有N个弱引用指向此对象，那么对象还是会被销毁。对象被释放时，__weak 指针会被自动置为nil，不会引发野指针问题。</p>
<ul>
<li>__autoreleasing</li>
</ul>
<p>相当于MRC中的 autorelease，属性不能使用此修饰符。使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//ARC</span><br><span class="line">NSDictionary * __autoreleasing dic = [[NSDictionary alloc] init];</span><br><span class="line">//MRC</span><br><span class="line">NSDictionary *dic = [[[NSDictionary alloc] init] autorelease];</span><br></pre></td></tr></table></figure>
<ul>
<li>__unsafe_unretained</li>
</ul>
<p>对应属性修饰符中的<code>unsafe_unretained</code>，相当于 MRC 中的<code>assign</code>，只是将指针指向某对象，不改变其引用计数，不影响其释放。之所以以<code>unsafe</code>开头，是因为当此对象被释放时，原指针仍会指向此对象所在的内存区域，再次调用此指针时会引发野指针问题，不安全。</p>
<h4 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2.注意事项"></a>2.2.注意事项</h4><ul>
<li>不能再手动向对象发送retain, release, autorelease、retainCount、dealloc消息；</li>
<li>可以重写 dealloc 方法，但不能在其内部调用[super dealloc]；</li>
<li>不能使用 NSAutoreleasePool 对象，而是使用 @autoreleasepool{}；</li>
<li>属性修饰符 weak 相当于原来的 assign，strong 相当于原来的 retain；</li>
</ul>
<p>XCode中 ARC 的开关，可以通过 Build Settings-&gt;Objective-C Automotic Reference Counting选项来设置。</p>
<hr>
<p>相关参考：</p>
<p>#<a href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting" target="_blank" rel="noopener">©wiki-Automatic_Reference_Counting</a></p>
<p>#<a href="http://www.cnblogs.com/flyFreeZn/p/4264220.html" target="_blank" rel="noopener">©不忘初“辛”-ARC技术要点</a></p>
<p>#<a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=objc" target="_blank" rel="noopener">©Apple-NSAutoreleasePool</a></p>
<p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-SW5" target="_blank" rel="noopener">©Apple-Autorelease Pool Blocks</a></p>
<p>#<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">©sunnyxx</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#机制" >
    <span class="tag-code">机制</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/01/20/reuse_cell.html">
        <span class="nav-arrow">← </span>
        
          UITableViewCell 的重用、卡顿与离屏渲染
        
      </a>
    
    
      <a class="nav-right" href="/2018/01/27/compile.html">
        
          编译器、代码编译过程、Xcode Build过程
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-MRC"><span class="toc-nav-text">1.MRC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-retain-release"><span class="toc-nav-text">1.1.retain/release</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-自动释放池"><span class="toc-nav-text">1.2.自动释放池</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-3-pool的创建"><span class="toc-nav-text">1.3.pool的创建</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#1-3-1-自动创建"><span class="toc-nav-text">1.3.1.自动创建</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#1-3-2-手动创建"><span class="toc-nav-text">1.3.2.手动创建</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-4-pool的销毁"><span class="toc-nav-text">1.4.pool的销毁</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-5-pool的实现"><span class="toc-nav-text">1.5.pool的实现</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-6-释放的过程"><span class="toc-nav-text">1.6.释放的过程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-ARC"><span class="toc-nav-text">2.ARC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-变量修饰符"><span class="toc-nav-text">2.1.变量修饰符</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-注意事项"><span class="toc-nav-text">2.2.注意事项</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/01/21/autoreleasepool.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "OC中的内存管理",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>