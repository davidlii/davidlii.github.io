

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Davidli">
  <meta name="keywords" content="Davidli">
  
    <meta name="description" content="MRC1.retain&#x2F;release123456789@protocol NSObject&#x2F;&#x2F;...- (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUI">
<meta property="og:type" content="article">
<meta property="og:title" content="OC中的内存管理">
<meta property="og:url" content="https://davidlii.cn/2018/01/21/autoreleasepool.html">
<meta property="og:site_name" content="Davidli">
<meta property="og:description" content="MRC1.retain&#x2F;release123456789@protocol NSObject&#x2F;&#x2F;...- (instancetype)retain OBJC_ARC_UNAVAILABLE;- (oneway void)release OBJC_ARC_UNAVAILABLE;- (instancetype)autorelease OBJC_ARC_UNAVAILABLE;- (NSUI">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_WithoutPool.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_WithPool.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_add_autoreleaseObj.jpg">
<meta property="article:published_time" content="2018-01-21T14:15:32.000Z">
<meta property="article:modified_time" content="2019-01-11T15:00:32.000Z">
<meta property="article:author" content="Davidli">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://davidlii.nos-eastchina1.126.net/pic_WithoutPool.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>OC中的内存管理 - Davidli</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"davidlii.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Davidlii</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/IMG_0.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="OC中的内存管理"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-01-21 22:15" pubdate>
          2018年1月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          40k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          337 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">OC中的内存管理</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><h4 id="1-retain-x2F-release"><a href="#1-retain-x2F-release" class="headerlink" title="1.retain&#x2F;release"></a>1.retain&#x2F;release</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">//...</span><br>- (<span class="hljs-keyword">instancetype</span>)<span class="hljs-keyword">retain</span> OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-keyword">oneway</span> <span class="hljs-type">void</span>)release OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-keyword">instancetype</span>)autorelease OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-built_in">NSUInteger</span>)retainCount OBJC_ARC_UNAVAILABLE;<br><br>- (<span class="hljs-keyword">struct</span> _NSZone *)zone OBJC_ARC_UNAVAILABLE;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>在MRC时代，对象的生命周期是通过引用计数来管理的，我们需要通过频繁地手动添加<code>retain</code>来使引用计数 +1，通过<code>release</code>来使引用计数 -1，当对象的引用计数为 0 时，对象会被销毁。<br><br/></p>
<p>#示例1：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe">- (void)setName:<span class="hljs-type"></span>(NSString *)<span class="hljs-keyword">new</span><span class="hljs-type">Name</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (_name != <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>) &#123;<br>        [<span class="hljs-keyword">new</span><span class="hljs-type">Name</span> retain]<span class="hljs-comment">//引用计数+1，强引用新值</span><br>        [_name release];<span class="hljs-comment">//引用计数-1，释放旧值</span><br>        _name = <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样的管理方式不仅比较繁琐，而且可能会因为疏忽大意而导致内存泄露或过度释放情况的发生。比如示例1中，我们是先通过<code>retain</code>使<code>newName</code>引用计数 +1，再通过<code>release</code>使引用计数 -1。如果这两者顺序颠倒，则就可能出问题。假设<code>newName</code>和_name 的旧值是同一个对象，那么先<code>release</code>旧值就会使旧值的引用计数为0，从而导致对象被提前释放，后面再赋值给_name 就无效。</p>
<h4 id="2-自动释放池"><a href="#2-自动释放池" class="headerlink" title="2.自动释放池"></a>2.自动释放池</h4><p>与 release 相比，<code>autorelease</code>算是一种延迟对象释放时间的方式。它需要配合 autorelease pool(自动释放池)使用，我们只需要将对象标记为<code>autorelease</code>，这样对象就会被自动加入到自动释放池中；自动释放池会在合适的时机自动或手动执行<code>drain</code>方法进行销毁；销毁前会向其内部的这些对象发送<code>release</code>消息，从而使对象的引用计数-1；当引用计数为 0 时，对象的内存空间就会被释放。一个对象可以被多次放入到同一个自动释放池内，并且每次放入池内时都会调用一次<code>release</code>方法。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">NSDictionary *dic = <span class="hljs-comment">[<span class="hljs-comment">[<span class="hljs-comment">[NSDictionary alloc]</span> init]</span> autorelease]</span>;<br></code></pre></td></tr></table></figure>

<p>自动释放池在 MRC 和 ARC 中有不同的形式和使用方法：</p>
<ul>
<li>MRC 中的 NSAutoreleasePool</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NSAutoreleasePool</span> <span class="hljs-operator">*</span>pool <span class="hljs-operator">=</span> [[<span class="hljs-type">NSAutoreleasePool</span> alloc] <span class="hljs-keyword">init</span>];<br><span class="hljs-comment">// Code benefitting from a local autorelease pool.</span><br>[pool release];<br></code></pre></td></tr></table></figure>

<ul>
<li>ARC 中的 @autoreleasepool{}</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@autoreleasepool</span> &#123;<br>    // <span class="hljs-selector-tag">Code</span> benefitting <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> local autorelease pool.<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在ARC环境下，我们不能直接使用 NSAutoreleasePool 对象，而要使用后者。根据 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=objc">开发文档</a> 的描述，后者的效率更高。</p>
<h4 id="3-pool的创建"><a href="#3-pool的创建" class="headerlink" title="3.pool的创建"></a>3.pool的创建</h4><h5 id="3-1-自动"><a href="#3-1-自动" class="headerlink" title="3.1.自动"></a>3.1.自动</h5><p>大部分情况下，系统已经为我们创建了自动释放池，并不需要我们自己创建。那么系统是什么时候帮我们创建的自动释放池呢。。。？这就要结合 runloop 来分析，下面这段内容是应用执行到didFinishLaunchingWithOptions时，通过 po [NSRunLoop currentRunLoop] 打印的当前runloop的信息：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs xquery">po [NSRunLoop currentRunLoop]<br>&lt;CFRunLoop <span class="hljs-number">0x600001cb0100</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;wakeup port = <span class="hljs-number">0x1f07</span>, stopped =<span class="hljs-built_in"> false</span>, ignoreWakeUps =<span class="hljs-built_in"> false</span>, <br>current mode = kCFRunLoopDefaultMode,<br>common modes = &lt;CFBasicHash <span class="hljs-number">0x600002ef2910</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">2</span>,<br>entries =&gt;<br>    <span class="hljs-number">0</span> : &lt;CFString <span class="hljs-number">0x116ab9be0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;contents = <span class="hljs-string">&quot;UITrackingRunLoopMode&quot;</span>&#125;<br>    <span class="hljs-number">2</span> : &lt;CFString <span class="hljs-number">0x10bef8168</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;contents = <span class="hljs-string">&quot;kCFRunLoopDefaultMode&quot;</span>&#125;<br>&#125;<br>,<br>common mode items = &lt;CFBasicHash <span class="hljs-number">0x600002e81da0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">13</span>,<br>entries =&gt;<br>    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;&#125;<br>    <span class="hljs-number">1</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0540</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000015b5080</span>, callout = __handleEventQueue (<span class="hljs-number">0x116270912</span>)&#125;&#125;<br>    <span class="hljs-number">2</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b1f80</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = Yes, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000004b1680</span>, callout = FBSSerialQueueRunLoopSourceHandler (<span class="hljs-number">0x118c99f0b</span>)&#125;&#125;<br>    <span class="hljs-number">3</span> : &lt;CFRunLoopObserver <span class="hljs-number">0x6000011b0c80</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0x1161aedfc</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;<br>    <span class="hljs-number">4</span> : &lt;CFRunLoopObserver <span class="hljs-number">0x6000011b0be0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0x1</span>, repeats = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (<br>    <span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;</span><br><span class="language-xml">)&#125;&#125;</span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0b40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0x1161aee75</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    6 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0aa0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (</span><br><span class="language-xquery">    <span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;</span></span><br><span class="language-xml"><span class="language-xquery">)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    7 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0cc0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    13 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0e40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">13583</span>, subsystem = <span class="hljs-number">0x116a53448</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x0</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    14 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x600002e81830</span>, callout = __handleHIDEventFetcherDrain (<span class="hljs-number">0x11627091e</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    15 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b05a0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0x1117046ae</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x0</span>&gt;&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">    18 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b4480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">42499</span>, subsystem = <span class="hljs-number">0x116a654b0</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x6000020acb80</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    21 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b4640</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x20</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x600000bb5a40</span>&gt;&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">modes = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002ef2850</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">4</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">2</span> : &lt;CFRunLoopMode <span class="hljs-number">0x600001bb4270</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;<span class="hljs-built_in">&#123;name</span> = UITrackingRunLoopMode, port set = <span class="hljs-number">0x5103</span>, queue = <span class="hljs-number">0x600000eb5500</span>, source = <span class="hljs-number">0x600000eb5600</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0x5003</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = &lt;CFBasicHash <span class="hljs-number">0x600002e81e30</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">4</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    4 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0540</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000015b5080</span>, callout = __handleEventQueue (<span class="hljs-number">0x116270912</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b1f80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = Yes, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000004b1680</span>, callout = FBSSerialQueueRunLoopSourceHandler (<span class="hljs-number">0x118c99f0b</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    6 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x600002e81830</span>, callout = __handleHIDEventFetcherDrain (<span class="hljs-number">0x11627091e</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    sources1 = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002e81e60</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">3</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0e40</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">13583</span>, subsystem = <span class="hljs-number">0x116a53448</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x0</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    1 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b4480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">42499</span>, subsystem = <span class="hljs-number">0x116a654b0</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x6000020acb80</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    2 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0cc0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    observers = (</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0be0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x1</span>, repeats = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b4640</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x20</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x600000bb5a40</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0c80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0x1161aedfc</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b05a0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0x1117046ae</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0b40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0x1161aee75</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0aa0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;</span><br><span class="language-xml">),</span><br><span class="language-xml">    timers = (null),</span><br><span class="language-xml">    currently 563029792 (7903325957143) / soft deadline in: 1.84467362e+10 sec (@ -1) / hard deadline in: 1.84467362e+10 sec (@ -1)</span><br><span class="language-xml">&#125;,</span><br><span class="language-xml"></span><br><span class="language-xml">    3 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopMode</span> <span class="hljs-attr">0x600001bb4340</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> = GSEventReceiveRunLoopMode, port set = <span class="hljs-number">0x2e03</span>, queue = <span class="hljs-number">0x600000eb5680</span>, source = <span class="hljs-number">0x600000eb5780</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0x4e03</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = &lt;CFBasicHash <span class="hljs-number">0x600002e81ef0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    sources1 = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002e81f20</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">2</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0f00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    observers = (null),</span><br><span class="language-xml">    timers = (null),</span><br><span class="language-xml">    currently 563029792 (7903327601583) / soft deadline in: 1.84467362e+10 sec (@ -1) / hard deadline in: 1.84467362e+10 sec (@ -1)</span><br><span class="language-xml">&#125;,</span><br><span class="language-xml"></span><br><span class="language-xml">    4 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopMode</span> <span class="hljs-attr">0x600001bb04e0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> = kCFRunLoopDefaultMode, port set = <span class="hljs-number">0x210b</span>, queue = <span class="hljs-number">0x600000eb1500</span>, source = <span class="hljs-number">0x600000eb1600</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0x1d07</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = &lt;CFBasicHash <span class="hljs-number">0x600002e81e90</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">4</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    4 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0540</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000015b5080</span>, callout = __handleEventQueue (<span class="hljs-number">0x116270912</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b1f80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = Yes, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000004b1680</span>, callout = FBSSerialQueueRunLoopSourceHandler (<span class="hljs-number">0x118c99f0b</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    6 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x600002e81830</span>, callout = __handleHIDEventFetcherDrain (<span class="hljs-number">0x11627091e</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    sources1 = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002e81ec0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">3</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0e40</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">13583</span>, subsystem = <span class="hljs-number">0x116a53448</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x0</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    1 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b4480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">42499</span>, subsystem = <span class="hljs-number">0x116a654b0</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x6000020acb80</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    2 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0cc0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    observers = (</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0be0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x1</span>, repeats = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b4640</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x20</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x600000bb5a40</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0c80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0x1161aedfc</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b05a0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0x1117046ae</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0b40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0x1161aee75</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0aa0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;</span><br><span class="language-xml">),</span><br><span class="language-xml">    timers = <span class="hljs-tag">&lt;<span class="hljs-name">CFArray</span> <span class="hljs-attr">0x6000004b7360</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopTimer <span class="hljs-number">0x6000015b5440</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;valid = Yes, firing = No, interval = <span class="hljs-number">0</span>, tolerance = <span class="hljs-number">0</span>, <span class="hljs-keyword">next</span> fire date = <span class="hljs-number">563029756</span> (-<span class="hljs-number">36.444778</span> @ <span class="hljs-number">7866885955998</span>), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (<span class="hljs-number">0x10ac9327d</span> / <span class="hljs-number">0x115810fb9</span>) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore), <span class="hljs-keyword">context</span> = &lt;CFRunLoopTimer <span class="hljs-keyword">context</span> <span class="hljs-number">0x6000035f3a40</span>&gt;&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">)&#125;,</span><br><span class="language-xml">    currently 563029792 (7903327672130) / soft deadline in: 1.8446744e+10 sec (@ 7866885955998) / hard deadline in: 1.8446744e+10 sec (@ 7866885955998)</span><br><span class="language-xml">&#125;,</span><br><span class="language-xml"></span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopMode</span> <span class="hljs-attr">0x600001bb08f0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> = kCFRunLoopCommonModes, port set = <span class="hljs-number">0x3e0f</span>, queue = <span class="hljs-number">0x600000ebc400</span>, source = <span class="hljs-number">0x600000ebc500</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0xa803</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    sources1 = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    observers = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    timers = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    currently <span class="hljs-number">563029792</span> (<span class="hljs-number">7903329641921</span>) / soft deadline in: <span class="hljs-number">1.84467362</span>e+<span class="hljs-number">10</span> sec (@ -<span class="hljs-number">1</span>) / hard deadline in: <span class="hljs-number">1.84467362</span>e+<span class="hljs-number">10</span> sec (@ -<span class="hljs-number">1</span>)</span></span><br><span class="language-xquery"><span class="language-xquery">&#125;</span></span><span class="language-xml">,</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure>

<p>以下是摘要，显示的是启动后系统在主线程的 Runloop 中自动添加的观察者：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">observers = (<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x6000011b0be0 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>x1, repeats = Yes, order = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0</span>x<span class="hljs-number">11617f1b1</span>), context = &lt;CFArray <span class="hljs-number">0</span>x600002efc360 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;type = mutable-small, count = <span class="hljs-number">1</span>, values = (\n\t0 : &lt;<span class="hljs-number">0</span>x7ffe<span class="hljs-number">6c009058</span>&gt;\n)&#125;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b4640</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>x20, repeats = Yes, order = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x600000bb5a40&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b0c80</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0</span>x1161aedfc), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x7ffe<span class="hljs-number">6b7018e0</span>&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b05a0</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0</span>x1117046ae), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x0&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b0b40</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0</span>x1161aee75), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x7ffe<span class="hljs-number">6b7018e0</span>&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x6000011b0aa0 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0</span>x<span class="hljs-number">11617f1b1</span>), context = &lt;CFArray <span class="hljs-number">0</span>x600002efc360 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;type = mutable-small, count = <span class="hljs-number">1</span>, values = (\n\t0 : &lt;<span class="hljs-number">0</span>x7ffe<span class="hljs-number">6c009058</span>&gt;\n)&#125;&#125;&quot;<br>),<br></code></pre></td></tr></table></figure>

<p>其中第1和第6个观察者，两者的<code>activities</code>分别是<code>0x1</code>和<code>0xa0</code>。<code>activities</code>表示的是当前 runloop 所处的状态，下面是 CFRunloop.h 中定义的 activities 枚举值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/* Run Loop Observer Activities */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">CF_OPTIONS</span>(<span class="hljs-built_in">CFOptionFlags</span>, <span class="hljs-built_in">CFRunLoopActivity</span>) &#123;<br>    kCFRunLoopEntry = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">0</span>),<br>    kCFRunLoopBeforeTimers = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">1</span>),<br>    kCFRunLoopBeforeSources = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">2</span>),<br>    kCFRunLoopBeforeWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">5</span>),<br>    kCFRunLoopAfterWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">6</span>),<br>    kCFRunLoopExit = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">7</span>),<br>    kCFRunLoopAllActivities = <span class="hljs-number">0x0FFFFFFF</span>U<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>activities &#x3D; 0x1，对应的就是 kCFRunLoopEntry；activities &#x3D; 0xa0，对应的就是 kCFRunLoopBeforeWaiting | kCFRunLoopExit。</p>
</blockquote>
<p>解释一下，<code>kCFRunLoopEntry</code>表示 runloop 已启动；<code>kCFRunLoopBeforeWaiting</code>表示 runloop 没事做了即将休眠；<code>kCFRunLoopExit</code>表示 runloop 已结束；从第1和第6个观察者的 callout 描述可以看到，它们的回调都是_wrapRunLoopWithAutoreleasePoolHandler，关于这个回调，目前我尚未查到其源码，它具体怎么实现自动释放池的创建和销毁暂不能一探究竟。按照网上各大博主的说法：</p>
<ul>
<li>在进入runloop时（kCFRunLoopEntry），观察者回调中会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li>
<li>在runloop即将休眠时（kCFRunLoopBeforeWaiting），观察者回调中会调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；</li>
<li>在runloop退出时（kCFRunLoopExit），观察者回调中会调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个观察者的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li>
</ul>
<p>虽然_wrapRunLoopWithAutoreleasePoolHandler的源码我暂时不得而知，但_objc_autoreleasePoolPush()和_objc_autoreleasePoolPop()的源码是可追踪的，后面的5.2小节中会具体讲解~<br><br/></p>
<p><strong>小结：</strong>系统提供的自动释放池，其创建发生在两个时机：runloop启动时 和 runloop即将休眠时。</p>
<h5 id="3-2-手动"><a href="#3-2-手动" class="headerlink" title="3.2.手动"></a>3.2.手动</h5><p>绝大多数情况下，系统会帮我们自动创建和销毁自动释放池。但是，根据 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-SW5">开发文档</a> 的描述，以下场景下我们需要自己创建自动释放池：</p>
<ul>
<li>If you are writing a program that is not based on a UI framework, such as a command-line tool.</li>
</ul>
<p>如果你的项目不是基于UI framework的，比如命令行工具，则你需要自己创建自动释放池管理对象的生命周期。</p>
<ul>
<li>If you write a loop that creates many temporary objects.</li>
</ul>
<blockquote>
<p>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</p>
</blockquote>
<p>就是说，当你的循环体内创建了大量的临时对象时，你需要在循环体内创建一个自动释放池，这样临时对象会被标记为 autorelease 并在下次循环之前销毁。 在循环体内使用自动释放池可以降低内存峰值。<br><br/></p>
<p>#示例2：在一个模态弹出的界面的<code>viewDidLoad</code>方法中模拟一个循环体内大量创建临时变量的情况：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>        <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>            <span class="hljs-built_in">NSString</span> *string = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;ADFAFDSFNKFNASFSKJFNSFSDAFAOSJDSAFASFJDSJFIOWJFIOKALNFJASFASLKFLSAJFSLAFK&quot;</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是<strong>不使用</strong>自动释放池，反复弹出界面时的内存峰值状况图：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_WithoutPool.png" srcset="/img/loading.gif" lazyload alt="不使用释放池"></p>
<p>这是<strong>使用</strong>自动释放池，反复弹出界面时的内存峰值状况图：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_WithPool.png" srcset="/img/loading.gif" lazyload alt="使用释放池"></p>
<p>通过对比，可以清楚的看到，使用自动释放池时，即使创建了大量的临时对象，对象都能及时释放，内存的峰值也几乎没变化~</p>
<ul>
<li>If you spawn a secondary thread.</li>
</ul>
<blockquote>
<p>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects.</p>
</blockquote>
<p>当你创建了一个子线程时，也需要在线程启动时主动创建一个自动释放池，否则会产生内存泄露。<br><br/></p>
<p>#示例3：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSThread</span> *thread = [[[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onHandleThread) object:<span class="hljs-literal">nil</span>] autorelease];<br>        [thread start];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br>- (<span class="hljs-type">void</span>)onHandleThread<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        Person *person = [[[Person alloc] init] autorelease];<br>        person.name = <span class="hljs-string">@&quot;IOI&quot;</span>;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++子线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br>-(<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++PERSON IS DEALLOCED~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>注意，先将 Build Settings-&gt;Objective-C Automotic Reference Counting 选项设置为NO，禁用ARC。运行后，输出日志：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">+++++子线程:&lt;NSThread: <span class="hljs-number">0x600002bf8180</span>&gt;&#123;number = <span class="hljs-number">3</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++++PERSON <span class="hljs-keyword">IS</span> DEALLOCED~<br></code></pre></td></tr></table></figure>

<p>如日志所示，MRC环境下，在子线程中创建对象之后，使用 autorelease pool 并将对象标记为 autorelease，任务执行完成之后对象能正常释放。你也可以试着将 @autorelease{ } 块和 autorelease 去掉，运行之后对象不会销毁。<br><br/></p>
<p><strong>需要注意的是</strong>，子线程中需要自己创建释放池的说法只针对MRC的环境。在ARC的环境下，我们在子线程中创建新的对象后，该对象是能自动释放的。可以将 Build Settings-&gt;Objective-C Automotic Reference Counting 选项设置为 YES，启用ARC，修改代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onHandleThread) object:<span class="hljs-literal">nil</span>];<br>    [thread start];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br>- (<span class="hljs-type">void</span>)onHandleThread<br>&#123;<br>    Person *person = [[Person alloc] init];<br>    person.name = <span class="hljs-string">@&quot;IOI&quot;</span>;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++子线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">+++++子线程:&lt;NSThread: <span class="hljs-number">0x600003d3f040</span>&gt;&#123;number = <span class="hljs-number">3</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++++PERSON <span class="hljs-keyword">IS</span> DEALLOCED~<br></code></pre></td></tr></table></figure>

<p>可以看到，ARC环境下，在子线程中创建了 Person 的实例对象，并且没有主动在子线程中添加释放池，但 person 对象最后确实销毁了。<br><br/></p>
<p>那么为啥 ARC 环境下子线程中不使用自动释放池，临时对象也能释放呢？StackOverflow 的 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now">这篇帖子</a> 中有一种解释：</p>
<blockquote>
<p>The latest version of the runtime (646, which shipped with OS X 10.10 and iOS 8) does indeed add a pool if you perform an autorelease without a pool on the current thread. The previous version of the runtime (551.1, which came with OS X 10.9 and iOS 7), also did this.</p>
</blockquote>
<p>从 OSX 10.9 和 iOS7 开始，如果我们在线程中没有使用 autorelease pool，那么苹果会自动帮我们创建一个 pool 来释放对象，避免了内存泄露。我瞄了一眼这份<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/RevisionHistory.html#//apple_ref/doc/uid/20001607-CJBGIAGF">开发文档</a>的更新日志，上次更新时间竟还停留在 2012-07-17！下面是最新的 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 中的源码：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-built_in">id</span> autorelease(<span class="hljs-built_in">id</span> obj)<br>    &#123;<br>        <span class="hljs-keyword">assert</span>(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>obj<span class="hljs-operator">-&gt;</span>isTaggedPointer());<br>        <span class="hljs-built_in">id</span> <span class="hljs-operator">*</span>dest __unused <span class="hljs-operator">=</span> autoreleaseFast(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>dest  <span class="hljs-operator">||</span>  dest <span class="hljs-operator">==</span> EMPTY_POOL_PLACEHOLDER  <span class="hljs-operator">||</span>  <span class="hljs-operator">*</span>dest <span class="hljs-operator">==</span> obj);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这是 autorelease 方法底层实现的源码，在子线程中不创建自动释放池，直接将对象标记为 autorelease 时，会调用 autoreleaseFast()，参数为当前 autorelease 对象。</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sas">static inline id <span class="hljs-comment">*autoreleaseFast(id obj)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        AutoreleasePoolPage *page = hotPage();</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">page</span> <span class="hljs-variable">&amp;&amp;</span> !<span class="hljs-keyword">page</span>-&gt;full()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">page</span>-&gt;<span class="hljs-keyword">add</span>(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">page</span>) &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseFullPage(obj, <span class="hljs-keyword">page</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>因为没有创建释放池，所以 autoreleaseFast() 内会直接进入最后一个判断语句中，接着调用 autoreleaseNoPage()，参数为 autorelease 对象。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">static</span> __attribute__((noinline))<br>    id *autoreleaseNoPage(id obj)<br>    &#123;<br>        <span class="hljs-comment">// &quot;No page&quot; could mean no pool has been pushed</span><br>        <span class="hljs-comment">// or an empty placeholder pool has been pushed and has no contents yet</span><br>        <span class="hljs-keyword">assert</span>(!hotPage());<br><br>        bool pushExtraBoundary = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;<br>            <span class="hljs-comment">// We are pushing a second pool over the empty placeholder pool</span><br>            <span class="hljs-comment">// or pushing the first object into the empty placeholder pool.</span><br>            <span class="hljs-comment">// Before doing that, push a pool boundary on behalf of the pool </span><br>            <span class="hljs-comment">// that is currently represented by the empty placeholder.</span><br>            pushExtraBoundary = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing an object with no pool in place, </span><br>            <span class="hljs-comment">// and no-pool debugging was requested by environment.</span><br>            _objc_inform(<span class="hljs-string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br>                         <span class="hljs-string">&quot;autoreleased with no pool in place - &quot;</span><br>                         <span class="hljs-string">&quot;just leaking - break on &quot;</span><br>                         <span class="hljs-string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, <br>                         pthread_self(), (<span class="hljs-keyword">void</span>*)obj, object_getClassName(obj));<br>            objc_autoreleaseNoPool(obj);<br>            <span class="hljs-keyword">return</span> nil;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing a pool with no pool in place,</span><br>            <span class="hljs-comment">// and alloc-per-pool debugging was not requested.</span><br>            <span class="hljs-comment">// Install and return the empty pool placeholder.</span><br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">setEmptyPoolPlaceholder</span><span class="hljs-params">()</span></span>;<br>        &#125;<br><br>        <span class="hljs-comment">// We are pushing an object or a non-placeholder&#x27;d pool.</span><br><br>        <span class="hljs-comment">// Install the first page.创建page </span><br>        AutoreleasePoolPage *page = <span class="hljs-keyword">new</span> AutoreleasePoolPage(nil);<br>        setHotPage(page); <span class="hljs-comment">//设置为当前正在使用的 pool</span><br>        <br>        <span class="hljs-comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br>        <span class="hljs-keyword">if</span> (pushExtraBoundary) &#123;<br>            page-&gt;add(POOL_BOUNDARY);<br>        &#125;<br>        <br>        <span class="hljs-comment">// Push the requested object or pool.</span><br>        <span class="hljs-keyword">return</span> page-&gt;add(obj);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>进入函数后，因为没设置释放池，所以 haveEmptyPoolPlaceholder() 返回 false；又因为传进来的 obj 参数是 autorelease 对象而非 POOL_BOUNDARY(边界对象)，所以会直接创建 page 并将其设置为当前正在使用的 pool；随后将 autorelease 对象加入自动释放池的栈顶；在当前线程结束后 pool 会出栈，其中的 autorelease 对象也会随之释放。<br><br/></p>
<p>可见，<strong>ARC环境下苹果已经更改了实现，子线程中会帮我们创建自动释放池，只是文档未更新</strong>。</p>
<h4 id="4-pool的销毁"><a href="#4-pool的销毁" class="headerlink" title="4.pool的销毁"></a>4.pool的销毁</h4><p>在 3.1 小节中讲过，自动释放池的销毁时机主要有两个：runloop即将进入休眠时 和 runloop退出时~</p>
<ul>
<li>AppKit 与自动释放池</li>
</ul>
<blockquote>
<p>AppKit and UIKit frameworks process each event-loop iteration (such as a mouse down event or a tap) within an autorelease pool block. Therefore you typically do not have to create an autorelease pool block yourself, or even see the code that is used to create one.</p>
</blockquote>
<p>在事件循环(event-loop)开始时，AppKit 和 UIKit 会在主线程中创建一个自动释放池，不需要我们手动创建。当事件循环结束时，自动释放池会执行 drain 并销毁。</p>
<ul>
<li>线程与自动释放池</li>
</ul>
<p>每个线程(包括主线程)都维护着自己的<code>自动释放池栈</code>，新创建的 pool 会被 push 到栈顶，当 pool 销毁时它会 pop 出栈。当前线程中被标记为 autorelease 的对象会被加入到栈顶的 pool 内。当线程销毁时，与当前线程相关的 pool 也都会通过 drain 自动销毁。</p>
<h4 id="5-结构与源码"><a href="#5-结构与源码" class="headerlink" title="5.结构与源码"></a>5.结构与源码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   Autorelease pool implementation</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   A thread&#x27;s autorelease pool is a stack of pointers. </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   Each pointer is either an object to release, or POOL_BOUNDARY which is </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     an autorelease pool boundary.</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   A pool token is a pointer to the POOL_BOUNDARY for that pool. When </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     the pool is popped, every object hotter than the sentinel is released.</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   The stack is divided into a doubly-linked list of pages. Pages are added </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     and deleted as necessary. </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   Thread-local storage points to the hot page, where newly autoreleased </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     objects are stored. </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">*</span>**</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*/</span></span><br></code></pre></td></tr></table></figure>

<p>这是 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 源码中对 autorelease pool 的描述。它明确指出：</p>
<ul>
<li>autorelease pool 是一个保存着指针的栈，此栈由一个双向的 pages(AutoreleasePoolPage) 链表组成，链表会在需要时被添加和删除；</li>
<li>栈内指针指向的对象有两种：一种是被标记为 autorelease 而待 release 的对象；另一种是表示 pool 边界的哨兵对象(POOL_BOUNDARY)；</li>
<li>当 pool 被销毁而出栈时，哨兵对象前面的所有 autorelease 对象都会收到 release 消息而释放。</li>
</ul>
<h5 id="5-1-栈与链表"><a href="#5-1-栈与链表" class="headerlink" title="5.1.栈与链表"></a>5.1.栈与链表</h5><p>这里我们先讲一下上面提到的链表。Autorelease pool 并没有单独的结构体，它由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成。<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 中有关于 AutoreleasePoolPage 的定义，成员变量部分摘要如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoreleasePoolPage</span> &#123;<br>    <span class="hljs-type">magic_t</span> <span class="hljs-type">const</span> magic;<br>    id *next;<br>    <span class="hljs-type">pthread_t</span> <span class="hljs-type">const</span> thread;<br>    AutoreleasePoolPage * <span class="hljs-type">const</span> parent;<br>    AutoreleasePoolPage *child;<br>    <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>thread，表示当前线程，每个线程中都有与之对应的 pool，线程启动时创建pool，线程销毁时 drain pool；</li>
<li>id *next，游标，指向栈顶最新 add 进来的 autorelease 对象的下一个位置。</li>
<li>parent，指向父 page；</li>
<li>child，指向子 page；</li>
</ul>
<p>每个线程中都有一个自动释放池的栈，栈内可能有一个或多个<code>AutoreleasePoolPage</code>对象；当将对象标记为<code>autorelease</code>时，此对象会被 add 到栈顶的 page 内；如果此 page 已满，则会创建一个新的 page 作为 <code>child</code>，新 page 的<code>next</code>指针被初始化在栈底；标记为 autorelease 的对象会被 add 到这个新建的 page 内；文字不如图表，这里借用博主 <a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">©sunnyxx</a> 的一张图能更清晰的看到添加 autorelease 对象后 page 的结构：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_add_autoreleaseObj.jpg" srcset="/img/loading.gif" lazyload alt="image"></p>
<h5 id="5-2-pool的创建"><a href="#5-2-pool的创建" class="headerlink" title="5.2.pool的创建"></a>5.2.pool的创建</h5><p>上面对 autorelease pool 的栈结构在原理上有了一个简单的描述，那么在代码层上 pool 是如何被创建的呢？<br><br/></p>
<p>#示例4：使用 @autoreleasepool{ } 来<code>手动</code>创建一个自动释放池</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    @autoreleasepool &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">void</span> (^ blk)(<span class="hljs-type">void</span>) = ^()&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;varable in block:%d&quot;</span>,count);<br>        &#125;;<br>        <span class="hljs-built_in">blk</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用Clang编译后得到的结果如下，这里只截取关键部分的代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">extern <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-constructor">__declspec(<span class="hljs-params">dllimport</span>)</span> void<span class="hljs-operator"> * </span>objc<span class="hljs-constructor">_autoreleasePoolPush(<span class="hljs-params">void</span>)</span>;<br>extern <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-constructor">__declspec(<span class="hljs-params">dllimport</span>)</span> void objc<span class="hljs-constructor">_autoreleasePoolPop(<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>;<br><br><span class="hljs-keyword">struct</span> __AtAutoreleasePool &#123;<br>  <span class="hljs-constructor">__AtAutoreleasePool()</span> &#123;atautoreleasepoolobj = objc<span class="hljs-constructor">_autoreleasePoolPush()</span>;&#125;<br>  ~<span class="hljs-constructor">__AtAutoreleasePool()</span> &#123;objc<span class="hljs-constructor">_autoreleasePoolPop(<span class="hljs-params">atautoreleasepoolobj</span>)</span>;&#125;<br>  void<span class="hljs-operator"> * </span>atautoreleasepoolobj;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, const <span class="hljs-built_in">char</span><span class="hljs-operator"> * </span>argv<span class="hljs-literal">[]</span>) &#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>        <span class="hljs-built_in">int</span> count = <span class="hljs-number">10</span>;<br>        void (* blk)(void) = ((void (*)<span class="hljs-literal">()</span>)&amp;<span class="hljs-constructor">__main_block_impl_0((<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, count));<br>        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，我们声明的 count 和 block 变量及其调用，在编译后的结果中是被 {__AtAutoreleasePool…} 包裹着的。所以实际上，@autoreleasepool{ } 就是通过<code>__AtAutoreleasePool</code>来实现的，它是一个结构体，其定义中包含了：</p>
<ul>
<li>构造函数，负责pool的创建或入栈；</li>
<li>析构函数，负责pool的出栈、销毁；</li>
<li>一个通过析构函数创建的 atautoreleasepoolobj 对象的指针。</li>
</ul>
<p>构造函数和析构函数中分别调用了<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>，关于这两个函数，我们可以在 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 源码中追踪到其具体的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> *<span class="hljs-title function_">objc_autoreleasePoolPush</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">AutoreleasePoolPage</span>::<span class="hljs-title function_">push</span>();<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">objc_autoreleasePoolPop</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *ctxt</span>)<br>&#123;<br>    <span class="hljs-title class_">AutoreleasePoolPage</span>::<span class="hljs-title function_">pop</span>(ctxt);<br>&#125;<br><span class="hljs-keyword">void</span> *<span class="hljs-title function_">_objc_autoreleasePoolPush</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">objc_autoreleasePoolPush</span>();<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">_objc_autoreleasePoolPop</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *ctxt</span>)<br>&#123;<br>    <span class="hljs-title function_">objc_autoreleasePoolPop</span>(ctxt);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里注意，_objc_autoreleasePoolPush 和_objc_autoreleasePoolPop 正是在3.2小节的最后提到的那两个函数，也就是之前说的，主线程会在 Runloop<code>启动</code>和<code>即将休眠</code>时通过回调函数中调用_objc_autoreleasePoolPush()创建 pool，在<code>即将休眠</code>和<code>退出loop</code>时调用_objc_autoreleasePoolPop()释放 pool。这两个函数的内部也只是调用了 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop（注：函数名的开头不带下划线）。<br><br/></p>
<p>因为本小节是介绍 pool 入栈，所以先只讲解 objc_autoreleasePoolPush 函数。它跟 pool 的创建和入栈有什么关系呢？<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-autoreleasepoolpush-void">Clang文档</a> 中有一段关于此函数的描述：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> *objc_autoreleasePoolPush(<span class="hljs-type">void</span>);<br>Creates a <span class="hljs-built_in">new</span> autorelease pool that <span class="hljs-keyword">is</span> enclosed <span class="hljs-keyword">by</span> the <span class="hljs-keyword">current</span> pool, makes that the <span class="hljs-keyword">current</span> pool, <span class="hljs-keyword">and</span> <span class="hljs-keyword">returns</span> an <span class="hljs-type">opaque</span> “handle” <span class="hljs-keyword">to</span> it.<br></code></pre></td></tr></table></figure>

<p>就是说，此函数就是用来创建 autorelease pool 并将其设置为当前 pool，它的内部的调用了<code>AutoreleasePoolPage::push()</code>函数：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-operator">*</span>push() <br>    &#123;<br>        <span class="hljs-built_in">id</span> <span class="hljs-operator">*</span>dest;<br>        <span class="hljs-keyword">if</span> (DebugPoolAllocation) &#123;<span class="hljs-comment">//调试模式</span><br>            <span class="hljs-comment">// Each autorelease pool starts on a new pool page.</span><br>            dest <span class="hljs-operator">=</span> autoreleaseNewPage(POOL_BOUNDARY);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dest <span class="hljs-operator">=</span> autoreleaseFast(POOL_BOUNDARY);<br>        &#125;<br>        <span class="hljs-keyword">assert</span>(dest <span class="hljs-operator">==</span> EMPTY_POOL_PLACEHOLDER <span class="hljs-operator">||</span> <span class="hljs-operator">*</span>dest <span class="hljs-operator">==</span> POOL_BOUNDARY);<br>        <span class="hljs-keyword">return</span> dest;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>if 语句第一个条件是针对调试模式，调试模式下每次自动释放池都会调用 autoreleaseNewPage() 方法，因为是第一次调用所以没有page，就创建一个新的 page。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">id *autorelease<span class="hljs-constructor">NewPage(<span class="hljs-params">id</span> <span class="hljs-params">obj</span>)</span><br>    &#123;<br>        AutoreleasePoolPage *page = hot<span class="hljs-constructor">Page()</span>;<br>        <span class="hljs-keyword">if</span> (page) return autorelease<span class="hljs-constructor">FullPage(<span class="hljs-params">obj</span>, <span class="hljs-params">page</span>)</span>;<br>        <span class="hljs-keyword">else</span> return autorelease<span class="hljs-constructor">NoPage(<span class="hljs-params">obj</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这是调试模式下的实现，我们不用关心它，我们只需要看<code>autoreleaseFast()</code>函数，其参数为<code>POOL_BOUNDARY</code>(注意这个参数，后面讲 autorelease 对象入栈时，会有对比)。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">static inline id *autoreleaseFast(id obj)<br>    &#123;<br>        AutoreleasePoolPage *<span class="hljs-built_in">page</span> = hotPage();<span class="hljs-comment">//获取当前 pool 栈中正在使用的page</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span> &amp;&amp; !<span class="hljs-built_in">page</span>-&gt;</span>full()) &#123;<span class="hljs-comment">//如果当前有page且page没有满，则autorelease对象入栈</span><br>            <span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-built_in">page</span>-&gt;</span>add(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>) &#123;<span class="hljs-comment">//如果此page已经满了，则新建一个page并将此autorelease对象压入栈</span><br>            return autoreleaseFullPage(obj, <span class="hljs-built_in">page</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果没有page，则会创建一个空的占位池</span><br>            return autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br>static inline AutoreleasePoolPage *hotPage() <br>    &#123;<br>        AutoreleasePoolPage *result = (AutoreleasePoolPage *)<br>            tls_get_direct(key);<span class="hljs-comment">//通过线程局部存储(Thread Local Storage)获取当前正在使用的page</span><br>        <span class="hljs-keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) return <span class="hljs-literal">nil</span>;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (result) result-&gt;</span>fastcheck();<br>        return result;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>autoreleaseFast() 函数中，hotPage()用来获取当前 pool 栈内正在使用的 page，首次调用<code>push()</code>时没有 page，所以会进入最后一个判断，调用 autoreleaseNoPage()函数来创建一个<code>空的占位池</code>。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">id *autoreleaseNoPage(id obj)<br>    &#123;<br>        <span class="hljs-comment">// &quot;No page&quot; could mean no pool has been pushed</span><br>        <span class="hljs-comment">// or an empty placeholder pool has been pushed and has no contents yet</span><br>        <span class="hljs-keyword">assert</span>(!hotPage());<br><br>        bool pushExtraBoundary = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否要 push 边界对象</span><br>        <span class="hljs-keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;<span class="hljs-comment">//如果有占位的 EMPTY_POOL_PLACEHOLDER，则设置需&quot;pushExtraBoundary=TRUE&quot;</span><br>            <span class="hljs-comment">// We are pushing a second pool over the empty placeholder pool</span><br>            <span class="hljs-comment">// or pushing the first object into the empty placeholder pool.</span><br>            <span class="hljs-comment">// Before doing that, push a pool boundary on behalf of the pool </span><br>            <span class="hljs-comment">// that is currently represented by the empty placeholder.</span><br>            pushExtraBoundary = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing an object with no pool in place, </span><br>            <span class="hljs-comment">// and no-pool debugging was requested by environment.</span><br>            _objc_inform(<span class="hljs-string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br>                         <span class="hljs-string">&quot;autoreleased with no pool in place - &quot;</span><br>                         <span class="hljs-string">&quot;just leaking - break on &quot;</span><br>                         <span class="hljs-string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, <br>                         pthread_self(), (<span class="hljs-keyword">void</span>*)obj, object_getClassName(obj));<br>            objc_autoreleaseNoPool(obj);<br>            <span class="hljs-keyword">return</span> nil;<br>        &#125;<br>        <span class="hljs-comment">//如果不是调试模式，且对象是边界对象，则去设置空的占位池，也就是 EMPTY_POOL_PLACEHOLDER</span><br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing a pool with no pool in place,</span><br>            <span class="hljs-comment">// and alloc-per-pool debugging was not requested.</span><br>            <span class="hljs-comment">// Install and return the empty pool placeholder.</span><br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">setEmptyPoolPlaceholder</span><span class="hljs-params">()</span></span>;<br>        &#125;<br><br>        <span class="hljs-comment">// We are pushing an object or a non-placeholder&#x27;d pool.</span><br><br>        <span class="hljs-comment">// Install the first page.创建第一个page</span><br>        AutoreleasePoolPage *page = <span class="hljs-keyword">new</span> AutoreleasePoolPage(nil);<br>        setHotPage(page);<span class="hljs-comment">//设置最新的page</span><br>        <br>        <span class="hljs-comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br>        <span class="hljs-keyword">if</span> (pushExtraBoundary) &#123;<br>            page-&gt;add(POOL_BOUNDARY);<br>        &#125;<br>        <br>        <span class="hljs-comment">// Push the requested object or pool.</span><br>        <span class="hljs-keyword">return</span> page-&gt;add(obj);<span class="hljs-comment">//添加一个对象</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>第一次进入此函数时，haveEmptyPoolPlaceholder()会返回 false，所以会进入最后一个判断，调用 setEmptyPoolPlaceholder():</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static inline id* set<span class="hljs-constructor">EmptyPoolPlaceholder()</span><br>    &#123;<br>        <span class="hljs-keyword">assert</span>(tls<span class="hljs-constructor">_get_direct(<span class="hljs-params">key</span>)</span><span class="hljs-operator"> == </span>nil);<br>        tls<span class="hljs-constructor">_set_direct(<span class="hljs-params">key</span>, (<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>EMPTY_POOL_PLACEHOLDER);<br>        return EMPTY_POOL_PLACEHOLDER;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>setEmptyPoolPlaceholder() 会通过 TLS 返回一个 EMPTY_POOL_PLACEHOLDER，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span><br><span class="hljs-comment">// pushed and it has never contained any objects. This saves memory </span><br><span class="hljs-comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span><br><span class="hljs-comment">// never uses them.</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span><br></code></pre></td></tr></table></figure>

<p>EMPTY_POOL_PLACEHOLDER 是一个空的占位池，它存储在 TLS 中，不包含任何对象。<br><br/></p>
<p>至此，执行 @autorelease{ }，第一次调用 push() 函数，最终创建了一个空的占位池~</p>
<h5 id="5-3-对象入栈"><a href="#5-3-对象入栈" class="headerlink" title="5.3.对象入栈"></a>5.3.对象入栈</h5><p>如果在 @autorelease block 内创建了对象，那么这些对象就会被自动标记为 autorelease，并加入到自动释放池中：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-built_in">id</span> autorelease(<span class="hljs-built_in">id</span> obj)<br>    &#123;<br>        <span class="hljs-keyword">assert</span>(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>obj<span class="hljs-operator">-&gt;</span>isTaggedPointer());<br>        <span class="hljs-built_in">id</span> <span class="hljs-operator">*</span>dest __unused <span class="hljs-operator">=</span> autoreleaseFast(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>dest  <span class="hljs-operator">||</span>  dest <span class="hljs-operator">==</span> EMPTY_POOL_PLACEHOLDER  <span class="hljs-operator">||</span>  <span class="hljs-operator">*</span>dest <span class="hljs-operator">==</span> obj);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>从函数实现的源码中可以看到，对象被标记为 autorelease 后，会调用 autoreleaseFast()。上面在介绍 pool 的创建时，已经介绍过这个函数，当时 autoreleaseFast 的参数是一个边界对象(哨兵)，这里的参数则是被标记为 autorelease 的对象本身：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl">static inline id *autoreleaseFast(id obj)<br>    &#123;<br>        AutoreleasePoolPage *<span class="hljs-built_in">page</span> = hotPage();<span class="hljs-comment">//获取当前 pool 栈中正在使用的page</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span> &amp;&amp; !<span class="hljs-built_in">page</span>-&gt;</span>full()) &#123;<span class="hljs-comment">//如果当前有page且page没有满，则autorelease对象入栈</span><br>            <span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-built_in">page</span>-&gt;</span>add(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>) &#123;<span class="hljs-comment">//如果此page已经满了，则新建一个page并将此autorelease对象压入栈</span><br>            return autoreleaseFullPage(obj, <span class="hljs-built_in">page</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果没有page，则会创建一个新的page并插入边界对象</span><br>            return autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>进入函数体之后，会先调用 hotPage() 获取当前在用的page，</li>
</ul>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">static</span> <span class="hljs-variable">inline</span> <span class="hljs-variable">AutoreleasePoolPage</span> *<span class="hljs-function"><span class="hljs-title">hotPage</span>() </span><br><span class="hljs-function">    &#123;</span><br><span class="hljs-function">        <span class="hljs-variable">AutoreleasePoolPage</span> *<span class="hljs-variable"><span class="hljs-class">result</span></span> = (<span class="hljs-variable">AutoreleasePoolPage</span> *)</span><br>            <span class="hljs-function"><span class="hljs-title">tls_get_direct</span>(<span class="hljs-variable">key</span>);</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> ((<span class="hljs-variable">id</span> *)<span class="hljs-variable"><span class="hljs-class">result</span></span> == <span class="hljs-variable">EMPTY_POOL_PLACEHOLDER</span>) <span class="hljs-variable">return</span> <span class="hljs-variable"><span class="hljs-literal">nil</span></span>;</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-class">result</span></span>) <span class="hljs-variable"><span class="hljs-class">result</span></span>-&gt;<span class="hljs-title">fastcheck</span>();</span><br><span class="hljs-function">        <span class="hljs-variable">return</span> <span class="hljs-variable"><span class="hljs-class">result</span></span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure>

<p>当前是第一次调用 autorelease，栈中还没有创建好的page，只在5.2 小节中执行 @autorelease 时创建了一个 EMPTY_POOL_PLACEHOLDER(空的占位池)，所以 hotPage() 会返回 nil。因此 autoreleaseFast()函数会继续调用 autoreleaseNoPage()。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">id *autorelease<span class="hljs-constructor">NoPage(<span class="hljs-params">id</span> <span class="hljs-params">obj</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">assert</span>(!hot<span class="hljs-constructor">Page()</span>);<br><br>        <span class="hljs-built_in">bool</span> pushExtraBoundary = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (have<span class="hljs-constructor">EmptyPoolPlaceholder()</span>) &#123;<br>            pushExtraBoundary = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj != POOL_BOUNDARY<span class="hljs-operator">  &amp;&amp;  </span>DebugMissingPools) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">            </span>return nil;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj<span class="hljs-operator"> == </span>POOL_BOUNDARY<span class="hljs-operator">  &amp;&amp;  </span>!DebugPoolAllocation) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">            </span>return set<span class="hljs-constructor">EmptyPoolPlaceholder()</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Install the first page.</span><br>        AutoreleasePoolPage *page = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AutoreleasePoolPage(<span class="hljs-params">nil</span>)</span>;<br>        set<span class="hljs-constructor">HotPage(<span class="hljs-params">page</span>)</span>;<br>        <br>        <span class="hljs-comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br>        <span class="hljs-keyword">if</span> (pushExtraBoundary) &#123;<br>            page-&gt;add(POOL_BOUNDARY);<br>        &#125;<br>        <br>        <span class="hljs-comment">// Push the requested object or pool.</span><br>        return page-&gt;add(obj);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>因为之前在创建空的占位池时 autoreleaseNoPage()内调用了 setEmptyPoolPlaceholder()，所以这次 haveEmptyPoolPlaceholder() 会返回 true，进入第一个条件语句，pushExtraBoundary 被置为 true，所以最后创建了一个新的page，插入了边界对象，autorelease 对象入栈。<br><br/></p>
<p>将对象压入栈时，会调用 add() 函数，首先解除保护；随后将对象插入到 page 中，并重新设置 next 指针；最后设置保护，返回值为当前 autorelease 对象下一位的索引。源码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">id</span> *add(<span class="hljs-built_in">id</span> obj)<br>    &#123;<br>        <span class="hljs-keyword">assert</span>(!full());<br>        unprotect();<br>        <span class="hljs-built_in">id</span> *ret = <span class="hljs-built_in">next</span>;  // faster than `<span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span>-<span class="hljs-number">1</span>` because of aliasing<br>        *<span class="hljs-built_in">next</span>++ = obj;//将对象压到栈顶，并重新定位栈顶<br>        protect();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>至此，<strong>第一个 autorelease 对象完成入栈~</strong><br><br/></p>
<p>后面再有对象被标记为 autorelease 时，依然走 autoreleaseFast()，但这时 page 已经存在，如果 page 没满，则直接 page-&gt;add() 让对象入栈；如果page已满，则调用 autoreleaseFullPage()新建page，再让对象入栈；</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">static __attribute__((noinline))<br>    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *<span class="hljs-built_in">page</span>)<br>    &#123;<br>        <span class="hljs-comment">// The hot page is full. </span><br>        <span class="hljs-comment">// Step to the next non-full page, adding a new page if necessary.</span><br>        <span class="hljs-comment">// Then add the object to that page.</span><br>        assert(<span class="hljs-built_in">page</span> == hotPage());<br>        <span class="hljs-comment">//判断page-&gt;child是否存在</span><br>        <span class="hljs-function"><span class="hljs-title">assert</span>(<span class="hljs-built_in">page</span>-&gt;</span>full()  ||  DebugPoolAllocation);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>) <span class="hljs-built_in">page</span> = <span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>;//存在<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>的话就将 <span class="hljs-built_in">page</span>置为<span class="hljs-built_in">page</span>-&gt;</span>child<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">page</span> = new AutoreleasePoolPage(<span class="hljs-built_in">page</span>);<span class="hljs-comment">////否则就去创建新的page</span><br>        &#125; <span class="hljs-function"><span class="hljs-title">while</span> (<span class="hljs-built_in">page</span>-&gt;</span>full());<br><br>        setHotPage(<span class="hljs-built_in">page</span>);<br>        <span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-built_in">page</span>-&gt;</span>add(obj);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>因为是栈式结构，所以先入栈的对象会在栈底，后入栈的对象则依次往栈顶的方向添加，具体可以参考 5.1 小节中的示意图。</p>
<h5 id="5-4-对象释放"><a href="#5-4-对象释放" class="headerlink" title="5.4.对象释放"></a>5.4.对象释放</h5><p>当 Runloop 即将进入休眠 和 Runloop 退出时，如线程执行完任务销毁时，autorelease pool 会 drain 并销毁，销毁前向其中保存着的 autorelease 对象依次发送 release 消息，从而释放对象。那么自动释放池的底层是如何释放对象的呢？</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs xl">void objc_autoreleasePoolPop(void *ctxt)<br>&#123;<br>    AutoreleasePoolPage::pop(ctxt);<br>&#125;<br><br>static inline void pop(void *token) <br>    &#123;<br>        AutoreleasePoolPage *<span class="hljs-built_in">page</span>;<br>        id *stop;<br><br>        <span class="hljs-comment">//如果是空的占位池</span><br>        <span class="hljs-keyword">if</span> (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;<br>            <span class="hljs-comment">// Popping the top-level placeholder pool.</span><br>            <span class="hljs-keyword">if</span> (hotPage()) &#123;<br>                <span class="hljs-comment">// Pool was used. Pop its contents normally.</span><br>                <span class="hljs-comment">// Pool pages remain allocated for re-use as usual.</span><br>                <span class="hljs-function"><span class="hljs-title">pop</span>(coldPage()-&gt;</span>begin());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Pool was never used. Clear the placeholder.</span><br>                setHotPage(<span class="hljs-literal">nil</span>);<br>            &#125;<br>            return;<br>        &#125;<br><br>        <span class="hljs-built_in">page</span> = pageForPointer(token);<br>        stop = (id *)token;<br>        <span class="hljs-keyword">if</span> (*stop != POOL_BOUNDARY) &#123;<br>            <span class="hljs-comment">//不是边界对象的情况，如MRC环境中，在子线程中没使用@autorelease，而直接调用了autorelease，这时添加到pool的对象就不是 POOL_BOUNDARY</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (stop == <span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">begin</span>()  &amp;&amp;  !<span class="hljs-built_in">page</span>-&gt;</span>parent) &#123;<span class="hljs-comment">//栈底不是哨兵对象</span><br>                <span class="hljs-comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span><br>                <span class="hljs-comment">// 1. top-level pool is popped, leaving the cold page in place</span><br>                <span class="hljs-comment">// 2. an object is autoreleased with no pool </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Error. For bincompat purposes this is not </span><br>                <span class="hljs-comment">// fatal in executables built with old SDKs.</span><br>                return badPop(token);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (PrintPoolHiwat) printHiwat();<br><br>        <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>releaseUntil(stop);<span class="hljs-comment">//从栈顶开始向栈中的对象发送release消息，直到遇到第一个边界对象</span><br><br>        <span class="hljs-comment">// memory: delete empty children</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (DebugPoolAllocation  &amp;&amp;  <span class="hljs-built_in">page</span>-&gt;</span>empty()) &#123;<br>            <span class="hljs-comment">// special case: delete everything during page-per-pool debugging</span><br>            A<span class="hljs-function"><span class="hljs-title">utoreleasePoolPage</span> *parent = <span class="hljs-built_in">page</span>-&gt;</span>parent;<br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>kill();<br>            setHotPage(parent);<br>        &#125; <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (DebugMissingPools  &amp;&amp;  <span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">empty</span>()  &amp;&amp;  !<span class="hljs-built_in">page</span>-&gt;</span>parent) &#123;<br>            <span class="hljs-comment">// special case: delete everything for pop(top) </span><br>            <span class="hljs-comment">// when debugging missing autorelease pools</span><br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>kill();<br>            setHotPage(<span class="hljs-literal">nil</span>);<br>        &#125; <br>        <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>-&gt;</span>child) &#123;<br>            <span class="hljs-comment">// hysteresis: keep one empty child if page is more than half full</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span>-&gt;</span>lessThanHalfFull()) &#123;<br>                <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span>kill();<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span>child) &#123;<br>                <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span>kill();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>static AutoreleasePoolPage *pageForPointer(uintptr_t p) <br>    &#123;<br>        AutoreleasePoolPage *result;<br>        uintptr_t offset = p % SIZE;<br><br>        assert(offset &gt;= sizeof(AutoreleasePoolPage));<br><br>        result = (AutoreleasePoolPage *)(p - offset);<br>        <span class="hljs-function"><span class="hljs-title">result</span>-&gt;</span>fastcheck();<br><br>        return result;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>objc_autoreleasePoolPop()即 Runloop 退出，自动释放池出栈时调用的函数。函数内会判断当前 token 是 EMPTY_POOL_PLACEHOLDER 还是 POOL_BOUNDARY 或者 autorelease 对象。如果是空的占位池，则清空占位池；如果栈底不是边界对象，则直接报错；其他情况，直接调用 releaseUntil()，释放对象。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xl">void releaseUntil(id *stop) <br>    &#123;<br>        <span class="hljs-comment">// Not recursive: we don&#x27;t want to blow out the stack </span><br>        <span class="hljs-comment">// if a thread accumulates a stupendous amount of garbage</span><br>        <br>        <span class="hljs-function"><span class="hljs-title">while</span> (this-&gt;</span>next != stop) &#123;<br>            <span class="hljs-comment">// Restart from hotPage() every time, in case -release </span><br>            <span class="hljs-comment">// autoreleased more objects</span><br>            AutoreleasePoolPage *<span class="hljs-built_in">page</span> = hotPage();<br><br>            <span class="hljs-comment">// fixme I think this `while` can be `if`, but I can&#x27;t prove it</span><br>            <span class="hljs-function"><span class="hljs-title">while</span> (<span class="hljs-built_in">page</span>-&gt;</span>empty()) &#123;<br>                <span class="hljs-function"><span class="hljs-title">page</span> = <span class="hljs-built_in">page</span>-&gt;</span>parent;<br>                setHotPage(<span class="hljs-built_in">page</span>);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>unprotect();<br>            <span class="hljs-function"><span class="hljs-title">id</span> obj = *--<span class="hljs-built_in">page</span>-&gt;</span>next;<br>            <span class="hljs-function"><span class="hljs-title">memset</span>((void*)<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>, SCRIBBLE, sizeof(*<span class="hljs-built_in">page</span>-&gt;</span>next));<br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>protect();<br><br>            <span class="hljs-keyword">if</span> (obj != POOL_BOUNDARY) &#123;<br>                objc_release(obj);<br>            &#125;<br>        &#125;<br><br>        setHotPage(this);<br><br>#<span class="hljs-keyword">if</span> DEBUG<br>        <span class="hljs-comment">// we expect any children to be completely empty</span><br>        <span class="hljs-function"><span class="hljs-title">for</span> (AutoreleasePoolPage *<span class="hljs-built_in">page</span> = child; <span class="hljs-built_in">page</span>; <span class="hljs-built_in">page</span> = <span class="hljs-built_in">page</span>-&gt;</span>child) &#123;<br>            <span class="hljs-function"><span class="hljs-title">assert</span>(<span class="hljs-built_in">page</span>-&gt;</span>empty());<br>        &#125;<br>#endif<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>上面章节中讲到，第一次将对象标记为 autorelease 时，在对象入栈前会往栈内插入一个边界对象(哨兵)，这些边界对象可以视为一个 pool 的开始。当 pool 需要释放对象时，会从栈顶开始，依次向栈底边界对象的方向清理掉这中间的所有 autorelease 对象，具体流程为：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的 page；</li>
<li>向当前 page 中晚于哨兵对象插入的所有 autorelease 对象发送 -release 消息；</li>
<li>回头移动 next 指针到正确位置；</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page。</li>
</ol>
<p>以上，就是 MRC 中有关 retain，release，autorelease 和自动释放池相关的原理和具体的实现。</p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>ARC，自动引用计数是苹果在 iOS5 之后推出的新技术。使用ARC时，我们不再需要手动添加<code>retain</code>、<code>release</code>、<code>autorelease</code>这样的内存管理代码，编译器会在编译代码时自动帮我们添加。比如系统会自动帮我们在主线程 Runloop 中创建一个自动释放池，ARC下自动释放池内的对象会被自动标记为 autorelease，等 Runloop 退出时线程结束，pool被销毁，autorelease 对象就会 release。<br><br/></p>
<p>ARC 不仅减少了开发者的麻烦，还避免了因为疏忽而导致的内存泄露或者过度释放等问题，我们只需要专注于自己的业务。</p>
<blockquote>
<p>ARC differs from tracing garbage collection in that there is no background process that deallocates the objects asynchronously at runtime.[3] Unlike garbage collection, ARC does not handle reference cycles automatically. This means that as long as there are “strong” references to an object, it will not be deallocated. Strong cross-references can accordingly create deadlocks and memory leaks. It is up to the developer to break cycles by using weak references.</p>
</blockquote>
<h4 id="2-ARC与GC"><a href="#2-ARC与GC" class="headerlink" title="2.ARC与GC"></a>2.ARC与GC</h4><p><code>ARC</code> <strong>!&#x3D;</strong> <code>垃圾回收机制</code>！<br><br/></p>
<p>ARC 发生在<code>编译阶段</code>，它是LLVM 3.0 编译器中的新特性。ARC 环境中，编译器在代码<code>编译时</code>帮我们将对象标记为 autorelease、retain、release，我们无须再写这些内存管理的代码，只需要用<code>strong</code>或者<code>weak</code>表示你对对象的所有权，或者注意像循环强引用这种问题即可。<br><br/></p>
<p>JAVA中的垃圾回收机制则是在<code>运行时</code>检查对象的依赖，如果没有指针指向某个对象，那么这个对象就是垃圾对象，到达一定量级后系统就会自动清除这些垃圾对象，或者由调用者主动调用GC清理~<br><br/></p>
<p>作为对比来说，OC中的<code>引用计数</code>更靠近垃圾回收机制一些，即当对象的引用计数&#x3D;0时，就会自动调用对象的<code>dealloc</code>函数进行销毁。</p>
<h4 id="3-变量修饰符"><a href="#3-变量修饰符" class="headerlink" title="3.变量修饰符"></a>3.变量修饰符</h4><p>ARC下的四个变量修饰符：</p>
<ul>
<li>__strong</li>
</ul>
<p>对应属性修饰符中的<code>strong</code>，强引用，表示指针指向并拥有某个对象（引用计数+1）。这是声明对象时默认的修饰符，如果想释放强引用的对象，则将指针置为nil即可。ARC下当没有任何一个强引用指向对象时，对象才会销毁。</p>
<ul>
<li>__weak</li>
</ul>
<p>对应属性修饰符中的<code>weak</code>，弱引用，表示指向但不拥有某个对象（引用计数不变）。__weak 不会影响对象的释放，即只要没有强引用指向对象，即使有N个弱引用指向此对象，那么对象还是会销毁。对象被释放时，__weak 指针会被自动置为nil，不会引发野指针问题。</p>
<ul>
<li>__autoreleasing</li>
</ul>
<p>相当于MRC中的 autorelease，属性不能使用此修饰符。使用示例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//ARC</span><br><span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span> __autoreleasing dic <span class="hljs-operator">=</span> [[<span class="hljs-type">NSDictionary</span> alloc] <span class="hljs-keyword">init</span>];<br><span class="hljs-comment">//MRC</span><br><span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span>dic <span class="hljs-operator">=</span> [[[<span class="hljs-type">NSDictionary</span> alloc] <span class="hljs-keyword">init</span>] autorelease];<br></code></pre></td></tr></table></figure>

<ul>
<li>__unsafe_unretained</li>
</ul>
<p>对应属性修饰符中的<code>unsafe_unretained</code>，相当于 MRC 中的<code>assign</code>，只是将指针指向某对象，不改变其引用计数，不影响其释放。之所以以<code>unsafe</code>开头，是因为当此对象被释放时，原指针仍会指向此对象所在的内存区域，再次调用此指针时会引发野指针问题，不安全。<br><br/></p>
<p>Clang<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">文档</a>中有这样一段描述：</p>
<blockquote>
<p>Methods in the alloc, copy, init, mutableCopy, and new families are implicitly marked <strong>attribute</strong>((ns_returns_retained)). This may be suppressed by explicitly marking the method <strong>attribute</strong>((ns_returns_not_retained)).</p>
</blockquote>
<p>与MRC一样，以 <code>alloc</code>、<code>init</code>、<code>copy</code>、<code>mutableCopy</code>、<code>new</code>开头的方法返回的对象，会被隐式的标记为<code>ns_returns_retained</code>，其他情况下创建的对象则会被标记为 autorelease 并加入自动释放池中。</p>
<h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h4><ul>
<li>不能再手动向对象发送retain, release, autorelease、retainCount、dealloc消息；</li>
<li>可以重写 dealloc 方法，但不能在其内部调用[super dealloc]；</li>
<li>不能使用 NSAutoreleasePool 对象，而是使用 @autoreleasepool{}；</li>
<li>属性修饰符 weak 相当于原来的 assign，strong 相当于原来的 retain；</li>
<li>注意循环引用问题；</li>
</ul>
<p>在整个 XCode 中 开关 ARC，可以通过 Build Settings -&gt; Objective-C Automotic Reference Counting 选项来设置。设置单独的某个或某几个文件开关 ARC 时，可到 Build Phases -&gt; Compile Sources 中双击对应的文件，添加<code>-fobjc-arc</code>或<code>-fno-objc-arc</code>即可~</p>
<hr>
<p>相关参考：</p>
<p>#<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting">©wiki-Automatic_Reference_Counting</a></p>
<p>#<a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">©Clang llvm-ARC</a></p>
<p>#<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=objc">©Apple-NSAutoreleasePool</a></p>
<p>#<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-SW5">©Apple-Autorelease Pool Blocks</a></p>
<p>#<a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">©sunnyxx</a></p>
<p>#<a target="_blank" rel="noopener" href="https://www.2cto.com/kf/201804/739679.html">©ZCMUCZX-自动释放池</a></p>
<p>#<a target="_blank" rel="noopener" href="http://www.cnblogs.com/flyFreeZn/p/4264220.html">©不忘初“辛”-ARC技术要点</a></p>
<p>#<a target="_blank" rel="noopener" href="http://www.cocoachina.com/bbs/read.php?tid=1729516">©CocoaChina论坛7楼-垃圾收集机制与ARC</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AF%BE%E5%A4%96/" class="category-chain-item">课外</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">#内存管理</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>OC中的内存管理</div>
      <div>https://davidlii.cn/2018/01/21/autoreleasepool.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Davidli</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年1月21日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/01/28/source_code_sd.html" title="SDWebImage">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SDWebImage</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/01/20/reuse_cell.html" title="Cell重用、卡顿、离屏渲染">
                        <span class="hidden-mobile">Cell重用、卡顿、离屏渲染</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/davidli-" target="_blank" rel="nofollow noopener"><span>Davidlii</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
