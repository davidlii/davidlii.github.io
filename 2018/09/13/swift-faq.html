<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"/> 
  
  <title>
    
      Swift 中的常见问题 | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">

  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  
<script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>

  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


<meta name="generator" content="Hexo 6.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Davidli</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Davidli</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Swift 中的常见问题</h2>
  <p class="post-date">2018-09-13</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="1-Struct-与-Class"><a href="#1-Struct-与-Class" class="headerlink" title="1.Struct 与 Class"></a>1.Struct 与 Class</h3><p>相同点：</p>
<ul>
<li>定义属性和方法；</li>
<li>使用下标语法<code>subscript syntax</code>；</li>
<li>定义初始化器设置初始状态；</li>
<li>添加扩展、实现协议；</li>
</ul>
<p>class 独有的特性：</p>
<ul>
<li>继承</li>
<li>类型转换<code>Type casting</code></li>
<li>析构</li>
<li>class 的实例可被多个对象引用</li>
</ul>
<p>最大的不同：struct 是值类型，class 是引用类型。</p>
<h3 id="2-比较符：-与"><a href="#2-比较符：-与" class="headerlink" title="2.比较符：==与==="></a>2.比较符：<code>==</code>与<code>===</code></h3><blockquote>
<p>Note that identical to (represented by three equals signs, or &#x3D;&#x3D;&#x3D;) doesn’t mean the same thing as equal to (represented by two equals signs, or &#x3D;&#x3D;). Identical to means that two constants or variables of class type refer to exactly the same class instance. Equal to means that two instances are considered equal or equivalent in value, for some appropriate meaning of equal, as defined by the type’s designer.</p>
</blockquote>
<blockquote>
<p>When you define your own custom structures and classes, it’s your responsibility to decide what qualifies as two instances being equal. </p>
</blockquote>
<ul>
<li><code>===</code>表示两个实例引用了相同的对象，强调“引用”相同；</li>
<li><code>==</code> 表示两个实例中的值“相等”，至于哪些值相等，需要自己在类中定义；</li>
</ul>
<p>2.1、自定义类时，实现<code>Equatable</code>协议并重写全局操作符<code>==</code>来决定两个操作数是否相等。<br>&amp;emsp;</p>
<p>#示例1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Cat:Equatable &#123;</span><br><span class="line">    </span><br><span class="line">    var name: String?</span><br><span class="line">    </span><br><span class="line">    static func ==(lhs:Cat, rhs:Cat) -&gt; Bool &#123;</span><br><span class="line">        if lhs.name == rhs.name&#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用并打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let cat1 = Cat()</span><br><span class="line">let cat2 = Cat()</span><br><span class="line">cat1.name = &quot;Miao&quot;</span><br><span class="line">cat2.name = &quot;Miao&quot;</span><br><span class="line"></span><br><span class="line">print(cat1 == cat2) //true</span><br></pre></td></tr></table></figure>

<p>2.2、注意，<code>===</code>的左右两个操作数必须是类的实例，对枚举或结构体及其变种（String、Array、Dictionary）等使用时会报错。</p>
<h3 id="3-属性的修饰符"><a href="#3-属性的修饰符" class="headerlink" title="3.属性的修饰符"></a>3.属性的修饰符</h3><h4 id="3-1-强弱"><a href="#3-1-强弱" class="headerlink" title="3.1.强弱"></a>3.1.强弱</h4><p>Swift 里属性默认是强类型的，OC 中<code>strong</code>属性在 Swift 中会转换为<code>存储属性</code>。<br>&amp;emsp;</p>
<p>Swift 中的<code>weak</code>对应 OC 中的<code>weak</code>，仅能修饰引用类型的属性，不能修饰<code>String</code>、<code>Int</code>等值类型属性（它们实质上是结构体）；<br>&amp;emsp;</p>
<p>另外，<code>weak</code>修饰的属性必须是 optional 对象类型，否则会报错“’weak’ variable should have optional type ‘xxClass?’”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weak var ani:Animal?</span><br></pre></td></tr></table></figure>

<p>所以，weak 一般用来解决对象间或闭包属性与其所属对象之间的循环引用问题。</p>
<h4 id="3-2-读写"><a href="#3-2-读写" class="headerlink" title="3.2.读写"></a>3.2.读写</h4><p>Swift中没有<code>readwrite</code>和<code>readonly</code>特性。<br>&amp;emsp;</p>
<p>对于<code>存储属性</code>，使用<code>let</code>表明其为只读；使用<code>var</code>表明其为可读／可写。<br>&amp;emsp;</p>
<p>对于<code>计算属性</code>，为其提供一个 getter 方法，使其成为可读的；提供 setter 方法，使其成为可写的。如果只提供了 getter 而没有 setter，则属性只读；计算属性不能只提供 setter 不提供 getter，否则报错“Variable with a setter must also have a getter”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    var aInt: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return 1</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-原子性"><a href="#3-3-原子性" class="headerlink" title="3.3.原子性"></a>3.3.原子性</h4><p>OC 中的<code>atomic</code>和<code>nonatomic</code>在 Swift 中没有对应的修饰符，Swift 中属性默认是<code>nonatomic</code>的，可以通过 OC 中类似的锁机制来保证属性对象的线程安全。</p>
<h4 id="3-4-拷贝"><a href="#3-4-拷贝" class="headerlink" title="3.4.拷贝"></a>3.4.拷贝</h4><p>在Swift中，OC的<code>copy</code>被转换为<code>@NSCopying</code>属性。这一类属性须遵守 <code>NSCopying</code>协议。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Book: NSCopying &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    func copy(with zone: NSZone? = nil) -&gt; Any &#123;</span><br><span class="line">        let copy = Book()</span><br><span class="line">        copy.name = name</span><br><span class="line">        return copy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BooksShelf &#123;</span><br><span class="line">    @NSCopying var book: Book?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用及日志</span><br><span class="line">let book1 = Book()</span><br><span class="line">book1.name = &quot;swift&quot;</span><br><span class="line">let bookShelf = BooksShelf()</span><br><span class="line">bookShelf.book = book1</span><br><span class="line">print(bookShelf.book === book1)//false</span><br></pre></td></tr></table></figure>


<h3 id="5-final、static、class"><a href="#5-final、static、class" class="headerlink" title="5.final、static、class"></a>5.final、static、class</h3><h4 id="5-1-final"><a href="#5-1-final" class="headerlink" title="5.1.final"></a>5.1.final</h4><p>修饰类及其元素，强调不能被继承和重写。</p>
<ul>
<li>final 只能修饰类和类中的元素，不能修饰值类型的结构体和枚举，它们本身就不能被继承；</li>
<li>final 修饰的方法、属性、下标不能被重写；</li>
<li>final 修饰整个类时此类不能被继承，其中的元素也将被标记为 final，因此不能重写；</li>
</ul>
<p>#示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final class A &#123;</span><br><span class="line">    var aInt: Int&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func callFunction() &#123;</span><br><span class="line">        print(&quot;A&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B:A &#123; // 报错“Inheritance from a final class &#x27;A&#x27;”</span><br><span class="line">    override var aInt: Int &#123; // 报错“Property overrides a &#x27;final&#x27; property”</span><br><span class="line">        get &#123;</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override func callFunction() &#123; //报错“Instance method overrides a &#x27;final&#x27; instance method”</span><br><span class="line">        print(&quot;B&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>final</code>修饰类的属性、方法时只是将其标记为不能重写，并不会将其变成类属性或类方法。</p>
<h4 id="5-2-static"><a href="#5-2-static" class="headerlink" title="5.2.static"></a>5.2.static</h4><p>修饰类中元素，强调属于类、不可重写。</p>
<ul>
<li>static 可以修饰类中的元素，但不能修饰类本身;</li>
<li>static 可以修饰结构体中的元素，但不能修饰结构体本身；</li>
<li>static 不能修饰枚举及其元素；</li>
<li>static 修饰的属性将成为静态属性，修饰的方法将成为静态方法，不能重写，需通过类型名来调用；</li>
</ul>
<p>#示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    static var aInt: Int = 1</span><br><span class="line">    static func callFunction() &#123;</span><br><span class="line">        print(&quot;A.aInt:\(aInt)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B:A &#123;</span><br><span class="line">    var aInt: Int = 2 // 属性前不能加override 否则会报错“Property does not override any property from its superclass”</span><br><span class="line"></span><br><span class="line">    func callFunction() &#123; // 方法前不能加override 否则会报错“Method does not override any method from its superclass”</span><br><span class="line">        print(&quot;B.aInt:\(aInt)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.aInt // 1</span><br><span class="line">B.aInt // 1</span><br><span class="line">A.callFunction() // A.aInt:1</span><br><span class="line">let b = B()</span><br><span class="line">b.aInt // 2</span><br><span class="line">b.callFunction()  // 打印 B.aInt:2</span><br></pre></td></tr></table></figure>

<h4 id="5-3-class"><a href="#5-3-class" class="headerlink" title="5.3.class"></a>5.3.class</h4><p>修饰类中元素，强调属于类、可重写。</p>
<ul>
<li>class 只能用在类中，不能修饰结构体或枚举及它们的元素；</li>
<li>class 修饰的属性和方法，可以被重写；</li>
<li>class 修饰的属性是类属性，修饰的方法是类方法，可以通过“类名.xx”直接调用；</li>
<li>class 可以修饰计算属性，不能修饰存储属性，因为存储属性属于类的实例；</li>
</ul>
<p>#示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    class var aInt: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return 1</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class func callFunction() &#123;</span><br><span class="line">        print(&quot;A&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B:A &#123;</span><br><span class="line">    override class var aInt: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override class func callFunction() &#123;</span><br><span class="line">        print(&quot;B&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.aInt // 打印：1</span><br><span class="line">B.aInt // 打印：2</span><br><span class="line">let b = B()</span><br><span class="line">B.callFunction() // 打印：B</span><br></pre></td></tr></table></figure>

<h3 id="6-访问控制符"><a href="#6-访问控制符" class="headerlink" title="6.访问控制符"></a>6.访问控制符</h3><p>五种访问修饰符，按从高到低排序是：open &gt; public &gt; interal &gt; fileprivate &gt; private。</p>
<ul>
<li>open：可以被任何模块的代码访问，可以被继承和重写。</li>
<li>public: 可以被任何模块的代码访问，模块内是可以被继承和重写，其他模块中不可继承和重写。</li>
<li>internal：内部的意思。默认访问级别，修饰的元素在源代码所在的整个模块都可以访问。</li>
<li>fileprivate：修饰的元素只能在当前文件中访问，当前类的extension中也可以。如果一个文件中含有多个类，这些类中也可以。</li>
<li>private：修饰的元素只能在当前类中访问，当前类的extension中也可以访问。如果当前文件有多个类，这些类中不可以访问。</li>
</ul>
<h3 id="7-typealias"><a href="#7-typealias" class="headerlink" title="7.typealias"></a>7.typealias</h3><p>作用：给已有类型重新定义名称，方便代码阅读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//eg:1.已有类型的重新命名</span><br><span class="line">typealias  Address = CGPoint</span><br><span class="line"></span><br><span class="line">let point: CGPoint = CGPoint(x: 0,y: 0)</span><br><span class="line">//等价于</span><br><span class="line">let point: Address = CGPoint(x: 0,y: 0)</span><br></pre></td></tr></table></figure>

<p>常见应用场景：定义闭包，类似oc的 block 定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typealias successBlock = (_ code: Int, _ message: String) -&gt; Void</span><br><span class="line">var callBack: successBlock?</span><br><span class="line">self.callBack!(code: 200, message: &quot;ok&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="8-associatedtype"><a href="#8-associatedtype" class="headerlink" title="8.associatedtype"></a>8.associatedtype</h3><p>协议中不支持<code>&lt;T&gt;</code>这种方式定义泛型，使用<code>associatedtype</code>关键字定义某种泛型，在协议的实现类中才指明此泛型具体是何类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Container &#123;</span><br><span class="line">    associatedtype Item  //这个Item就是泛型，可现在协议中用着</span><br><span class="line">    mutating func append(_ item: Item)</span><br><span class="line">    var count: Int &#123; get &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Item &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现协议</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct IntStack: Container &#123;</span><br><span class="line">    // IntStack 类的自有部分</span><br><span class="line">    var items: [Int] = []</span><br><span class="line">    mutating func push(_ item: Int) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; Int &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    // 实现 Container 协议的部分</span><br><span class="line">    typealias Item = Int  //这里指明Item是Int类型</span><br><span class="line">    mutating func append(_ item: Int) &#123;</span><br><span class="line">        self.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    var count: Int &#123;</span><br><span class="line">        return items.count</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(i: Int) -&gt; Int &#123;</span><br><span class="line">        return items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-逃逸闭包"><a href="#9-逃逸闭包" class="headerlink" title="9.逃逸闭包"></a>9.逃逸闭包</h3><blockquote>
<p>A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns. When you declare a function that takes a closure as one of its parameters, you can write @escaping before the parameter’s type to indicate that the closure is allowed to escape.</p>
</blockquote>
<p>当闭包作为函数的参数，在函数<code>return</code>之后被调用时，我们就说这个闭包从函数中逃离，即<code>逃逸闭包</code>，使用<code>@escaping</code>来标示。<br>&amp;emsp;</p>
<p>这种情况常见于函数中发起了一个异步请求并把闭包作为异步操作的回调。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 逃逸闭包示例</span><br><span class="line">class NetHelper &#123; //网络工具类</span><br><span class="line">    </span><br><span class="line">    var statusOK = false</span><br><span class="line">    func httpRequest(withUrl url:String,</span><br><span class="line">                     succeesCallback: @escaping (Data?,URLResponse?)-&gt;(),</span><br><span class="line">                     failCallback: @escaping (Error?)-&gt;()) &#123;</span><br><span class="line">        //逃逸闭包必须用@escaping声明;</span><br><span class="line">        //否则编译时报错 Escaping closure captures non-escaping parameter &#x27;succeesCallback&#x27;</span><br><span class="line">        guard !url.isEmpty else&#123;</span><br><span class="line">            print(&quot;+++URL is nil~&quot;)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;++task start&quot;)</span><br><span class="line">        let urlT:URL? = URL(string: url)</span><br><span class="line">        let task = URLSession.shared.dataTask(with: urlT!) &#123;(data:Data?, response:URLResponse?, error:Error?) in</span><br><span class="line">            if error != nil &#123;</span><br><span class="line">                self.statusOK = false // 逃逸闭包中使用到闭包所在类型时 需要显式的调用self 以便提醒自己捕获了self, 不写编译器会报错!</span><br><span class="line">                failCallback(error) //调用逃逸闭包</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                self.statusOK = true</span><br><span class="line">                succeesCallback(data,response) //调用逃逸闭包</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume() // 开始任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 发起网络请求</span><br><span class="line">var netHelper = NetHelper()</span><br><span class="line">netHelper.httpRequest(withUrl: &quot;https://www.baidu.com&quot;, succeesCallback: &#123; (data, response) in</span><br><span class="line">    print(&quot;+++Network finished successfully~\n response:\(response!)&quot;)</span><br><span class="line">&#125;) &#123; (error) in</span><br><span class="line">    print(&quot;++++error:\(error!)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-autoclosure"><a href="#10-autoclosure" class="headerlink" title="10.autoclosure"></a>10.autoclosure</h3><blockquote>
<p>An autoclosure is a closure that’s automatically created to wrap an expression that’s being passed as an argument to a function. It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it. This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</p>
</blockquote>
<p>自动闭包，一种自动创建的闭包，用来把作为函数参数的表达式进行打包。它不接受任何实际参数，当它被调用时，会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显示闭包，使你省略函数参数的<code>&#123;&#125;</code>括号。它允许你延迟处理，闭包内的代码直到你调用它时才会运行，对于有副作用或者占用资源的代码来说很有作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span><br><span class="line">print(customersInLine.count)</span><br><span class="line">// 打印结果 &quot;5&quot;</span><br><span class="line"></span><br><span class="line">//1、定义一个block，其类型为()-&gt;String，此时block内的代码尚未执行</span><br><span class="line">let customerProvider = &#123; customersInLine.remove(at: 0) &#125; </span><br><span class="line">print(customersInLine.count)</span><br><span class="line">// 打印结果 &quot;5&quot;</span><br><span class="line"></span><br><span class="line">//2、调用闭包表达式，真正执行上面定义的block</span><br><span class="line">print(&quot;Now serving \(customerProvider())!&quot;)</span><br><span class="line">// 打印结果 &quot;Now serving Chris!&quot;</span><br><span class="line"></span><br><span class="line">print(customersInLine.count)</span><br><span class="line">// 打印结果 &quot;4&quot;</span><br></pre></td></tr></table></figure>

<p>当你传一个闭包作为参数到函数时，你会得到与延迟处理相同的行为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var customersInLine = [&quot;Chris&quot;,&quot;Alex&quot;,&quot;Ewa&quot;,&quot;Barry&quot;,&quot;Daniella&quot;]</span><br><span class="line"> </span><br><span class="line">//定义block，其类型为()-&gt;String，此时尚未执行</span><br><span class="line">let customProvider = &#123;customersInLine.remove(at: 0)&#125;</span><br><span class="line"> </span><br><span class="line"> //定义函数，接受一个()-&gt;String类型的block作为参数</span><br><span class="line">func serve(custom customerProvider:() -&gt;String)&#123;</span><br><span class="line">    print(&quot;Now serving\(customerProvider())!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">serve(custom: &#123;customersInLine.remove(at: 0)&#125;)</span><br></pre></td></tr></table></figure>

<p>@autoclosure将参数标记为使用自动闭包，再调用函数时它就像接受了一个String 参数而非闭包，因为参数被自动地转换为了闭包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var customersInLine = [&quot;Chris&quot;,&quot;Alex&quot;,&quot;Ewa&quot;,&quot;Barry&quot;,&quot;Daniella&quot;]</span><br><span class="line"> </span><br><span class="line">//定义闭包</span><br><span class="line">let customProvider = &#123;customersInLine.remove(at: 0)&#125;</span><br><span class="line"> </span><br><span class="line">//将闭包参数标记为@autoclosure</span><br><span class="line">func serve(custom customerProvider: @autoclosure () -&gt;String )&#123;</span><br><span class="line">    print(&quot;Now serving \(customerProvider())!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//调用函数时，不需要再写花括号&#123;&#125;，@autoclosure会根据上面的定义，自动将其转换为闭包</span><br><span class="line">serve(custom: customersInLine.remove(at: 0))</span><br></pre></td></tr></table></figure>


<hr>
<p>相关参考：</p>
<p>#<a target="_blank" rel="noopener" href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/UsingSwiftwithCocoaandObjective-C%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C.md">©Swift翻译组</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Swift" >
    <span class="tag-code">Swift</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2018/09/02/swift-mixmatch.html">
        <span class="nav-arrow">← </span>
        
          Swift 与 OC 的混编
        
      </a>
    
    
      <a class="nav-right" href="/2018/09/14/swift-map.html">
        
          Swift高阶函数
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-Struct-%E4%B8%8E-Class"><span class="toc-nav-text">1.Struct 与 Class</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E6%AF%94%E8%BE%83%E7%AC%A6%EF%BC%9A-%E4%B8%8E"><span class="toc-nav-text">2.比较符：&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-nav-text">3.属性的修饰符</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-%E5%BC%BA%E5%BC%B1"><span class="toc-nav-text">3.1.强弱</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-%E8%AF%BB%E5%86%99"><span class="toc-nav-text">3.2.读写</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-nav-text">3.3.原子性</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-4-%E6%8B%B7%E8%B4%9D"><span class="toc-nav-text">3.4.拷贝</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-final%E3%80%81static%E3%80%81class"><span class="toc-nav-text">5.final、static、class</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-final"><span class="toc-nav-text">5.1.final</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-2-static"><span class="toc-nav-text">5.2.static</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-3-class"><span class="toc-nav-text">5.3.class</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-nav-text">6.访问控制符</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-typealias"><span class="toc-nav-text">7.typealias</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-associatedtype"><span class="toc-nav-text">8.associatedtype</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85"><span class="toc-nav-text">9.逃逸闭包</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-autoclosure"><span class="toc-nav-text">10.autoclosure</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2018/09/13/swift-faq.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Swift 中的常见问题",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>