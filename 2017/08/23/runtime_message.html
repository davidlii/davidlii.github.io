<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"/> 
  
  <title>
    
      Runtime：消息机制 | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Runtime：消息机制</h2>
  <p class="post-date">2017-08-23</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="1-运行时的常用场景"><a href="#1-运行时的常用场景" class="headerlink" title="1.运行时的常用场景"></a>1.运行时的常用场景</h3><ul>
<li>发送消息；</li>
<li>读取成员变量；</li>
<li>动态为某个类增加属性；</li>
<li>交换类中的方法、动态为某个类添加方法；</li>
<li>动态创建、删除、修改一个类；</li>
</ul>
<h3 id="2-消息"><a href="#2-消息" class="headerlink" title="2.消息"></a>2.消息</h3><p>在C语言中，函数的调用在编译时就已经决定了。而OC是一种动态语言。对于OC的函数，在编译时并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。所以，你会发现：在编译阶段，只要声明过，OC可以调用任何函数且不会报错，即使这个函数并未实现。相反，编译阶段C语言调用未实现的函数时会报错。</p>
<blockquote>
<p>OC中，方法调用的本质，就是向对象发送一条消息。</p>
</blockquote>
<p>打开<code>objc/message.h</code>文件，可见如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ )</span><br></pre></td></tr></table></figure>
<h3 id="3-id"><a href="#3-id" class="headerlink" title="3.id"></a>3.id</h3><p>在<code>objc/objc.h</code>中，id的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>id是一个结构体指针类型，它指向OC中的任何对象。</p>
<h3 id="4-类（class）"><a href="#4-类（class）" class="headerlink" title="4.类（class）"></a>4.类（class）</h3><p>在<code>objc/runtime.h</code>中，类的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">Class isa  OBJC_ISA_AVAILABILITY;       //指针</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">Class super_class                       //父类;</span><br><span class="line">const char *name                        //类名;</span><br><span class="line">long version                                             //类的版本信息，默认为0;</span><br><span class="line">long info                               //位标识;</span><br><span class="line">long instance_size                      //类的实例变量大小;</span><br><span class="line">struct objc_ivar_list *ivars            //类的成员变量链表;</span><br><span class="line">struct objc_method_list **methodLists   //方法定义的链表;</span><br><span class="line">struct objc_cache *cache                //方法缓存;</span><br><span class="line">struct objc_protocol_list *protocols    //协议链表;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<h3 id="5-Method"><a href="#5-Method" class="headerlink" title="5.Method"></a>5.Method</h3><p><code>Method</code>是 Runtime 内部定义的方法,上面 class 的结构体内定义有一个 <code>objc_method_list</code>链表，保存的是 <code>objc_method</code> 对象，定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name        //方法名称</span><br><span class="line">    char * _Nullable method_types   //方法的参数类型</span><br><span class="line">    IMP _Nonnull method_imp         //指向该方法的具体实现的函数指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-SEL"><a href="#6-SEL" class="headerlink" title="6.SEL"></a>6.SEL</h3><p>在<code>objc/objc.h</code>中，SEL的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method selector.</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p><code>SEL</code>就是方法选择器（实质上是一个C字符串）。它的主要作用是通过方法名称，查找到对应方法的函数指针，然后调用其函数。OC 的类中每个方法都对应着一个 <code>SEL</code>，同一个类中不能存在两个名称相同的方法，即使参数类型不同。因为<code>SEL</code>是根据方法名称生成的，相同的方法名称只能对应一个<code>SEL</code>。</p>
<h3 id="7-IMP"><a href="#7-IMP" class="headerlink" title="7.IMP"></a>7.IMP</h3><p>在<code>objc/objc.h</code>中，IMP的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// A pointer to the function of a method implementation. </span><br><span class="line">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="line">typedef void (*IMP)(void /* id, SEL, ... */ ); </span><br><span class="line">#else</span><br><span class="line">typedef id (*IMP)(id, SEL, ...); </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>IMP</code>是一个函数指针，这个被指向的函数包含一个接收消息的对象<code>id</code>, 调用方法的选择器<code>SEL</code>，以及不定个数的方法参数，并返回一个<code>id</code>。<code>IMP</code>是消息最终调用的执行代码，是方法真正的实现。<br>&emsp;</p>
<p><strong>SEL与IMP的关系</strong>：在编译时，编译器会为类创建一个数据结构体，其中包括了isa指针和cache等内容。同时也包含着一个dispatch table，它是一张SEL与IMP的对应表。SEL最后要通过<code>dispatch table</code>查找到对应的IMP，IMP就是一个函数指针，找到后执行这个方法。<br>&emsp;</p>
<p>结合以上背景，回到消息机制中来，先看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject *obj = [NSObject alloc];</span><br></pre></td></tr></table></figure>
<p>上面的示例代码中，<code>[NSObject alloc]</code> 实际上就是向 NSObject 这个类对象发送了一条<code>alloc</code>消息。 </p>
<h3 id="8-方法调用的过程"><a href="#8-方法调用的过程" class="headerlink" title="8.方法调用的过程"></a>8.方法调用的过程</h3><p>1、调用方法时，runtime 会把方法的调用转化为<code>消息发送</code>，并把方法的调用者和方法选择器当作参数传递过去；即 <code>objc_msgSend(id, SEL)</code>；<br>&emsp;</p>
<p>2、方法的调用者会通过 <code>isa</code> 指针找到其所属的类。在类中有一块最近调用的方法的指针缓存（即cache，参见上面类的定义），出于性能考虑 runtime 会先去 <code>cache</code> 查找对应的方法;<br>&emsp;</p>
<p>3、若 <code>cache</code> 中没有找到，则去 <code>methodLists</code> 中查找。找到后通过函数指针跳转到对应的实现中，之后将方法加入到 <code>cache</code> 中；<br>&emsp;</p>
<p>4、若未找到该方法，则通过 <code>super_class</code>往上一级父类查找。<br>&emsp;</p>
<p>5、如果一直找到 <code>NSObject</code> 都没有找到该方法时，在不做特殊处理的情况下（如消息转发），应用会报运行时错误：unrecognized selector sent to instance xxx）；</p>
<h3 id="9-动态方法决议"><a href="#9-动态方法决议" class="headerlink" title="9.动态方法决议"></a>9.动态方法决议</h3><p>为防止上述第5种情况下发生的 crash，OC 提供了动态方法决议，以便在运行时动态地为一个 <code>selector</code> 提供实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveClassMethod:(SEL)name;    //类方法</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)name; //实例方法</span><br></pre></td></tr></table></figure>
<ul>
<li>name参数，表示需要被动态决议的selector；</li>
<li>Bool返回值，表示动态决议是否成功；</li>
</ul>
<p>上述方法是NSObject类中的两个类方法，动态方法决议时，须实现这两个方法，并在其中为指定的selector提供实现即可(通过调用运行时函数class_addMethod来添加)。<br>&emsp;</p>
<p>在不涉及消息转发的情况下：</p>
<ul>
<li>若上述两函数内为指定的selector提供实现，无论返回YES或NO，编译运行都会正常；</li>
<li>若上述两函数内并没有为selector提供实现，无论返回YES或NO，编译运行都会crash；</li>
</ul>
<p>#示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//DynamicTool头文件如下：</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface DynamicTool : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//DynamicTool实现文件如下：</span><br><span class="line"></span><br><span class="line">#import &quot;DynamicTool.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">void instanceMethod(id self,SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;instance method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void classMethod(id self,SEL sel,NSString* str1,NSString* str2)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;class method param1:%@,param2:%@&quot;,str1,str2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation DynamicTool</span><br><span class="line"></span><br><span class="line">#pragma mark -动态决议</span><br><span class="line">//实例方法</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(instanceMethodSelector)) &#123;</span><br><span class="line">        class_addMethod([self class], sel, (IMP)instanceMethod, &quot;v@:&quot;);</span><br><span class="line">        /*每个方法都有 self 和_cmd 两个默认的隐藏参数，</span><br><span class="line">        self 即接收消息的对象本身，_cmd 即是 selector 选择器；</span><br><span class="line">        v表示void返回值；@表示一个对象，这里指self；&quot;:&quot;表示SEL，即_cmd。</span><br><span class="line">        其他符号的意义可参考文章底部链接</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">//类方法</span><br><span class="line">+(BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(classMethodSelector)) &#123;</span><br><span class="line">        class_addMethod(objc_getMetaClass(&quot;DynamicTool&quot;), sel,</span><br><span class="line">        (IMP)classMethod, &quot;s#:@@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DynamicTool *insObj = [DynamicTool new];</span><br><span class="line">Class classObj = NSClassFromString(@&quot;DynamicTool&quot;);</span><br><span class="line"></span><br><span class="line">[insObj performSelector:@selector(instanceMethodSelector)];</span><br><span class="line"></span><br><span class="line">[classObj performSelector:@selector(classMethodSelector) </span><br><span class="line">withObject:@&quot;A&quot; withObject:@&quot;B&quot;];</span><br></pre></td></tr></table></figure>
<p>上述代码中，DynamicTool 的头文件并未定义实例方法<code>instanceMethodSelector</code> 和类方法<code>classMethodSelector</code>。因此通过 performSelector 调用时，runtime会按照“方法调用的实际过程”小结所述流程从类中查找该方法，因为未定义，所以查找失败并走动态方法决议流程，分别通过<code>resolveInstanceMethod</code>与 <code>resolveClassMethod</code>查找具体的方法实现。</p>
<h3 id="10-消息转发机制"><a href="#10-消息转发机制" class="headerlink" title="10.消息转发机制"></a>10.消息转发机制</h3><p>如果没有实现动态方法决议机制，或者在动态方法决议时并未为selector提供实现，那么就会发生crash。为防止这种崩溃，OC还提供了消息转发机制。<br>&emsp;<br>如果同时提供了动态方法决议和消息转发，那么动态方法决议先于消息转发，只有当动态方法决议依然无法正确决议selector的实现，才会尝试进行消息转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)sel;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel；</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invo;</span><br></pre></td></tr></table></figure>
<p>#示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//DynamicTool实现文件如下：</span><br><span class="line"></span><br><span class="line">#import &quot;DynamicTool.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">#import &quot;ForwardTool.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation DynamicTool</span><br><span class="line"></span><br><span class="line">#pragma mark -动态决议</span><br><span class="line">//实例方法</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line">//类方法</span><br><span class="line">+(BOOL)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -消息转发</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    //if (sel == @selector(unknownSelector)) &#123;</span><br><span class="line">    //    return [ForwardTool new];</span><br><span class="line">    //&#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!methodSignature) &#123;</span><br><span class="line">        methodSignature = [NSMethodSignature signatureWithObjCTypes:&quot;v@:*&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return methodSignature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    ForwardTool *forwardTool = [ForwardTool new];</span><br><span class="line">    if ([forwardTool respondsToSelector:@selector(unknownSelector)]) &#123;</span><br><span class="line">        //这里可以转发给多个对象，最终的返回值以最后一个调用的返回值为准</span><br><span class="line">        [anInvocation invokeWithTarget:forwardTool];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>ForwardTool</code>类的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ForwardTool : NSObject</span><br><span class="line">- (void)unknownSelector;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//ForwardTool实现文件如下：</span><br><span class="line"></span><br><span class="line">#import &quot;ForwardTool.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ForwardTool</span><br><span class="line"></span><br><span class="line">- (void)unknownSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;消息转发&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>调用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DynamicTool *insObj = [DynamicTool new];</span><br><span class="line">Class classObj = NSClassFromString(@&quot;DynamicTool&quot;);</span><br><span class="line">[insObj performSelector:@selector(unknownSelector)];</span><br></pre></td></tr></table></figure>
<h3 id="11-消息转发的过程"><a href="#11-消息转发的过程" class="headerlink" title="11.消息转发的过程"></a>11.消息转发的过程</h3><p>1、动态方法决议进入<code>resolveInstanceMethod</code>方法时，指定是否动态添加方法。若指定了实现函数，则通过<code>class_addMethod</code>函数动态地添加方法，并正常执行作为替代的C函数，如上面示例中的<code>dynamicResolution</code>方法；否则，进入第2步；<br>&emsp;</p>
<p>2、<code>resolveInstanceMethod</code>方法中未指定实现函数时，不论返回YES或NO，都会进入<code>forwardingTargetForSelector</code>方法，这是runtime给我们的第二次机会，用于指定哪个对象响应这个selector。若返回某个对象，则会调用该对象的方法；若返回nil，进入第3步;<br>&emsp;</p>
<p>3、<code>forwardingTargetForSelector</code>返回nil时，则要通过 <code>methodSignatureForSelector</code>来指定方法签名。若返回nil，表示不处理，程序会crash；若返回方法签名，则进入第4步。<br>&emsp;</p>
<p>4、<code>methodSignatureForSelector</code>方法返回方法签名时，会调用<code>forwardInvocation</code>方法，此时程序不会崩溃。在<code>forwardInvocation</code>方法中，可以通过<code>anInvocation</code>对象做相应处理，比如修改实现方法，修改响应对象等。</p>
<h3 id="12-NSInvocation"><a href="#12-NSInvocation" class="headerlink" title="12.NSInvocation"></a>12.NSInvocation</h3><p>OC中 直接调用类的方法有两种途径：</p>
<ul>
<li>通过 NSObject 分类中定义的 <code>performSelector: withObject:</code> 方法；</li>
<li>通过 <code>NSInvocation</code>；</li>
</ul>
<p>第一种适合处理单个参数和没有返回值的方法调用；当有多个参数或者有返回值时，就需要使用第二种方式。<br>&emsp;</p>
<p>#示例3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *signature = [NSMethodSignature signatureWithObjCTypes:&quot;@@:@B&quot;];</span><br><span class="line">    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">    invocation.target = self;</span><br><span class="line">    invocation.selector = @selector(onSendMessageWithParam1:param2:);//方法必须和签名中的方法一致</span><br><span class="line">    </span><br><span class="line">    NSString*str1 = @&quot;THIS IS A STR~&quot;;</span><br><span class="line">    BOOL boolValue = YES;</span><br><span class="line"></span><br><span class="line">    //第一个参数为参数对象的指针；</span><br><span class="line">    //第二个参数为参数的索引，注意不能从0开始，因为0已经被self占用，1已经被_cmd占用</span><br><span class="line">    [invocation setArgument:&amp;str1 atIndex:2];</span><br><span class="line">    [invocation setArgument:&amp;boolValue atIndex:3];</span><br><span class="line">    </span><br><span class="line">    [invocation invoke];//执行方法</span><br><span class="line">    id retLoc = nil;</span><br><span class="line">    [invocation getReturnValue:&amp;retLoc];//获取返回值</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)onSendMessageWithParam1:(NSString*)str1 param2:(BOOL)boolvalue</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;+++%@++++%d&quot;,str1,boolvalue);</span><br><span class="line">    return str1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>相关参考：</p>
<p>#<a href="https://blog.csdn.net/zhaochen_009/article/details/54602930" target="_blank" rel="noopener">©WoodBear009-forwardInvocation</a></p>
<p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">©Apple-Type Encodings</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#runtime" >
    <span class="tag-code">runtime</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/08/22/runtime_metaclass.html">
        <span class="nav-arrow">← </span>
        
          Runtime：元类
        
      </a>
    
    
      <a class="nav-right" href="/2017/08/25/runtime_ivar.html">
        
          Runtime：成员变量、属性、快速序列化、dic转Model
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-运行时的常用场景"><span class="toc-nav-text">1.运行时的常用场景</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-消息"><span class="toc-nav-text">2.消息</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-id"><span class="toc-nav-text">3.id</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-类（class）"><span class="toc-nav-text">4.类（class）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-Method"><span class="toc-nav-text">5.Method</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-SEL"><span class="toc-nav-text">6.SEL</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-IMP"><span class="toc-nav-text">7.IMP</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-方法调用的过程"><span class="toc-nav-text">8.方法调用的过程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-动态方法决议"><span class="toc-nav-text">9.动态方法决议</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-消息转发机制"><span class="toc-nav-text">10.消息转发机制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11-消息转发的过程"><span class="toc-nav-text">11.消息转发的过程</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-NSInvocation"><span class="toc-nav-text">12.NSInvocation</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/08/23/runtime_message.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Runtime：消息机制",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>