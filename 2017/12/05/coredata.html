

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Davidli">
  <meta name="keywords" content="Davidli">
  
    <meta name="description" content="一.简介Core Data 是一个对象-关系映射持久化方案，处于应用与持久化存储之间，可以将应用中的对象转化成数据，保存在SQLite文件等持久化存储中，也可以缓存临时数据。在单台设备上 Core Data 支持回滚重做，在多台设备间使用同一 iCloud 账户同步数据时，Core Data 会自动将结构映射到 CloudKit 中。 在.xcdatamodeld数据模型中，可以定义数据类型与关系">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库：Core Data">
<meta property="og:url" content="https://davidlii.cn/2017/12/05/coredata.html">
<meta property="og:site_name" content="Davidli">
<meta property="og:description" content="一.简介Core Data 是一个对象-关系映射持久化方案，处于应用与持久化存储之间，可以将应用中的对象转化成数据，保存在SQLite文件等持久化存储中，也可以缓存临时数据。在单台设备上 Core Data 支持回滚重做，在多台设备间使用同一 iCloud 账户同步数据时，Core Data 会自动将结构映射到 CloudKit 中。 在.xcdatamodeld数据模型中，可以定义数据类型与关系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_persistence.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_Undo.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_backgroundTask.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_entity.jpeg">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_entity_conf.jpeg">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_attr_conf.jpeg">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_att_types.jpeg">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_relation.jpeg">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_stack.jpeg">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_n_thread_1_moc.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_n_thread_n_moc.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_n_moc_1_psc.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_parent_child_moc.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_3moc.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_entity.jpeg">
<meta property="article:published_time" content="2017-12-05T03:34:32.000Z">
<meta property="article:modified_time" content="2017-12-05T03:34:32.000Z">
<meta property="article:author" content="Davidli">
<meta property="article:tag" content="数据">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://davidlii.nos-eastchina1.126.net/pic_cd_persistence.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>数据库：Core Data - Davidli</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"davidlii.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>嵇风</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="数据库：Core Data"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-12-05 11:34" pubdate>
          2017年12月5日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          304 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据库：Core Data</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h3><p>Core Data 是一个<code>对象-关系映射</code>持久化方案，处于应用与持久化存储之间，可以将应用中的对象转化成数据，保存在SQLite文件等持久化存储中，也可以缓存临时数据。在单台设备上 Core Data 支持回滚重做，在多台设备间使用同一 iCloud 账户同步数据时，Core Data 会自动将结构映射到 CloudKit 中。</p>
<p>在<code>.xcdatamodeld</code>数据模型中，可以定义数据类型与关系、生成对应的类定义。Core Data 会自动管理数据对象并提供以下功能：</p>
<ul>
<li>持久化</li>
</ul>
<p>抽象化映射对象到持久化存储中的细节，让保存数据更加简单，你甚至不用写数据库管理代码。</p>
<p>持久化存储包括四种：SQLite, Binary, XML, In-Memory，其中 XML 在 iOS 中不可用。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_persistence.png" srcset="/img/loading.gif" lazyload alt="从持久化存储中存-取数据"></p>
<ul>
<li>回滚&amp;重做</li>
</ul>
<p>Core Data 的回滚管理器会跟踪数据变化，支持单独、批量或者全部回滚数据。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_Undo.png" srcset="/img/loading.gif" lazyload alt="摇晃设备回滚数据功能"></p>
<ul>
<li>在后台处理任务</li>
</ul>
<p>支持在后台处理会堵塞UI线程的任务，例如将JSON解析成对象。稍后你可以将结果缓存或保存起来，节省与服务器的数据交互次数。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_backgroundTask.png" srcset="/img/loading.gif" lazyload alt="更新UI前在后台处理数据"></p>
<ul>
<li>视图同步</li>
</ul>
<p>为<code>table</code>与<code>collection</code>视图提供数据源，帮助处理视图与数据的同步。</p>
<ul>
<li>版本与迁移</li>
</ul>
<p>给<code>.xcdatamodeld</code>文件设置版本，支持在model变化后将数据迁移到最新版本。</p>
<h3 id="二-Model-模型"><a href="#二-Model-模型" class="headerlink" title="二.Model-模型"></a>二.Model-模型</h3><p><code>.xcdatamodeld</code>文件用来定义应用中数据对象的结构，包括数据对象的类型、属性、关系。可通过<code>新建文件</code>→<code>Data Model</code>手动创建，其默认文件名为<code>Model.xcdatamodeld</code>。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_entity.jpeg" srcset="/img/loading.gif" lazyload alt=".xcdatamodeld文件"></p>
<h3 id="三-Entity-实体"><a href="#三-Entity-实体" class="headerlink" title="三.Entity-实体"></a>三.Entity-实体</h3><p><code>.xcdatamodeld</code>&#x3D;<code>库</code>，<code>Entity</code>&#x3D;<code>表</code>，Entity 描述的是一个对象，包括它的名字、属性、关系。在<code>.xcdatamodeld</code>编辑器侧边栏中表示为<code>Entity</code>，可配置的字段包括：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_entity_conf.jpeg" srcset="/img/loading.gif" lazyload alt="实体配置面板"></p>
<h4 id="1-Entity-Name"><a href="#1-Entity-Name" class="headerlink" title="1.Entity Name"></a>1.Entity Name</h4><p>model文件中实体的名字。</p>
<h4 id="2-Abstract-Entity"><a href="#2-Abstract-Entity" class="headerlink" title="2.Abstract Entity"></a>2.Abstract Entity</h4><p>若实体只作为父类使用而不会被直接实例化，可勾选此复选框。默认未勾选，即创建具体的实体。</p>
<h4 id="3-Parent-Entity"><a href="#3-Parent-Entity" class="headerlink" title="3.Parent Entity"></a>3.Parent Entity</h4><p>当有多个属性相似的实体时，可在一个父实体中定义通用属性，然后让子实体继承这些属性。</p>
<h4 id="4-Class-Name"><a href="#4-Class-Name" class="headerlink" title="4.Class Name"></a>4.Class Name</h4><p>以实体为基础创建托管对象实例时所指定的类名，默认与实体名相同。</p>
<h4 id="5-Codegen"><a href="#5-Codegen" class="headerlink" title="5.Codegen"></a>5.Codegen</h4><p>在<code>.xcdatamodeld</code>编辑界面定义好实体后，还需要生成对应的托管对象类和属性文件，以便在实际开发中创建和使用实体的实例。这些文件可以手动生成，也可以让 Core Data 帮我们自动生成。我们需要做的是为<code>Codegen</code>选项指定不同的值。以下是选项值与具体场景的对应关系：</p>
<table>
<thead>
<tr>
<th align="left"><center>选项</center></th>
<th align="left"><center>场景</center></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Class Definition</td>
<td align="left">由Core Data自动生成托管对象类和属性文件，且我们不会主动修改这些文件。托管对象类和属性文件在编译时被放到编译目录，而不会出现在工程列表中；</td>
</tr>
<tr>
<td align="left">Category&#x2F;Extension</td>
<td align="left">由Core Data自动生成托管对象类和属性文件，同时我们可自己生成分类，添加自己的业务逻辑或方法，以便能完全控制托管对象类的实现。</td>
</tr>
<tr>
<td align="left">Manual&#x2F;None</td>
<td align="left">Core Data 不会帮我们生成任何文件，由你自己手动维护类和属性。通过编辑面板中设置的<code>class name</code>来定位和关联这些文件。</td>
</tr>
</tbody></table>
<h4 id="6-Renaming-ID"><a href="#6-Renaming-ID" class="headerlink" title="6.Renaming ID"></a>6.Renaming ID</h4><p>给实体重命名后，需要将新model中实体的<code>renaming identifier</code>设置成原model中实体的名字。</p>
<h3 id="四-Attribute-属性"><a href="#四-Attribute-属性" class="headerlink" title="四.Attribute-属性"></a>四.Attribute-属性</h3><p>配置属性时至少需要指定属性名、类型、是否必须保存到存储中、保存时是否必须有值。</p>
<p>对于一些属性，你还可以选择是否使用纯量类型、属性的默认值、指定数据校验规则。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_attr_conf.jpeg" srcset="/img/loading.gif" lazyload alt="属性配置面板"></p>
<h4 id="1-Type"><a href="#1-Type" class="headerlink" title="1.Type"></a>1.Type</h4><p>属性的可用数据类型如下所示：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_att_types.jpeg" srcset="/img/loading.gif" lazyload alt="数据类型"></p>
<p>其中<code>transformable</code>用于保存我们自定义的类、数组及图片等非常规数据类型。</p>
<h4 id="2-Optional"><a href="#2-Optional" class="headerlink" title="2.Optional"></a>2.Optional</h4><p>属性默认为<code>Optional</code>，即保存到持久化存储时，属性不要求必须有值。Core Data 不推荐使用这个选项，因为SQL中对<code>Null</code>的比较与OC中对<code>nil</code>的比较机制完全不一样，在数据库中<code>NULL ≠ 0</code>，且<code>NULL ≠ 空字符串</code>，所以用SQL搜索数字<code>0</code>的结果与搜索NULL的结果并不相同。</p>
<h4 id="3-Default-Value"><a href="#3-Default-Value" class="headerlink" title="3.Default Value"></a>3.Default Value</h4><p>属性默认值，初始化实体时，该属性会被自动赋上此默认值。可勾掉<code>Optional</code>选项搭配使用。</p>
<h4 id="4-Transient"><a href="#4-Transient" class="headerlink" title="4.Transient"></a>4.Transient</h4><p>默认情况下，属性会被保存到持久化存储中，但<code>Transient</code>属性不会。<code>短暂的</code>属性适用于临时保存一些值的场景。Core Data 不会跟踪这种属性的变化，所以也就没法做回滚这种操作。</p>
<h4 id="5-Validation"><a href="#5-Validation" class="headerlink" title="5.Validation"></a>5.Validation</h4><p>设置校验规则，例如给数值类型设置最大值最小值，或者给字符串类型设置正则表达式。</p>
<h4 id="6-Renaming-ID-1"><a href="#6-Renaming-ID-1" class="headerlink" title="6.Renaming ID"></a>6.Renaming ID</h4><p>给属性重命名后，需要将新model中属性的<code>renaming identifier</code>设置成原model中属性的名字。</p>
<h3 id="五-Relationship-关系"><a href="#五-Relationship-关系" class="headerlink" title="五.Relationship-关系"></a>五.Relationship-关系</h3><p>设置关系时需要指定其名字、目标实体、删除规则、对1或对N类型，并且配置反相的关系。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_relation.jpeg" srcset="/img/loading.gif" lazyload alt="关系配置"></p>
<h4 id="1-Destination"><a href="#1-Destination" class="headerlink" title="1.Destination"></a>1.Destination</h4><p>目标实体，例如一个<code>课程</code>对应多个<code>老师</code>时，在<code>课程</code>实体中可设置关系的目标实体为名<code>老师</code>。</p>
<h4 id="2-Inverse"><a href="#2-Inverse" class="headerlink" title="2.Inverse"></a>2.Inverse</h4><p>设置关系的另一半，因为在面板中只能从一个方向定义关系，这个选项是让两个关系组合起来成为一个完整的双向关系。这样 Core Data 才能在实体发生变化时在双方间传递这种变化。</p>
<h4 id="3-Delete-Rule"><a href="#3-Delete-Rule" class="headerlink" title="3.Delete Rule"></a>3.Delete Rule</h4><p>当源实体被删除时，关系的目标实体如何响应。</p>
<table>
<thead>
<tr>
<th align="left"><center>选项</center></th>
<th align="left"><center>删除规则</center></th>
</tr>
</thead>
<tbody><tr>
<td align="left">No Action</td>
<td align="left">删除源实体时，目标实体中保留关系的引用，由你手动更新</td>
</tr>
<tr>
<td align="left">Nullify</td>
<td align="left">删除源实体时，目标实体中的关系引用自动置空</td>
</tr>
<tr>
<td align="left">Cascade</td>
<td align="left">删除源实体时，同时删除关系中的所有目标实体</td>
</tr>
<tr>
<td align="left">Deny</td>
<td align="left">只在关系未指向任何目标实体时才删除源实体</td>
</tr>
</tbody></table>
<h4 id="4-Cardinality-Type"><a href="#4-Cardinality-Type" class="headerlink" title="4.Cardinality Type"></a>4.Cardinality Type</h4><p>关系分为<code>对1</code>和<code>对多</code>两种类型。</p>
<h4 id="5-Renaming-ID"><a href="#5-Renaming-ID" class="headerlink" title="5.Renaming ID"></a>5.Renaming ID</h4><p>给关系重命名后，需要将新model中关系的<code>renaming identifier</code>设置成原model中关系的名字。</p>
<h3 id="六-Core-Data-Stack"><a href="#六-Core-Data-Stack" class="headerlink" title="六.Core Data Stack"></a>六.Core Data Stack</h3><p>创建数据模型文件后需要设置相关类以便真正操作数据对象，这些类被称为<code>Core Data Stack</code>。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_stack.jpeg" srcset="/img/loading.gif" lazyload alt="Core Data Stack"></p>
<h4 id="1-MOM"><a href="#1-MOM" class="headerlink" title="1.MOM"></a>1.MOM</h4><p>ManagedObjectModel，托管对象模型，对应着Xcode中的<code>.xcdatamodeld</code>文件，保存在工程或 framework 里，通过<code>URL</code>加载。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSManagedObjectModel</span> *)managedObjectModel &#123;<br>    <span class="hljs-keyword">if</span> (_managedObjectModel != <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _managedObjectModel;<br>    &#125;<br>    <span class="hljs-built_in">NSURL</span> *modelURL = [[<span class="hljs-built_in">NSBundle</span> mainBundle] URLForResource:<span class="hljs-string">@&quot;Model&quot;</span> withExtension:<span class="hljs-string">@&quot;momd&quot;</span>];<br>    _managedObjectModel = [[<span class="hljs-built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelURL];<br>    <span class="hljs-keyword">return</span> _managedObjectModel;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>MOM</code>中包含了一个或多个<code>NSEntityDescription</code>对象，维护着<code>Entity</code>与对应的<code>managed object</code>间的映射关系。<code>MOM</code>支持使用预定义的<code>Fetch request</code>，以返回符合条件的数据对象。可以在<code>.xcdatamodeld</code>编辑面板中定义 fetch request 模板，也可以通过代码创建。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">NSManagedObjectModel</span> *model = [CoreDataStack shareInstance].managedObjectModel;<br><span class="hljs-attribute">NSFetchRequest</span> *request = [model fetchRequestTemplateForName:@<span class="hljs-string">&quot;Fetch1&quot;</span>];<br><span class="hljs-attribute">NSError</span> *<span class="hljs-literal">error</span>;<br><span class="hljs-attribute">NSArray</span> *matchArr = [self.viewContext executeFetchRequest:request <span class="hljs-literal">error</span>:&amp;<span class="hljs-literal">error</span>];<br></code></pre></td></tr></table></figure>

<h4 id="2-MOC"><a href="#2-MOC" class="headerlink" title="2.MOC"></a>2.MOC</h4><p>ManagedObjectContext，托管对象上下文，在<code>managed object</code>的生命周期中扮演者重要角色。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSManagedObjectContext</span> *)managedObjectContext &#123;<br>    <span class="hljs-keyword">if</span> (_managedObjectContext != <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _managedObjectContext;<br>    &#125;<br>    <span class="hljs-built_in">NSPersistentStoreCoordinator</span> *coordinator = [<span class="hljs-keyword">self</span> persistentStoreCoordinator];<br>    <span class="hljs-keyword">if</span> (!coordinator) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    _managedObjectContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    [_managedObjectContext setPersistentStoreCoordinator:coordinator];<br>    <span class="hljs-keyword">return</span> _managedObjectContext;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>跟踪变化</li>
</ul>
<p>所有的托管对象都必须在MOC中，而 MOC 位于RAM中。通过 MOC 你可以从持久化存储中返回托管对象，并且 MOC 会负责跟踪它们的变化，例如对托管对象的增删改、校验、反向关系的处理、回滚&#x2F;重做等。这些变化会先保存在内存中关联的 MOC 中，直到执行 save 操作时，Core Data 才会将此变化同步到持久化存储中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1.从数据库中删除</span><br><span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [Course fetchRequest];<br>Course *indexedCourse = _mDatasourceArr[index];<br><span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,indexedCourse.id];<br>[fetchRequest setPredicate:predicate];<br>    <br><span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br><span class="hljs-built_in">NSArray</span> *fetchedObjects = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:fetchRequest error:&amp;error];<br><span class="hljs-keyword">for</span> (Course *c <span class="hljs-keyword">in</span> fetchedObjects) &#123;<br>    [<span class="hljs-keyword">self</span>.viewContext deleteObject:c]; <span class="hljs-comment">// 还在内存中</span><br>&#125;<br>[<span class="hljs-keyword">self</span> save]; <span class="hljs-comment">// 写入持久化存储中</span><br></code></pre></td></tr></table></figure>

<ul>
<li>为什么要有MOC这一层呢？</li>
</ul>
<p>我们的数据对象需要保存到持久化存储中，而持久化存储一般在磁盘中，读写速度相对较慢，不应频繁地访问。MOC位于 RAM 中，读写速度相对较快，它可以快速访问内存中的托管对象，跟踪托管对象的频繁变化，提供完整的回滚和重做支持。开发者只需定期通过 MOC 调用<code>save</code>方法，将这些托管对象真正写入磁盘中。</p>
<h4 id="3-PSC"><a href="#3-PSC" class="headerlink" title="3.PSC"></a>3.PSC</h4><p>NSPersistentStoreCoordinator，是MOC与应用持久化存储之间的桥梁。MOC需要通过PSC访问MOM，PSC将注册在其下面的持久化存储集中展示，便于MOC一次性操作，而非一个个去操作。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (<span class="hljs-type">NSPersistentStoreCoordinator</span> <span class="hljs-operator">*</span>)persistentStoreCoordinator &#123;<br>    <span class="hljs-keyword">if</span> (_persistentStoreCoordinator <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>    &#125;<br>    _persistentStoreCoordinator <span class="hljs-operator">=</span> [[<span class="hljs-type">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="hljs-keyword">self</span> managedObjectModel]];<br>    <span class="hljs-type">NSURL</span> <span class="hljs-operator">*</span>storeURL <span class="hljs-operator">=</span> [[<span class="hljs-keyword">self</span> applicationDocumentsDirectory] <span class="hljs-type">URLByAppendingPathComponent</span>:@<span class="hljs-string">&quot;ASDF.sqlite&quot;</span>];<br>    <span class="hljs-type">NSError</span> <span class="hljs-operator">*</span>error <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 数据库做轻量迁移时 传入此options字典</span><br>    <span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span>options <span class="hljs-operator">=</span> @&#123;<span class="hljs-type">NSMigratePersistentStoresAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>, <br>                              <span class="hljs-type">NSInferMappingModelAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>&#125;;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>[_persistentStoreCoordinator addPersistentStoreWithType:<span class="hljs-type">NSSQLiteStoreType</span> <br>                                                   configuration:<span class="hljs-literal">nil</span> <br>                                                             URL:storeURL <br>                                                         options:options error:<span class="hljs-operator">&amp;</span>error]) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PSC在私有串行队列上执行任务，如果有需要你也可以使用多个PSC以便在不同的队列上执行任务。</p>
<p>使用PSC可以增加或删除某个持久化存储，更改存储的类型或位置，查询存储的元数据，定义存储的迁移，定义两个对象是否源自于同一个存储等等。</p>
<h4 id="4-NSPersistentContainer"><a href="#4-NSPersistentContainer" class="headerlink" title="4.NSPersistentContainer"></a>4.NSPersistentContainer</h4><p>这是 iOS10 之后新出的一个封装了MOC、MOM、PSC的容器，用来简化 Core Data stack 的初始化和管理工作。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSPersistentContainer</span> *)persistentContainer<br>&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_persistentContainer == <span class="hljs-literal">nil</span>) &#123;<br>            _persistentContainer = [[<span class="hljs-built_in">NSPersistentContainer</span> alloc] initWithName:<span class="hljs-string">@&quot;Model&quot;</span>]; <span class="hljs-comment">// 只需指定model文件名</span><br>            [_persistentContainer loadPersistentStoresWithCompletionHandler:^(<span class="hljs-built_in">NSPersistentStoreDescription</span> *storeDescription, <span class="hljs-built_in">NSError</span> *error) &#123;<br>                <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">nil</span>) &#123;<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error %@, %@&quot;</span>, error, error.userInfo);<br>                &#125;<br>            &#125;];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _persistentContainer;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它提供了我们常用的三个 Stack 属性，通过 persistentContainer 对象调用即可：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSManagedObjectContext</span> *viewContext;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSManagedObjectModel</span> *managedObjectModel;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSPersistentStoreCoordinator</span> *persistentStoreCoordinator;<br></code></pre></td></tr></table></figure>

<h3 id="七-托管对象"><a href="#七-托管对象" class="headerlink" title="七.托管对象"></a>七.托管对象</h3><p>定义好MOM、初始化 Core Data Stack 之后，就可以为持久化存储创建、保存数据对象了。</p>
<h4 id="1-MO"><a href="#1-MO" class="headerlink" title="1.MO"></a>1.MO</h4><p>NSManagedObject，表示持久化存储中保存的数据对象，它是所有MO对象的基类，是<code>Entity</code>在代码层面真正对应的类。在<code>.xcdatamodeld</code>编辑界面中，选中<code>Course</code>这个<code>Entity</code>，打开右侧的属性面板，在<code>Entity</code>栏下有个<code>Name</code>字段，它是<code>Entity</code>在<code>.xcdatamodeld</code>文件中的名字；而下方有个<code>Class</code>栏，这些是与此<code>Entity</code>绑定的MO子类信息，其中<code>Name</code>字段就是对应的MO子类名，一般与<code>Entity</code>同名，即<code>Course</code>。当然，你也可以根据自己的规范定义成别的名字。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Course</span> : <span class="hljs-title">NSManagedObject</span></span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>通常<code>Entity</code>属性面板中<code>codegen</code>字段设置为<code>Class Definition</code>时，Core Data 会自动为我们生成此类定义，只是这个类不会出现在代码列表中，我们可在代码中导入其头文件直接使用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1.导入MO实体头文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Course+CoreDataClass.h&quot;</span></span><br><br><span class="hljs-comment">// 2.创建 NSManagedObject 对象</span><br>Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>c.id = index;<br>c.name = <span class="hljs-string">@&quot;英语&quot;</span>; <span class="hljs-comment">// 给实体的属性赋值</span><br><span class="hljs-built_in">NSManagedObjectContext</span> *context = <span class="hljs-keyword">self</span>.persistentContainer.viewContext;<br><span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-comment">// 3.保存到持久化存储中</span><br><span class="hljs-keyword">if</span> ([context hasChanges] &amp;&amp; ![context save:&amp;error]) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-NSEntityDescription"><a href="#2-NSEntityDescription" class="headerlink" title="2.NSEntityDescription"></a>2.NSEntityDescription</h4><p>通过上面MO的示例可以看到，使用MO时需要两个元素的配合：<code>NSEntityDescription</code>与<code>MOC</code>。</p>
<p>其中<code>NSEntityDescription</code>是对模型文件中<code>Entity</code>的描述，包括名字、属性、关系，及代码层面此<code>Entity</code>代表的MO实体类。我们在<code>.xcdatamodeld</code>编辑面板中定义<code>Entity</code>，而 Core Data 使用<code>NSEntityDescription</code>来匹配持久化存储中的<code>Managed Object</code>。</p>
<p>后者是管理MO的上下文，顾名思义，就是用来跟踪MO及其关系的变化。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-comment">// 设置描述</span><br><span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [[<span class="hljs-built_in">NSFetchRequest</span> alloc] init];<br><span class="hljs-built_in">NSEntityDescription</span> *desription = [<span class="hljs-built_in">NSEntityDescription</span> entityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>[fetchRequest setEntity:desription];<br>    <br>Course *indexedCourse = _mDatasourceArr[index];<br><span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,indexedCourse.id];<br>[fetchRequest setPredicate:predicate];<br><br><span class="hljs-comment">// 根据描述查询 Managed Object</span><br><span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br><span class="hljs-built_in">NSArray</span> *fetchedObjects = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:fetchRequest error:&amp;error];<br><span class="hljs-keyword">for</span> (Course *c <span class="hljs-keyword">in</span> fetchedObjects) &#123;<br>    <span class="hljs-comment">// 删除 Managed Object</span><br>    [<span class="hljs-keyword">self</span>.viewContext deleteObject:c];<br>&#125;<br>[<span class="hljs-keyword">self</span> save];<br></code></pre></td></tr></table></figure>
<h3 id="八-增删改查"><a href="#八-增删改查" class="headerlink" title="八.增删改查"></a>八.增删改查</h3><h4 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h4><h5 id="1-1-结果类型"><a href="#1-1-结果类型" class="headerlink" title="1.1.结果类型"></a>1.1.结果类型</h5><p>MOC需通过<code>NSFetchRequest</code>执行查询操作，查询结果以数组形式返回，默认情况下数组中返回的是托管对象<code>MO</code>。当然你也可以通过 fetch 的<code>resultType</code>属性将数组中的对象指定为其他类型。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSFetchRequestResultType</span> resultType;<br></code></pre></td></tr></table></figure>
<p>Core Data 支持四种返回类型：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_OPTIONS</span>(<span class="hljs-type">NSUInteger</span>, <span class="hljs-type">NSFetchRequestResultType</span>) &#123;<br>    <span class="hljs-type">NSManagedObjectResultType</span>      = 0x00,<br>    <span class="hljs-type">NSManagedObjectIDResultType</span>    = 0x01,<br>    <span class="hljs-type">NSDictionaryResultType</span>         = 0x02,<br>    <span class="hljs-type">NSCountResultType</span>              = 0x04<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>NSDictionaryResultType</code>，返回字典类型的对象；</li>
<li><code>NSCountResultType</code>，返回请求结果的count数值；</li>
<li><code>NSManagedObjectResultType</code>，默认值，查询结果数组中的元素为MO对象；</li>
<li><code>NSManagedObjectIDResultType</code>，查询结果数组中的元素为NSManagedObjectID 对象，即MO对象的ID。这种类型的内存占用比较小，MOC可以继续通过ID对象获取对应的MO。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-built_in">NSManagedObjectID</span> *moID = objectIDs[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">NSManagedObject</span> *obj = [managedObjectContext existingObjectWithID:moID error:&amp;error];<br></code></pre></td></tr></table></figure>

<h5 id="1-2-Fault对象"><a href="#1-2-Fault对象" class="headerlink" title="1.2.Fault对象"></a>1.2.Fault对象</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">BOOL</span> returnsObjectsAsFaults;<br></code></pre></td></tr></table></figure>

<p>这是 Fetch 请求的一个属性，默认值是YES，表示让查询结果返回<code>Fault</code>(惰值)状态的托管对象。<code>Fault</code>对象是托管对象的占位对象，作为查询结果被保存在 MOC 中，而 MOC 位于内存中。为了节省内存开销，<code>Fault</code>对象的属性值暂时不会填充到对应字段上，而是先保存在持久化存储的<code>row cache</code>(行缓存)中。当访问或修改这些属性值时，Core Data 才去持久化存储的<code>行缓存</code>中取出属性值并填充到<code>Fault</code>对象中，使其成为完全体的托管对象。</p>
<p>这种设计减少了内存消耗，却有一定的性能开销，如果你想在 fetch 结果返回后立即访问其中MO对象的属性，则应该将这个属性的值置为<code>NO</code>。</p>
<p>另外，这个属性只在返回类型为<code>ObjectResultType</code>时有效，对<code>ObjectIDResultType</code>无效, 因为 object IDs 没有属性值，设置此属性没有意义。</p>
<h5 id="1-3-过滤条件"><a href="#1-3-过滤条件" class="headerlink" title="1.3.过滤条件"></a>1.3.过滤条件</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSPredicate</span> *predicate;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><center>运算符</center></th>
<th align="left"><center> 作用 </center></th>
<th align="left"><center> 示例 </center></th>
</tr>
</thead>
<tbody><tr>
<td align="left">&gt; 、&lt; 、&#x3D;&#x3D; 、&gt;&#x3D; 、&lt;&#x3D; 、!&#x3D;</td>
<td align="left">比较运算</td>
<td align="left">age &gt; 18</td>
</tr>
<tr>
<td align="left">IN</td>
<td align="left">被包含</td>
<td align="left">name IN {‘张三’,’李四’}</td>
</tr>
<tr>
<td align="left">BETWEEN</td>
<td align="left">在区间内</td>
<td align="left">age BETWEEN {18,80}</td>
</tr>
<tr>
<td align="left">BEGINSWITH</td>
<td align="left">开头是</td>
<td align="left">name BEGINSWITH ‘张’</td>
</tr>
<tr>
<td align="left">ENDSWITH</td>
<td align="left">结尾是</td>
<td align="left">name ENDSWITH ‘四’</td>
</tr>
<tr>
<td align="left">CONTAINS</td>
<td align="left">包含有</td>
<td align="left">name CONTAINS ‘四’</td>
</tr>
<tr>
<td align="left">LIKE</td>
<td align="left">通配符 *和?</td>
<td align="left">name LIKE ‘*四’</td>
</tr>
<tr>
<td align="left">MATCHES</td>
<td align="left">正则</td>
<td align="left">name MATCHES ‘(regex)’</td>
</tr>
</tbody></table>
<h5 id="1-4-排序规则"><a href="#1-4-排序规则" class="headerlink" title="1.4.排序规则"></a>1.4.排序规则</h5><p>返回数据的排序规则，这是个数组，即支持多重排序，按数组中的前后顺序先后执行。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSSortDescriptor</span> *&gt; *sortDescriptors;<br></code></pre></td></tr></table></figure>

<h5 id="1-5-分页查询"><a href="#1-5-分页查询" class="headerlink" title="1.5.分页查询"></a>1.5.分页查询</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 总共查询的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchLimit;<br><span class="hljs-comment">// 每次查询返回的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchBatchSize;<br><span class="hljs-comment">// 分页查询的下标，从哪条开始查</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchOffset;<br></code></pre></td></tr></table></figure>

<h5 id="1-6-案例演示"><a href="#1-6-案例演示" class="headerlink" title="1.6.案例演示"></a>1.6.案例演示</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)loadDataAtPage:(<span class="hljs-built_in">NSUInteger</span>)page&#123;<br>    <span class="hljs-comment">// 1.设置请求</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br>    <span class="hljs-comment">/*相当于上面的代码</span><br><span class="hljs-comment">    NSFetchRequest * request = [[NSFetchRequest alloc] init];</span><br><span class="hljs-comment">    NSEntityDescription *desription = [NSEntityDescription entityForName:@&quot;Course&quot; inManagedObjectContext:self.viewContext];</span><br><span class="hljs-comment">    [request setEntity:desription];</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 2.排序</span><br>    <span class="hljs-built_in">NSSortDescriptor</span> *descriptor = [<span class="hljs-built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="hljs-string">@&quot;id&quot;</span> ascending:<span class="hljs-literal">YES</span>];<br>    request.sortDescriptors = @[descriptor];<br>    <br>    <span class="hljs-comment">// 3.分页</span><br>    request.fetchOffset = (page - <span class="hljs-number">1</span>) * kLimiteSize;<br>    request.fetchLimit = kLimiteSize;<br>    <br>    <span class="hljs-comment">// 4.查询</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h4><p>先查询MO对象，再逐一修改其属性，最后由MOC执行save，保存到持久化存储中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)updateDataAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index&#123;<br>    <span class="hljs-comment">// 1.创建fetch</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br>    <span class="hljs-comment">// 2.设置过滤条件</span><br>    <span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,index];<br>    [request setPredicate:predicate];<br>    <span class="hljs-built_in">NSSortDescriptor</span> *descriptor = [<span class="hljs-built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="hljs-string">@&quot;id&quot;</span> ascending:<span class="hljs-literal">YES</span>];<br>    request.sortDescriptors = @[descriptor]; <span class="hljs-comment">// 排序</span><br>    <span class="hljs-comment">// 3.执行fetch</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>    <span class="hljs-built_in">NSInteger</span> count = matchArr.count;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        Course *c = matchArr[i];<br>        <span class="hljs-comment">//4.修改托管对象</span><br>        c.name = [c.name stringByAppendingString:<span class="hljs-string">@&quot;X&quot;</span>]; <span class="hljs-comment">//managed object对象，更新到内存中</span><br>    &#125;<br>    <span class="hljs-comment">// 5.同步到数据库</span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.viewContext hasChanges] &amp;&amp; ![<span class="hljs-keyword">self</span>.viewContext save:&amp;error]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h4><p>插入数据，要用到以下这个<code>NSEntityDescription</code>的静态方法来执行数据的创建工作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSManagedObject</span> *)insertNewObjectForEntityForName:(<span class="hljs-built_in">NSString</span> *)entityName<br>                              inManagedObjectContext:(<span class="hljs-built_in">NSManagedObjectContext</span> *)context;<br></code></pre></td></tr></table></figure>
<p>这里的<code>name</code>参数是模型文件中<code>Entity</code>的名字，Core Data 根据<code>Entity</code>的结构来创建MO对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-comment">// 往数据库中插入数据</span><br>- (<span class="hljs-type">void</span>)insertData&#123;<br>    <span class="hljs-comment">// 1.在内存中创建MO实例并设置各字段</span><br>    int32_t index = (int32_t)<span class="hljs-keyword">self</span>.mDatasourceArr.count;<br>    Student *s1 = [[Student alloc] init];<br>    s1.sID = <span class="hljs-number">101</span>;<br>    s1.name = <span class="hljs-string">@&quot;学生甲&quot;</span>;<br>    <br>    Student *s2 = [[Student alloc] init];<br>    s2.sID = <span class="hljs-number">102</span>;<br>    s2.name = <span class="hljs-string">@&quot;学生乙&quot;</span>;<br>    <br>    Teacher *t = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Teacher&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>    t.id = index;<br>    t.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;老师%d&quot;</span>,index];<br>    t.avator = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;1&quot;</span>];<br>    t.descript = <span class="hljs-string">@&quot;省级优秀教师&quot;</span>;<br>    <br>    Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>    c.id = index;<br>    c.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;课程%d&quot;</span>,index];<br>    c.url = <span class="hljs-string">@&quot;https://www.baidu.com&quot;</span>;<br>    c.teachers = [<span class="hljs-built_in">NSSet</span> setWithObject:t]; <span class="hljs-comment">// 1-&gt;N，直接设置course对应的关系“teachers”字段</span><br>    c.students = [<span class="hljs-built_in">NSSet</span> setWithObjects:s1, s2, <span class="hljs-literal">nil</span>]; <span class="hljs-comment">// 数组，transformable类型，数组中的元素student需要实现NSCoding协议</span><br><br>    <span class="hljs-comment">// 2.通过MOC执行保存操作，写入数据库</span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.viewContext hasChanges] &amp;&amp; ![<span class="hljs-keyword">self</span>.viewContext save:&amp;error]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h4><p>先查询MO对象，再通过MOC执行delete，删除这些MO，最后执行save同步到存储中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)removeDataAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index&#123;<br>    <span class="hljs-comment">// 1.设置查询目标实体及条件</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [Course fetchRequest];<br>    <span class="hljs-comment">/*相当于上面的代码</span><br><span class="hljs-comment">     NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];</span><br><span class="hljs-comment">     NSEntityDescription *desription = [NSEntityDescription entityForName:@&quot;Course&quot; inManagedObjectContext:self.viewContext];</span><br><span class="hljs-comment">     [fetchRequest setEntity:desription];</span><br><span class="hljs-comment">     */</span><br>    Course *indexedCourse = _mDatasourceArr[index];<br>    <span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,indexedCourse.id];<br>    [fetchRequest setPredicate:predicate];<br><br>    <span class="hljs-comment">// 2.从数据库中查询MO    </span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-built_in">NSArray</span> *fetchedObjects = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:fetchRequest error:&amp;error];<br>    <span class="hljs-keyword">for</span> (Course *c <span class="hljs-keyword">in</span> fetchedObjects) &#123;<br>        <span class="hljs-comment">// 3.在内存中删除MO</span><br>        [<span class="hljs-keyword">self</span>.viewContext deleteObject:c];<br>    &#125;<br>    <span class="hljs-comment">// 4.在数据库中删除MO</span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.viewContext hasChanges] &amp;&amp; ![<span class="hljs-keyword">self</span>.viewContext save:&amp;error]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="九-类型转换"><a href="#九-类型转换" class="headerlink" title="九.类型转换"></a>九.类型转换</h3><p>在定义Entity时，属性可以是以下类型：</p>
<ul>
<li>Integer</li>
<li>Float</li>
<li>Double</li>
<li>Decimal</li>
<li>Boolean</li>
<li>String</li>
<li>Date</li>
<li>Binary Data</li>
<li>UUID</li>
<li>URI</li>
<li>Transformable</li>
</ul>
<p>Core Data 不支持直接保存图片、音视频文件、颜色、数组、自定义类型等，这时可以将实体中对应的属性设置成 Binary Data 类型，再将这些文件或自定义类型转换成 Data，赋值给实体的属性，执行 save 保存到持久化存储中。读取属性时则反过来，将持久化存储中的 data 手动转换成对应的文件或自定义类型即可。</p>
<p>但是，每次都自己手动转换显然比较麻烦。这时可以这样做：</p>
<ol>
<li>将属性设置成<code>Transformable</code>类型；</li>
<li>提供一个继承自<code>NSValueTransformer</code>的子类，重写必须的方法；</li>
<li>在模型编辑窗口，设置属性的<code>Transformer</code>与<code>Custom Class</code>字段；</li>
<li>保存属性时，直接给属性赋值，Core Data 会通过我们指定的<code>NSValueTransformer</code>子类，自动执行数据转换，将属性中的值转换成 data，写入持久化存储；</li>
<li>读取属性时，从持久化存储中读取 data，由<code>NSValueTransformer</code>子类自动转换成对应类型；</li>
</ol>
<p>这里的<code>NSValueTransformer</code>是一个抽象类，支持单向或双向的类型转换。其内部已经封装好了数据类型转换所需的抽象方法，子类需要自己提供实现：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">+ (<span class="hljs-keyword">Class</span>)transformedValueClass;<br></code></pre></td></tr></table></figure>
<ul>
<li>转换后对象所属的类。</li>
</ul>
<p>例如将<code>Student</code>保存入库时，需要将<code>Student</code>对象转换成<code>Data</code>，这里就返回<code>Data</code>类型。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">- (<span class="hljs-literal">null</span>able id)transformedValue:(<span class="hljs-literal">null</span>able id)value;<br></code></pre></td></tr></table></figure>
<ul>
<li>被转换对象的值。</li>
</ul>
<p>例如保存<code>Student</code>类型时，需要将<code>Student</code>对象转换成<code>Data</code>，这里就返回转换之后 Data 的值。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> (BOOL)allowsReverseTransformation;<br></code></pre></td></tr></table></figure>
<ul>
<li>bool值，表示是否支持反向转换。</li>
</ul>
<p>例如将<code>Student</code>转成data入库后，读取时是否允许将data回转成<code>Student</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">- (<span class="hljs-literal">null</span>able id)reverseTransformedValue:(<span class="hljs-literal">null</span>able id)value;<br></code></pre></td></tr></table></figure>

<ul>
<li>反向转换时，转换出来的对象的值。</li>
</ul>
<p>例如读取属性时，要将库中的<code>Data</code>转换成<code>Student</code>，这里就返回转换之后的<code>Student</code>实例。</p>
<hr>
<p>下面来看一些常见的类型转换怎么重写：</p>
<h4 id="1-颜色转Data"><a href="#1-颜色转Data" class="headerlink" title="1.颜色转Data"></a>1.颜色转Data</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 颜色转Data</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RGBColorValueTransformer</span> : <span class="hljs-title">NSValueTransformer</span> </span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RGBColorValueTransformer</span></span><br><br><span class="hljs-comment">// 颜色转Data，这里返回 Data 类型</span><br>+ (Class)transformedValueClass &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSData</span> <span class="hljs-keyword">class</span>];<br>&#125;<br> <br><span class="hljs-comment">// 颜色转Data后得到的data</span><br>- (<span class="hljs-type">id</span>)transformedValue:(<span class="hljs-type">id</span>)value &#123;<br>    <span class="hljs-built_in">UIColor</span>* color = value;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">CGFloat</span>* components = <span class="hljs-built_in">CGColorGetComponents</span>(color.CGColor);<br>    <span class="hljs-built_in">NSString</span>* colorAsString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%f,%f,%f,%f&quot;</span>, components[<span class="hljs-number">0</span>], components[<span class="hljs-number">1</span>], components[<span class="hljs-number">2</span>], components[<span class="hljs-number">3</span>]];<br>    <span class="hljs-keyword">return</span> [colorAsString dataUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>&#125;<br> <br><span class="hljs-comment">// Data反向转换成颜色时得到的颜色对象</span><br>- (<span class="hljs-type">id</span>)reverseTransformedValue:(<span class="hljs-type">id</span>)value &#123;<br>    <span class="hljs-built_in">NSString</span>* colorAsString = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:value encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>    <span class="hljs-built_in">NSArray</span>* components = [colorAsString componentsSeparatedByString:<span class="hljs-string">@&quot;,&quot;</span>];<br>    <span class="hljs-built_in">CGFloat</span> r = [[components objectAtIndex:<span class="hljs-number">0</span>] floatValue];<br>    <span class="hljs-built_in">CGFloat</span> g = [[components objectAtIndex:<span class="hljs-number">1</span>] floatValue];<br>    <span class="hljs-built_in">CGFloat</span> b = [[components objectAtIndex:<span class="hljs-number">2</span>] floatValue];<br>    <span class="hljs-built_in">CGFloat</span> a = [[components objectAtIndex:<span class="hljs-number">3</span>] floatValue];<br> <br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">UIColor</span> colorWithRed:r green:g blue:b alpha:a];<br>&#125;<br><br><span class="hljs-comment">// 是否允许反向转换</span><br>+ (<span class="hljs-type">BOOL</span>)allowsReverseTransformation &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h4 id="2-图片转Data"><a href="#2-图片转Data" class="headerlink" title="2.图片转Data"></a>2.图片转Data</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 图片转Data</span><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">ImageToDataValueTransformer </span>: NSValueTransformer<br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@implementation</span> ImageToDataValueTransformer<br><br><span class="hljs-comment">// 图片转Data时，data所属的类</span><br>+ (Class)transformedValueClass &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-attr">[NSData class]</span>;<br>&#125;<br><br><span class="hljs-comment">// 图片转Data后，得到的data</span><br><span class="hljs-selector-tag">-</span> (id)<span class="hljs-selector-tag">transformedValue</span>:(id)<span class="hljs-selector-tag">value</span> &#123;<br>    <span class="hljs-selector-tag">if</span> (value == nil) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">nil</span>;<br>    &#125;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">UIImagePNGRepresentation</span>(value);<br>&#125;<br><br><span class="hljs-comment">// data反向转成图片时，得到的图片对象</span><br><span class="hljs-selector-tag">-</span> (id)<span class="hljs-selector-tag">reverseTransformedValue</span>:(id)<span class="hljs-selector-tag">value</span> &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-attr">[UIImage imageWithData:(NSData *)value]</span>;<br>&#125;<br><br><span class="hljs-comment">// 是否允许反向转换</span><br>+ (BOOL)<span class="hljs-selector-tag">allowsReverseTransformation</span> &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">YES</span>;<br>&#125;<br><br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure>

<h4 id="3-数组转Data"><a href="#3-数组转Data" class="headerlink" title="3.数组转Data"></a>3.数组转Data</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 数组转Data</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ArrayToDataValueTransformer</span> : <span class="hljs-title">NSValueTransformer</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ArrayToDataValueTransformer</span></span><br><br><span class="hljs-comment">// 数组转Data时，被转换的数组所属的类</span><br>+ (Class)transformedValueClass&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSArray</span> <span class="hljs-keyword">class</span>];<br>&#125;<br><br><span class="hljs-comment">// 数组转换成Data时，得到的data</span><br>- (<span class="hljs-type">id</span>)transformedValue:(<span class="hljs-type">id</span>)value&#123;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSKeyedArchiver</span> archivedDataWithRootObject:value requiringSecureCoding:<span class="hljs-literal">YES</span> error:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><span class="hljs-comment">// data反过来转换成数组时，得到的数组对象</span><br>- (<span class="hljs-type">id</span>)reverseTransformedValue:(<span class="hljs-type">id</span>)value&#123;<br>    <span class="hljs-comment">// 指明转换成数组后，其中元素的类型</span><br>    <span class="hljs-built_in">NSSet</span> *unarchivedSet = [<span class="hljs-built_in">NSSet</span> setWithObjects:[MyClassA <span class="hljs-keyword">class</span>], [MyClassB <span class="hljs-keyword">class</span>], <span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSKeyedUnarchiver</span> unarchivedObjectOfClasses:unarchivedSet fromData:value error:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><span class="hljs-comment">// 是否允许反向转换</span><br>+ (<span class="hljs-type">BOOL</span>)allowsReverseTransformation&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>注意，当被转换的是自定义类型时，需要这些自定义类型实现<code>NSSecureCoding </code>协议，重写<code>encodeWithCoder:</code>和<code>initWithCoder:</code>方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClassA</span></span><br><br>- (<span class="hljs-type">void</span>)encodeWithCoder:(<span class="hljs-built_in">NSCoder</span> *)aCoder<br>&#123;<br>    [aCoder encodeObject:_property1 forKey:<span class="hljs-string">@&quot;property1&quot;</span>];<br>    [aCoder encodeObject:_property2 forKey:<span class="hljs-string">@&quot;property2&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">instancetype</span>)initWithCoder:(<span class="hljs-built_in">NSCoder</span> *)aDecoder<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init])<br>    &#123;<br>        _property1 = [aDecoder decodeObjectForKey:<span class="hljs-string">@&quot;property1&quot;</span>];<br>        _property2 = [aDecoder decodeObjectForKey:<span class="hljs-string">@&quot;property2&quot;</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br><br>+ (<span class="hljs-type">BOOL</span>)supportsSecureCoding&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h3 id="十-性能优化"><a href="#十-性能优化" class="headerlink" title="十.性能优化"></a>十.性能优化</h3><p>IO操作通常是比较费性能的，而 Core Data 的底层就是对 sqlite 文件等持久化存储进行读写，大量的读写操作会阻塞线程或引发性能问题，所以要考虑内存、性能、线程、并发等问题。</p>
<h4 id="1-多MOC"><a href="#1-多MOC" class="headerlink" title="1.多MOC"></a>1.多MOC</h4><h5 id="1-1-并发"><a href="#1-1-并发" class="headerlink" title="1.1.并发"></a>1.1.并发</h5><p>为了缓解主线程的压力，对于一些不涉及到UI更新的数据库操作，通常是放到新开辟的一个或多个线程进行。需要注意的是，Core Data的MO与MOC不是线程安全的，对MO与MOC的操作不会上锁去保证操作的原子性，多个线程共用MOC时可能会出现数据混乱甚至闪退。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_n_thread_1_moc.png" srcset="/img/loading.gif" lazyload alt="多个线程共用一个MOC"></p>
<p>错误示范：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 测试：多个线程中共用一个MOC可能会引起数据混乱或闪退</span><br>- (<span class="hljs-type">void</span>)testOptionsInMultiThread &#123;<br><br>    <span class="hljs-comment">// 1.共用一个MOC</span><br>    _sameContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _sameContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    <br>    <span class="hljs-comment">// 2.模拟测试数据</span><br>    <span class="hljs-built_in">NSMutableArray</span> *sectionData = [<span class="hljs-built_in">NSMutableArray</span> array];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-built_in">NSString</span> *descript = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;this is %d&quot;</span>,i];<br>        [sectionData addObject:@&#123;<span class="hljs-string">@&quot;id&quot;</span>: @(i), <span class="hljs-string">@&quot;name&quot;</span>: @(i), <span class="hljs-string">@&quot;descript&quot;</span>: descript&#125;];<br>    &#125;<br>    <span class="hljs-comment">// 3.异步线程A 插入数据</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSDictionary</span> *params <span class="hljs-keyword">in</span> sectionData) &#123;<br>            Section *section = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Section&quot;</span> inManagedObjectContext:_sameContext];<br>            <span class="hljs-type">int</span> idf = [params[<span class="hljs-string">@&quot;id&quot;</span>] intValue];<br>            section.id   = idf;<br>            section.name = idf;<br>            section.descript = params[<span class="hljs-string">@&quot;descript&quot;</span>];<br>            <span class="hljs-comment">// 模拟插入10条数据后，异步线程B执行更新操作</span><br>            <span class="hljs-keyword">if</span> (idf == <span class="hljs-number">10</span>) &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        [_sameContext save:<span class="hljs-literal">nil</span>];<br>    &#125;);<br>    <span class="hljs-comment">// 4.异步线程B 更新数据</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [[<span class="hljs-built_in">NSFetchRequest</span> alloc] initWithEntityName:<span class="hljs-string">@&quot;Section&quot;</span>];<br>        <span class="hljs-built_in">NSArray</span> *results = [_sameContext executeFetchRequest:fetchRequest error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">for</span> (Section *section <span class="hljs-keyword">in</span> results) &#123;<br>            <span class="hljs-type">int</span> i = arc4random();<br>            section.id = i;<br>            section.name = i;<br>            section.descript = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;this is %d&quot;</span>,i];<br>        &#125;<br>        [_sameContext save:<span class="hljs-literal">nil</span>];<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例中<code>线程A</code>、<code>线程B</code>分别执行插入和更新操作。由于是共用一个MOC且是异步操作，<code>线程A</code>新增的MO可能在<code>线程B</code>中被提前执行了<code>save</code>，两种操作混在一起会产生闪退。</p>
<p>苹果推荐的是每个线程使用一个独立的MOC，这样MOC在自己所属的线程中管理自己监听的MO，不受其他MOC的影响，从而避免MOC保存前它监听的MO被其他MOC篡改或提前 save 的情况。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_n_thread_n_moc.png" srcset="/img/loading.gif" lazyload alt="多个线程对应多个MOC"></p>
<p>创建多MOC时需要指定它的并发类型以便进行多线程管理，Core Data 提供了两个选择：</p>
<ol>
<li><code>Main</code>：MOC与主队列关联并且依赖应用的<code>event loop</code>；</li>
<li><code>Private</code>：MOC会创建并管理一个私有串行队列。</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 主MOC</span><br>_mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc]<br>                    initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br><span class="hljs-comment">// 私有队列MOC</span><br>_backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc]<br>                          initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br></code></pre></td></tr></table></figure>

<p>基于队列的多 MOC 需要搭配以下两个API使用：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[moc performBlock:]</span><br><span class="hljs-string">[moc performBlockAndWait:]</span><br></code></pre></td></tr></table></figure>

<p>前者是异步操作，被调用后立刻返回；</p>
<p>后者是同步操作，会堵塞线程直到任务完成才返回。</p>
<p>对于更新UI或其他需要在主线程中执行的操作，推荐使用<code>Main</code>主队列MOC。</p>
<p>对于一些耗时的任务，推荐使用<code>Private</code>私有队列MOC+异步block执行。</p>
<h5 id="1-2-同PSC"><a href="#1-2-同PSC" class="headerlink" title="1.2.同PSC"></a>1.2.同PSC</h5><p>示例1：多MOC使用同一个PSC</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_n_moc_1_psc.png" srcset="/img/loading.gif" lazyload alt="多MOC使用同一个PSC"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)initMulMOCWithOnePSC<br>&#123;<br>    <span class="hljs-comment">// 主队列使用的MOC</span><br>    _mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _mainContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    <br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    <br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onUpdate:) name:<span class="hljs-built_in">NSManagedObjectContextDidSaveNotification</span> object:_mainContext];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onUpdate:) name:<span class="hljs-built_in">NSManagedObjectContextDidSaveNotification</span> object:_backgroudnContext];<br>    <br>    <span class="hljs-comment">// 主MOC增加实体</span><br>    Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.mainContext];<br>    c.id = <span class="hljs-number">1</span>;<br>    c.name =<span class="hljs-string">@&quot;A1&quot;</span>;<br>    [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br><br>    <span class="hljs-comment">// 子MOC增加实体    </span><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 子MOC插入实体</span><br>        Course *c2 = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.backgroudnContext];<br>        c2.id = <span class="hljs-number">2</span>;<br>        c2.name =<span class="hljs-string">@&quot;A2&quot;</span>;<br>        <span class="hljs-comment">// 子MOC执行save</span><br>        [<span class="hljs-keyword">self</span>.backgroudnContext save:<span class="hljs-literal">nil</span>];<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// 监听save通知，合并来自其他MOC的修改</span><br>- (<span class="hljs-type">void</span>)onUpdate:(<span class="hljs-built_in">NSNotification</span> *)notification&#123;<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++通知所在线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <br>    <span class="hljs-comment">// 区分通知中context是哪个，将其中的变化合并到别的context中</span><br>    <span class="hljs-built_in">NSManagedObjectContext</span> *context = notification.object;<br>    <span class="hljs-keyword">if</span> ([context isEqual:_mainContext]) &#123;<br>        [_backgroudnContext performBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++_backgroudnContext performBlock 所在线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>            [_backgroudnContext mergeChangesFromContextDidSaveNotification:notification];<br>        &#125;];<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([context isEqual:_backgroudnContext])&#123;<br>        [_mainContext performBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++_mainContext performBlock 所在线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>            [_mainContext mergeChangesFromContextDidSaveNotification:notification];<br>        &#125;];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不要在一个线程上创建MO再把它传给另一个线程，可通过MOC使用MO的<code>ID</code>查询对应的MO；或者监听<code>NSManagedObjectContextDidSaveNotification</code>通知，在回调里合并来自其他MOC的修改。</p>
<p>这种方案的问题在于，需要在不同的MOC间监听通知，手动同步来自其他MOC的修改，稍显麻烦。</p>
<h5 id="1-3-父MOC"><a href="#1-3-父MOC" class="headerlink" title="1.3.父MOC"></a>1.3.父MOC</h5><p>MOC都有对应的父存储，通过父存储可以返回代表托管对象的数据，也可以提交修改之后的托管对象。在 iOS5 之前，父存储只能是<code>persistent store coordinator</code>，而 iOS5 之后父存储可以是另一个MOC了。但无论如何，最终MOC的根源必须是一个<code>PSC</code>，通过<code>PSC</code>提供MOM并分发增删改查等请求到不同的持久化存储中。</p>
<p><code>父MOC</code>这种模式适用于在子线程处理耗时任务的场景。例如，将<code>主线程</code>对应的MOC设置为<code>子线程</code>MOC的父存储，那么在<code>子MOC</code>中保存对MO的修改时，这些修改会被推送到<code>父MOC</code>中，最终<code>子线程MOC</code>的 fetch 与 save 操作都会通过<code>主线程MOC</code>代为执行。与<code>同PSC</code>方案相比，此方案里某一个MOC的改动不需要用通知去告知其他MOC同步了，省事不少。</p>
<p>注意：保存对子MOC中数据的修改时，切记先在子MOC中执行 save，再在父MOC中执行 save。</p>
<p>示例2：子MOC使用 parent context</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_parent_child_moc.png" srcset="/img/loading.gif" lazyload alt="父子MOC"></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)initMulMocWithParentMoc<br>&#123;<br>    <span class="hljs-comment">// 主队列使用的MOC</span><br>    _mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _mainContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_mainContext];    <br><br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_backgroudnContext];    <br><br>    <span class="hljs-comment">// 在父MOC中增加一个实体</span><br>    Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.mainContext];<br>    c.id = <span class="hljs-number">1</span>;<br>    c.name =<span class="hljs-string">@&quot;A1&quot;</span>;<br>    [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br><br>    <span class="hljs-comment">// 在子MOC中执行perform</span><br>    [<span class="hljs-keyword">self</span>.backgroudnContext performBlock:^&#123;<br><br>        <span class="hljs-comment">// 在子MOC中增加一个实体</span><br>        Course *c2 = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.backgroudnContext];<br>        c2.id = <span class="hljs-number">2</span>;<br>        c2.name =<span class="hljs-string">@&quot;A2&quot;</span>;<br><br>        <span class="hljs-comment">// 先在子MOC中执行 save</span><br>        [<span class="hljs-keyword">self</span>.backgroudnContext save:<span class="hljs-literal">nil</span>];<br>        <br>        [<span class="hljs-keyword">self</span>.mainContext performBlock:^&#123;<br>            <span class="hljs-comment">// 再在父MOC中执行 save，否则backgroudnContext所做修改不会被持久化</span><br>            [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br>        &#125;];<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// 监听通知，将新创建的MO的临时ID转换成永久ID</span><br>- (<span class="hljs-type">void</span>)onContextWillSave:(<span class="hljs-built_in">NSNotification</span> *)notification&#123;<br>    <span class="hljs-built_in">NSManagedObjectContext</span> *moc = notification.object;<br>    <span class="hljs-built_in">NSSet</span> *insertMO = moc.insertedObjects;<br>    <span class="hljs-keyword">if</span> (insertMO.count) &#123;<br>        <span class="hljs-type">BOOL</span> succeed = [moc obtainPermanentIDsForObjects:insertMO.allObjects error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">if</span> (!succeed) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Error occured!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>必要时可以使用三MOC，其中：</p>
<ul>
<li><code>Private MOC</code>用于执行耗时操作；</li>
<li><code>Main MOC</code>用于与UI协作；</li>
<li><code>Root MOC</code>用于在后台保存所有子MOC提交的修改。</li>
</ul>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_3moc.png" srcset="/img/loading.gif" lazyload alt="三MOC方案"></p>
<p>示例3：使用三MOC</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)init3MocWithParentMoc<br>&#123;<br>    <span class="hljs-comment">// 根MOC，保存子MOC提交的修改</span><br>    _rootContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _rootContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_rootContext];<br>    <br>    <span class="hljs-comment">// 主队列使用的MOC</span><br>    _mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _mainContext.parentContext = _rootContext;<br>    <br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_backgroudnContext];<br><br>    <span class="hljs-comment">// 在子MOC中执行perform</span><br>    [<span class="hljs-keyword">self</span>.backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.在子MOC中增加一个实体</span><br>        Course *c2 = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.backgroudnContext];<br>        c2.id = <span class="hljs-number">2</span>;<br>        c2.name =<span class="hljs-string">@&quot;A2&quot;</span>;<br><br>        <span class="hljs-comment">// 2.先在子MOC中执行 save</span><br>        [<span class="hljs-keyword">self</span>.backgroudnContext save:<span class="hljs-literal">nil</span>];<br>        <br>        [<span class="hljs-keyword">self</span>.mainContext performBlock:^&#123;<br>            <span class="hljs-comment">// 3.再在父MOC中执行 save</span><br>            [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br>            <br>            [<span class="hljs-keyword">self</span>.rootContext performBlock:^&#123;<br>                <span class="hljs-comment">// 4.最后在rootMOC中执行 save，保存子MOC提交的修改</span><br>                [<span class="hljs-keyword">self</span>.rootContext save:<span class="hljs-literal">nil</span>];<br>            &#125;];<br>        &#125;];<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// 监听通知，将新创建的MO的临时ID转换成永久ID</span><br>- (<span class="hljs-type">void</span>)onContextWillSave:(<span class="hljs-built_in">NSNotification</span> *)notification&#123;<br>    <span class="hljs-built_in">NSManagedObjectContext</span> *moc = notification.object;<br>    <span class="hljs-built_in">NSSet</span> *insertMO = moc.insertedObjects;<br>    <span class="hljs-keyword">if</span> (insertMO.count) &#123;<br>        <span class="hljs-type">BOOL</span> succeed = [moc obtainPermanentIDsForObjects:insertMO.allObjects error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">if</span> (!succeed) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Error occured!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用多MOC时需要注意：MO在实例化时会被赋予一个临时ID，这个ID在当前MOC范围内是唯一的。但在提交对MOC的修改时，要将临时ID转换成全局ID，所以需要监听MOC即将保存的通知，以转换永久ID。</p>
<h5 id="1-4-通知"><a href="#1-4-通知" class="headerlink" title="1.4.通知"></a>1.4.通知</h5><p>MOC会在不同的时机发送不同的通知，注册通知时需要区分MOC，一是因为我们自己会定义不同的MOC，二是系统本身也会使用 Core Data 并发送通知。我们只关心从自己定义的特定MOC中收到的通知，所以在注册通知时需要做区分，可参考上面的👆🏻<code>示例1</code>。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">[[NSNotificationCenter defaultCenter] addObserver:self<br>                                      selector:@selector(&lt;#Selector name#&gt;)<br>                                      name:NSManagedObjectContextDidSaveNotification<br>                                      object:&lt;#A managed object context#&gt;];<br><br></code></pre></td></tr></table></figure>

<h4 id="2-批量操作"><a href="#2-批量操作" class="headerlink" title="2.批量操作"></a>2.批量操作</h4><h5 id="2-1-一般流程"><a href="#2-1-一般流程" class="headerlink" title="2.1.一般流程"></a>2.1.一般流程</h5><p>先来看一次普通查询或修改对象属性值操作的执行流程：</p>
<ol>
<li>执行查询时，MOC 将<code>fetchRequest</code>传递给 PSC；</li>
<li>PSC 将 fetch 请求转换成对应的<code>NSPersistentStoreRequest</code>，并执行自己的<code>excute</code>方法，将 fetch 与 MOC 发送给持久化存储(NSPersistentStore)；</li>
<li>持久化存储将<code>NSPersistentStoreRequest</code>转换成 SQL 语句，交给 SQLite 执行；</li>
<li>SQLite 将符合条件的数据返回给持久化存储，持久化存储将其保存在<code>行缓存</code>(row cache)中；</li>
<li>持久化存储将获取到的数据实例化成托管对象，交给PSC。此时 fetch.returnsObjectsAsFaults 的默认值为YES，所以这些对象暂时还是惰值形态(<code>Fault</code>)的，其属性值尚未填充，而是暂时被保存在了持久化存储的<code>行缓存</code>中；</li>
<li>PSC将这些<code>Fault</code>形态的托管对象以数组的形式返回给MOC；</li>
<li>访问或修改这些托管对象时，MOC会检查它们是否为<code>Fault</code>形态。如果是，则MOC 向 PSC 发起填充请求；</li>
<li>PSC 向持久化存储请求与当前对象关联的数据；</li>
<li>持久化存储在它的<code>行缓存</code>中查找并返回数据，交给MOC；</li>
<li>MOC将返回的数据填充到<code>Fault</code>形态的托管对象中，使其成为完全体的托管对象；</li>
<li>执行 save 时 MOC 发送<code>NSManagedObjectContextWillSaveNotification</code>通知；</li>
<li>创建一个持久化存储请求(NSSaveChangesRequest)，调用PSC的 excute 方法，将请求发送给持久化存储；</li>
<li>持久化存储对比请求中的数据与自己<code>行缓存</code>中的数据，检测是否有冲突并按照设置的合并策略处理冲突；</li>
<li>持久化存储将<code>NSSaveChangesRequest</code>转换成 SQL 语句交给 SQLite 执行更新；</li>
<li>持久化存储更新自己的<code>行缓存</code>；</li>
<li>MOC 发送<code>NSManagedObjectContextDidSaveNotification</code>通知；</li>
</ol>
<p>可以看到，整个过程所需的步骤还是挺多的~</p>
<h5 id="2-2-批量操作"><a href="#2-2-批量操作" class="headerlink" title="2.2.批量操作"></a>2.2.批量操作</h5><p>前面介绍的增、删、改，都是先从持久化存储中读取数据对象到内存中，再通过 MOC 逐一对这些对象执行增删改，最后执行 save 将数据再次保存到持久化存储中。在涉及到大批量数据的操作时，这种方式效率低、费内存，可能会遇到性能问题。为此，Core Data 提供了<code>批量操作</code>功能。</p>
<p><code>批量操作</code>是直接在持久化存储中操作 MO 对象，不需要先查询 MO 对象，效率高；不需查询 MO 也就无需将它们加载到内存中，节省了内存开销。这个功能需要用到<code>NSBatchxxxRequest</code>系列类，并且这些类只支持 SQLite 类型的持久化存储，因为它是在持久化存储的 SQL 层面直接操作这些对象。也正是因为发生在 SQL 层面，所以 MOC 不会自动合并这种操作，也不会发送相关通知，需要我们自己通过 MOC 的 merge 静态方法，同步增删改内存中对应的 MO 对象。为此，需要将批量操作的返回值设置成<code>NSManagedObjectID</code>，即被操作对象的ID，再用这些ID更新 MOC 即可。</p>
<p>需要注意的是，在执行批量操作时，最好是放到一个私有 MOC 中进行。</p>
<h5 id="2-3-批量修改"><a href="#2-3-批量修改" class="headerlink" title="2.3.批量修改"></a>2.3.批量修改</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)batchUpdate&#123;<br><br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.设置修改的实体</span><br>        <span class="hljs-built_in">NSBatchUpdateRequest</span> *request = [<span class="hljs-built_in">NSBatchUpdateRequest</span> batchUpdateRequestWithEntityName:<span class="hljs-string">@&quot;Course&quot;</span>];<br>        <span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id &gt; 0&quot;</span>];<br>        [request setPredicate:predicate];<br>        <span class="hljs-comment">// 2.设置修改的字段</span><br>        request.propertiesToUpdate = @&#123;<span class="hljs-string">@&quot;name&quot;</span>:<span class="hljs-string">@&quot;课程S&quot;</span>,<span class="hljs-string">@&quot;url&quot;</span>:<span class="hljs-string">@&quot;www.xxx.com&quot;</span>&#125;;<br>        request.resultType = <span class="hljs-built_in">NSUpdatedObjectIDsResultType</span>;<br>    <br>        <span class="hljs-comment">// 3.执行批量修改</span><br>        <span class="hljs-built_in">NSError</span> *error;<br>        <span class="hljs-built_in">NSBatchUpdateResult</span> *batchResult = [<span class="hljs-keyword">self</span>.viewContext executeRequest:request error:&amp;error];<br>        <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSManagedObjectID</span>*&gt; *updatedObjectIDs = batchResult.result;<br>    <br>        <span class="hljs-comment">// 同步数据的变化到MOC中 方式1（推荐）</span><br>        <span class="hljs-built_in">NSDictionary</span> *updatedDict = @&#123;<span class="hljs-built_in">NSUpdatedObjectsKey</span> : updatedObjectIDs&#125;;<br>        [<span class="hljs-built_in">NSManagedObjectContext</span> mergeChangesFromRemoteContextSave:updatedDict intoContexts:@[<span class="hljs-keyword">self</span>.viewContext]];<br>    <br>        <span class="hljs-comment">// 同步数据的变化到MOC中 方式2</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        [updatedObjectIDs enumerateObjectsUsingBlock:^(NSManagedObjectID *objID, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="hljs-comment">            NSManagedObject *obj = [self.viewContext objectWithID:objID];</span><br><span class="hljs-comment">            if (![obj isFault]) &#123;</span><br><span class="hljs-comment">                [self.viewContext refreshObject:obj mergeChanges:YES];</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;];*/</span><br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-4-批量删除"><a href="#2-4-批量删除" class="headerlink" title="2.4.批量删除"></a>2.4.批量删除</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)batchDelete&#123;<br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.创建fetch</span><br>        <span class="hljs-built_in">NSFetchRequest</span> *fetch = [Course fetchRequest];<br>        <span class="hljs-comment">// 2.设置过滤条件</span><br>        fetch.predicate = [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id &gt; 0&quot;</span>];<br><br>        <span class="hljs-comment">// 3.创建删除request</span><br>        <span class="hljs-built_in">NSBatchDeleteRequest</span> *delReqest = [[<span class="hljs-built_in">NSBatchDeleteRequest</span> alloc] initWithFetchRequest:fetch];<br>        delReqest.resultType = <span class="hljs-built_in">NSBatchDeleteResultTypeObjectIDs</span>;<br><br>        <span class="hljs-comment">// 4.开始批量删除</span><br>        <span class="hljs-built_in">NSError</span> *error;<br>        <span class="hljs-built_in">NSBatchDeleteResult</span> *deleteResult = [<span class="hljs-keyword">self</span>.viewContext executeRequest:delReqest error:&amp;error];<br>        <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSManagedObjectID</span>*&gt; *deletedObjectIDs = deleteResult.result;<br><br>        <span class="hljs-comment">// 5.同步更新到MOC</span><br>        <span class="hljs-built_in">NSDictionary</span> *deletedDict = @&#123;<span class="hljs-built_in">NSDeletedObjectsKey</span> : deletedObjectIDs&#125;;<br>        [<span class="hljs-built_in">NSManagedObjectContext</span> mergeChangesFromRemoteContextSave:deletedDict intoContexts:@[<span class="hljs-keyword">self</span>.viewContext]];<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-5-批量插入"><a href="#2-5-批量插入" class="headerlink" title="2.5.批量插入"></a>2.5.批量插入</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)batchInser&#123;<br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.创建由实体Map组成的数组</span><br>        <span class="hljs-built_in">NSArray</span> *sectionsArr = @[@&#123;<span class="hljs-string">@&quot;name&quot;</span>:@(<span class="hljs-number">001</span>),<span class="hljs-string">@&quot;id&quot;</span>:@(<span class="hljs-number">1</span>),<span class="hljs-string">@&quot;descript&quot;</span>:<span class="hljs-string">@&quot;Section 1&quot;</span>&#125;,<br>                                 @&#123;<span class="hljs-string">@&quot;name&quot;</span>:@(<span class="hljs-number">002</span>),<span class="hljs-string">@&quot;id&quot;</span>:@(<span class="hljs-number">2</span>),<span class="hljs-string">@&quot;descript&quot;</span>:<span class="hljs-string">@&quot;Section 2&quot;</span>&#125;,<br>                                 @&#123;<span class="hljs-string">@&quot;name&quot;</span>:@(<span class="hljs-number">003</span>),<span class="hljs-string">@&quot;id&quot;</span>:@(<span class="hljs-number">3</span>),<span class="hljs-string">@&quot;descript&quot;</span>:<span class="hljs-string">@&quot;Section 3&quot;</span>&#125;];<br>        <span class="hljs-comment">// 2.创建插入请求</span><br>        <span class="hljs-built_in">NSBatchInsertRequest</span> *request = [[<span class="hljs-built_in">NSBatchInsertRequest</span> alloc] initWithEntityName:<span class="hljs-string">@&quot;Section&quot;</span> objects:sectionsArr];<br>        request.resultType = <span class="hljs-built_in">NSUpdatedObjectIDsResultType</span>;<br>    <br>        <span class="hljs-comment">// 3.执行批量插入</span><br>        <span class="hljs-built_in">NSError</span> *error;<br>        <span class="hljs-built_in">NSBatchInsertResult</span> *batchResult = [<span class="hljs-keyword">self</span>.viewContext executeRequest:request error:&amp;error];<br>        <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSManagedObjectID</span>*&gt; *insertedObjectIDs = batchResult.result;<br>    <br>        <span class="hljs-comment">// 4.同步数据的变化到MOC中</span><br>        <span class="hljs-built_in">NSDictionary</span> *updatedDict = @&#123;<span class="hljs-built_in">NSInsertedObjectsKey</span> : insertedObjectIDs&#125;;<br>        [<span class="hljs-built_in">NSManagedObjectContext</span> mergeChangesFromRemoteContextSave:updatedDict intoContexts:@[<span class="hljs-keyword">self</span>.viewContext]];<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要指出的是，虽然批量操作比普通增删改操作的效率高很多，但它的代价是放弃了很多细节的处理，比如批量操作不支持校验、不会发送通知、无法处理 Entity 间的关系等。</p>
<h4 id="3-减少内存消耗"><a href="#3-减少内存消耗" class="headerlink" title="3.减少内存消耗"></a>3.减少内存消耗</h4><h5 id="3-1-分页查询"><a href="#3-1-分页查询" class="headerlink" title="3.1.分页查询"></a>3.1.分页查询</h5><p>查询时最好是限制总量和每页的数量，防止所有结果一次性加载到内存中；</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 总共查询的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchLimit;<br><span class="hljs-comment">// 每次查询返回的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchBatchSize;<br><span class="hljs-comment">// 分页查询的下标，从哪条开始查</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchOffset;<br><span class="hljs-comment">// 返回Fault对象，其属性值在行缓存中，默认值YES</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">BOOL</span> returnsObjectsAsFaults;<br></code></pre></td></tr></table></figure>

<p>案例演示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)loadDataAtPage:(<span class="hljs-built_in">NSUInteger</span>)page&#123;<br>    <span class="hljs-comment">// 1.设置请求</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br><br>    <span class="hljs-comment">// 2.排序</span><br>    <span class="hljs-built_in">NSSortDescriptor</span> *descriptor = [<span class="hljs-built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="hljs-string">@&quot;id&quot;</span> ascending:<span class="hljs-literal">YES</span>];<br>    request.sortDescriptors = @[descriptor];<br>    <br>    <span class="hljs-comment">// 3.分页</span><br>    request.fetchOffset = (page - <span class="hljs-number">1</span>) * kLimiteSize;<br>    request.fetchLimit = kLimiteSize;<br>    <br>    <span class="hljs-comment">// 4.查询</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="3-2-fault对象"><a href="#3-2-fault对象" class="headerlink" title="3.2.fault对象"></a>3.2.fault对象</h5><ul>
<li>返回fault</li>
</ul>
<p>查询后不会立刻访问其属性值时，可设置 fetch 请求返回<code>fault</code>对象，以节省内存；</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)faultMO&#123;<br>    <span class="hljs-comment">// 1.设置请求</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br>    request.returnsObjectsAsFaults = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-comment">// 2.查询</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>重置成fault</li>
</ul>
<p>不再需要的托管对象，让 MOC 调用下面的方法，清除对象的属性值，将其还原成<code>fault</code>状态。</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>refreshObject:<span class="hljs-params">(NSManagedObject *)</span>object <br>         mergeChanges:<span class="hljs-params">(BOOL)</span>flag;<br></code></pre></td></tr></table></figure>

<p>其中<code>flag</code>参数为NO时，MOC会丢弃未保存的修改，当前托管对象变成<code>fault</code>对象；</p>
<p>当<code>flag</code>为YES时，MOC会从持久化存储或缓存中重新加载MO的属性值，再更新成本地修改的值。</p>
<h5 id="3-3-重置所有MO"><a href="#3-3-重置所有MO" class="headerlink" title="3.3.重置所有MO"></a>3.3.重置所有MO</h5><p>调用MOC的<code>reset</code>方法，可以将MOC中所有的MO都清除。此时原来跟MOC关联的MO都会失效，你需要重置它们的引用，并重新执行 fetch。</p>
<h5 id="3-4-遍历与销毁MO"><a href="#3-4-遍历与销毁MO" class="headerlink" title="3.4.遍历与销毁MO"></a>3.4.遍历与销毁MO</h5><p>当遍历大量托管对象时，需要使用<code>autorelease pool</code>来确保临时MO尽快销毁。</p>
<h5 id="3-5-不查询属性值"><a href="#3-5-不查询属性值" class="headerlink" title="3.5.不查询属性值"></a>3.5.不查询属性值</h5><p>执行 Fetch 时，Core Data 默认会查询对象的ID和属性值，填充行缓存，用ID创建<code>fault</code>对象并返回。如果你确定只想查询托管对象，而不会访问其属性，可设置<code>fetch.includesPropertyValues = NO</code>，此时 Core Data 只会查询对象的 ID 并返回<code>fault</code>对象，而不会查询属性值，也不会填充行缓存，这样就又省去了一部分内存开销。</p>
<p>当然，如果<code>includesPropertyValues=NO</code>而你又访问了<code>fault</code>对象的属性，那么 Core Data 在空的行缓存中查询不到数据，就会去持久化存储中重新查询并填充到<code>fault</code>对象中。</p>
<p>如果<code>includesPropertyValues=YES</code>而<code>resultType</code>是<code>managedObjectIDResultType</code>类型，那么还是会查询属性，这会造成不必要的性能开销。因为返回值是 ID 类型，没有属性字段，这些被查询出来的属性根本就没有机会被展示到应用里。</p>
<h4 id="4-BLOBs-二进制大文件"><a href="#4-BLOBs-二进制大文件" class="headerlink" title="4.BLOBs-二进制大文件"></a>4.BLOBs-二进制大文件</h4><p>Binary Large Data Objects，指二进制大数据对象，例如图片、音频等。使用Core Data 保存这种对象时，需要选择 SQLite 作为持久化存储。因为其他存储要求将整个对象都加载到内存中，并且写入存储是原子性的，这会导致它们处理 BLOBs 的效率相对不高。</p>
<p>BLOB 通常是 Entity 的属性，例如<code>员工</code>实体的<code>头像</code>属性。可以为 BLOB 创建一个单独的<code>照片</code>实体，在它与<code>员工</code>实体间设置<code>1对1</code>的<code>关系</code>，以替代原<code>员工</code>实体中的<code>头像</code>属性。这样做可以充分利用<code>Fault</code>对象节省内存的特点，查询员工的照片<code>关系</code>字段时，Core Data 暂时不会将关系属性值(即二进制的照片数据)加载到内存中，只有真正访问或修改此属性时，才填充到<code>fault</code>对象中。</p>
<p>更好的做法是将 BLOBs 保存到文件系统里，将其 URL 或路径保存在数据库中，需要用到时再通过 URL 或路径加载此文件。</p>
<h3 id="十一-合并冲突"><a href="#十一-合并冲突" class="headerlink" title="十一.合并冲突"></a>十一.合并冲突</h3><p>应用中一般会存在多个MOC，它们使用同一份持久化存储，执行不同任务以便优化性能。每个 MOC 都能独立执行 save 保存对托管对象的修改，其他 MOC 需要合并这些修改，以保证各处托管对象状态的一致性。当 MOC 合并对托管对象的修改时，如果另一个 MOC 也修改了同一个属性并且值不相同，就产生了冲突。这时就需要根据 MOC 的合并策略属性来处理冲突：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">@<span class="hljs-keyword">property</span> (strong) <span class="hljs-built_in">id</span> mergePolicy;<br></code></pre></td></tr></table></figure>
<p>以下是各个策略及其对应的处理：</p>
<table>
<thead>
<tr>
<th align="left"><center>合并策略</center></th>
<th align="left"><center>说明</center></th>
</tr>
</thead>
<tbody><tr>
<td align="left">NSErrorMergePolicy</td>
<td align="left">默认的合并策略，产生冲突时返回错误；</td>
</tr>
<tr>
<td align="left">NSMergeByPropertyStoreTrumpMergePolicy</td>
<td align="left">只合并产生冲突的属性，用外部修改覆盖当前修改，其他未产生冲突的属性保持不变；</td>
</tr>
<tr>
<td align="left">NSMergeByPropertyObjectTrumpMergePolicy</td>
<td align="left">只合并产生冲突的属性，用当前修改覆盖外部修改，其他未产生冲突的属性保持不变；</td>
</tr>
<tr>
<td align="left">NSOverwriteMergePolicy</td>
<td align="left">将当前MOC的托管对象写入持久化存储；</td>
</tr>
<tr>
<td align="left">NSRollbackMergePolicy</td>
<td align="left">丢弃冲突中所有的修改，保持持久化存储中的版本不变；</td>
</tr>
</tbody></table>
<h3 id="十二-数据迁移"><a href="#十二-数据迁移" class="headerlink" title="十二.数据迁移"></a>十二.数据迁移</h3><p><code>MOM</code>用来描述持久化存储中数据的结构，Core Data 中只能使用 MOM 打开持久化存储，改变 MOM 中的任何一部分都会导致它与之前版本的存储产生冲突。例如在<code>.xcdatamodel</code>中增加新实体，修改实体的名字，增删属性等，那么老版本的持久化存储就不能使用了。需要通过<code>数据迁移</code>，将老版本存储中的数据迁移到新版本中。为了让 Core Data 知道如何迁移数据，有时我们需要主动提供一些信息，例如，创建一个<code>mapping model</code>映射文件。对于简单的变化，可以使用轻量级迁移功能。</p>
<p>使用轻量级迁移功能时，Core Data 会根据前后<code>MOM</code>的不同，自动推断出一个<code>mapping model</code>，无需我们自己创建。轻量级迁移在我们项目的初期可能会非常有用，因为这一时期我们可能会经常性的改动模型文件，而又不希望频繁重新生成测试数据。当然，这些<code>小的</code>改动只能是以下这些操作：</p>
<ul>
<li>增、删、重命名属性；</li>
<li>给属性设置默认值；</li>
<li>不可选属性变可选；</li>
<li>可选属性变不可选并设置默认值；</li>
<li>增、删、重命关系；</li>
<li>修改关系成对1或对多、排序或不排序；</li>
<li>增、删、重命名实体；</li>
<li>创建新的父实体或子实体；</li>
<li>在实体继承树上将属性移到别的实体中；</li>
<li>将实体移出继承树；</li>
</ul>
<h4 id="1-建新model"><a href="#1-建新model" class="headerlink" title="1.建新model"></a>1.建新model</h4><p>做数据迁移时既需要新版本model文件，也需要新版本model文件，新版model文件设置方法如下：</p>
<ul>
<li>Xcode 中选中<code>.xcdatamodeld</code>文件；</li>
<li><code>Editor</code> -&gt; <code>add model version</code>；</li>
<li>设置新版本文件名和它基于哪个版本；</li>
<li>创建新模型文件；</li>
<li>设置新<code>xcdatamodel</code>作为当前版本；</li>
</ul>
<p>这样，就可以在新版本的模型文件中修改 Entity 了。</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_entity.jpeg" srcset="/img/loading.gif" lazyload alt="新建Model 2.xcdatamodel文件"></p>
<h4 id="2-修改Entity"><a href="#2-修改Entity" class="headerlink" title="2.修改Entity"></a>2.修改Entity</h4><p>重命名属性时，需要在设置面板中将目标版本属性的<code>Renaming ID</code>字段设置成原属性的名字。例如可以在版本2中将属性<code>name</code>重命名成<code>name2</code>，设置<code>name2</code>的<code>Renaming ID</code>为<code>name</code>；然后在版本3中可以继续将<code>name</code>重命名成<code>name3</code>，同样将<code>name3</code>的<code>Renaming ID</code>设置为<code>name</code>。这样 Core Data 就能从版本1推断出到版本2，或者从版本1到版本3的<code>mapping model</code>，以此完成数据迁移。</p>
<p>重命名实体或关系时，也是同样的步骤，设置目标实体&#x2F;关系的<code>Renaming ID</code>字段。</p>
<h4 id="3-设置options"><a href="#3-设置options" class="headerlink" title="3.设置options"></a>3.设置options</h4><p>修改实体后，还要在添加持久化存储时将<code>options</code>字典中自动迁移和自动推断的值设置为<code>YES</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (<span class="hljs-type">NSPersistentStoreCoordinator</span> <span class="hljs-operator">*</span>)persistentStoreCoordinator &#123;<br>    <span class="hljs-keyword">if</span> (_persistentStoreCoordinator <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>    &#125;<br>    _persistentStoreCoordinator <span class="hljs-operator">=</span> [[<span class="hljs-type">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="hljs-keyword">self</span> managedObjectModel]];<br>    <span class="hljs-type">NSURL</span> <span class="hljs-operator">*</span>storeURL <span class="hljs-operator">=</span> [[<span class="hljs-keyword">self</span> applicationDocumentsDirectory] <span class="hljs-type">URLByAppendingPathComponent</span>:@<span class="hljs-string">&quot;ASDF.sqlite&quot;</span>];<br>    <span class="hljs-type">NSError</span> <span class="hljs-operator">*</span>error <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 数据库做轻量迁移时 传入此options字典</span><br>    <span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span>options <span class="hljs-operator">=</span> @&#123;<span class="hljs-type">NSMigratePersistentStoresAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>, <br>                              <span class="hljs-type">NSInferMappingModelAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>&#125;;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>[_persistentStoreCoordinator addPersistentStoreWithType:<span class="hljs-type">NSSQLiteStoreType</span> <br>                                                   configuration:<span class="hljs-literal">nil</span> <br>                                                             URL:storeURL <br>                                                         options:options error:<span class="hljs-operator">&amp;</span>error]) &#123; &#125;<br>    <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，轻量级迁移就完成了，用户升级版本后启动时就不会因数据版本问题闪退了。</p>
<hr>
<p>相关参考：</p>
<p>#<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/FaultingandUniquing.html#//apple_ref/doc/uid/TP40001075-CH18-SW1">©Fault</a><br>#<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/Performance.html#//apple_ref/doc/uid/TP40001075-CH25-SW1">©性能</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OC/" class="category-chain-item">OC</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE/">#数据</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>数据库：Core Data</div>
      <div>https://davidlii.cn/2017/12/05/coredata.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Davidli</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年12月5日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/12/11/idfa.html" title="设备唯一标识符">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">设备唯一标识符</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/12/02/sandbox.html" title="沙盒 &amp; 本地持久化方案">
                        <span class="hidden-mobile">沙盒 &amp; 本地持久化方案</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/davidli-" target="_blank" rel="nofollow noopener"><span>嵇风</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
