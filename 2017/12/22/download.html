<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"/> 
  
  <title>
    
      iOS 文件下载 | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">

  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  
<script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>

  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


<meta name="generator" content="Hexo 6.2.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Davidli</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">关于</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Davidli</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">关于</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>iOS 文件下载</h2>
  <p class="post-date">2017-12-22</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>iOS 中实现文件下载有以下几种方式：</p>
<h3 id="一-NSData"><a href="#一-NSData" class="headerlink" title="一.NSData"></a>一.NSData</h3><p>NSData 提供了类方法实现文件下载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL  *aUrl = [NSURL URLWithString:@&quot;https://example.jpg&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfURL:aUrl];</span><br><span class="line">UIImage *image = [UIImage imageWithData:data];</span><br></pre></td></tr></table></figure>
<p>使用这种方式会一次性返回整个下载到的文件，且在当前线程中同步下载文件。所以，在主线程中下载时，遇到网络状况不佳的情况时，会出现卡顿的现象。</p>
<p>&amp;emsp;解决方案之一：把下载任务放到异步线程中进行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t downloadQueue = dispatch_queue_create(</span><br><span class="line">&quot;downloadQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(downloadQueue, ^&#123;</span><br><span class="line">    NSURL *aUrl = [NSURL URLWithString:@&quot;https://example.jpg&quot;];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:aUrl];</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此方法虽然解决了卡顿的问题，但还有另外的问题：返回的 data 是在内存中的。当目标文件过大时，内存会爆掉。所以，我们希望有这样一种方案：</p>
<ol>
<li>文件数据能分批返回。</li>
<li>解决保存返回的数据时内存占用过大的情况。</li>
</ol>
<p>对于第1点，我们可以使用系统提供的 NSURLConnection、NSURLSession 类来解决。它们都可以通过代理来不断接收返回的数据。</p>
<p>对于第2点，我们可以把接收到的数据保存到沙盒里。待全部数据接收并处理完成后，删除此沙盒文件即可。</p>
<h3 id="二-NSURLConnection"><a href="#二-NSURLConnection" class="headerlink" title="二.NSURLConnection"></a>二.NSURLConnection</h3><p>通过 <strong>NSURLConnection</strong> 可以实现创建连接、自动发送请求、通过代理接收服务器返回的数据。同时，可以实现暂停和断点续传功能。</p>
<h4 id="2-1-下载功能"><a href="#2-1-下载功能" class="headerlink" title="2.1.下载功能"></a>2.1.下载功能</h4><ol>
<li>创建一个 NSURL 对象，设置请求地址；</li>
<li>创建一个 NSURLRequest 对象，设置请求头和请求体；</li>
<li>使用 NSURLConnection 发送请求；</li>
<li>通过代理方法接收服务器的响应和数据，写入沙盒中；</li>
</ol>
<h4 id="2-2-暂停功能"><a href="#2-2-暂停功能" class="headerlink" title="2.2.暂停功能"></a>2.2.暂停功能</h4><p>NSURLConnection 本身并没有暂停的相关函数，但我们可以使用它提供的 <code>cancel</code> 方法来实现暂停功能。</p>
<h4 id="2-3-断点续传功能"><a href="#2-3-断点续传功能" class="headerlink" title="2.3.断点续传功能"></a>2.3.断点续传功能</h4><p>要实现断点续传，可借助 HTTP 请求头的 <code>range</code> 字段。它可以指定每次从网络上下载的数据包的大小。<code>range</code> 字段的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes = 0-100，             从0到100的100个字节。</span><br><span class="line">bytes = 200-,               从200字节以后的所有字节。</span><br><span class="line">bytes = - 500,              最后500个字节。</span><br><span class="line">bytes = 200-300，500-800，  同时指定几个范围。</span><br></pre></td></tr></table></figure>

<p>每次暂停时，在 <code>connection:didReceiveData:</code> 回调中记录已经接收到的数据大小，在恢复下载时，把此大小对应的 <code>range</code> 字段设置到请求头中，重新创建连接并发送请求即可。</p>
<p>具体可参考以下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//DataTaskTool.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@class DataTaskTool;</span><br><span class="line"></span><br><span class="line">@protocol DataTaskToolDelegate</span><br><span class="line"></span><br><span class="line">- (void)dataTaskTool:(DataTaskTool*)tool </span><br><span class="line">onDownloadProgress:(double)progress;</span><br><span class="line"></span><br><span class="line">- (void)dataTaskTool:(DataTaskTool*)tool </span><br><span class="line">onDownloadFinishedWithInfo:(id)info;</span><br><span class="line"></span><br><span class="line">- (void)dataTaskTool:(DataTaskTool*)tool </span><br><span class="line">onDownloadFailedWithError:(NSError*)error;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface DataTaskTool : NSObject</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithURL:(NSString*)URL </span><br><span class="line">delegate:(id&lt;DataTaskToolDelegate&gt;)delegate;</span><br><span class="line"></span><br><span class="line">- (void)start;</span><br><span class="line">- (void)pause;</span><br><span class="line">- (void)resume;</span><br><span class="line">- (void)cancel;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">//DataTaskTool.m</span><br><span class="line"></span><br><span class="line">#import &quot;DataTaskTool.h&quot;</span><br><span class="line"></span><br><span class="line">@interface DataTaskTool ()</span><br><span class="line">&lt;</span><br><span class="line">NSURLConnectionDataDelegate</span><br><span class="line">&gt;</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableURLRequest *mRequest; //请求对象</span><br><span class="line">    NSURLConnection *mUrlConnection; //连接对象</span><br><span class="line">    NSFileHandle *mFileHandle; //文件管理</span><br><span class="line">    NSString *mFilePath; //沙盒文件路径</span><br><span class="line">    unsigned long long mTotalContentLength; //文件总长度</span><br><span class="line">    unsigned long long mCurrentContentLength; //当前接收到的数据总长度</span><br><span class="line">    double mProgressValue; //当前下载进度值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id &lt;DataTaskToolDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation DataTaskTool</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithURL:(NSString*)URL </span><br><span class="line">delegate:(id&lt;DataTaskToolDelegate&gt;)delegate</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init])</span><br><span class="line">    &#123;</span><br><span class="line">        if (0 == URL.length) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        _delegate = delegate;</span><br><span class="line">        </span><br><span class="line">        //设置请求</span><br><span class="line">        mRequest = [[NSMutableURLRequest alloc] </span><br><span class="line">        initWithURL:[NSURL URLWithString:URL]];</span><br><span class="line">        </span><br><span class="line">        mRequest.HTTPMethod = @&quot;GET&quot;;</span><br><span class="line">        mRequest.timeoutInterval = 60;</span><br><span class="line">        </span><br><span class="line">        //创建连接对象</span><br><span class="line">        mUrlConnection = [[NSURLConnection alloc] </span><br><span class="line">        initWithRequest:mRequest </span><br><span class="line">        delegate:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -NSURLConnectionDataDelegate</span><br><span class="line">//接收到服务器的响应</span><br><span class="line">-(void)connection:(NSURLConnection *)connection </span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line">&#123;</span><br><span class="line">    mTotalContentLength = response.expectedContentLength;</span><br><span class="line">    </span><br><span class="line">    //设置文件路径</span><br><span class="line">    NSString *fileName = response.suggestedFilename;</span><br><span class="line">    NSString* caches = [NSSearchPathForDirectoriesInDomains(</span><br><span class="line">    NSCachesDirectory, NSUserDomainMask, YES) </span><br><span class="line">    lastObject];</span><br><span class="line">    </span><br><span class="line">    mFilePath = [caches stringByAppendingPathComponent:fileName];</span><br><span class="line">    </span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:mFilePath])</span><br><span class="line">    &#123;</span><br><span class="line">        [[NSFileManager defaultManager] </span><br><span class="line">        createFileAtPath:mFilePath </span><br><span class="line">        contents:nil attributes:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mFileHandle = [NSFileHandle fileHandleForWritingAtPath:mFilePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收到服务器返回的数据（此方法可能会回调多次）</span><br><span class="line">-(void)connection:(NSURLConnection *)connection </span><br><span class="line">didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    //移动到文件的结尾</span><br><span class="line">    [mFileHandle seekToEndOfFile];</span><br><span class="line">    //新数据追加到文件中</span><br><span class="line">    [mFileHandle writeData:data];</span><br><span class="line">    </span><br><span class="line">    //计算当前下载进度</span><br><span class="line">    mCurrentContentLength += data.length;</span><br><span class="line">    mProgressValue = (double)mCurrentContentLength / mTotalContentLength;</span><br><span class="line">    </span><br><span class="line">    //回调进度</span><br><span class="line">    [_delegate dataTaskTool:self onDownloadProgress:mProgressValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下载完成</span><br><span class="line">-(void)connectionDidFinishLoading:(NSURLConnection *)connection</span><br><span class="line">&#123;</span><br><span class="line">    //结束写入</span><br><span class="line">    [mFileHandle closeFile];</span><br><span class="line">    NSError *error = [NSError new];</span><br><span class="line">    [[NSFileManager defaultManager] removeItemAtPath:mFilePath error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    //完成回调</span><br><span class="line">    [_delegate dataTaskTool:self onDownloadFinishedWithInfo:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)connection:(NSURLConnection *)connection </span><br><span class="line">didFailWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    [_delegate dataTaskTool:self onDownloadFailedWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -BUSINESS API</span><br><span class="line">//开始请求</span><br><span class="line">- (void)start</span><br><span class="line">&#123;</span><br><span class="line">    [mUrlConnection start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//暂停</span><br><span class="line">- (void)pause</span><br><span class="line">&#123;</span><br><span class="line">    [mUrlConnection cancel];</span><br><span class="line">    mUrlConnection = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//恢复</span><br><span class="line">- (void)resume</span><br><span class="line">&#123;</span><br><span class="line">    //设置断点下载的区间</span><br><span class="line">    NSString *range = [NSString stringWithFormat:</span><br><span class="line">    @&quot;bytes=%lld-&quot;, mCurrentContentLength];</span><br><span class="line">    </span><br><span class="line">    [mRequest setValue:range forHTTPHeaderField:@&quot;Range&quot;];</span><br><span class="line">    </span><br><span class="line">    mUrlConnection = [[NSURLConnection alloc] </span><br><span class="line">    initWithRequest:mRequest delegate:self];</span><br><span class="line">    </span><br><span class="line">    [mUrlConnection start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取消请求</span><br><span class="line">- (void)cancel</span><br><span class="line">&#123;</span><br><span class="line">    [mUrlConnection cancel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>调用示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*Windows10下载地址</span><br><span class="line">URL: https://software-download.microsoft.com/</span><br><span class="line">db/Win10_1709_Chinese(Simplified)_x32.iso?</span><br><span class="line">t=e56bdb47-6973-4da2-9e94-5a6a458c9192&amp;e</span><br><span class="line">=1513964531&amp;h=d9ba28ed1645810206cd89e7c4675a5b</span><br><span class="line">*/</span><br><span class="line">DataTaskTool *tool = [[DataTaskTool alloc] </span><br><span class="line">initWithURL:url delegate:self];</span><br><span class="line"></span><br><span class="line">[tool start];</span><br></pre></td></tr></table></figure>

<p>需要注意的是，iOS9之后，NSURLConnection 已被废弃，苹果转而推荐使用 NSURLSession。</p>
<h3 id="三-NSURLSession"><a href="#三-NSURLSession" class="headerlink" title="三.NSURLSession"></a>三.NSURLSession</h3><p>NSURLSession 是苹果在 iOS7 后为数据传输提供的一系列接口，它比 NSURLConnection 更强大。</p>
<ul>
<li>任务都是异步进行的，没有同步执行的单独接口；</li>
<li>支持后台数据上传和下载；</li>
<li>有单独接口支持断点续传；</li>
<li>数据下载会保存到缓存目录，解决了下载时的内存问题；</li>
<li>任务创建后不会自动发送请求，需要手动开始执行任务；</li>
</ul>
<h4 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1.配置"></a>3.1.配置</h4><p>NSURLSessionConfiguration，这是一个定义URLSession的行为和策略的配置，是实例化URLSession对象的必备参数；一旦配置完成则当前会话会使用该配置的一个备份，并忽略你对原配置对象的任何修改；如果想修改配置信息，你需要更新对应的字段并且用更新后的配置创建一个新的URLSession对象。</p>
<p>&amp;emsp;</p>
<p>1、会话配置分类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration;</span><br><span class="line">@property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration;</span><br><span class="line">+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>defaultSessionConfiguration</strong></li>
</ul>
<p>默认的会话配置，它会使用硬盘空间做缓存；用钥匙串保存用户的授权信息；会将cookie保存到<code>shared cookie store</code>中。</p>
<ul>
<li><strong>ephemeralSessionConfiguration</strong></li>
</ul>
<p>临时会话配置，不做硬盘缓存，而是保存到内存RAM中；不保存用户的cookie和证书；invalidate后所有配置信息会被抹去。</p>
<ul>
<li><strong>backgroundSessionConfiguration</strong></li>
</ul>
<p>后台会话配置，需要指定一个标识符。它允许在后台执行数据的上传或下载任务，使用这个配置时session会将数据的传输控制权交给系统，系统会在一个单独的进程中处理这个任务，即使应用被挂起甚至被杀掉时，仍能继续数据的上传或下载。注意这里的被杀掉是指被系统杀掉，如果是用户通过多任务界面主动杀掉了应用，则系统会自动清空当前session的所有后台传输任务，任务会暂停。用户需要主动重启应用，之前的任务才能继续。如果应用是被系统杀掉并重启的，那么应用内可以使用与之前后台会话配置中相同的<code>identifier</code>标识符重新创建配置和URLSession对象，此session对象可以返回后台任务被杀掉时所处的状态。关于后台任务的具体实现，后面章节中会详细介绍~<br>&amp;emsp;</p>
<p>2、可配置属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* identifier for the background session configuration */</span><br><span class="line">@property (nullable, readonly, copy) NSString *identifier; // 后台任务的标识符</span><br><span class="line"></span><br><span class="line">/* default cache policy for requests */</span><br><span class="line">@property NSURLRequestCachePolicy requestCachePolicy; // 请求的缓存策略</span><br><span class="line"></span><br><span class="line">/* default timeout for requests.  This will cause a timeout if no data is transmitted </span><br><span class="line"> *for the given timeout value, and is reset whenever data is transmitted. */</span><br><span class="line">@property NSTimeInterval timeoutIntervalForRequest; // 超时时长</span><br><span class="line"></span><br><span class="line">/* allow request to route over cellular. */</span><br><span class="line">@property BOOL allowsCellularAccess; // 是否允许蜂窝网路</span><br><span class="line"></span><br><span class="line">/* allows background tasks to be scheduled at the discretion of the system for optimal performance. */</span><br><span class="line">// 数据量大时，让系统自主优化后台任务（比如连上WiFi再开始传输）</span><br><span class="line">@property (getter=isDiscretionary) BOOL discretionary; </span><br><span class="line"></span><br><span class="line">/* The maximum number of simultanous persistent connections per host */</span><br><span class="line">@property NSInteger HTTPMaximumConnectionsPerHost; // 单个主机允许的最大同时并发连接数</span><br><span class="line"></span><br><span class="line">/* The cookie storage object to use, or nil to indicate that no cookies should be handled */</span><br><span class="line">@property (nullable, retain) NSHTTPCookieStorage *HTTPCookieStorage;</span><br><span class="line"></span><br><span class="line">/* The credential storage object, or nil to indicate that no credential storage is to be used */</span><br><span class="line">@property (nullable, retain) NSURLCredentialStorage *URLCredentialStorage;</span><br><span class="line"></span><br><span class="line">/* The URL resource cache, or nil to indicate that no caching is to be performed */</span><br><span class="line">@property (nullable, retain) NSURLCache *URLCache;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-创建会话"><a href="#3-2-创建会话" class="headerlink" title="3.2.创建会话"></a>3.2.创建会话</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;</span><br><span class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration </span><br><span class="line">                                  delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate </span><br><span class="line">                             delegateQueue:(nullable NSOperationQueue *)queue;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数1</strong>：configuration</li>
</ul>
<p>配置信息，包括cookie、缓存策略、代理、超时、证书配置等；</p>
<ul>
<li><strong>参数2</strong>：delegate</li>
</ul>
<p>会话的代理对象，处理鉴权、缓存策略等事宜，在AFN中是AFURLSessionManager类；</p>
<blockquote>
<p>The session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session by calling the invalidateAndCancel or finishTasksAndInvalidate method, your app leaks memory until it exits.</p>
</blockquote>
<p>注意：session会强引用 delegate 对象直到通过<code>invalidateAndCancel</code>或<code>finishTasksAndInvalidate</code>将session置为无效，如果不将session作废就会造成内存泄露。</p>
<ul>
<li><strong>参数3</strong>：queue</li>
</ul>
<p>代理所处的队列，可以是主队列或我们创建的私有队列。</p>
<blockquote>
<p>An operation queue for scheduling the delegate calls and completion handlers. The queue should be a serial queue, in order to ensure the correct ordering of callbacks. If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.</p>
</blockquote>
<p>注意：queue参数必须是串行队列，这是为了保证回调的顺序。如果为nil则session会自动创建一个串行队列执行代理。</p>
<h4 id="3-3-创建任务"><a href="#3-3-创建任务" class="headerlink" title="3.3.创建任务"></a>3.3.创建任务</h4><p>URLSession提供了数据下载和上传相关的API，通过不同接口可以创建不同类型的任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 普通任务，返回的数据保存在内存中，不支持后台任务</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;</span><br><span class="line"></span><br><span class="line">// 上传任务，支持后台上传</span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;</span><br><span class="line"></span><br><span class="line">// 下载任务，保存到本地文件中，支持后台下载</span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;</span><br><span class="line"></span><br><span class="line">// 数据流任务，从指定的服务器和端口建立一个 TCP/IP 连接</span><br><span class="line">- (NSURLSessionStreamTask *)streamTaskWithHostName:(NSString *)hostname port:(NSInteger)port;</span><br></pre></td></tr></table></figure>

<p>每个NSURLSession对象可以包含多个任务，类似于浏览器中多个窗口可以分别处理网页浏览和数据下载等任务。</p>
<h4 id="3-4-会话作废"><a href="#3-4-会话作废" class="headerlink" title="3.4.会话作废"></a>3.4.会话作废</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* -finishTasksAndInvalidate returns immediately and existing tasks will be allowed</span><br><span class="line"> * to run to completion.  New tasks may not be created.  The session</span><br><span class="line"> * will continue to make delegate callbacks until URLSession:didBecomeInvalidWithError:</span><br><span class="line"> * has been issued. </span><br><span class="line"> *</span><br><span class="line"> * -finishTasksAndInvalidate and -invalidateAndCancel do not</span><br><span class="line"> * have any effect on the shared session singleton.</span><br><span class="line"> *</span><br><span class="line"> * When invalidating a background session, it is not safe to create another background</span><br><span class="line"> * session with the same identifier until URLSession:didBecomeInvalidWithError: has</span><br><span class="line"> * been issued.</span><br><span class="line"> */</span><br><span class="line">- (void)finishTasksAndInvalidate;</span><br></pre></td></tr></table></figure>

<p>作用：将session作废，但允许未完成的task继续执行完。<br>&amp;emsp;</p>
<p>此方法不会等待任务完成而立刻返回，URLSession会话对象调用此方法后将不能再重用，也不再接收新的task，已存在或在执行的task则会继续执行直到全部完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* -invalidateAndCancel acts as -finishTasksAndInvalidate, but issues</span><br><span class="line"> * -cancel to all outstanding tasks for this session.  Note task </span><br><span class="line"> * cancellation is subject to the state of the task, and some tasks may</span><br><span class="line"> * have already have completed at the time they are sent -cancel. </span><br><span class="line"> */</span><br><span class="line">- (void)invalidateAndCancel;</span><br></pre></td></tr></table></figure>

<p>作用：将未完成的task取消，同时将session作废。<br>&amp;emsp;</p>
<p>与第一个方法的区别在于，本方法会取消未完成的任务。注意，二者对于<code>NSURLSession.sharedSession</code>会话无效。</p>
<h4 id="3-5-会话协议"><a href="#3-5-会话协议" class="headerlink" title="3.5.会话协议"></a>3.5.会话协议</h4><p>NSURLSessionDelegate，用来处理session-level事件的协议，比如 session 生命周期的变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSURLSessionDelegate &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">/* The last message a session receives.  A session will only become</span><br><span class="line"> * invalid because of a systemic error or when it has been</span><br><span class="line"> * explicitly invalidated, in which case the error parameter will be nil.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(nullable NSError *)error;</span><br><span class="line"></span><br><span class="line">/* If implemented, when a connection level authentication challenge</span><br><span class="line"> * has occurred, this delegate will be given the opportunity to</span><br><span class="line"> * provide authentication credentials to the underlying</span><br><span class="line"> * connection. Some types of authentication will apply to more than</span><br><span class="line"> * one request on a given connection to a server (SSL Server Trust</span><br><span class="line"> * challenges).  If this delegate message is not implemented, the </span><br><span class="line"> * behavior will be to use the default handling, which may involve user</span><br><span class="line"> * interaction. </span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line">completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, </span><br><span class="line">NSURLCredential *credential))completionHandler;</span><br><span class="line"></span><br><span class="line">/* If an application has received an</span><br><span class="line"> * -application:handleEventsForBackgroundURLSession:completionHandler:</span><br><span class="line"> * message, the session delegate will receive this message to indicate</span><br><span class="line"> * that all messages previously enqueued for this session have been</span><br><span class="line"> * delivered.  At this time it is safe to invoke the previously stored</span><br><span class="line"> * completion handler, or to begin any internal updates that will</span><br><span class="line"> * result in invoking the completion handler.</span><br><span class="line"> */</span><br><span class="line"> // 后台任务完成时 触发此回调</span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h4 id="3-6-Task"><a href="#3-6-Task" class="headerlink" title="3.6.Task"></a>3.6.Task</h4><p>数据请求可抽象为任务，即NSURLSessionTask，这是网络任务的基类，一般不直接使用此类，创建数据任务可使用其子类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSObject</span><br><span class="line">└── NSURLSessionTask</span><br><span class="line">    ├── NSURLSessionDataTask</span><br><span class="line">    │   └── NSURLSessionUploadTask</span><br><span class="line">    ├── NSURLSessionDownloadTask</span><br><span class="line">    └── NSURLSessionStreamTask</span><br></pre></td></tr></table></figure>

<p>每个类的具体作用下面章节中会继续介绍~此基类提供了任务状态和进度相关的属性，以及开始、暂停、取消等接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">@interface NSURLSessionTask : NSObject &lt;NSCopying, NSProgressReporting&gt;</span><br><span class="line"></span><br><span class="line">@property (readonly)                 NSUInteger    taskIdentifier;    /* an identifier for this task, assigned by and unique to the owning session */</span><br><span class="line">@property (nullable, readonly, copy) NSURLRequest  *originalRequest;  /* may be nil if this is a stream task */</span><br><span class="line">@property (nullable, readonly, copy) NSURLRequest  *currentRequest;   /* may differ from originalRequest due to http server redirection */</span><br><span class="line">@property (nullable, readonly, copy) NSURLResponse *response;         /* may be nil if no response has been received */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * NSProgress object which represents the task progress.</span><br><span class="line"> * It can be used for task progress tracking.</span><br><span class="line"> */</span><br><span class="line">@property (readonly, strong) NSProgress *progress API_AVAILABLE(macos(10.13), ios(11.0), watchos(4.0), tvos(11.0));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Start the network load for this task no earlier than the specified date. If</span><br><span class="line"> * not specified, no start delay is used.</span><br><span class="line"> *</span><br><span class="line"> * Only applies to tasks created from background NSURLSession instances; has no</span><br><span class="line"> * effect for tasks created from other session types.</span><br><span class="line"> */</span><br><span class="line">@property (nullable, copy) NSDate *earliestBeginDate API_AVAILABLE(macos(10.13), ios(11.0), watchos(4.0), tvos(11.0));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The number of bytes that the client expects (a best-guess upper-bound) will</span><br><span class="line"> * be sent and received by this task. These values are used by system scheduling</span><br><span class="line"> * policy. If unspecified, NSURLSessionTransferSizeUnknown is used.</span><br><span class="line"> */</span><br><span class="line">@property int64_t countOfBytesClientExpectsToSend API_AVAILABLE(macos(10.13), ios(11.0), watchos(4.0), tvos(11.0));</span><br><span class="line">@property int64_t countOfBytesClientExpectsToReceive API_AVAILABLE(macos(10.13), ios(11.0), watchos(4.0), tvos(11.0));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Byte count properties may be zero if no body is expected, </span><br><span class="line"> * or NSURLSessionTransferSizeUnknown if it is not possible </span><br><span class="line"> * to know how many bytes will be transferred.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* number of body bytes already received */</span><br><span class="line">@property (readonly) int64_t countOfBytesReceived;</span><br><span class="line"></span><br><span class="line">/* number of body bytes already sent */</span><br><span class="line">@property (readonly) int64_t countOfBytesSent;</span><br><span class="line"></span><br><span class="line">/* number of body bytes we expect to send, derived from the Content-Length of the HTTP request */</span><br><span class="line">@property (readonly) int64_t countOfBytesExpectedToSend;</span><br><span class="line"></span><br><span class="line">/* number of byte bytes we expect to receive, usually derived from the Content-Length header of an HTTP response. */</span><br><span class="line">@property (readonly) int64_t countOfBytesExpectedToReceive;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The taskDescription property is available for the developer to</span><br><span class="line"> * provide a descriptive label for the task.</span><br><span class="line"> */</span><br><span class="line">@property (nullable, copy) NSString *taskDescription;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The current state of the task within the session.</span><br><span class="line"> */</span><br><span class="line">@property (readonly) NSURLSessionTaskState state;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The error, if any, delivered via -URLSession:task:didCompleteWithError:</span><br><span class="line"> * This property will be nil in the event that no error occured.</span><br><span class="line"> */</span><br><span class="line">@property (nullable, readonly, copy) NSError *error;</span><br><span class="line"></span><br><span class="line">/* -cancel returns immediately, but marks a task as being canceled.</span><br><span class="line"> * The task will signal -URLSession:task:didCompleteWithError: with an</span><br><span class="line"> * error value of &#123; NSURLErrorDomain, NSURLErrorCancelled &#125;.  In some </span><br><span class="line"> * cases, the task may signal other work before it acknowledges the </span><br><span class="line"> * cancelation.  -cancel may be sent to a task that has been suspended.</span><br><span class="line"> */</span><br><span class="line">- (void)cancel;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Suspending a task will prevent the NSURLSession from continuing to</span><br><span class="line"> * load data.  There may still be delegate calls made on behalf of</span><br><span class="line"> * this task (for instance, to report data received while suspending)</span><br><span class="line"> * but no further transmissions will be made on behalf of the task</span><br><span class="line"> * until -resume is sent.  The timeout timer associated with the task</span><br><span class="line"> * will be disabled while a task is suspended. -suspend and -resume are</span><br><span class="line"> * nestable. </span><br><span class="line"> */</span><br><span class="line">- (void)suspend;</span><br><span class="line">- (void)resume;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Sets a scaling factor for the priority of the task. The scaling factor is a</span><br><span class="line"> * value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest</span><br><span class="line"> * priority and 1.0 is considered the highest.</span><br><span class="line"> *</span><br><span class="line"> * The priority is a hint and not a hard requirement of task performance. The</span><br><span class="line"> * priority of a task may be changed using this API at any time, but not all</span><br><span class="line"> * protocols support this; in these cases, the last priority that took effect</span><br><span class="line"> * will be used.</span><br><span class="line"> *</span><br><span class="line"> * If no priority is specified, the task will operate with the default priority</span><br><span class="line"> * as defined by the constant NSURLSessionTaskPriorityDefault. Two additional</span><br><span class="line"> * priority levels are provided: NSURLSessionTaskPriorityLow and</span><br><span class="line"> * NSURLSessionTaskPriorityHigh, but use is not restricted to these.</span><br><span class="line"> */</span><br><span class="line">@property float priority API_AVAILABLE(macos(10.10), ios(8.0), watchos(2.0), tvos(9.0));</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li>NSURLSessionTaskDelegate</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Messages related to the operation of a specific task.</span><br><span class="line"> */</span><br><span class="line">@protocol NSURLSessionTaskDelegate &lt;NSURLSessionDelegate&gt;</span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Sent when the system is ready to begin work for a task with a delayed start</span><br><span class="line"> * time set (using the earliestBeginDate property). The completionHandler must</span><br><span class="line"> * be invoked in order for loading to proceed. The disposition provided to the</span><br><span class="line"> * completion handler continues the load with the original request provided to</span><br><span class="line"> * the task, replaces the request with the specified task, or cancels the task.</span><br><span class="line"> * If this delegate is not implemented, loading will proceed with the original</span><br><span class="line"> * request.</span><br><span class="line"> *</span><br><span class="line"> * Recommendation: only implement this delegate if tasks that have the</span><br><span class="line"> * earliestBeginDate property set may become stale and require alteration prior</span><br><span class="line"> * to starting the network load.</span><br><span class="line"> *</span><br><span class="line"> * If a new request is specified, the allowsCellularAccess property from the</span><br><span class="line"> * new request will not be used; the allowsCellularAccess property from the</span><br><span class="line"> * original request will continue to be used.</span><br><span class="line"> *</span><br><span class="line"> * Canceling the task is equivalent to calling the task&#x27;s cancel method; the</span><br><span class="line"> * URLSession:task:didCompleteWithError: task delegate will be called with error</span><br><span class="line"> * NSURLErrorCancelled.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task</span><br><span class="line">                        willBeginDelayedRequest:(NSURLRequest *)request</span><br><span class="line">                              completionHandler:(void (^)(NSURLSessionDelayedRequestDisposition disposition, NSURLRequest * _Nullable newRequest))completionHandler</span><br><span class="line">    API_AVAILABLE(macos(10.13), ios(11.0), watchos(4.0), tvos(11.0));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Sent when a task cannot start the network loading process because the current</span><br><span class="line"> * network connectivity is not available or sufficient for the task&#x27;s request.</span><br><span class="line"> *</span><br><span class="line"> * This delegate will be called at most one time per task, and is only called if</span><br><span class="line"> * the waitsForConnectivity property in the NSURLSessionConfiguration has been</span><br><span class="line"> * set to YES.</span><br><span class="line"> *</span><br><span class="line"> * This delegate callback will never be called for background sessions, because</span><br><span class="line"> * the waitForConnectivity property is ignored by those sessions.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session taskIsWaitingForConnectivity:(NSURLSessionTask *)task</span><br><span class="line">    API_AVAILABLE(macos(10.13), ios(11.0), watchos(4.0), tvos(11.0));</span><br><span class="line"></span><br><span class="line">/* An HTTP request is attempting to perform a redirection to a different</span><br><span class="line"> * URL. You must invoke the completion routine to allow the</span><br><span class="line"> * redirection, allow the redirection with a modified request, or</span><br><span class="line"> * pass nil to the completionHandler to cause the body of the redirection </span><br><span class="line"> * response to be delivered as the payload of this request. The default</span><br><span class="line"> * is to follow redirections. </span><br><span class="line"> *</span><br><span class="line"> * For tasks in background sessions, redirections will always be followed and this method will not be called.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task</span><br><span class="line">                     willPerformHTTPRedirection:(NSHTTPURLResponse *)response</span><br><span class="line">                                     newRequest:(NSURLRequest *)request</span><br><span class="line">                              completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler;</span><br><span class="line"></span><br><span class="line">/* The task has received a request specific authentication challenge.</span><br><span class="line"> * If this delegate is not implemented, the session specific authentication challenge</span><br><span class="line"> * will *NOT* be called and the behavior will be the same as using the default handling</span><br><span class="line"> * disposition. </span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task</span><br><span class="line">                            didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge </span><br><span class="line">                              completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler;</span><br><span class="line"></span><br><span class="line">/* Sent if a task requires a new, unopened body stream.  This may be</span><br><span class="line"> * necessary when authentication has failed for any request that</span><br><span class="line"> * involves a body stream. </span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task</span><br><span class="line">                              needNewBodyStream:(void (^)(NSInputStream * _Nullable bodyStream))completionHandler;</span><br><span class="line"></span><br><span class="line">/* Sent periodically to notify the delegate of upload progress.  This</span><br><span class="line"> * information is also available as properties of the task.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task</span><br><span class="line">                                didSendBodyData:(int64_t)bytesSent</span><br><span class="line">                                 totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">                       totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Sent when complete statistics information has been collected for the task.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br><span class="line">/* Sent as the last message related to a specific task.  Error may be</span><br><span class="line"> * nil, which implies that no error occurred and this task is complete. </span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task</span><br><span class="line">                           didCompleteWithError:(nullable NSError *)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h4 id="3-7-DataTask"><a href="#3-7-DataTask" class="headerlink" title="3.7.DataTask"></a>3.7.DataTask</h4><p>NSURLSessionDataTask，上传数据并接收返回的数据，返回的数据被保存到内存中。<br>&amp;emsp;</p>
<p>#GET请求示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">NSURLSessionDataTask *dataTask =[session dataTaskWithURL:</span><br><span class="line">                                 [NSURL URLWithString:url]</span><br><span class="line">                                       completionHandler:^(NSData *data,</span><br><span class="line">                                                           NSURLResponse *response, NSError *error)</span><br><span class="line">&#123;</span><br><span class="line">    //data为服务器返回的数据</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">        NSLog(@&quot;+++文件大小：%lld&quot;,response.expectedContentLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">//启动任务</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>

<p>dataTask也可以胜任 downloadTask 和 uploadTask 的工作。区别在于dataTask 不支持后台下载。<br>&amp;emsp;</p>
<p>例如，dataTask一般用来上传表单数据，比如将用户名、密码等信息以GET的方式追加到请求的RUL.query部分；当然也可以将数据以POST请求的方式追加到http.body中；这时 datatask 的功能有点类似 uploadTask。<br>&amp;emsp;</p>
<p>而服务器收到datatask上传的信息后，会返回一个状态码和对应的json数据，这时 dataTask 的功能又有点像 downloadTask；<br>&amp;emsp;</p>
<p>尽管dataTask可以做这些事，URLSession还是对请求进行了详细分类，提供了专门的类单独负责上传、下载及数据流任务。</p>
<ul>
<li>NSURLSessionDataDelegate</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Messages related to the operation of a task that delivers data</span><br><span class="line"> * directly to the delegate.</span><br><span class="line"> */</span><br><span class="line">@protocol NSURLSessionDataDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">@optional</span><br><span class="line">/* The task has received a response and no further messages will be</span><br><span class="line"> * received until the completion block is called. The disposition</span><br><span class="line"> * allows you to cancel a request or to turn a data task into a</span><br><span class="line"> * download task. This delegate message is optional - if you do not</span><br><span class="line"> * implement it, you can get the response as a property of the task.</span><br><span class="line"> *</span><br><span class="line"> * This method will not be called for background upload tasks (which cannot be converted to download tasks).</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                                 didReceiveResponse:(NSURLResponse *)response</span><br><span class="line">                                  completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler;</span><br><span class="line"></span><br><span class="line">/* Notification that a data task has become a download task.  No</span><br><span class="line"> * future messages will be sent to the data task.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                              didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Notification that a data task has become a bidirectional stream</span><br><span class="line"> * task.  No future messages will be sent to the data task.  The newly</span><br><span class="line"> * created streamTask will carry the original request and response as</span><br><span class="line"> * properties.</span><br><span class="line"> *</span><br><span class="line"> * For requests that were pipelined, the stream object will only allow</span><br><span class="line"> * reading, and the object will immediately issue a</span><br><span class="line"> * -URLSession:writeClosedForStream:.  Pipelining can be disabled for</span><br><span class="line"> * all requests in a session, or by the NSURLRequest</span><br><span class="line"> * HTTPShouldUsePipelining property.</span><br><span class="line"> *</span><br><span class="line"> * The underlying connection is no longer considered part of the HTTP</span><br><span class="line"> * connection cache and won&#x27;t count against the total number of</span><br><span class="line"> * connections per host.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                                didBecomeStreamTask:(NSURLSessionStreamTask *)streamTask;</span><br><span class="line"></span><br><span class="line">/* Sent when data is available for the delegate to consume.  It is</span><br><span class="line"> * assumed that the delegate will retain and not copy the data.  As</span><br><span class="line"> * the data may be discontiguous, you should use </span><br><span class="line"> * [NSData enumerateByteRangesUsingBlock:] to access it.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                                     didReceiveData:(NSData *)data;</span><br><span class="line"></span><br><span class="line">/* Invoke the completion routine with a valid NSCachedURLResponse to</span><br><span class="line"> * allow the resulting data to be cached, or pass nil to prevent</span><br><span class="line"> * caching. Note that there is no guarantee that caching will be</span><br><span class="line"> * attempted for a given resource, and you should not rely on this</span><br><span class="line"> * message to receive the resource data.</span><br><span class="line"> */</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                                  willCacheResponse:(NSCachedURLResponse *)proposedResponse </span><br><span class="line">                                  completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果既设置了<code>completionHandler</code>，又实现了<code>NSURLSessionTaskDelegate</code>或其子类的协议方法，则优先执行 block，代理方法不再执行。</p>
<h4 id="3-8-DownloadTask"><a href="#3-8-DownloadTask" class="headerlink" title="3.8.DownloadTask"></a>3.8.DownloadTask</h4><p>NSURLSessionDownloadTask，将数据下载并保存到文件中，且下载文件时不需要考虑边下载边写入沙盒的问题，苹果都帮我们做好了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">NSURLSessionDownloadTask *dataTask = [session downloadTaskWithURL:[NSURL URLWithString:url]</span><br><span class="line">                                                completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">                                                    if (!error) &#123;</span><br><span class="line">                                                        NSLog(@&quot;++++文件位置：%@ \n文件大小：%lld&quot;,</span><br><span class="line">                                                              location,response.expectedContentLength);</span><br><span class="line">                                                        </span><br><span class="line">                                                        NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">                                                        NSString *filePath = [caches stringByAppendingPathComponent:</span><br><span class="line">                                                                              response.suggestedFilename];</span><br><span class="line">                                                        //移动文件</span><br><span class="line">                                                        [[NSFileManager defaultManager] moveItemAtPath:location.path</span><br><span class="line">                                                                                                toPath:filePath error:nil];</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;];</span><br><span class="line">//开始任务</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++++文件位置：Users/xxx/Library/Developer/CoreSimulator/</span><br><span class="line">Devices/2EDED966-0D34-4965-A946-F547BBCE33DA/data/</span><br><span class="line">Containers/Data/Application/5A2FAF81-62D5-485A-B059-22AD6DECA518</span><br><span class="line">/tmp/CFNetworkDownload_JVNOrU.tmp </span><br><span class="line">文件大小：100626</span><br></pre></td></tr></table></figure>

<p>从回调的参数可以看到，并没有 NSData 字段传回来。回调中包括了一个 <code>location</code> 参数，它就是下载好的文件在沙盒中的地址。下载好的文件被放到<code>tmp</code>目录下。由于<code>tmp</code>目录下的文件随时可能被系统自动删除，我们在回调中把文件移动指定的目录下即可。</p>
<ul>
<li>NSURLSessionDownloadDelegate</li>
</ul>
<p>上面的示例中，NSURLSession 通过 block 的方式返回数据，这种方式有个不好的地方是无法监听下载进度。如果想要在接收数据过程中做进一步的处理，可以通过 <code>NSURLSessionDownloadDelegate</code> 协议来实现。(更新：iOS11后可以使用新增的 <code>NSProgress * progress</code> 属性来监听进度了)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendRequest</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionConfiguration *config = [NSURLSessionConfiguration</span><br><span class="line">    defaultSessionConfiguration];</span><br><span class="line">    </span><br><span class="line">    config.timeoutIntervalForRequest = 60;</span><br><span class="line">    config.allowsCellularAccess = YES;</span><br><span class="line">    </span><br><span class="line">    NSURLSession *session = [NSURLSession sessionWithConfiguration:config</span><br><span class="line">    delegate:self delegateQueue:nil];</span><br><span class="line">    </span><br><span class="line">    NSURLSessionDownloadTask *dataTask = [session downloadTaskWithURL:</span><br><span class="line">    [NSURL URLWithString:url]];</span><br><span class="line">    </span><br><span class="line">    //开始任务</span><br><span class="line">    [dataTask resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -NSURLSessionDownloadDelegate</span><br><span class="line"></span><br><span class="line">//下载完成</span><br><span class="line">-(void)URLSession:(NSURLSession *)session</span><br><span class="line">     downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每次写入沙盒完成后</span><br><span class="line">-(void)URLSession:(NSURLSession *)session</span><br><span class="line">     downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">     didWriteData:(int64_t)bytesWritten</span><br><span class="line">totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;+++下载进度：%f&quot;,(double)totalBytesWritten/totalBytesExpectedToWrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//恢复下载后</span><br><span class="line">-(void)URLSession:(NSURLSession *)session</span><br><span class="line">     downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-后台任务"><a href="#3-9-后台任务" class="headerlink" title="3.9.后台任务"></a>3.9.后台任务</h4><p>对于一些耗时或者优先级不高的数据传输任务，可以在后台创建一个任务进行传输。URLSession中支持后台传输，并且可以在应用进入后台或者被系统杀掉后，继续执行传输任务。</p>
<ul>
<li>创建后台会话、发起任务</li>
</ul>
<p>这里需要给Configuration指定一个标识符，方便后台任务完成后回调函数中继续使用此标识符处理任务。同时建议打开其中两个选项，以便系统对任务进行优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//HelNetHelper.m</span><br><span class="line"></span><br><span class="line">#import &quot;HelNetHelper.h&quot;</span><br><span class="line"></span><br><span class="line">NSString * const k_BackSessionID = @&quot;k_URLSession_001&quot;;</span><br><span class="line"></span><br><span class="line">@implementation HelNetHelper</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareInstance&#123;</span><br><span class="line">    static HelNetHelper *instance;</span><br><span class="line">    static dispatch_once_t token;</span><br><span class="line">    _dispatch_once(&amp;token, ^&#123;</span><br><span class="line">        instance = [[HelNetHelper alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSURLSession *)backgroundSession &#123;</span><br><span class="line">    static NSURLSession *session = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        // 1.配置后台session，指定唯一标识符。</span><br><span class="line">        NSURLSessionConfiguration* config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:k_BackSessionID];</span><br><span class="line">        config.discretionary = YES; //允许系统采取最优时机执行传输任务</span><br><span class="line">        config.sessionSendsLaunchEvents = YES; // 当session中有任务完成时允许应用恢复或启动</span><br><span class="line">        // 2.创建session 设置代理和代理所在队列</span><br><span class="line">        session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil];</span><br><span class="line">    &#125;);</span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发起后台下载任务</span><br><span class="line">- (void)startBackgroundTask&#123;</span><br><span class="line">    NSLog(@&quot;+++start session~&quot;);</span><br><span class="line">    NSURLSession *session = [[HelNetHelper shareInstance] backgroundSession];</span><br><span class="line">    NSURLSessionDownloadTask * task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;https://dl.360safe.com/pclianmeng/n/1__6000322__00__7777772e68616f373339392e636f6d__079b.exe&quot;]];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取消任务</span><br><span class="line">- (void)stop&#123;</span><br><span class="line">    NSLog(@&quot;+++task canceled~&quot;);</span><br><span class="line">    [[[HelNetHelper shareInstance] backgroundSession] invalidateAndCancel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -URLSession Delegate</span><br><span class="line"></span><br><span class="line">// session中所有task都已完成时 回调此方法</span><br><span class="line">-  (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;++++thread on finishEvent:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.completeBlock();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文件下载完成</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location&#123;</span><br><span class="line">    NSLog(@&quot;+++downloadtask finished, file in :%@~&quot;,location.path);</span><br><span class="line">    //移动文件</span><br><span class="line">    //[[NSFileManager defaultManager] moveItemAtURL:location toURL:targetPath error:nil];</span><br><span class="line">    //删除文件</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    [[NSFileManager defaultManager] removeItemAtURL:location error:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下载进行中 跟踪进度</span><br><span class="line">-(void)URLSession:(NSURLSession *)session</span><br><span class="line">     downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">     didWriteData:(int64_t)bytesWritten</span><br><span class="line">totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;+++下载进度：%f&quot;,(double)totalBytesWritten/totalBytesExpectedToWrite);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 下载成功或失败 都会回调此方法，只是失败时error不为空，可处理错误信息</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(nullable NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;++download failed:%@&quot;,error.description);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;+++download succeed~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li>AppDelegate收到下载完成回调</li>
</ul>
<p>在AppDelegate.m中将回调中的<code>completionHandler</code>保存起来，以便后面继续使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// AppDelegate.m</span><br><span class="line"></span><br><span class="line">- (void)application:(UIApplication *)application</span><br><span class="line">handleEventsForBackgroundURLSession:(NSString *)identifier</span><br><span class="line">  completionHandler:(void (^)(void))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 使用与挂起前后台任务相同的标识符 重新创建session并设置代理，系统会自动将之前的任务与当前session关联起来</span><br><span class="line">    [[HelNetHelper shareInstance] backgroundSession];</span><br><span class="line">    </span><br><span class="line">    [HelNetHelper shareInstance].completeBlock = completionHandler;</span><br><span class="line">    NSLog(@&quot;++++handleEventsForBackgroundURLSession:%@~&quot;,identifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HelNetHelper中回调completeBlock</li>
</ul>
<p>上面AppDelegate收到回调后，系统会在 HelNetHelper 中回调 NSURLSessionDelegate 协议的以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//HelNetHelper.m</span><br><span class="line"></span><br><span class="line">/* If an application has received an</span><br><span class="line"> * -application:handleEventsForBackgroundURLSession:completionHandler:</span><br><span class="line"> * message, the session delegate will receive this message to indicate</span><br><span class="line"> * that all messages previously enqueued for this session have been</span><br><span class="line"> * delivered.  At this time it is safe to invoke the previously stored</span><br><span class="line"> * completion handler, or to begin any internal updates that will</span><br><span class="line"> * result in invoking the completion handler.</span><br><span class="line"> */</span><br><span class="line">-  (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;++++thread on finishEvent:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    // 当前回调可能在私有队列中 需要回到主线程</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        self.completeBlock();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调中我们调用之前保存起来的<code>completeBlock()</code>即可。<br>&amp;emsp;</p>
<p>注意，我们创建session时<code>delegateQueue</code>参数传的是nil，所以任务的回调 NSURLSessionDelegate 会在一个私有串行队列中执行，苹果要求我们在执行<code>completeBlock()</code>回调时必须在主线程中。</p>
<blockquote>
<p>The URL session API itself is fully thread-safe. You can freely create sessions and tasks in any thread context. When your delegate methods call the provided completion handlers, the work is automatically scheduled on the correct delegate queue.</p>
</blockquote>
<blockquote>
<p>The system may call the URLSessionDidFinishEventsForBackgroundURLSession: session delegate method on a secondary thread. However, in iOS, your implementation of that method may need to call a completion handler provided to you in your application:handleEventsForBackgroundURLSession:completionHandler: app delegate method. You must call that completion handler on the main thread.</p>
</blockquote>
<ul>
<li>处理下载的文件</li>
</ul>
<p>当应用回调完<code>completeBlock()</code>后，下载任务就自动完成，随后回调：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    //移动文件</span><br><span class="line">    [[NSFileManager defaultManager] moveItemAtURL:location toURL:targetPath error:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将下载的文件从缓存目录中移到你指定的目录中即可。</p>
<ul>
<li>应用挂起时被系统杀掉情况下任务的恢复</li>
</ul>
<p>应用被挂起时有可能被系统杀掉，后台任务在单独的进程中继续执行，当任务完成时系统会自动在后台重启你的应用。应用启动阶段你可以使用与之前的后台任务相同的标识符重新创建URLSession会话，<code>系统会自动将原来的后台任务与你的新session关联起来</code>。这样不论应用是由用户启动还是由系统启动，后台任务都会继续回调各种事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    // 重用后台任务标识符 重建session 设置回调代理</span><br><span class="line">    [[HelNetHelper shareInstance] backgroundSession];</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<p>在ViewController中 点击按钮开始下载任务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)onClick:(id)sender &#123;</span><br><span class="line">    [[HelNetHelper shareInstance] backgroundTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模拟器中调试，控制台会不断打印当前下载的进度。此时可先直接<code>command + .</code>停止模拟器并记住控制台中最后一条进度的数值；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+++start session~</span><br><span class="line">+++下载进度：0.000021</span><br><span class="line">+++下载进度：0.000025</span><br><span class="line">...</span><br><span class="line">+++下载进度：0.012226</span><br></pre></td></tr></table></figure>

<p>随后重新运行模拟器，可以看到日志继续打印，并且进度并不是从0开始，而是以比之前数值更大的进度继续进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++下载进度：0.089701</span><br><span class="line">+++下载进度：0.089829</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这说明虽然应用退出但是后台任务仍在单独的进程中运行，重新启动应用后任务继续并执行回调。</p>
<p>&amp;emsp;</p>
<p>如果开始下载后，直接进入后台，直到文件下载完成，则完整的日志如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+++start session~</span><br><span class="line">+++下载进度：0.000381</span><br><span class="line">+++下载进度：0.000573</span><br><span class="line">+++下载进度：0.000765</span><br><span class="line">+++下载进度：0.001149</span><br><span class="line">++++handleEventsForBackgroundURLSession:k_URLSession_001~</span><br><span class="line">+++downloadtask finished, file in :/Users/xxx/Library/Developer/CoreSimulator/Devices/xxx/Library/Caches/com.apple.nsurlsessiond/Downloads/Helko/CFNetworkDownload_MaGyNe.tmp~</span><br><span class="line">+++download succeed~</span><br><span class="line">++++thread on finishEvent:&lt;NSThread: 0x6000020a56c0&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>即任务会在后台自动进行，直到最终完成。任务完成后，自动调用AppDelegate和我们工具类中的URLSession各项回调。</p>
<ul>
<li>后台任务的限制条件</li>
</ul>
<p>后台session中的数据传输任务是<code>在一个单独的进程中执行</code>的，重启应用是比较昂贵的操作，所以后台session会有一些限制条件：</p>
<ol>
<li>后台session必须提供一个delegate处理事件；</li>
<li>只支持 HTTP 和 HTTPS 协议，不支持私有协议；</li>
<li>允许重定向且会直接执行，不会回调 URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:方法；</li>
<li>只支持上传和下载，不支持dataTask；且上传的文件必须在文件夹中，上传内存中的数据或者数据流在应用退出时会失败。</li>
</ol>
<h4 id="3-10-断点下载"><a href="#3-10-断点下载" class="headerlink" title="3.10.断点下载"></a>3.10.断点下载</h4><p>NSURLSessionDownloadTask 提供了断点下载的相关方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dataTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) &#123;</span><br><span class="line">    _mResumeData = resumeData;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>此方法用来取消下载任务，取消下载后的回调中，参数 <code>resumeData</code> 包含了继续下载文件的位置信息。<code>resumeData</code> 只包含了url和已经下载了多少数据，不会很大，不用担心内存问题。<br>&amp;emsp;</p>
<p>恢复下载时，可使用下面的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mDataTask = [mURLSession downloadTaskWithResumeData:_mResumeData];</span><br><span class="line">[mDataTask resume];</span><br></pre></td></tr></table></figure>

<p>另外，由于下载失败导致的下载中断会进入此协议方法，也可以得到用来恢复的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session </span><br><span class="line">task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 保存恢复数据</span><br><span class="line">    _mResumeData = error.userInfo[NSURLSessionDownloadTaskResumeData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完结，撒花~</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#网络" >
    <span class="tag-code">网络</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/11/28/crash.html">
        <span class="nav-arrow">← </span>
        
          iOS异常捕获
        
      </a>
    
    
      <a class="nav-right" href="/2017/12/24/initializer.html">
        
          构造函数
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%80-NSData"><span class="toc-nav-text">一.NSData</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BA%8C-NSURLConnection"><span class="toc-nav-text">二.NSURLConnection</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD"><span class="toc-nav-text">2.1.下载功能</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-%E6%9A%82%E5%81%9C%E5%8A%9F%E8%83%BD"><span class="toc-nav-text">2.2.暂停功能</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E5%8A%9F%E8%83%BD"><span class="toc-nav-text">2.3.断点续传功能</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%89-NSURLSession"><span class="toc-nav-text">三.NSURLSession</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-%E9%85%8D%E7%BD%AE"><span class="toc-nav-text">3.1.配置</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D"><span class="toc-nav-text">3.2.创建会话</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1"><span class="toc-nav-text">3.3.创建任务</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-4-%E4%BC%9A%E8%AF%9D%E4%BD%9C%E5%BA%9F"><span class="toc-nav-text">3.4.会话作废</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-5-%E4%BC%9A%E8%AF%9D%E5%8D%8F%E8%AE%AE"><span class="toc-nav-text">3.5.会话协议</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-6-Task"><span class="toc-nav-text">3.6.Task</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-7-DataTask"><span class="toc-nav-text">3.7.DataTask</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-8-DownloadTask"><span class="toc-nav-text">3.8.DownloadTask</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-9-%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="toc-nav-text">3.9.后台任务</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-10-%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD"><span class="toc-nav-text">3.10.断点下载</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/12/22/download.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "iOS 文件下载",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>