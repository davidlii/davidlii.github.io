

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Davidli">
  <meta name="keywords" content="Davidli">
  
    <meta name="description" content="1.图层的绘制图层，即CALayer的绘有两种实现方案：  自己绘制； 交给代理对象绘制。  1.1.自己绘制图层自己绘制时，需要重写 -drawInContext 方法，具体步骤为：  调用 CALayer 对象的 setNeedsDisplay 方法触发重绘； 重写 drawInContext: 方法绘制新内容。  #示例1.1： 1234567891011121314151617181920">
<meta property="og:type" content="article">
<meta property="og:title" content="CALayer、动画、frame">
<meta property="og:url" content="https://davidlii.cn/2017/12/29/draw.html">
<meta property="og:site_name" content="Davidli">
<meta property="og:description" content="1.图层的绘制图层，即CALayer的绘有两种实现方案：  自己绘制； 交给代理对象绘制。  1.1.自己绘制图层自己绘制时，需要重写 -drawInContext 方法，具体步骤为：  调用 CALayer 对象的 setNeedsDisplay 方法触发重绘； 重写 drawInContext: 方法绘制新内容。  #示例1.1： 1234567891011121314151617181920">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_drawrect.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_action_for_layer.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_frame_bounds.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_position_anchor1.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_position_anchor2.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_position_anchor3.png">
<meta property="og:image" content="https://davidlii.nos-eastchina1.126.net/pic_position_anchor4.png">
<meta property="article:published_time" content="2017-12-29T11:52:47.000Z">
<meta property="article:modified_time" content="2019-01-08T11:20:47.000Z">
<meta property="article:author" content="Davidli">
<meta property="article:tag" content="UI">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://davidlii.nos-eastchina1.126.net/pic_drawrect.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>CALayer、动画、frame - Davidli</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"davidlii.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>嵇风</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="CALayer、动画、frame"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-12-29 19:52" pubdate>
          2017年12月29日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          162 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CALayer、动画、frame</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="1-图层的绘制"><a href="#1-图层的绘制" class="headerlink" title="1.图层的绘制"></a>1.图层的绘制</h3><p>图层，即<code>CALayer</code>的绘有两种实现方案：</p>
<ol>
<li>自己绘制；</li>
<li>交给代理对象绘制。</li>
</ol>
<h4 id="1-1-自己绘制"><a href="#1-1-自己绘制" class="headerlink" title="1.1.自己绘制"></a>1.1.自己绘制</h4><p>图层自己绘制时，需要重写 -drawInContext 方法，具体步骤为：</p>
<ul>
<li>调用 CALayer 对象的 setNeedsDisplay 方法触发重绘；</li>
<li>重写 drawInContext: 方法绘制新内容。</li>
</ul>
<p>#示例1.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomLayer</span></span><br><br><span class="hljs-comment">//重写drawInContext</span><br>- (<span class="hljs-type">void</span>)drawInContext:(<span class="hljs-built_in">CGContextRef</span>)ctx<br>&#123;<br>    <span class="hljs-built_in">CGContextSetLineWidth</span>(ctx, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">CGContextSetFillColorWithColor</span>(ctx, [<span class="hljs-built_in">UIColor</span> blueColor].CGColor);<br>    <span class="hljs-built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor);<br>    <br>    <span class="hljs-comment">//贝塞尔曲线画三角形</span><br>    <span class="hljs-built_in">UIBezierPath</span> *aPath = [<span class="hljs-built_in">UIBezierPath</span> bezierPath];<br>    aPath.lineWidth = <span class="hljs-number">2.0</span>; <span class="hljs-comment">//设置线宽</span><br>    aPath.lineCapStyle = kCGLineCapRound; <span class="hljs-comment">//线条拐角</span><br>    aPath.lineJoinStyle = kCGLineCapRound; <span class="hljs-comment">//终点处理</span><br>    [aPath moveToPoint:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>)];<br>    [aPath addLineToPoint:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">150</span>, <span class="hljs-number">100</span>)];<br>    [aPath addLineToPoint:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>)];<br>    [aPath closePath];<br><br>    <span class="hljs-built_in">CGContextAddPath</span>(ctx, aPath.CGPath);<br>    <span class="hljs-built_in">CGContextDrawPath</span>(ctx, kCGPathFillStroke);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>将自定义 CustomLayer 添加到视图上，调用-setNeedsDisplay触发重绘：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    CustomLayer *layer = [[CustomLayer alloc] init];<br>    layer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    layer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:layer];<br>    [layer setNeedsDisplay];<span class="hljs-comment">//调用此方法触发重绘</span><br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h4 id="1-2-代理绘制"><a href="#1-2-代理绘制" class="headerlink" title="1.2.代理绘制"></a>1.2.代理绘制</h4><p>图层内部没有实现<code>-drawInContext</code>方法时，就需要将绘制任务代理给别的对象。默认情况下，CALayer的代理是其所属的视图。代理给别的对象时，此对象需要实现 CALayerDelegate。</p>
<ul>
<li>设置 CALayer 的 CALayerDelegate；</li>
<li>调用 CALayer 的-setNeedsDisplay 触发绘制；</li>
<li>在代理方法-drawLayer:inContext:的实现中绘制内容。</li>
</ul>
<p>#示例1.2：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomLayer</span></span><br><span class="hljs-comment">//这里不重写-drawInContext:方法</span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>将自定义CALayer添加到视图上，设置代理并调用-setNeedsDisplay触发重绘：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">CALayerDelegate</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    CustomLayer *layer = [[CustomLayer alloc] init];<br>    layer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    layer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    layer.delegate = <span class="hljs-keyword">self</span>;<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:layer];<br>    [layer setNeedsDisplay];<span class="hljs-comment">//调用此方法触发重绘</span><br>&#125;<br><br><span class="hljs-comment">//CALayerDelegate</span><br>-(<span class="hljs-type">void</span>)drawLayer:(<span class="hljs-built_in">CALayer</span> *)layer inContext:(<span class="hljs-built_in">CGContextRef</span>)ctx<br>&#123;<br>    <span class="hljs-built_in">CGContextAddEllipseInRect</span>(ctx, <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>));<br>    <span class="hljs-built_in">CGContextSetRGBFillColor</span>(ctx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">CGContextDrawPath</span>(ctx, kCGPathFillStroke);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>如果既重写了 CustomLayer 中的-drawInContext:，又实现了 CALayerDelegate，那么最终只会在-drawInContext中进行重绘。</p>
<h3 id="2-视图的绘制"><a href="#2-视图的绘制" class="headerlink" title="2.视图的绘制"></a>2.视图的绘制</h3><h4 id="2-1-显示原理"><a href="#2-1-显示原理" class="headerlink" title="2.1.显示原理"></a>2.1.显示原理</h4><p>通常，我们会使用UIView等控件来设置需要显示的内容，但实际上，视图本身并不负责内容的显示，甚至动画也不是在视图上执行的。从继承关系上来看，视图都直接或间接的继承自 UIResponder，从设计目标上来看视图的主要作用是处理用户交互。那么，显示和动画的工作由谁来处理呢？答案：CALayer！</p>
<blockquote>
<p>CALayer<br>An object that manages image-based content and allows you to perform animations on that content.</p>
</blockquote>
<p>视图内部默认有个.layer属性，这个<code>CALayer</code>对象正是视图显示和动画的幕后主角，视图的绘制本质上来说就是图层的绘制。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/* An object providing <span class="hljs-keyword">the</span> <span class="hljs-built_in">contents</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> layer, typically a CGImageRef,<br> * <span class="hljs-keyword">but</span> may be something <span class="hljs-keyword">else</span>. (For example, NSImage objects are<br> * supported <span class="hljs-keyword">on</span> Mac OS X <span class="hljs-number">10.6</span> <span class="hljs-keyword">and</span> later.) Default value <span class="hljs-keyword">is</span> nil.<br> * Animatable. */<br><br>@<span class="hljs-keyword">property</span>(nullable, strong) <span class="hljs-built_in">id</span> <span class="hljs-built_in">contents</span>;<br></code></pre></td></tr></table></figure>

<p>CALayer 中有个<code>contents</code>属性，即图层的内容，是一个位图（CGImageRef），指向一片叫做 backing store(后备存储区)的缓存区。默认情况下，此属性的值为空，它会从<code>后备存储</code>中读取内容并显示。当我们通过视图展示内容时：</p>
<ul>
<li>使用视图及其子控件，设置好宽高、背景色等内容；</li>
<li>runloop即将休眠或退出时，开始视图的绘制，调用 drawRect 方法；</li>
<li>drawRect 内通过 CoreGraphics 在 CGContextRef 中绘制内容并保存为位图；</li>
<li>绘制的位图被保存到由 CPU 开辟的一片叫 backing store 的缓存中；</li>
<li>图层的<code>contents</code>会从 backing store 中读取内容；</li>
<li>图层将<code>contents</code>中的位图交给<code>GPU</code>进行合成、转换和渲染；</li>
<li>GPU 将渲染结果放入<code>帧缓冲区</code>；</li>
<li><code>视频控制器</code>按照 VSync 信号逐行读取帧缓冲区的数据，经过数模转换传递给<code>显示器</code>展示。</li>
</ul>
<p>除了设置视图的宽高、背景色来展示内容外，我们也可以直接给 layer.contents 赋值，这种情况下，显示内容时不再从<code>后备存储</code>中读取内容，而是直接使用<code>contents</code>中的位图。</p>
<blockquote>
<p>If you are using the layer to display a static image, you can set this property to the CGImageRef containing the image you want to display. Assigning a value to this property causes the layer to use your image rather than create a separate backing store.</p>
</blockquote>
<h4 id="2-2-drawRect"><a href="#2-2-drawRect" class="headerlink" title="2.2.drawRect"></a>2.2.drawRect</h4><p>一般在自定义一个视图的绘制时，我们需要重写其-drawRect:方法。</p>
<p>#示例2.2:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomView.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br>    <br>    CustomView *view = [[CustomView alloc] init];<br>    view.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor];<br>    view.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view addSubview:view];<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomView.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomView</span></span><br><span class="hljs-comment">//自定义视图并重写drawRect</span><br>- (<span class="hljs-type">void</span>)drawRect:(<span class="hljs-built_in">CGRect</span>)rect<br>&#123;<br>    <span class="hljs-comment">//边宽</span><br>    <span class="hljs-built_in">CGFloat</span> lineWidth = <span class="hljs-number">3.0</span>f;<br>    <span class="hljs-comment">//半径</span><br>    <span class="hljs-built_in">CGFloat</span> radius = (<span class="hljs-built_in">CGRectGetWidth</span>(rect) - lineWidth * <span class="hljs-number">2</span>) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-comment">//圆心</span><br>    <span class="hljs-built_in">CGPoint</span> center = <span class="hljs-built_in">CGPointMake</span>(<span class="hljs-built_in">CGRectGetWidth</span>(rect)/<span class="hljs-number">2.0</span>, <span class="hljs-built_in">CGRectGetHeight</span>(rect) / <span class="hljs-number">2.0</span>);<br>    <span class="hljs-comment">//扇形起点</span><br>    <span class="hljs-built_in">CGFloat</span> startAngle = - M_PI_2;<br>    <span class="hljs-comment">//根据进度计算扇形结束位置</span><br>    <span class="hljs-built_in">CGFloat</span> endAngle = startAngle + <span class="hljs-number">0.8</span> * M_PI * <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//根据起始点、原点、半径绘制弧线</span><br>    <span class="hljs-built_in">UIBezierPath</span> *path = [<span class="hljs-built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startAngle endAngle:endAngle clockwise:<span class="hljs-literal">YES</span>];<br>    <br>    <span class="hljs-built_in">CGContextRef</span> ref = <span class="hljs-built_in">UIGraphicsGetCurrentContext</span>();<br>    <span class="hljs-built_in">CGContextSetLineWidth</span>(ref, lineWidth);<br>    <span class="hljs-built_in">CGContextSetFillColorWithColor</span>(ref, [<span class="hljs-built_in">UIColor</span> yellowColor].CGColor);<br>    <span class="hljs-built_in">CGContextSetStrokeColorWithColor</span>(ref, [<span class="hljs-built_in">UIColor</span> blueColor].CGColor);<br>    <span class="hljs-comment">//从弧线结束为止绘制一条线段到圆心。这样系统会自动闭合图形，绘制一条从圆心到弧线起点的线段。</span><br>    [path addLineToPoint:center];<br>    <span class="hljs-built_in">CGContextAddPath</span>(ref, path.CGPath);<br>    <span class="hljs-built_in">CGContextDrawPath</span>(ref, kCGPathFillStroke);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<h4 id="2-3-调用堆栈"><a href="#2-3-调用堆栈" class="headerlink" title="2.3.调用堆栈"></a>2.3.调用堆栈</h4><p><img src="https://davidlii.nos-eastchina1.126.net/pic_drawrect.png" srcset="/img/loading.gif" lazyload alt="视图重绘"></p>
<p>这是调用-drawRect时的堆栈图。当前 runloop 即将休眠或退出时，观察者回调函数中自动调用视图对象中 CALayer 的<code>-display</code>方法。下面是 CALayer.h 中对此方法的描述：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/* Reload the content of this layer. Calls the -drawInContext: method</span><br><span class="hljs-comment"> * then updates the `contents&#x27; property of the layer. Typically this is</span><br><span class="hljs-comment"> * not called directly. */</span><br><br>- (<span class="hljs-type">void</span>)display;<br></code></pre></td></tr></table></figure>

<p>即<code>-display</code>用来更新图层的内容，其内部会继续调用<code>-drawInContext:</code>并更新<code>contents</code>中的内容。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/* Called via the -display method when the `contents&#x27; property is being</span><br><span class="hljs-comment"> * updated. Default implementation does nothing. The context may be</span><br><span class="hljs-comment"> * clipped to protect valid layer content. Subclasses that wish to find</span><br><span class="hljs-comment"> * the actual region to draw can call CGContextGetClipBoundingBox(). */</span><br><br>- (<span class="hljs-type">void</span>)drawInContext:(<span class="hljs-built_in">CGContextRef</span>)ctx;<br><br><span class="hljs-comment">/* If defined, called by the default implementation of -drawInContext: */</span><br><br>- (<span class="hljs-type">void</span>)drawLayer:(<span class="hljs-built_in">CALayer</span> *)layer inContext:(<span class="hljs-built_in">CGContextRef</span>)ctx;<br></code></pre></td></tr></table></figure>

<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Draws the layer’s content <span class="hljs-keyword">using</span> the specified graphics context.The <span class="hljs-keyword">default</span> <span class="hljs-keyword">implementation</span> <span class="hljs-keyword">of</span> this <span class="hljs-keyword">method</span> <span class="hljs-title function_">does</span> <span class="hljs-title function_">not</span> <span class="hljs-title function_">do</span> <span class="hljs-title function_">any</span> <span class="hljs-title function_">drawing</span> <span class="hljs-title function_">itself</span>. <span class="hljs-title function_">If</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">layer</span>’<span class="hljs-title function_">s</span> <span class="hljs-title function_">delegate</span> <span class="hljs-title function_">implements</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">drawLayer</span>:inContext: <span class="hljs-keyword">method</span>, <span class="hljs-title function_">that</span> <span class="hljs-title function_">method</span> <span class="hljs-title function_">is</span> <span class="hljs-title function_">called</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">do</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">actual</span> <span class="hljs-title function_">drawing</span>.<br><span class="hljs-title function_">Subclasses</span> <span class="hljs-title function_">can</span> <span class="hljs-title function_">override</span> <span class="hljs-title function_">this</span> <span class="hljs-title function_">method</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">use</span> <span class="hljs-title function_">it</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">draw</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">layer</span>’<span class="hljs-title function_">s</span> <span class="hljs-title function_">content</span>. <span class="hljs-title function_">When</span> <span class="hljs-title function_">drawing</span>, <span class="hljs-title function_">all</span> <span class="hljs-title function_">coordinates</span> <span class="hljs-title function_">should</span> <span class="hljs-title function_">be</span> <span class="hljs-title function_">specified</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">points</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">logical</span> <span class="hljs-title function_">coordinate</span> <span class="hljs-title function_">space</span>.<br></code></pre></td></tr></table></figure>

<p><code>-drawInContext:</code>是图层内绘制内容的地方。默认情况下方法体中什么都不做，如果图层的代理实现了 drawLayer:inContext: 代理方法，那么就由这个方法来实现真正的绘制。示例3中我们没有重写此方法，所以图层会将绘制任务代理给别人。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">In iOS, <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> layer is associated <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> UIView object, this property must be <span class="hljs-built_in">set</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> view that owns <span class="hljs-keyword">the</span> layer.<br></code></pre></td></tr></table></figure>

<p>默认情况下，视图中根layer的代理是视图对象本身，所以绘制任务会通过代理转交给layer所属的视图。从堆栈图来看，drawLayer:inContext:代理方法内自动调用了视图的 drawRect 方法。也就是说，本来需要由 CALayer 来完成的绘制任务，通过代理转交给了视图的 drawRect，这也正是我们重写视图 drawRect 方法所要做的事情。</p>
<p>调用流程梳理如下：</p>
<ol>
<li>将视图添加到界面或者调用视图对象的-setNeedsDisplay方法，触发重绘；</li>
<li>视图将绘制任务交给内部的.layer处理；</li>
<li>layer 调用 -display 方法；</li>
<li>-display 继续调用-drawInContext绘制内容；</li>
<li>因为没有重写-drawInContext，CALayer将绘制任务通过代理交给layer所属的视图；</li>
<li>视图实现-drawLayer:inContext:代理方法，并调用自己的-drarRect:绘制内容；</li>
</ol>
<p>有个小知识点，-drawLayer:inContext:代理方法最后有个参数<code>ctx</code>，即绘图的上下文。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)drawLayer:(<span class="hljs-built_in">CALayer</span>*)layer inContext:(<span class="hljs-built_in">CGContextRef</span>)context &#123;<br>    <span class="hljs-built_in">UIGraphicsPushContext</span>(context);<br><br>    <span class="hljs-built_in">CGRect</span> bounds;<br>    bounds = <span class="hljs-built_in">CGContextGetClipBoundingBox</span>(context);<br>    [<span class="hljs-keyword">self</span> drawRect:bounds];<br><br>    <span class="hljs-built_in">UIGraphicsPopContext</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是博主thinkq的一篇 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c49833c04362">文章</a> 中帖出来的 drawLayer:inContext: 的实现代码，方法内将layer传递过来的 CGContextRef 压入绘图上下文栈顶。我们在视图的 drawRect 中通过 UIGraphicsGetCurrentContext() 获取的正是此上下文，最后 drawRect 中的绘制任务都会保存在此<code>ctx</code>中。CGContextRef 是 <code>per-thread</code>的，进入子线程中通过 UIGraphicsGetCurrentContext() 获取栈顶的上下文会为空。这时，就需要通过 UIGraphicsBeginImageContext() 创建一个<code>基于位图的</code>上下文并将其设为当前上下文进行绘图。</p>
<p>另外，通过重写视图的 drawRect 方法，使用 CoreGraphic 来绘制内容，这会消耗很大一部分内存，尤其是当你需要不断重绘时。所以，可以考虑使用 <code>CAShapeLayer</code> 来绘制。CAShapeLayer 通过矢量图形而非 bitmap 来绘制图层，所以更节省内存、渲染速度也更快。</p>
<h4 id="2-3-绘制与线程"><a href="#2-3-绘制与线程" class="headerlink" title="2.3.绘制与线程"></a>2.3.绘制与线程</h4><p>视图的显示流程被分为<code>绘制</code>和<code>渲染</code>两个阶段。绘制的工作是由<code>CPU</code>来处理的，视图的 drawRect 方法或者图层的 drawInContext 方法内，绘制任务默认都是在主线程进行的，当使用 CoreGraphics绘图时，如果内容比较复杂则会导致CPU性能瓶颈从而造成卡顿现象。渲染的工作是由<code>GPU</code>来完成的，当需要渲染的图片过大、有离屏渲染等情况时，渲染不能及时完成，也会造成卡顿现象。所以有时我们需要在异步线程中执行绘图任务，再回到主线程将绘制结果返回给视图或CALayer。在使用 tableviewCell 这种控件时，避免离屏渲染问题。</p>
<p>#示例2.3：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (<span class="hljs-type">UIImage</span><span class="hljs-operator">*</span>)drawdrawAsynchronousInRect:(<span class="hljs-type">CGRect</span>)rect<br>&#123;<br>    <span class="hljs-type">CGFloat</span> scale <span class="hljs-operator">=</span> [[<span class="hljs-type">UIScreen</span> mainScreen] scale];<br>    <br>    rect.size.width <span class="hljs-operator">*=</span> scale;<br>    rect.size.height <span class="hljs-operator">*=</span> scale;<br>    <br>    <span class="hljs-type">UIGraphicsBeginImageContext</span>(rect.size);<br>    <br>    <span class="hljs-type">CGContextRef</span> context <span class="hljs-operator">=</span> <span class="hljs-type">UIGraphicsGetCurrentContext</span>();<br>    <span class="hljs-type">CGContextScaleCTM</span>(context, scale, scale);<br>    <br>    <span class="hljs-type">UIImage</span> <span class="hljs-operator">*</span>image <span class="hljs-operator">=</span> <span class="hljs-type">UIGraphicsGetImageFromCurrentImageContext</span>();<br>    <span class="hljs-type">UIGraphicsEndImageContext</span>();<br>    <span class="hljs-keyword">return</span> [<span class="hljs-type">UIImage</span> imageWithCGImage:image.<span class="hljs-type">CGImage</span> scale:scale orientation:<span class="hljs-type">UIImageOrientationUp</span>];<br>&#125;<br><br><span class="hljs-comment">//调用示例</span><br><span class="hljs-type">UIImageView</span> <span class="hljs-operator">*</span>imageView;<br>    <span class="hljs-type">NSOperationQueue</span> <span class="hljs-operator">*</span>drawQueue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br>    [drawQueue addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-comment">//异步队列中绘图</span><br>        <span class="hljs-type">UIImage</span> <span class="hljs-operator">*</span>image <span class="hljs-operator">=</span> [<span class="hljs-keyword">self</span> drawdrawAsynchronousInRect:rect];<br>        <span class="hljs-comment">//回到主线程设置图片</span><br>        [[<span class="hljs-type">NSOperationQueue</span> mainQueue] addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>            [imageView setImage:image];<br>        &#125;];<br>    &#125;];<br></code></pre></td></tr></table></figure>

<h3 id="3-图层与动画"><a href="#3-图层与动画" class="headerlink" title="3.图层与动画"></a>3.图层与动画</h3><h4 id="3-1-隐式动画"><a href="#3-1-隐式动画" class="headerlink" title="3.1.隐式动画"></a>3.1.隐式动画</h4><p>当我们修改了图层的可动画属性时，属性并不会立刻显示最终结果，而是有一个平滑的过渡效果，持续0.25秒，这就是图层的<code>隐式动画</code>。这个过程中，我们没有明确指定动画的类型，仅仅是改变了某个属性。</p>
<p>#示例3.1.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) CustomLayer *mSublayer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    _mSublayer = [[CustomLayer alloc] init];<br>    _mSublayer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    _mSublayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_mSublayer];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = _mSublayer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    _mSublayer.affineTransform = transform;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例中我们只是对刚添加的图层的<code>affineTransform</code>属性值做了修改，运行点击界面后图层会有一个0.25秒的旋转动画。</p>
<p>隐式动画的背后其实是<code>Core Animation</code>在默默处理动画事务：当我们修改了图层的可动画属性时，Core Animation 会通过事务将我们的属性变化包裹起来，即包含在<code>CATransaction</code>的<code>begin</code>与<code>commit</code>中；事务被保存在一个栈结构中，当隐式动画被提交之后，它就被保存在栈顶的事务中；<code>runloop</code>的循环中会自动开始栈顶的这个事务，从而执行动画过程。</p>
<p>我们可以试着将上面执行动画部分的代码稍作修改，加入事务的语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span>(void)touchesBegan:(<span class="hljs-type">NSSet</span>&lt;<span class="hljs-type">UITouch</span> *&gt; <span class="hljs-operator">*</span>)touches withEvent:(<span class="hljs-type">UIEvent</span> <span class="hljs-operator">*</span>)event&#123;<br>    <span class="hljs-comment">//创建事务</span><br>    [<span class="hljs-type">CATransaction</span> begin];<br>    <span class="hljs-comment">//自定义动画时长</span><br>    [<span class="hljs-type">CATransaction</span> setAnimationDuration:<span class="hljs-number">2</span>.0f];<br>    <span class="hljs-comment">//自定义动画结束后的处理逻辑</span><br>    [<span class="hljs-type">CATransaction</span> setCompletionBlock:<span class="hljs-operator">^</span>&#123;<br>        _mSublayer.backgroundColor <span class="hljs-operator">=</span> [<span class="hljs-type">UIColor</span> redColor].<span class="hljs-type">CGColor</span>;<br>    &#125;];<br>    <span class="hljs-type">CGAffineTransform</span> transform <span class="hljs-operator">=</span> _mSublayer.affineTransform;<br>    transform <span class="hljs-operator">=</span> <span class="hljs-type">CGAffineTransformRotate</span>(transform, <span class="hljs-type">M_PI_2</span>);<br>    _mSublayer.affineTransform <span class="hljs-operator">=</span> transform;<br>    <span class="hljs-comment">//[CATransaction commit];</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行后可以看到，如果不<code>commit</code>，动画根本不会执行~另外，可以看到可变属性的动画时长和动画后的处理语句都可以自定义，这跟下面两种<code>UIView</code>的动画方式类似：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span><br>[UIView beginAnimations:@<span class="hljs-string">&quot;x&quot;</span> context:nil];<br><span class="hljs-regexp">//</span>animation here<br>[UIView commitAnimations];<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span><br>[UIView animateWithDuration:<span class="hljs-number">2.0</span>f animations:^&#123;<br>    <span class="hljs-regexp">//</span>animation here<br>&#125;];<br></code></pre></td></tr></table></figure>

<p>实际上这两种方式的内部都是通过<code>事务</code>来实现的，动画的创建和提交分别调用了<code>CATransaction</code>的<code>begin</code>与<code>commit</code>。</p>
<p>需要注意的是，<strong>隐式动画只在我们直接创建的图层上有效，<code>UIView</code>中根图的隐式动画默认是关闭的</strong>，对<code>UIView</code>中根图层做动画时，不会有动画效果:</p>
<p>#示例3.1.2：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    [<span class="hljs-built_in">CATransaction</span> begin];<br>    [<span class="hljs-built_in">CATransaction</span> setAnimationDuration:<span class="hljs-number">2.0</span>f];<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = <span class="hljs-keyword">self</span>.view.layer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    <span class="hljs-comment">//修改 self.view 中根图层的可变属性</span><br>    <span class="hljs-keyword">self</span>.view.layer.affineTransform = transform;<br>    [<span class="hljs-built_in">CATransaction</span> commit];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例中我们对<code>self.view.layer.affineTransform</code>做了修改，并且通过事务设置了动画时长为2秒，但运行后可以看到并没有动画效果，而是直接变到目标值。</p>
<p>那么，CALayer 是如何确定自己是否执行隐式动画的呢？我们对<code>#示例3.1.1</code>中的代码稍作修改：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">CALayerDelegate</span>&gt;//修改1：声明图层代理</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) CustomLayer *mSublayer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    _mSublayer = [[CustomLayer alloc] init];<br>    <span class="hljs-comment">//修改2：指定图层的代理为当前VC</span><br>    _mSublayer.delegate = <span class="hljs-keyword">self</span>;<br>    _mSublayer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    _mSublayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_mSublayer];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = _mSublayer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    _mSublayer.affineTransform = transform;<br>&#125;<br><br><span class="hljs-comment">//修改3：实现代理</span><br>- (<span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForLayer:(<span class="hljs-built_in">CALayer</span> *)layer forKey:(<span class="hljs-built_in">NSString</span> *)event&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++属性:%@&quot;</span>,event);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例中有三处修改，都是关于<code>CALayerDelegate</code>的。运行后点击界面触发隐式动画，下面是动画触发时的堆栈信息：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_action_for_layer.png" srcset="/img/loading.gif" lazyload alt="actionForLayer"></p>
<p>可以看到，动画提交后，CALayer 调用了其<code>actionForKey</code>方法，试图返回一个实现了<code>CAAction</code>协议的对象，参数<code>event</code>对应的正是我们修改的可动画属性。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/** Action methods. **/</span><br><br><span class="hljs-comment">/* An &quot;action&quot; is an object that responds to an &quot;event&quot; via the</span><br><span class="hljs-comment"> * CAAction protocol (see below). Events are named using standard</span><br><span class="hljs-comment"> * dot-separated key paths. Each layer defines a mapping from event key</span><br><span class="hljs-comment"> * paths to action objects. Events are posted by looking up the action</span><br><span class="hljs-comment"> * object associated with the key path and sending it the method</span><br><span class="hljs-comment"> * defined by the CAAction protocol.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When an action object is invoked it receives three parameters: the</span><br><span class="hljs-comment"> * key path naming the event, the object on which the event happened</span><br><span class="hljs-comment"> * (i.e. the layer), and optionally a dictionary of named arguments</span><br><span class="hljs-comment"> * specific to each event.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * To provide implicit animations for layer properties, an event with</span><br><span class="hljs-comment"> * the same name as each property is posted whenever the value of the</span><br><span class="hljs-comment"> * property is modified. A suitable CAAnimation object is associated by</span><br><span class="hljs-comment"> * default with each implicit event (CAAnimation implements the action</span><br><span class="hljs-comment"> * protocol).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The layer class also defines the following events that are not</span><br><span class="hljs-comment"> * linked directly to properties:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * onOrderIn</span><br><span class="hljs-comment"> *      Invoked when the layer is made visible, i.e. either its</span><br><span class="hljs-comment"> *      superlayer becomes visible, or it&#x27;s added as a sublayer of a</span><br><span class="hljs-comment"> *      visible layer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * onOrderOut</span><br><span class="hljs-comment"> *      Invoked when the layer becomes non-visible. */</span><br><br><span class="hljs-comment">/* Returns the default action object associated with the event named by</span><br><span class="hljs-comment"> * the string &#x27;event&#x27;. The default implementation returns a suitable</span><br><span class="hljs-comment"> * animation object for events posted by animatable properties, nil</span><br><span class="hljs-comment"> * otherwise. */</span><br><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)defaultActionForKey:(<span class="hljs-built_in">NSString</span> *)event;<br><br><span class="hljs-comment">/* Returns the action object associated with the event named by the</span><br><span class="hljs-comment"> * string &#x27;event&#x27;. The default implementation searches for an action</span><br><span class="hljs-comment"> * object in the following places:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. if defined, call the delegate method -actionForLayer:forKey:</span><br><span class="hljs-comment"> * 2. look in the layer&#x27;s `actions&#x27; dictionary</span><br><span class="hljs-comment"> * 3. look in any `actions&#x27; dictionaries in the `style&#x27; hierarchy</span><br><span class="hljs-comment"> * 4. call +defaultActionForKey: on the layer&#x27;s class</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If any of these steps results in a non-nil action object, the</span><br><span class="hljs-comment"> * following steps are ignored. If the final result is an instance of</span><br><span class="hljs-comment"> * NSNull, it is converted to `nil&#x27;. */</span><br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForKey:(<span class="hljs-built_in">NSString</span> *)event;<br><br><span class="hljs-comment">/* A dictionary mapping keys to objects implementing the CAAction</span><br><span class="hljs-comment"> * protocol. Default value is nil. */</span><br><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;&gt; *actions;<br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">CALayerDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><span class="hljs-comment">//...略</span><br><br><span class="hljs-comment">/* If defined, called by the default implementation of the</span><br><span class="hljs-comment"> * -actionForKey: method. Should return an object implementing the</span><br><span class="hljs-comment"> * CAAction protocol. May return &#x27;nil&#x27; if the delegate doesn&#x27;t specify</span><br><span class="hljs-comment"> * a behavior for the current event. Returning the null object (i.e.</span><br><span class="hljs-comment"> * &#x27;[NSNull null]&#x27;) explicitly forces no further search. (I.e. the</span><br><span class="hljs-comment"> * +defaultActionForKey: method will not be called.) */</span><br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForLayer:(<span class="hljs-built_in">CALayer</span> *)layer forKey:(<span class="hljs-built_in">NSString</span> *)event;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p><code>CAAction</code>可以视为图层隐式动画的行为。动画提交后图层会通过<code>-actionForKey:</code>方法寻找一个<code>CAAction</code>对象，寻找的过程如下：</p>
<ul>
<li>先尝试通过 CALayerDelegate 的 -actionForLayer:forKey: 代理方法返回一个 CAAction 对象；</li>
<li>如果代理方法返回 null，则停止寻找，属性的修改不执行任何动画，直接更新到目标值；</li>
<li>如果代理方法返回 nil，则继续从 layer 的 actions 字典中查找 CAAction 对象；</li>
<li>如果 actions 字典中没有包含对应的属性，则图层继续在它的 style 字典中搜索属性名；</li>
<li>如果在 style 里也找不到，则从 +defaultActionForKey: 方法中返回属性对应的默认行为对象；</li>
</ul>
<p>上面的搜索过程中，<code>-actionForLayer:forKey:</code>如果返回<code>null</code>对象，则不执行动画；如果返回<code>nil</code>则会执行隐式动画。如果返回<code>CAAction</code>协议对象，则由 Core Animation 创建对应的动画。</p>
<p>上面提到的对视图的根图层的可动画属性进行修改时，并不会触发隐式动画，实际上就是因为视图默认是其根图层的代理，<code>-actionForLayer:forKey:</code>返回了一个<code>null</code>对象。你可以尝试让当前 VC 实现<code>self.view.layer</code>的代理并返回<code>nil</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">CALayerDelegate</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-comment">//设置代理</span><br>    <span class="hljs-keyword">self</span>.view.layer.delegate = <span class="hljs-keyword">self</span>;<br>    [<span class="hljs-built_in">CATransaction</span> begin];<br>    [<span class="hljs-built_in">CATransaction</span> setAnimationDuration:<span class="hljs-number">2.0</span>f];<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = <span class="hljs-keyword">self</span>.view.layer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    <span class="hljs-comment">//修改 self.view 中根图层的可变属性</span><br>    <span class="hljs-keyword">self</span>.view.layer.affineTransform = transform;<br>    [<span class="hljs-built_in">CATransaction</span> commit];<br>&#125;<br><br>- (<span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForLayer:(<span class="hljs-built_in">CALayer</span> *)layer forKey:(<span class="hljs-built_in">NSString</span> *)event&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++属性:%@&quot;</span>,event);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>再运行并点击界面后可以看到，<code>self.view.layer</code>这次执行了隐式动画！</p>
<h4 id="3-2-图层树"><a href="#3-2-图层树" class="headerlink" title="3.2.图层树"></a>3.2.图层树</h4><p>和视图一样图层也有树形结构，称为“图层树”，即<code>展示树</code>和<code>模型树</code>。</p>
<ul>
<li>展示树</li>
</ul>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">- (instance<span class="hljs-keyword">type</span>)presentationLayer;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Returns a copy of the presentation layer object that represents the state of the layer as it currently appears onscreen.</p>
</blockquote>
<blockquote>
<p>Discussion<br>The layer object returned by this method provides a close approximation of the layer that is currently being displayed onscreen. While an animation is in progress, you can retrieve this object and use it to get the current values for those animations.<br>The sublayers, mask, and superlayer properties of the returned layer return the corresponding objects from the presentation tree (not the model tree). This pattern also applies to any read-only layer methods. For example, the hitTest: method of the returned object queries the layer objects in the presentation tree.</p>
</blockquote>
<p>当 layer 处于动画状态时，<code>展示树</code>会返回一个当前正在展示中的 layer，其属性值都是当前运动状态中对应的值，动画过程中会不断变化。</p>
<p>注意：展示树只有当图层展示在界面上之后才会有值，在此之前调用此树会返回<code>nil</code>。</p>
<ul>
<li>模型树</li>
</ul>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">- (instance<span class="hljs-keyword">type</span>)modelLayer;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Returns the model layer object associated with the receiver, if any.</p>
</blockquote>
<blockquote>
<p>Discussion<br>Calling this method on a layer in the presentation tree returns the corresponding layer object in the model tree. This method returns a value only when a transaction involving changes to the presentation layer is in progress. If no transaction is in progress, the results of calling this method are undefined.</p>
</blockquote>
<p>在<code>呈现图层</code>上调用<code>–modelLayer</code>将会返回它正在呈现所依赖的 CALayer。通常在一个图层上调用<code>-modelLayer</code>会返回<code>self</code>。</p>
<p>关于这两个树的应用，可以移步到<code>事件响应者链 &amp; 传递链</code>这篇文章中的<code>抢红包</code>的示例~</p>
<h3 id="4-位置相关属性"><a href="#4-位置相关属性" class="headerlink" title="4.位置相关属性"></a>4.位置相关属性</h3><h4 id="4-1-frame"><a href="#4-1-frame" class="headerlink" title="4.1.frame"></a>4.1.frame</h4><blockquote>
<p>The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.</p>
</blockquote>
<p><code>frame</code>，表示视图在其父视图坐标系中的位置和大小。这里的位置<code>frame.origin(x,y)</code>即视图的左上角，它参照的是父视图的坐标系原点。改变frame的值只会影响到视图本身，其子视图的相对位置不变。</p>
<h4 id="4-2-bounds"><a href="#4-2-bounds" class="headerlink" title="4.2.bounds"></a>4.2.bounds</h4><blockquote>
<p>The bounds rectangle, which describes the view’s location and size in its own coordinate system.</p>
</blockquote>
<p><code>bounds</code>，表示视图在其自身坐标系中的位置和大小。默认情况下，bounds &#x3D; (0, 0, frame.size.width, frame.size.heigth)，即：</p>
<ul>
<li>bounds.origin默认为 (0, 0)；</li>
<li>bounds.size &#x3D; frame.size；</li>
</ul>
<p>其中<code>bounds.origin(x,y)</code>参照的是视图自身的坐标系原点，修改<code>bounds.origin</code>不会改变视图本身的位置，而是改变其自身的坐标系原点；因为子视图的位置参照的是父视图坐标系的原点，所以修改视图的<code>bounds.origin</code>最终影响的是其子视图的位置。具体表现是：</p>
<ul>
<li><code>bounds.origin(x,y)</code>相当于当前视图的坐标系原点与视图左上角之间带向量的间距；</li>
<li>默认情况下，视图本身的坐标系原点与视图左上角重合，即bounds.origin(x,y) &#x3D; (0, 0)；</li>
<li>当<code>origin.x</code>为正值时，间距在x轴上拉大，因为修改origin不影响视图本身的位置，所以视图左上角位置不变，只能让视图坐标系原点向左移动；此时子视图frame和bounds的数值都没变，但受父视图坐标系原点左移的影响，子视图本身也会跟着父视图的原点左移；</li>
<li>当<code>origin.y</code>为正值时，间距在y轴上拉大，因为视图左上角不变，所以视图坐标系原点会向上移动；子视图frame和bounds都不变，但它的实际位置会跟着父视图的原点向上移；</li>
</ul>
<p>#示例：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_frame_bounds.png" srcset="/img/loading.gif" lazyload alt="bounds"></p>
<p>上图中，视图A是父视图，视图B是A的子视图。</p>
<ul>
<li>粉色背景中视图A.bounds.origin &#x3D; (0,0)；视图B.bounds.origin &#x3D; (0, 0)；</li>
<li>绿色背景中视图A.bounds.origin被修改为(50,0)，所以视图A自身的坐标系原点会向左移动50；</li>
<li>视图B是视图A的子视图，所以视图B会跟着视图A的坐标系原点向左移动50；</li>
</ul>
<p><strong>结论</strong>：修改bounds.origin会影响到子视图参照的坐标系原点；修改bounds.size会影响到视图本身的大小；</p>
<h4 id="4-3-anchorPoint"><a href="#4-3-anchorPoint" class="headerlink" title="4.3.anchorPoint"></a>4.3.anchorPoint</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">/* Defines the <span class="hljs-built_in">anchor</span> point of the layer&#x27;s bounds rect, as a point <span class="hljs-keyword">in</span><br> * normalized layer coordinates - &#x27;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#x27; is the bottom left corner of<br> * the bounds rect, &#x27;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)&#x27; is the top right corner. Defaults <span class="hljs-keyword">to</span><br> * &#x27;(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)&#x27;, i.e. the center of the bounds rect. Animatable. */<br><br>@property CGPoint <span class="hljs-built_in">anchor</span>Point;<br><br></code></pre></td></tr></table></figure>

<p>翻译过来是<code>锚点</code>，这是一个<code>CGPoint</code>类型的属性，可以理解为在 layer <code>自身坐标系</code>中的一个点。锚点在<code>x</code>轴和<code>y</code>轴上数值的变化范围均为[0~1]，例如<code>(0,0)</code>表示 layer 的左上角，<code>(0.5,0.5)</code>表示 layer 的中心点，<code>(1,1)</code>表示 layer 的右下角。锚点的默认值为<code>(0.5,0.5)</code>，即 layer 的中心点。直接修改锚点的值会触发隐式动画。</p>
<h4 id="4-4-position"><a href="#4-4-position" class="headerlink" title="4.4.position"></a>4.4.position</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/* The position in the superlayer that the anchor point of the layer&#x27;s</span><br><span class="hljs-comment"> * bounds rect is aligned to. Defaults to the zero point. Animatable. */</span><br><br><span class="hljs-variable">@property</span> CGPoint position;<br><br></code></pre></td></tr></table></figure>

<p>此属性也是<code>CGPoint</code>类型，表示一个点，即 layer 的<code>锚点</code>在其父图层中对应的点，也就是说<code>anchorPoint</code>与<code>position</code>两个点是重合的，只不过前者在自身坐标系统内，后者在父图层内。</p>
<p>为了方便理解，你可以将 layer 想象成一张便签纸，<code>anchorPoint</code>是用来固定便签纸的一枚图钉，图钉可以扎在便签纸自身范围内的任何位置上；<code>position</code>表示黑板上的一个点，便签纸会被图钉钉在黑板上，而钉在黑板上的这个点就是<code>position</code>。</p>
<p>#示例：</p>
<p><code>bounds = (0, 0, 50, 50)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0,0)</code>，效果如下：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor1.png" srcset="/img/loading.gif" lazyload alt="效果图1"></p>
<p><code>bounds = (0, 0, 50, 50)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0.5,0.5)</code>，效果如下：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor2.png" srcset="/img/loading.gif" lazyload alt="效果图2"></p>
<p><code>bounds = (0, 0, 100, 100)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0.5,0.5)</code>，效果如下：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor3.png" srcset="/img/loading.gif" lazyload alt="效果图3"></p>
<p><code>bounds = (0, 0, 50, 50)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0,0)</code>，<code>affineTransform = (M_PI / 4.0);</code>效果如下：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor4.png" srcset="/img/loading.gif" lazyload alt="效果图4"></p>
<p><strong>结论：</strong>CALayer 在其<code>superlayer</code>上的<code>frame</code>是由其自己的<code>bounds</code>、<code>position</code>和<code>anchorPoint</code>及<code>affineTransform</code>等属性共同决定的。</p>
<hr>
<p>相关参考：</p>
<p>#<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/calayer?language=objc">©Apple-CALayer</a></p>
<p>#<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/quartzcore/cashapelayer">©AppleDev-CAShapelayer</a></p>
<p>#<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c49833c04362">©thinkq-关于drawRect</a></p>
<p>#<a target="_blank" rel="noopener" href="https://blog.csdn.net/catsmen/article/details/46546897">©catsmen-隐式动画和显式动画</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/OC/" class="category-chain-item">OC</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/UI/">#UI</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>CALayer、动画、frame</div>
      <div>https://davidlii.cn/2017/12/29/draw.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Davidli</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年12月29日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/01/07/responder.html" title="响应者链 &amp; 传递链">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">响应者链 &amp; 传递链</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/12/27/autolayout.html" title="UI布局 &amp; 适配">
                        <span class="hidden-mobile">UI布局 &amp; 适配</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/davidli-" target="_blank" rel="nofollow noopener"><span>嵇风</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
