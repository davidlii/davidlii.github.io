<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"> 
  
  <title>
    
      多线程：NSOperation | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>多线程：NSOperation</h2>
  <p class="post-date">2017-11-17</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>iOS2 时 OS X 与 iOS 的程序都普遍采用 NSOperation 来编写线程代码，而之后出现的 GCD 技术大体是依照前者的原则来实现的。随着 GCD 的普及，在iOS4 与 OS X 10.6 以后，OperationQueue 的底层都是用 GCD 来实现的。</p>
</blockquote>
<h3 id="1-与-GCD-的对比"><a href="#1-与-GCD-的对比" class="headerlink" title="1.与 GCD 的对比"></a>1.与 GCD 的对比</h3><h4 id="1-1-GCD-的特点："><a href="#1-1-GCD-的特点：" class="headerlink" title="1.1.GCD 的特点："></a>1.1.GCD 的特点：</h4><p>GCD 是面向过程的，它是由 C 语言构成的 API，一般与 block 结合使用，简洁高效；</p>
<h4 id="1-2-NSOperation的特点："><a href="#1-2-NSOperation的特点：" class="headerlink" title="1.2.NSOperation的特点："></a>1.2.NSOperation的特点：</h4><p><strong>复用率：</strong> NSOperation 是面向对象的，拥有更多的函数可用；同时它能被继承，这一方面方便了我们重写其部分方法以实现特殊功能；另一方面也让我们可以根据需求定义不同的子类，从而提高代码的复用率；<br>&emsp;</p>
<p><strong>依赖关系：</strong> NSOperation 能够方便地设置依赖关系，这样可以方便的让处于同一个并行队列中的两个任务按照我们指定的先后顺序执行；<br>&emsp;</p>
<p><strong>属性监测：</strong> NSOperation 提供了部分属性，我们可通过 KVO 监听一个任务是否完成或取消。这让我们能比 GCD 更加有效地掌任务的进度和状态；<br>&emsp;</p>
<p><strong>优先级设置：</strong> NSOperation 中能设置任务的优先级，使同一个并行队列中的任务区分先后地执行。GCD 中只能区分不同任务队列的优先级，如果要区分 block 内任务的优先级，需要复杂的代码；</p>
<h3 id="2-NSOperation"><a href="#2-NSOperation" class="headerlink" title="2.NSOperation"></a>2.NSOperation</h3><p>NSOperation 是一个基类，不能直接使。系统给我们提供了它的两个可以直接使用的子类：NSInvocationOperation 和 NSBlockOperation。当然你也可以自定义一个基于 NSOperation 的子类。</p>
<h4 id="2-1-子类"><a href="#2-1-子类" class="headerlink" title="2.1.子类"></a>2.1.子类</h4><p>#示例1（NSInvocationOperation）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationGo</span><br><span class="line">&#123;</span><br><span class="line">    //invocation Operation</span><br><span class="line">    NSInvocationOperation *invocOperation = [[NSInvocationOperation alloc] </span><br><span class="line">    initWithTarget:self </span><br><span class="line">    selector:@selector(operationAction) </span><br><span class="line">    object:nil];</span><br><span class="line">    </span><br><span class="line">    //执行结束后调用的Block</span><br><span class="line">    [invocOperation setCompletionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++invocation Finished&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [invocOperation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)operationAction</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;++++execute invocation，</span><br><span class="line">    \n++++线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++execute invocation，</span><br><span class="line">++++线程:&lt;NSThread: 0x600000065f80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">++++invocation Finished</span><br></pre></td></tr></table></figure>
<p>#示例2（NSBlockOperation）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockOperationGo</span><br><span class="line">&#123;</span><br><span class="line">    //block Operation</span><br><span class="line">    NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++execute block，\n++++线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++added block, \n++++线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation setCompletionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++block Finished&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">++++added block,</span><br><span class="line">++++线程:&lt;NSThread: 0x60400027c4c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++execute block，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000078080&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">++++block Finished</span><br></pre></td></tr></table></figure>
<p>从上述示例及其输出结果中可以看到：<br>&emsp;</p>
<p>NSOperation 的俩子类在单独使用时都没有开辟新线程的能力，任务会在当前线程中同步执行。<br>&emsp;</p>
<p>NSBlockOperation 使用 addExecutionBlock 添加额外任务时，这些任务会在不同线程中并发执行。</p>
<h4 id="2-2-状态"><a href="#2-2-状态" class="headerlink" title="2.2.状态"></a>2.2.状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL executing;</span><br><span class="line">BOOL finished;</span><br><span class="line">BOOL asynchronous;</span><br><span class="line">BOOL ready;</span><br></pre></td></tr></table></figure>
<ul>
<li>isReady</li>
</ul>
<p>表示这个 operation 是否已做好准备去执行。=NO 表示它依赖的相关 operation 尚未完成。</p>
<ul>
<li>isExecuting</li>
</ul>
<p>表示当前 operation 中的任务是否正在执行。</p>
<ul>
<li>isFinished</li>
</ul>
<p>= YES 时表示当任务已完成或者已被取消。只有此属性为YES时 operation 才会从队列中出列。</p>
<ul>
<li>isCancelled</li>
</ul>
<p>当前 operation 是否被取消了。在自定义子类的任务开始前，需要在 start 方法中检查此属性。当 = YES 时应该立刻退出，同时将 finished属性设置为YES，executing 属性设置为 NO。</p>
<ul>
<li>isAsynchronous</li>
</ul>
<p>表示 operation 在当前线程是异步还是同步执行，默认值为NO。执行异步 operation 时必须重写此属性并返回 YES。<br>&emsp;</p>
<p>注意：NSOperationQueue 是通过 KVO 观察内部的 NSOperation 状态的变化，来自动管理 NSOperation 的执行的。重写 start 方法时，我们必须自己维护 isExecuting、isFinished 的值并正确的发送相关 KVO 通知。</p>
<h4 id="2-3-优先级"><a href="#2-3-优先级" class="headerlink" title="2.3.优先级"></a>2.3.优先级</h4><p>NSOperation的优先级可以由其属性<code>queuePriority</code>指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">    NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="line">    NSOperationQueuePriorityLow = -4L,</span><br><span class="line">    NSOperationQueuePriorityNormal = 0,</span><br><span class="line">    NSOperationQueuePriorityHigh = 4,</span><br><span class="line">    NSOperationQueuePriorityVeryHigh = 8</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这与 GCD 的队列优先级相似，有三点需要说明：</p>
<ul>
<li>优先级决定了各 operation 之间的开始顺序；</li>
<li>这种优先级只针对同一 OperationQueue 中的 operation，不同队列中的任务之间比较优先级无意义；</li>
<li>这种优先级是针对并发队列，对于并发数为 1 的串行队列来说无意义，它们还是按入队列的顺序执行。</li>
</ul>
<p><strong>ps</strong>：理论上来说优先级高的先执行，但实际使用中发现通过这个属性标记的任务，其开始的顺序并不一定按照我们指定的优先级来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationPriority&#123;</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;+++1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;+++2&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;+++3&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    op1.queuePriority = NSOperationQueuePriorityNormal;</span><br><span class="line">    op2.queuePriority = NSOperationQueuePriorityVeryHigh;</span><br><span class="line">    op3.queuePriority = NSOperationQueuePriorityVeryLow;</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue *aQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    [aQueue addOperations:@[op1,op2,op3] waitUntilFinished:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++3</span><br><span class="line">+++1</span><br><span class="line">+++2</span><br></pre></td></tr></table></figure>
<p>三个任务实际执行时并未按照我们指定的<code>2-&gt;1-&gt;3</code>的顺序来。<br>&emsp;</p>
<p>有种说法是决定任务开始顺序的不仅是优先级，还要看任务是否处在<code>isReady</code>状态。</p>
<blockquote>
<p>The readiness of operations is determined by their dependencies on other operations and potentially by custom conditions that you define. The NSOperation class manages dependencies on other operations and reports the readiness of the receiver based on those dependencies.</p>
</blockquote>
<blockquote>
<p>By default, an operation object that has dependencies is not considered ready until all of its dependent operation objects have finished executing. Once the last dependent operation finishes, however, the operation object becomes ready and able to execute.</p>
</blockquote>
<p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1412992-ready?language=objc" target="_blank" rel="noopener">官文</a>中说<code>ready</code>是根据当前任务“是否有依赖任务及该任务是否已完成”而定的。示例中的三个任务之间是并发且没有依赖关系的，所以按理它们被加入队列后，是否处在就绪状态是由队列或线程池状况来决定的，至于最终设置了优先级但失效了的问题，这不是我们能控制的了。</p>
<p>&emsp;</p>
<p>鉴于此，为了精确控制任务优先级，还是推荐使用接下来介绍的<code>qualityOfService</code>属性来指定任务优先级。</p>
<h4 id="2-4-服务质量"><a href="#2-4-服务质量" class="headerlink" title="2.4.服务质量"></a>2.4.服务质量</h4><p>qualityOfService，这是在iOS 8后推出的新属性，通过设置服务质量来决定任务在队列中的优先级和执行顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSQualityOfService) &#123;</span><br><span class="line">    NSQualityOfServiceUserInteractive = 0x21,</span><br><span class="line">    NSQualityOfServiceUserInitiated = 0x19,</span><br><span class="line">    NSQualityOfServiceUtility = 0x11,</span><br><span class="line">    NSQualityOfServiceBackground = 0x09,</span><br><span class="line">    NSQualityOfServiceDefault = -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些优先级按照枚举的值，从高到低排列：</p>
<ul>
<li><strong>UserInteractive</strong></li>
</ul>
<blockquote>
<p>Used for work directly involved in providing an interactive UI. For example, processing control events or drawing to the screen.</p>
</blockquote>
<p>最高，用于涉及到UI交互的场景，例如处理点击事件或绘制图片到屏幕上。</p>
<ul>
<li><strong>UserInitiated</strong></li>
</ul>
<blockquote>
<p>Used for performing work that has been explicitly requested by the user, and for which results must be immediately presented in order to allow for further user interaction. For example, loading an email after a user has selected it in a message list.</p>
</blockquote>
<p>次级，用于用户触发的、需要立刻返回结果的任务，例如用户点击邮件列表后立刻加载邮件内容。</p>
<ul>
<li><strong>Utility</strong></li>
</ul>
<blockquote>
<p>Used for performing work which the user is unlikely to be immediately waiting for the results. This work may have been requested by the user or initiated automatically, and often operates at user-visible timescales using a non-modal progress indicator. For example, periodic content updates or bulk file operations, such as media import.</p>
</blockquote>
<p>更次级，用于不需要立刻返回结果的任务，比如周期性的更新内容，或者导入媒体文件。</p>
<ul>
<li><strong>Background</strong></li>
</ul>
<blockquote>
<p>Used for work that is not user initiated or visible. In general, a user is unaware that this work is even happening. For example, pre-fetching content, search indexing, backups, or syncing of data with external systems.</p>
</blockquote>
<p>后台任务，用于非用户触发的、不可见的任务，比如发起的网络请求、检索结果、同步数据。</p>
<ul>
<li><strong>Default</strong></li>
</ul>
<blockquote>
<p>Indicates no explicit quality of service information. Whenever possible, an appropriate quality of service is determined from available sources. Otherwise, some quality of service level between NSQualityOfServiceUserInteractive and NSQualityOfServiceUtility is used.</p>
</blockquote>
<p>默认值，介于<code>UserInteractive</code>和<code>Utility</code>之间，系统会根据当前可用资源的状况决定任务的执行顺序。</p>
<p>&emsp;</p>
<p>#示例：服务质量决定优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationServiceQuality&#123;</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;+++1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;+++2&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;+++3&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    op1.qualityOfService = NSQualityOfServiceUserInitiated;</span><br><span class="line">    op2.qualityOfService = NSQualityOfServiceDefault;</span><br><span class="line">    op3.qualityOfService = NSQualityOfServiceUserInteractive;</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue *aQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    [aQueue addOperations:@[op1,op2,op3] waitUntilFinished:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++3</span><br><span class="line">+++1</span><br><span class="line">+++2</span><br></pre></td></tr></table></figure>
<h3 id="3-NSOperationQueue"><a href="#3-NSOperationQueue" class="headerlink" title="3.NSOperationQueue"></a>3.NSOperationQueue</h3><p>NSOperation 单独使用时，不具备开启新线程的能力，只有配合 NSOperationQueue 才能实现异步执行。配合使用时，NSOperation 相当于GCD中的任务，而 NSOperationQueue 则相当于GCD中的队列。将任务加入到队列中后，系统会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作，不需要再手动调用start。</p>
<h4 id="3-1-两种队列"><a href="#3-1-两种队列" class="headerlink" title="3.1.两种队列"></a>3.1.两种队列</h4><ul>
<li>主队列：（任务会在主线程执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
<ul>
<li>其他队列：（任务会放到子线程中执行）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>
<h4 id="3-2-添加任务"><a href="#3-2-添加任务" class="headerlink" title="3.2.添加任务"></a>3.2.添加任务</h4><p>#示例3：-addOperation:(NSOperation *)op;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperation</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    </span><br><span class="line">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] </span><br><span class="line">    initWithTarget:self </span><br><span class="line">    selector:@selector(run) </span><br><span class="line">    object:nil];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation </span><br><span class="line">    blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务，</span><br><span class="line">        \n++++线程:%@&quot;, </span><br><span class="line">        [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;++++执行invocation operation任务，</span><br><span class="line">    \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程调用之后，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++++执行block任务，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000268cc0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++执行invocation operation任务，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000268c80&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>#示例4：-addOperationWithBlock:(void (^)(void))block;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)addBlockOperation</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //最大并发数</span><br><span class="line">    //queue.maxConcurrentOperationCount = 1;</span><br><span class="line">    //queue.maxConcurrentOperationCount = 2;</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务1，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务2，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务3，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务4，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程调用之后，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">++++执行block任务3，</span><br><span class="line">++++线程:&lt;NSThread: 0x60000046c180&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++执行block任务4，</span><br><span class="line">++++线程:&lt;NSThread: 0x60000046c1c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">++++执行block任务1，</span><br><span class="line">++++线程:&lt;NSThread: 0x60400026a000&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">++++执行block任务2，</span><br><span class="line">++++线程:&lt;NSThread: 0x60400026a280&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>结合 NSOperationQueue 后，任务都在不同线程里并发执行，具备了开启新线程的能力。</p>
<h4 id="3-3-并发数"><a href="#3-3-并发数" class="headerlink" title="3.3.并发数"></a>3.3.并发数</h4><ul>
<li>-1，默认值，表示不进行限制，默认为并发执行；</li>
<li>=0，阻塞、都不执行；</li>
<li>=1，串行；</li>
<li>>1，并发；</li>
</ul>
<p>上面#示例4中，如果让 maxConcurrentOperationCount = 1，则队列为串行，输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">++++执行block任务1，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++执行block任务2，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++执行block任务3，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++执行block任务4，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，队列中的任务按照串行的方式在执行。不设置或者=2时，任务会并发执行，开启线程数量是由系统决定的，不需要我们来管理。</p>
<h4 id="3-4-依赖关系"><a href="#3-4-依赖关系" class="headerlink" title="3.4.依赖关系"></a>3.4.依赖关系</h4><p>#示例5：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)dependenceGo</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op2&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op3&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op1 addDependency:op2];</span><br><span class="line">    [op2 addDependency:op3];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++++执行op3</span><br><span class="line">++++执行op2</span><br><span class="line">++++执行op1</span><br></pre></td></tr></table></figure>
<p>如果不添加依赖，则3个任务会并发执行，先后顺序不定。添加依赖后，3个任务则按照设定倒序执行。</p>
<h4 id="3-5-暂停-amp-取消任务"><a href="#3-5-暂停-amp-取消任务" class="headerlink" title="3.5.暂停&amp;取消任务"></a>3.5.暂停&amp;取消任务</h4><ul>
<li>取消任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel;//NSOperation的方法 取消单个任务。</span><br><span class="line">- (void)cancelAllOperations;//NSOperationQueue的方法，取消队列中的所有任务。</span><br></pre></td></tr></table></figure>
<ul>
<li>暂停任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSuspended:(BOOL)b;//设置任务的暂停和恢复</span><br></pre></td></tr></table></figure>
<p>暂停和取消，都只对队列中尚未执行的任务有效。</p>
<h3 id="4-实现Group任务"><a href="#4-实现Group任务" class="headerlink" title="4.实现Group任务"></a>4.实现Group任务</h3><p>GCD中提供了<code>dispatch_group</code>以便将多个任务组合在一起，同时可以在这些任务执行完成后通过<code>dispatch_group_notify</code>的block执行某些特殊任务。NSOperation并没有<code>Group</code>相关字眼的接口，但是我们仍然可以在NSOperation已有接口的基础上变相实现此功能。</p>
<h4 id="4-1-依赖关系"><a href="#4-1-依赖关系" class="headerlink" title="4.1.依赖关系"></a>4.1.依赖关系</h4><p>思路：给封装了最后任务的 Operation 设置依赖关系，使其依赖于前面的所有任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)monitorGroupTasks</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op2&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op3&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //最后需要执行的UI任务</span><br><span class="line">    NSBlockOperation *finOp = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSLog(@&quot;++++最后执行UI任务~&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //添加依赖，让finOp依赖于Grop中的所有任务</span><br><span class="line">    [finOp addDependency:op1];</span><br><span class="line">    [finOp addDependency:op2];</span><br><span class="line">    [finOp addDependency:op3];</span><br><span class="line">    </span><br><span class="line">    [queue addOperations:@[finOp,op3,op2,op1] waitUntilFinished:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++++执行op2</span><br><span class="line">++++执行op1</span><br><span class="line">++++执行op3</span><br><span class="line">++++最后执行UI任务~</span><br></pre></td></tr></table></figure>
<h4 id="4-2-completionBlock"><a href="#4-2-completionBlock" class="headerlink" title="4.2.completionBlock"></a>4.2.completionBlock</h4><p>思路：NSBlockOperation中的<code>addExecutionBlock</code>接口可以给<code>operation</code>添加额外任务并在异步线程中执行。同时NSOperation提供了<code>completionBlock</code>属性，我们可以利用它来在所有任务执行完成后执行某个特殊任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)monitorGroupTasks</span><br><span class="line">&#123;</span><br><span class="line">    NSBlockOperation *blockOpration = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op1，线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOpration addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op2，线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOpration addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op3，线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    //最后需要执行的UI任务</span><br><span class="line">    [blockOpration setCompletionBlock:^&#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSLog(@&quot;++++最后执行UI任务~，线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    //开启任务</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queue addOperation:blockOpration];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">++++执行op1，线程:&lt;NSThread: 0x600003594d40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++执行op3，线程:&lt;NSThread: 0x6000035d9c80&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">++++执行op2，线程:&lt;NSThread: 0x6000035eeb40&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">++++最后执行UI任务~，线程:&lt;NSThread: 0x6000035f5dc0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-自定义NSOperation"><a href="#5-自定义NSOperation" class="headerlink" title="5.自定义NSOperation"></a>5.自定义NSOperation</h3><p>自定义时，需要重写 NSOperation 的<code>start</code>或<code>main</code>方法。</p>
<h4 id="5-1-重写main"><a href="#5-1-重写main" class="headerlink" title="5.1. 重写main"></a>5.1. 重写main</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)main;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1407732-main?language=objc" target="_blank" rel="noopener">Performs the receiver’s non-concurrent task</a>，执行非并发任务时重写此函数。<br>&emsp;</p>
<p>NSOperation 默认是非并发的，在不加入 Queue 的情况下，通过调用 <code>-(void)start</code> 对象方法在当前线程执行任务时， 会一直阻塞当前线程，直到任务完成。<code>-(void)main</code>方法默认情况下不做任何事，执行完成后属性<code>isExecuting</code>会被置为 NO， 属性<code>isFinished</code>被置为 YES。我们可以重写此方法以实现自定义的任务。重写时不能调用<code>super</code>，也不需要手动创建 autorelease pool，因为系统已自动帮你实现。<br>&emsp;</p>
<p>#示例6：自定义非并发 NSOperation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)main</span><br><span class="line">&#123;</span><br><span class="line">    if (self.isCancelled) return;</span><br><span class="line">    NSData *imageData = [[NSData alloc] initWithContentsOfURL:</span><br><span class="line">    [NSURL URLWithString:_mUrlStr]];</span><br><span class="line">    if (self.isCancelled) &#123;</span><br><span class="line">        imageData = nil;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.isCancelled) return;</span><br><span class="line">    if ([_delegate respondsToSelector:@selector(downloadFinishedWithData:)]) &#123;</span><br><span class="line">        [_delegate downloadFinishedWithData:imageData];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-重写start"><a href="#5-1-重写start" class="headerlink" title="5.1. 重写start"></a>5.1. 重写start</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)start;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1416837-start?language=objc" target="_blank" rel="noopener">Begins the execution of the operation</a>，If you are implementing a concurrent operation, you must override this method and use it to initiate your operation。<br>&emsp;</p>
<p>执行并发任务时“必须”重写此方法。<br>&emsp;</p>
<p>在没有被重写时，<code>start</code>方法的默认实现里会更新当前任务的执行状态，之后执行<code>-main</code>函数。此方法也会做一些检查，以确保当前任务能正常执行：如果任务已被取消或已完成，则<code>-start</code>方法直接返回并且不会再调用<code>-main</code>方法；如果任务正在执行或者尚未准备就绪，则会抛出异常；</p>
<blockquote>
<p>An operation is not considered ready to execute if it is still dependent on other operations that have not yet finished.</p>
</blockquote>
<p>重写<code>start</code>方法时也不能调用<code>super</code>函数，另外需要及时更新 isExecuting 和 isFinished 属性，并发出对应的 KVO 通知，因为在并发情况下系统不知道任务什么时候完成。自定义时，我们一般会将任务定义为异步执行，也就是说<code>start</code>函数返回了任务不一定就是完成了。 这个要你自己来控制，只有将 isFinished 置为 YES 时，operation 才算完成，才能出列和销毁。</p>
<h4 id="5-3-重写的示例"><a href="#5-3-重写的示例" class="headerlink" title="5.3.重写的示例"></a>5.3.重写的示例</h4><p>#示例7：自定义NSOperation子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//NetOperation.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@class NetOperation;</span><br><span class="line">//代理协议</span><br><span class="line">@protocol NetOperationDelegate&lt;NSObject&gt;</span><br><span class="line">- (void)downloadFinishedWithData:(id)data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NetOperation : NSOperation</span><br><span class="line">- (instancetype)initWithUrl:(NSString *)url </span><br><span class="line">delegate:(id&lt;NetOperationDelegate&gt;)delegate;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//NetOperation.m</span><br><span class="line">#import &quot;NetOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NetOperation()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *mUrlStr;</span><br><span class="line">@property (nonatomic, weak) id&lt;NetOperationDelegate&gt;delegate;</span><br><span class="line">@property (nonatomic, strong) NSURLSessionDownloadTask *dataTask;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NetOperation</span><br><span class="line">//因为父类的属性是readonly的，重载时如果需要setter的话则需要手动合成。</span><br><span class="line">@synthesize finished = _finished, executing = _executing;</span><br><span class="line"></span><br><span class="line">// 这里需要实现KVO相关的方法，NSOperationQueue是通过KVO来判断任务状态的</span><br><span class="line"></span><br><span class="line">- (void)setFinished:(BOOL)finished &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">    _finished = finished;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setExecuting:(BOOL)executing &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">    _executing = executing;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithUrl:(NSString *)url</span><br><span class="line">delegate:(id&lt;NetOperationDelegate&gt;)delegate&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _delegate = delegate;</span><br><span class="line">        _mUrlStr = url;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isAsynchronous&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    _delegate = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -重载start方法 实现业务需求</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        [self main];</span><br><span class="line">        self.executing = YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        [super cancel];</span><br><span class="line">        // 如果正在执行中则表示已经start过，可以将isFinished设为yes</span><br><span class="line">        if (self.isExecuting) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            self.executing = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        [_dataTask cancel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -BUSINESS</span><br><span class="line">-(void)main&#123;</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    _dataTask = [session downloadTaskWithURL:[NSURL URLWithString:_mUrlStr]</span><br><span class="line">    completionHandler:^(NSURL *location,NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            NSData *data = [NSData dataWithContentsOfFile:location.path];</span><br><span class="line">            strongSelf.finished = YES;</span><br><span class="line">            strongSelf.executing = NO;</span><br><span class="line">            if ([strongSelf.delegate respondsToSelector:@selector(downloadFinishedWithData:)]) &#123;</span><br><span class="line">                [strongSelf.delegate downloadFinishedWithData:data];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    //开始任务</span><br><span class="line">    [_dataTask resume];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>导入头文件，创建并执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)application:(UIApplication *)application </span><br><span class="line">willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *aQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NetOperation *anOperation = [[NetOperation alloc] initWithUrl:@&quot;xxx&quot; delegate:self];</span><br><span class="line">    [aQueue addOperation:anOperation];</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)downloadFinishedWithData:(id)data</span><br><span class="line">&#123;</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;++++++Reqest Finished!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>相关参考：</p>
<p>#<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW9" target="_blank" rel="noopener">©Apple-Operation Queues</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#多线程">
    <span class="tag-code">多线程</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/11/08/gcd.html">
        <span class="nav-arrow">← </span>
        
          多线程：GCD
        
      </a>
    
    
      <a class="nav-right" href="/2017/11/21/lock.html">
        
          iOS中的八大锁
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-与-GCD-的对比"><span class="toc-nav-text">1.与 GCD 的对比</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-GCD-的特点："><span class="toc-nav-text">1.1.GCD 的特点：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-NSOperation的特点："><span class="toc-nav-text">1.2.NSOperation的特点：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-NSOperation"><span class="toc-nav-text">2.NSOperation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-子类"><span class="toc-nav-text">2.1.子类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-状态"><span class="toc-nav-text">2.2.状态</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-优先级"><span class="toc-nav-text">2.3.优先级</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-4-服务质量"><span class="toc-nav-text">2.4.服务质量</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-NSOperationQueue"><span class="toc-nav-text">3.NSOperationQueue</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-两种队列"><span class="toc-nav-text">3.1.两种队列</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-添加任务"><span class="toc-nav-text">3.2.添加任务</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-并发数"><span class="toc-nav-text">3.3.并发数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-4-依赖关系"><span class="toc-nav-text">3.4.依赖关系</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-5-暂停-amp-取消任务"><span class="toc-nav-text">3.5.暂停&amp;取消任务</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-实现Group任务"><span class="toc-nav-text">4.实现Group任务</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-1-依赖关系"><span class="toc-nav-text">4.1.依赖关系</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#4-2-completionBlock"><span class="toc-nav-text">4.2.completionBlock</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-自定义NSOperation"><span class="toc-nav-text">5.自定义NSOperation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-重写main"><span class="toc-nav-text">5.1. 重写main</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-1-重写start"><span class="toc-nav-text">5.1. 重写start</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#5-3-重写的示例"><span class="toc-nav-text">5.3.重写的示例</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/11/17/nsoperation.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "多线程：NSOperation",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>