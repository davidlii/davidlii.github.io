<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"/> 
  
  <title>
    
      多线程：NSOperation | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>多线程：NSOperation</h2>
  <p class="post-date">2017-11-17</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>iOS2 时 OS X 与 iOS 的程序都普遍采用 NSOperation 来编写线程代码，而之后出现的 GCD 技术大体是依照前者的原则来实现的。随着 GCD 的普及，在iOS4 与 OS X 10.6 以后，OperationQueue 的底层都是用 GCD 来实现的。</p>
</blockquote>
<h3 id="1、与-GCD-的对比"><a href="#1、与-GCD-的对比" class="headerlink" title="1、与 GCD 的对比"></a>1、与 GCD 的对比</h3><h4 id="1-1-GCD-的特点："><a href="#1-1-GCD-的特点：" class="headerlink" title="1.1.GCD 的特点："></a>1.1.GCD 的特点：</h4><p>GCD 是面向过程的，它是由 C 语言构成的 API，一般与 block 结合使用，简洁高效；</p>
<h4 id="1-2-NSOperation的特点："><a href="#1-2-NSOperation的特点：" class="headerlink" title="1.2.NSOperation的特点："></a>1.2.NSOperation的特点：</h4><p><strong>复用率：</strong> NSOperation 是面向对象的，拥有更多的函数可用；同时它能被继承，这一方面方便了我们重写其部分方法以实现特殊功能；另一方面也让我们可以根据需求定义不同的子类，从而提高代码的复用率；<br>&emsp;</p>
<p><strong>依赖关系：</strong> NSOperation 能够方便地设置依赖关系，这样可以方便的让处于同一个并行队列中的两个任务按照我们指定的先后顺序执行；<br>&emsp;</p>
<p><strong>属性监测：</strong> NSOperation 提供了部分属性，我们可通过 KVO 监听一个任务是否完成或取消。这让我们能比 GCD 更加有效地掌任务的进度和状态；<br>&emsp;</p>
<p><strong>优先级设置：</strong> NSOperation 中能设置任务的优先级，使同一个并行队列中的任务区分先后地执行。GCD 中只能区分不同任务队列的优先级，如果要区分 block 内任务的优先级，需要复杂的代码；</p>
<h3 id="2、NSOperation"><a href="#2、NSOperation" class="headerlink" title="2、NSOperation"></a>2、NSOperation</h3><p>NSOperation 是一个基类，不能直接使。系统给我们提供了它的两个可以直接使用的子类：NSInvocationOperation 和 NSBlockOperation。当然你也可以自定义一个基于 NSOperation 的子类。</p>
<h4 id="2-1-子类"><a href="#2-1-子类" class="headerlink" title="2.1.子类"></a>2.1.子类</h4><p>#示例1（NSInvocationOperation）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)operationGo</span><br><span class="line">&#123;</span><br><span class="line">    //invocation Operation</span><br><span class="line">    NSInvocationOperation *invocOperation = [[NSInvocationOperation alloc] </span><br><span class="line">    initWithTarget:self </span><br><span class="line">    selector:@selector(operationAction) </span><br><span class="line">    object:nil];</span><br><span class="line">    </span><br><span class="line">    //执行结束后调用的Block</span><br><span class="line">    [invocOperation setCompletionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++invocation Finished&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [invocOperation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)operationAction</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;++++execute invocation，</span><br><span class="line">    \n++++线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">19:36:47.706220 ++++execute invocation，</span><br><span class="line">++++线程:&lt;NSThread: 0x600000065f80&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">19:36:47.706452 ++++invocation Finished</span><br></pre></td></tr></table></figure>
<p>#示例2（NSBlockOperation）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)blockOperationGo</span><br><span class="line">&#123;</span><br><span class="line">    //block Operation</span><br><span class="line">    NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++execute block，\n++++线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation addExecutionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++added block, \n++++线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation setCompletionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++block Finished&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    [blockOperation start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">19:52:59.475287 ++++added block,</span><br><span class="line">++++线程:&lt;NSThread: 0x60400027c4c0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">19:52:59.475291 ++++execute block，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000078080&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">19:52:59.475525 ++++block Finished</span><br></pre></td></tr></table></figure>
<p>从上述示例及其输出结果中可以看到：<br>&emsp;</p>
<p>NSOperation 的俩子类在单独使用时都没有开辟新线程的能力，任务会在当前线程中同步执行。<br>&emsp;</p>
<p>NSBlockOperation 使用 addExecutionBlock 添加额外任务时，这些任务会在不同线程中并发执行。</p>
<h4 id="2-2-状态"><a href="#2-2-状态" class="headerlink" title="2.2.状态"></a>2.2.状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL executing;</span><br><span class="line">BOOL finished;</span><br><span class="line">BOOL asynchronous;</span><br><span class="line">BOOL ready;</span><br></pre></td></tr></table></figure>
<ul>
<li>isReady</li>
</ul>
<p>表示这个 operation 是否已做好准备去去执行。=NO 表示它依赖的相关 operation 尚未完成。</p>
<ul>
<li>isExecuting</li>
</ul>
<p>表示当前 operation 中的任务是否正在执行。</p>
<ul>
<li>isFinished</li>
</ul>
<p>= YES 时表示当任务已完成或者已被取消。只有此属性为YES时 operation 才会从队列中出列。</p>
<ul>
<li>isCancelled</li>
</ul>
<p>当前 operation 是否被取消了。在自定义子类的任务开始前，需要在 start 方法中检查此属性。当 = YES 时应该立刻退出，同时将 finished属性设置为YES，executing 属性设置为 NO。</p>
<ul>
<li>isAsynchronous</li>
</ul>
<p>表示 operation 在当前线程是异步还是同步执行，默认值为NO。执行异步 operation 时必须重写此属性并返回 YES。<br>&emsp;</p>
<p>注意：NSOperationQueue 是通过 KVO 观察内部的 NSOperation 状态的变化，来自动管理 NSOperation 的执行的。重写 start 方法时，我们必须自己维护 isExecuting、isFinished 的值并正确的发送相关 KVO 通知。</p>
<h4 id="2-3-优先级-amp-服务质量"><a href="#2-3-优先级-amp-服务质量" class="headerlink" title="2.3.优先级&amp;服务质量"></a>2.3.优先级&amp;服务质量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;</span><br><span class="line">    NSOperationQueuePriorityVeryLow = -8L,</span><br><span class="line">    NSOperationQueuePriorityLow = -4L,</span><br><span class="line">    NSOperationQueuePriorityNormal = 0,</span><br><span class="line">    NSOperationQueuePriorityHigh = 4,</span><br><span class="line">    NSOperationQueuePriorityVeryHigh = 8</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, NSQualityOfService) &#123;</span><br><span class="line">    NSQualityOfServiceUserInteractive = 0x21,</span><br><span class="line">    NSQualityOfServiceUserInitiated = 0x19,</span><br><span class="line">    NSQualityOfServiceUtility = 0x11,</span><br><span class="line">    NSQualityOfServiceBackground = 0x09,</span><br><span class="line">    NSQualityOfServiceDefault = -1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在iOS 8.0 前，通过设置操作的优先级，尽可能的保证某个操作优先处理。随着硬件性能上的提升，通过设置优先级效果已经越来越不明显，在iOS 8.0 后，推出了服务质量，通过设置服务质量，让系统优先处理某一个操作。</p>
<h3 id="3、NSOperationQueue"><a href="#3、NSOperationQueue" class="headerlink" title="3、NSOperationQueue"></a>3、NSOperationQueue</h3><p>NSOperation 单独使用时，不具备开启新线程的能力，只有配合 NSOperationQueue 才能实现异步执行。配合使用时，NSOperation 相当于GCD中的任务，而 NSOperationQueue 则相当于GCD中的队列。将任务加入到队列中后，系统会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作，不需要再手动调用start。</p>
<h4 id="3-1-两种队列"><a href="#3-1-两种队列" class="headerlink" title="3.1.两种队列"></a>3.1.两种队列</h4><ul>
<li>主队列：（任务会在主线程执行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
<ul>
<li>其他队列：（任务会放到子线程中执行）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br></pre></td></tr></table></figure>
<h4 id="3-2-添加任务"><a href="#3-2-添加任务" class="headerlink" title="3.2.添加任务"></a>3.2.添加任务</h4><p>#示例3：-addOperation:(NSOperation *)op;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)addOperation</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    </span><br><span class="line">    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] </span><br><span class="line">    initWithTarget:self </span><br><span class="line">    selector:@selector(run) </span><br><span class="line">    object:nil];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation </span><br><span class="line">    blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务，</span><br><span class="line">        \n++++线程:%@&quot;, </span><br><span class="line">        [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;++++执行invocation operation任务，</span><br><span class="line">    \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程调用之后，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">21:55:06.217095 ++++执行block任务，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000268cc0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">21:55:06.217101 ++++执行invocation operation任务，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000268c80&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>#示例4：-addOperationWithBlock:(void (^)(void))block;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)addBlockOperation</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    //最大并发数</span><br><span class="line">    //queue.maxConcurrentOperationCount = 1;</span><br><span class="line">    //queue.maxConcurrentOperationCount = 2;</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务1，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务2，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务3，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行block任务4，</span><br><span class="line">        \n++++线程:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程调用之后，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">21:51:26.323988 ++++执行block任务3，</span><br><span class="line">++++线程:&lt;NSThread: 0x60000046c180&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">21:51:26.323992 ++++执行block任务4，</span><br><span class="line">++++线程:&lt;NSThread: 0x60000046c1c0&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">21:51:26.323993 ++++执行block任务1，</span><br><span class="line">++++线程:&lt;NSThread: 0x60400026a000&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">21:51:26.324042 ++++执行block任务2，</span><br><span class="line">++++线程:&lt;NSThread: 0x60400026a280&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>结合 NSOperationQueue 后，任务都在不同线程里并发执行，具备了开启新线程的能力。</p>
<h4 id="3-3-并发数"><a href="#3-3-并发数" class="headerlink" title="3.3.并发数"></a>3.3.并发数</h4><ul>
<li>-1，默认值，表示不进行限制，默认为并发执行；</li>
<li>=0，阻塞、都不执行；</li>
<li>=1，串行；</li>
<li>>1，并发；</li>
</ul>
<p>上面#示例4中，如果让 maxConcurrentOperationCount = 1，则队列为串行，输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">22:16:32.055189 ++++执行block任务1，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">22:16:32.055495 ++++执行block任务2，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">22:16:32.056026 ++++执行block任务3，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">22:16:32.056249 ++++执行block任务4，</span><br><span class="line">++++线程:&lt;NSThread: 0x604000272240&gt;&#123;number = 3, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，队列中的任务按照串行的方式在执行。不设置或者=2时，任务会并发执行，开启线程数量是由系统决定的，不需要我们来管理。</p>
<h4 id="3-4-依赖关系"><a href="#3-4-依赖关系" class="headerlink" title="3.4.依赖关系"></a>3.4.依赖关系</h4><p>#示例5：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)dependenceGo</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op1&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op2&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;++++执行op3&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op1 addDependency:op2];</span><br><span class="line">    [op2 addDependency:op3];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">22:31:43.603155 ++++执行op3</span><br><span class="line">22:31:43.603399 ++++执行op2</span><br><span class="line">22:31:43.603677 ++++执行op1</span><br></pre></td></tr></table></figure>
<p>如果不添加依赖，则3个任务会并发执行，先后顺序不定。添加依赖后，3个任务则按照设定倒序执行。</p>
<h4 id="3-5-暂停-amp-取消任务"><a href="#3-5-暂停-amp-取消任务" class="headerlink" title="3.5.暂停&amp;取消任务"></a>3.5.暂停&amp;取消任务</h4><ul>
<li>取消任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel;//NSOperation的方法 取消单个任务。</span><br><span class="line">- (void)cancelAllOperations;//NSOperationQueue的方法，取消队列中的所有任务。</span><br></pre></td></tr></table></figure>
<ul>
<li>暂停任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setSuspended:(BOOL)b;//设置任务的暂停和恢复</span><br></pre></td></tr></table></figure>
<p>暂停和取消，都只对队列中尚未执行的任务有效。</p>
<h3 id="4、自定义NSOperation的子类"><a href="#4、自定义NSOperation的子类" class="headerlink" title="4、自定义NSOperation的子类"></a>4、自定义NSOperation的子类</h3><p>自定义时，需要重写 NSOperation 的 start 或 main 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)main;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1407732-main?language=objc" target="_blank" rel="noopener">Performs the receiver’s non-concurrent task</a>，执行非并发任务时重写此函数。<br>&emsp;</p>
<p>NSOperation 默认是非并发的，在不加入 Queue 的情况下，通过调用 <code>-(void)start</code> 对象方法在当前线程执行任务时， 会一直阻塞当前线程，直到任务完成。<code>-(void)main</code>方法默认情况下不做任何事，执行完成后属性<code>isExecuting</code>会被置为 NO， 属性<code>isFinished</code>被置为 YES。我们可以重写此方法以实现自定义的任务。重写时不能调用<code>super</code>，也不需要手动创建 autorelease pool，因为系统已自动帮你实现。<br>&emsp;</p>
<p>#示例6：自定义非并发 NSOperation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)main</span><br><span class="line">&#123;</span><br><span class="line">    if (self.isCancelled) return;</span><br><span class="line">    NSData *imageData = [[NSData alloc] initWithContentsOfURL:</span><br><span class="line">    [NSURL URLWithString:_mUrlStr]];</span><br><span class="line">    if (self.isCancelled) &#123;</span><br><span class="line">        imageData = nil;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.isCancelled) return;</span><br><span class="line">    if ([_delegate respondsToSelector:@selector(downloadFinishedWithData:)]) &#123;</span><br><span class="line">        [_delegate downloadFinishedWithData:imageData];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)start;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1416837-start?language=objc" target="_blank" rel="noopener">Begins the execution of the operation</a>，If you are implementing a concurrent operation, you must override this method and use it to initiate your operation。<br>&emsp;</p>
<p>执行并发任务时“必须”重写此方法。<br>&emsp;</p>
<p>在没有被重写时，<code>start</code>方法的默认实现里会更新当前任务的执行状态，之后执行<code>-main</code>函数。此方法也会做一些检查，以确保当前任务能正常执行：如果任务已被取消或已完成，则<code>-start</code>方法直接返回并且不会再调用<code>-main</code>方法；如果任务正在执行或者尚未准备就绪，则会抛出异常；</p>
<blockquote>
<p>An operation is not considered ready to execute if it is still dependent on other operations that have not yet finished.</p>
</blockquote>
<p>重写<code>start</code>方法时也不能调用<code>super</code>函数，另外需要及时更新 isExecuting 和 isFinished 属性，并发出对应的 KVO 通知，因为在并发情况下系统不知道任务什么时候完成。自定义时，我们一般会将任务定义为异步执行，也就是说<code>start</code>函数返回了任务不一定就是完成了。 这个要你自己来控制，只有将 isFinished 置为 YES 时，operation 才算完成，才能出列和销毁。<br>&emsp;</p>
<p>#示例7：自定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//NetOperation.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@class NetOperation;</span><br><span class="line">//代理协议</span><br><span class="line">@protocol NetOperationDelegate&lt;NSObject&gt;</span><br><span class="line">- (void)downloadFinishedWithData:(id)data;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NetOperation : NSOperation</span><br><span class="line">- (instancetype)initWithUrl:(NSString *)url </span><br><span class="line">delegate:(id&lt;NetOperationDelegate&gt;)delegate;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//NetOperation.m</span><br><span class="line">#import &quot;NetOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@interface NetOperation()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *mUrlStr;</span><br><span class="line">@property (nonatomic, weak) id&lt;NetOperationDelegate&gt;delegate;</span><br><span class="line">@property (nonatomic, strong) NSURLSessionDownloadTask *dataTask;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NetOperation</span><br><span class="line">//因为父类的属性是readonly的，重载时如果需要setter的话则需要手动合成。</span><br><span class="line">@synthesize finished = _finished, executing = _executing;</span><br><span class="line"></span><br><span class="line">// 这里需要实现KVO相关的方法，NSOperationQueue是通过KVO来判断任务状态的</span><br><span class="line"></span><br><span class="line">- (void)setFinished:(BOOL)finished &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">    _finished = finished;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setExecuting:(BOOL)executing &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">    _executing = executing;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithUrl:(NSString *)url</span><br><span class="line">delegate:(id&lt;NetOperationDelegate&gt;)delegate&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _delegate = delegate;</span><br><span class="line">        _mUrlStr = url;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isAsynchronous&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    _delegate = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -重载start方法 实现业务需求</span><br><span class="line">- (void)start &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        [self main];</span><br><span class="line">        self.executing = YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        [super cancel];</span><br><span class="line">        // 如果正在执行中则表示已经start过，可以将isFinished设为yes</span><br><span class="line">        if (self.isExecuting) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            self.executing = NO;</span><br><span class="line">        &#125;</span><br><span class="line">        [_dataTask cancel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -BUSINESS</span><br><span class="line">-(void)main&#123;</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    _dataTask = [session downloadTaskWithURL:[NSURL URLWithString:_mUrlStr]</span><br><span class="line">    completionHandler:^(NSURL *location,NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">            NSData *data = [NSData dataWithContentsOfFile:location.path];</span><br><span class="line">            strongSelf.finished = YES;</span><br><span class="line">            strongSelf.executing = NO;</span><br><span class="line">            if ([strongSelf.delegate respondsToSelector:@selector(downloadFinishedWithData:)]) &#123;</span><br><span class="line">                [strongSelf.delegate downloadFinishedWithData:data];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    //开始任务</span><br><span class="line">    [_dataTask resume];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>导入头文件，创建并执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)application:(UIApplication *)application </span><br><span class="line">willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *aQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NetOperation *anOperation = [[NetOperation alloc] initWithUrl:@&quot;xxx&quot; delegate:self];</span><br><span class="line">    [aQueue addOperation:anOperation];</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)downloadFinishedWithData:(id)data</span><br><span class="line">&#123;</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;++++++Reqest Finished!&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>相关参考：</p>
<p>#<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW9" target="_blank" rel="noopener">©Apple-Operation Queues</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#多线程" >
    <span class="tag-code">多线程</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/11/08/gcd.html">
        <span class="nav-arrow">← </span>
        
          多线程：GCD
        
      </a>
    
    
      <a class="nav-right" href="/2017/11/21/lock.html">
        
          iOS中的八大锁
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1、与-GCD-的对比"><span class="toc-nav-text">1、与 GCD 的对比</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-1-GCD-的特点："><span class="toc-nav-text">1.1.GCD 的特点：</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-2-NSOperation的特点："><span class="toc-nav-text">1.2.NSOperation的特点：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2、NSOperation"><span class="toc-nav-text">2、NSOperation</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-1-子类"><span class="toc-nav-text">2.1.子类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-2-状态"><span class="toc-nav-text">2.2.状态</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-3-优先级-amp-服务质量"><span class="toc-nav-text">2.3.优先级&amp;服务质量</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3、NSOperationQueue"><span class="toc-nav-text">3、NSOperationQueue</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-两种队列"><span class="toc-nav-text">3.1.两种队列</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-添加任务"><span class="toc-nav-text">3.2.添加任务</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-并发数"><span class="toc-nav-text">3.3.并发数</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-4-依赖关系"><span class="toc-nav-text">3.4.依赖关系</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-5-暂停-amp-取消任务"><span class="toc-nav-text">3.5.暂停&amp;取消任务</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4、自定义NSOperation的子类"><span class="toc-nav-text">4、自定义NSOperation的子类</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/11/17/nsoperation.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "多线程：NSOperation",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>