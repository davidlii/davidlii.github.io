<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"/> 
  
  <title>
    
      多线程：GCD | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>多线程：GCD</h2>
  <p class="post-date">2017-11-08</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><code>GCD</code>是苹果公司在<code>线程池模式</code>基础上开发的一套多核编程的较新的解决方案。它的优点有：</p>
<ul>
<li>底层是由C语言实现，API使用时简洁明了；</li>
<li>为多核处理器而设计，会自动利用更多的CPU内核进行运算，执行效率高；</li>
<li>会自动管理线程的生命周期，不需要我们写任何线程管理的代码，只需告诉它我们想要执行的任务。</li>
</ul>
<h3 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2.同步与异步"></a>2.同步与异步</h3><p>GCD中同步和异步是将任务以 block 的形式提交到指定的队列中时使用的两种方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p>调用<code>dispatch_sync</code>函数来同步地执行任务。函数会一直等到 blcok 执行完才返回，这会阻塞当前线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p>调用<code>dispatch_async</code>函数异步地执行任务。函数在提交完任务后不等待 block 执行完就立刻返回了，不会阻塞当前线程。</p>
<h3 id="3-串行与并发队列"><a href="#3-串行与并发队列" class="headerlink" title="3.串行与并发队列"></a>3.串行与并发队列</h3><p>当有多个任务时，可以将它们放在队列中执行，队列分为串行和并发两种：<br>&emsp;</p>
<p><strong>串行队列</strong>：任务是按照FIFO的顺序执行的，先提交的任务先执行，后提交的任务须等前一个任务执行完成才能开始。对于不同的串行队列，系统会为它们创建不同的线程来执行任务。<br>&emsp;</p>
<p><strong>并发队列</strong>：任务也是按照FIFO的顺序执行，不同的是，任务不是必须等到前一个执行完才开始，同一时间可能会有多个任务在执行。GCD 会动态分配多条线程来执行这些任务，具体几条线程取决于当前内存状况和线程池中线程数等因素。<br>&emsp;</p>
<p>#<strong>特殊的串行队列：</strong> main_queue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//主队列本身是系统提供的一种特殊的串行队列</span><br><span class="line">//放在主队列中的任务都会在主线程中执行</span><br><span class="line">dispatch_queue_t mainQueue   = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<p>#<strong>特殊的并发队列：</strong> global_queue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//全局队列是系统提供的一种特殊并发队列</span><br><span class="line">//第一个参数指定queue的优先级,分为HIGH\DEFAULT\LOW\BACKGROUND四种;</span><br><span class="line">//第二个参数，目前只能为0或NULL;</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_ PRIORITY_DEFAULT,0);</span><br></pre></td></tr></table></figure>
<h4 id="3-1-任务-队列-的组合"><a href="#3-1-任务-队列-的组合" class="headerlink" title="3.1.任务+队列 的组合"></a>3.1.任务+队列 的组合</h4><table>
<thead>
<tr>
<th>.</th>
<th>并发队列</th>
<th>串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步</td>
<td>不能开启新线程,串行执行任务</td>
<td>不能开启新线程,串行执行任务</td>
<td>不能开启新线程,串行执行任务</td>
</tr>
<tr>
<td>异步</td>
<td>可以开启新线程,并发执行任务</td>
<td>可以开启新线程,串行执行任务</td>
<td>不能开启新线程,串行执行任务</td>
</tr>
</tbody>
</table>
<p>&emsp;</p>
<p>注意：不能开启新线程，就要继续运行在当前线程中。<br>&emsp;</p>
<p>#示例3.1.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_sync(concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;+++Thread:%@,main?:%d&quot;,[NSThread currentThread],[NSThread isMainThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动后输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+++Thread:&lt;NSThread: 0x6000000dca40&gt;&#123;number = 1, name = main&#125;,main?:1</span><br></pre></td></tr></table></figure>
<p>分析：示例中向并发队列<code>concurrentQueue</code>中同步的提交了一个打印日志的任务，虽然并发队列具有开辟新线程的能力，但是结合上<code>dispatch_sync</code>之后，就不行了，任务会继续运行在当前的主线程上。输出结果中“name = main” 且 “main?:1”也印证了这一点。<br>&emsp;</p>
<p>再注意：可以开启新线程，也不一定就真的会开辟新线程执行新的任务，要根据线程池中的状况来决定是开辟新线程，还是继续在当前线程上执行任务。<br>&emsp;</p>
<p>#示例3.1.2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrent&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    //step.1</span><br><span class="line">    dispatch_async(concurrentQueue, ^&#123;//具有开启新线程的能力</span><br><span class="line">        NSLog(@&quot;+++Thread1:%@,main?:%d&quot;,[NSThread currentThread],[NSThread isMainThread]);</span><br><span class="line">        //step.2</span><br><span class="line">        dispatch_async(concurrentQueue, ^&#123;//具有开启新线程的能力</span><br><span class="line">            NSLog(@&quot;+++Thread2:%@,main?:%d&quot;,[NSThread currentThread],[NSThread isMainThread]);</span><br><span class="line">            //step.3</span><br><span class="line">            dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                NSLog(@&quot;+++Thread3:%@,main?:%d&quot;,[NSThread currentThread],[NSThread isMainThread]);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        //step.4</span><br><span class="line">//        for (int i = 0; i&lt; 0xffffffff; i++)&#123;//for循环很多次，模拟大量运算</span><br><span class="line">//        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后日志为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++Thread1:&lt;NSThread: 0x600003bd5500&gt;&#123;number = 3, name = (null)&#125;,main?:0</span><br><span class="line">+++Thread2:&lt;NSThread: 0x600003bd5500&gt;&#123;number = 3, name = (null)&#125;,main?:0</span><br><span class="line">+++Thread3:&lt;NSThread: 0x600003bb1900&gt;&#123;number = 1, name = main&#125;,main?:1</span><br></pre></td></tr></table></figure>
<p>step1处，异步+并发，已经具备了开启新线程的能力，从日志来看 Thread1“name = (null),main?:0”，已经不在主线程，开启了新线程；<br>&emsp;</p>
<p>step2处，异步+并发，也已具备了开启新线程的能力，从日志来看线程Thread2的地址“0x600003bd5500”与step1时一样，说明继续运行在当前线程上，并没有开辟新线程~<br>&emsp;</p>
<p>不过，如果把step4处的注释去掉，模拟一次复杂运算，则输出结果就不一样了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++Thread1:&lt;NSThread: 0x600000c98ec0&gt;&#123;number = 3, name = (null)&#125;,main?:0</span><br><span class="line">+++Thread2:&lt;NSThread: 0x600000cab140&gt;&#123;number = 4, name = (null)&#125;,main?:0</span><br><span class="line">+++Thread3:&lt;NSThread: 0x600000cfd900&gt;&#123;number = 1, name = main&#125;,main?:1</span><br></pre></td></tr></table></figure>
<p>可以看到，日志中Thread2与Thread1的地址已经不一样了。这是因为Thread1中有大量运算，Thread2处要开启一个新线程执行任务。<br>&emsp;</p>
<p>另外，线程和队列是两个不同的概念，主线程不等于主队列。主线程只有一个，它既可以运行主队列，也可以运行全局并发队列。反过来，主队列一定是在主线程中，全局并发队列则不一定，它也可以在子线程中。</p>
<h4 id="3-2-死锁问题"><a href="#3-2-死锁问题" class="headerlink" title="3.2.死锁问题"></a>3.2.死锁问题</h4><p>不能在主队列中使用“同步+主队列”的组合，下面就是典型的死锁<br>&emsp;</p>
<p>#示例3.2.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    //step.1</span><br><span class="line">    NSLog(@&quot;++++任务开始&quot;);</span><br><span class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(mainQueue, ^&#123;//step.2</span><br><span class="line">    NSLog(@&quot;++++处理任务A&quot;);</span><br><span class="line">    //do something</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //step.3</span><br><span class="line">    NSLog(@&quot;++++任务结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码行后，只会输出“++++任务开始”，并卡死在<code>dispatch_sync</code>这一行。这是因为：<code>viewDidAppear</code>默认是在主队列中，当主队列执行到 step2 时，<code>dispatch_sync</code>函数向主队列中提交了一个任务(任务A)。需要说明的是，主队列是运行在主线程中的，且是一个串行队列，它里面的任务按照先进先出的顺序一个一个执行；<code>dispatch_sync</code>提交任务的特点是会阻塞当前线程，并立刻开始执行其中的任务。那么问题就来了，主线程本来要按顺序执行step1、2、3，结果执行到<code>dispatch_sync</code>函数时被强行阻塞，并被要求立刻去执行任务A。而这是不可能的，因为主队列中的后续任务step3尚未完成，不能先执行后加入进来的任务A。所以形成一种局面：主队列在等待任务A完成，任务A又在等待主队列完成后续任务stp3，从而形成了死锁问题。<br>&emsp;</p>
<p>#示例3.2.2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//当前在主线程</span><br><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;seria&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_async(serialQueue, ^&#123;//block1</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    dispatch_sync(serialQueue, ^&#123;// block2</span><br><span class="line">        NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;4&quot;);</span><br></pre></td></tr></table></figure>
<p>上述示例中会先打印日志“4”，后打印“1”，之后在 <code>dispatch_sync</code> 这一行卡死。这其实与示例1 类似：因为 block1 是异步执行，所以函数立刻返回并打印“4”；但是 block1 内任务是在一个串行队列中，执行到<code>dispatch_sync</code>处时线程被阻塞，并被要求立刻在当前串行队列中再执行一个新任务 block2。这当然也行不通，因为当前线程已被block2阻塞，block2又在等待队列完成后续任务。这样也造成了相互等待的情况，形成了死锁。<br>&emsp;</p>
<p>小结：<strong>在当前串行队列A中再同步地提交一个新任务到队列A会造成死锁</strong>！</p>
<h4 id="3-3-线程间的通信"><a href="#3-3-线程间的通信" class="headerlink" title="3.3.线程间的通信"></a>3.3.线程间的通信</h4><p>通常为了避免UI阻塞，我们可以在异步线程中做一些耗时的任务，完成后回到主线程中更新UI。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    //图片的网络路径</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;xxx.jpg&quot;];</span><br><span class="line">    //加载图片</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    //生成图片</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line"></span><br><span class="line">    //回到主线程，刷新UI，显示图片。</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [self.imageView setImage:image];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>例子在主线程中调用，dispatch_async配合全局并发队列，开辟了一个新线程用来加载图片资源；加载完成后再通过dispatch_get_main_queue返回到主队列中更新视图。因为主队列默认在主线程中，所以更新视图的任务会在主线程中进行。</p>
<h3 id="4-栅栏：dispatch-barrier-async"><a href="#4-栅栏：dispatch-barrier-async" class="headerlink" title="4.栅栏：dispatch_barrier_async"></a>4.栅栏：dispatch_barrier_async</h3><p>作用：让队列中排在它前面任务先执行完毕，再执行自己，最后再执行后续任务。<br>&emsp;</p>
<p>场景：向并发队列中加入5个异步任务：1、2、3、4、5。由于是异步且并发，所以任务实际执行时并不一定按照 12345 的顺序来。如果我们要求执行完任务 3 之后才能执行任务 4 和 5，此时就可以使用 <code>栅栏</code> 这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_barrier_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务3栅栏&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;++++1&quot;);</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;++++2&quot;);</span><br><span class="line">dispatch_async(concurrentQueue, ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务5&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码运行后，日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">19:38:26.034816  ++++1</span><br><span class="line">19:38:26.034853  ++++任务1</span><br><span class="line">19:38:26.034853  ++++任务2</span><br><span class="line">19:38:26.035059  ++++2</span><br><span class="line">19:38:26.035251  ++++任务3栅栏</span><br><span class="line">19:38:26.035466  ++++任务4</span><br><span class="line">19:38:26.035475  ++++任务5</span><br></pre></td></tr></table></figure>
<p>需要注意的是，该函数需要同 <code>dispatch_queue_create()</code> 函数生成的 <code>concurrent</code> 队列一起使用。系统提供的全局队列 <code>dispatch_get_global_queue</code> 也是一种并发队列，如果把上述代码中的并发队列换成此全局队列，则输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">19:43:02.508720 ++++1</span><br><span class="line">19:43:02.508738 ++++任务3栅栏</span><br><span class="line">19:43:02.508738 ++++任务2</span><br><span class="line">19:43:02.508738 ++++任务1</span><br><span class="line">19:43:02.508965 ++++2</span><br><span class="line">19:43:02.508982 ++++任务4</span><br><span class="line">19:43:02.509211 ++++任务5</span><br></pre></td></tr></table></figure>
<p>栅栏并未起效！！！</p>
<h3 id="5、dispatch-barrier-sync"><a href="#5、dispatch-barrier-sync" class="headerlink" title="5、dispatch_barrier_sync"></a>5、dispatch_barrier_sync</h3><p>上面的代码中<code>dispatch_barrier_async</code>替换为<code>dispatch_barrier_sync</code>后，日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">19:41:18.053258 ++++任务1</span><br><span class="line">19:41:18.053256 ++++任务2</span><br><span class="line">19:41:18.053498 ++++任务3栅栏</span><br><span class="line">19:41:18.053620 ++++1</span><br><span class="line">19:41:18.053763 ++++2</span><br><span class="line">19:41:18.053795 ++++任务4</span><br><span class="line">19:41:18.053935 ++++任务5</span><br></pre></td></tr></table></figure>
<p>通过日志对比可以看出，两种情况下：<br>&emsp;</p>
<p>1、任务都是按照栅栏3之前的先执行，再是3本身，最后是45；</p>
<p>2、“++++数字”日志都是按照12的顺序执行的，只是在异步栅栏中，“++++数字” 与 “++++任务x”的打印了顺序不同。<br>&emsp;</p>
<p><strong>两者的区别：</strong></p>
<p>1、同步栅栏：将自己的任务插入到队列时，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们。</p>
<p>2、异步栅栏：将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务。</p>
<p>3、栅栏本身不论异步还是同步，都只会给队列中的任务设置栅栏，不会阻碍主线程的代码。</p>
<h3 id="6、延时：dispatch-after"><a href="#6、延时：dispatch-after" class="headerlink" title="6、延时：dispatch_after"></a>6、延时：dispatch_after</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(</span><br><span class="line">dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)),</span><br><span class="line">dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    //2秒后的延时任务 do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="7、一次性代码：dispatch-once"><a href="#7、一次性代码：dispatch-once" class="headerlink" title="7、一次性代码：dispatch_once"></a>7、一次性代码：dispatch_once</h3><p>作用：对于某个任务执行一次，且只执行一次。<code>dispatch_once</code> 被广泛使用在单例、缓存等代码中，用以保证在初始化时执行一次某任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t predicate;</span><br><span class="line">dispatch_once(&amp;predicate, ^&#123;</span><br><span class="line">    // some one-time task</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一个参数 <code>predicate</code> 用来保证执行一次，第二个参数是要执行一次的任务 block。</p>
<h3 id="8、迭代：dispatch-apply"><a href="#8、迭代：dispatch-apply" class="headerlink" title="8、迭代：dispatch_apply"></a>8、迭代：dispatch_apply</h3><p>作用：按指定的次数将指定的 block 追加到指定的队列中，并等到全部的处理执行结束。<br>&emsp;</p>
<p>#示例8.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;, @&quot;h&quot;, @&quot;i&quot;, @&quot;j&quot;];</span><br><span class="line">NSLog(@&quot;++++开始&quot;);</span><br><span class="line">dispatch_apply([array count], concurrentQueue, ^(size_t index) &#123;</span><br><span class="line">    NSLog(@&quot;%zu: %@&quot;, index, [array objectAtIndex:index]);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;++++结束&quot;);</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">20:37:06.511098 ++++开始</span><br><span class="line">20:37:06.511305 0: a</span><br><span class="line">20:37:06.511322 2: c</span><br><span class="line">20:37:06.511324 1: b</span><br><span class="line">20:37:06.511339 3: d</span><br><span class="line">20:37:06.511463 4: e</span><br><span class="line">20:37:06.511463 5: f</span><br><span class="line">20:37:06.511571 6: g</span><br><span class="line">20:37:06.511844 7: h</span><br><span class="line">20:37:06.511902 8: i</span><br><span class="line">20:37:06.512006 9: j</span><br><span class="line">20:37:06.512608 ++++结束</span><br></pre></td></tr></table></figure>
<p>上面示例中使用了并发队列，所以索引值并非完全按照 0~9 的顺序。可以使用串行队列来模拟 for 循环。另外，<code>dispatch_apply</code> 与 for 循环类似，不会立刻返回，它会在循环完成之后再继续执行后续代码。</p>
<h3 id="9、队列组：dispatch-group"><a href="#9、队列组：dispatch-group" class="headerlink" title="9、队列组：dispatch_group"></a>9、队列组：dispatch_group</h3><p>场景：在并发队列的N个任务执行完毕后继续某种操作。<br>&emsp;</p>
<p>用法：<code>dispatch_group_async</code> 配合 <code>dispatch_group_notify</code>：<br>&emsp;</p>
<p>#示例9.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//自定义的并发队列1</span><br><span class="line">dispatch_queue_t dispatchQueue1 = dispatch_queue_create(&quot;concurrentQueue1&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">//自定义的并发队列2</span><br><span class="line">dispatch_queue_t dispatchQueue2 = dispatch_queue_create(&quot;concurrentQueue2&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;++++1&quot;);</span><br><span class="line"></span><br><span class="line">//并发队列1上执行任务1</span><br><span class="line">dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        if (888 == i) &#123;</span><br><span class="line">            NSLog(@&quot;++++任务1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//并发队列1上执行任务2</span><br><span class="line">dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:5];</span><br><span class="line">    NSLog(@&quot;++++任务2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//并发队列2上执行任务3</span><br><span class="line">dispatch_group_async(dispatchGroup, dispatchQueue2, ^()&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:3];</span><br><span class="line">    NSLog(@&quot;++++任务3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//任务执行完成</span><br><span class="line">dispatch_group_notify(dispatchGroup,dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务完成&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;++++稍等一哈&quot;);</span><br><span class="line">dispatch_async(dispatchQueue2, ^&#123;</span><br><span class="line">    dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;++++哈~就不等&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;++++2&quot;);</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">23:19:07.260507 ++++1</span><br><span class="line">23:19:07.260754 ++++稍等一哈</span><br><span class="line">23:19:07.260764 ++++任务1</span><br><span class="line">23:19:07.260931 ++++2</span><br><span class="line">23:19:10.262718 ++++任务3</span><br><span class="line">23:19:12.262749 ++++任务2</span><br><span class="line">23:19:12.263288 ++++哈~就不等</span><br><span class="line">23:19:12.263323 ++++任务完成</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<p>1、一个Group可以和多个queue关联。</p>
<p>2、如果提交到队列中的与Group关联起来的任务全都执行完毕，则会调用dispatch_group_notify并且dispatch_group_wait会停止等待；</p>
<p>3、假设一个队列中有2个任务，只有第二个与Group进行了关联，则只要第二个任务完成，不论第一个任务是否已完成，都会收到dispatch_group_notify通知。</p>
<p>4、dispatch_group_wait会阻塞当前线程，直到任务全部完成或者等待时间超过设置的超时时间，所以不能放在主线程调用。</p>
<h3 id="10、dispatch-group-enter"><a href="#10、dispatch-group-enter" class="headerlink" title="10、dispatch_group_enter"></a>10、dispatch_group_enter</h3><p><code>dispatch_group_enter</code>、<code>dispatch_group_leave</code> 的作用与<code>dispatch_group_async</code>类似，需成对使用:<br>&emsp;</p>
<p>#示例10.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//自定义的并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;concurrentQueue1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;++++1&quot;);</span><br><span class="line"></span><br><span class="line">//并发队列上执行任务1</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        if (888 == i) &#123;</span><br><span class="line">            NSLog(@&quot;++++任务1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//并发队列上执行任务2</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:5];</span><br><span class="line">    NSLog(@&quot;++++任务2&quot;);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//任务执行完成</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务完成&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>与 dispatch_group_async 的区别（线程同步问题）:</strong><br>&emsp;</p>
<p>如果 <code>dispatch_group_async</code> 里执行的是异步代码，<code>dispatch_group_notify</code> 会直接触发而不会等待异步任务完成；而 <code>dispatch_group_enter</code>、和 <code>dispatch_group_leave</code> 则不会有这个问题，它们只需要在任务开始前 <code>enter</code> 结束后 <code>leave</code> 即可达到线程同步的效果。<br>&emsp;</p>
<p>#示例10.2：<code>dispatch_group_async</code> 执行异步任务时的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//自定义的并发队列1</span><br><span class="line">dispatch_queue_t dispatchQueue1 = dispatch_queue_create(&quot;concurrentQueue1&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">//自定义的并发队列2</span><br><span class="line">dispatch_queue_t dispatchQueue2 = dispatch_queue_create(&quot;concurrentQueue2&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_group_t dispatchGroup = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">//并发队列1上执行任务1</span><br><span class="line">dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;</span><br><span class="line">    dispatch_async(dispatchQueue2, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">        NSLog(@&quot;++++任务1&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//并发队列1上执行任务2</span><br><span class="line">dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;</span><br><span class="line">    dispatch_async(dispatchQueue2, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:8];</span><br><span class="line">        NSLog(@&quot;++++任务2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//任务执行完成</span><br><span class="line">dispatch_group_notify(dispatchGroup,dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务完成&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出日志为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">23:44:07.922035  ++++任务完成</span><br><span class="line">23:44:12.779272  ++++任务1</span><br><span class="line">23:44:15.779346  ++++任务2</span><br></pre></td></tr></table></figure></p>
<p><code>notify</code> 在任务开始时就触发了~<br>&emsp;</p>
<p>#示例10.3：<code>dispatch_group_enter</code> 与 <code>leave</code> 执行异步任务时的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//自定义的并发队列</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;concurrentQueue1&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:5];</span><br><span class="line">    NSLog(@&quot;++++任务1&quot;);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//并发队列1上执行任务2</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [NSThread sleepForTimeInterval:8];</span><br><span class="line">    NSLog(@&quot;++++任务2&quot;);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//任务执行完成</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(), ^()&#123;</span><br><span class="line">    NSLog(@&quot;++++任务完成&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出日志为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">23:47:40.996232 ++++任务1</span><br><span class="line">23:47:43.996054 ++++任务2</span><br><span class="line">23:47:43.996486 ++++任务完成</span><br></pre></td></tr></table></figure>
<p><code>notify</code> 在任务结束时才触发!</p>
<h3 id="11、线程挂起-恢复："><a href="#11、线程挂起-恢复：" class="headerlink" title="11、线程挂起/恢复："></a>11、线程挂起/恢复：</h3><p><code>dispatch_suspend</code>，<code>dispatch_resume</code> 提供了“挂起、恢复”队列的功能，可以暂停、恢复队列上的任务。但是这里的“挂起”，并不能保证可以立即停止队列上正在运行的 block。<br>&emsp;</p>
<p>#示例11.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;Queue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">//提交第一个任务，延时5秒输出日志</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    sleep(5);</span><br><span class="line">    NSLog(@&quot;++++第1个任务 延时5秒咯&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">//提交第二个任务，延时5秒输出日志</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    sleep(5);</span><br><span class="line">    NSLog(@&quot;++++第2个任务 延时5秒咯&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//延时1秒</span><br><span class="line">NSLog(@&quot;++++延时1秒&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line"></span><br><span class="line">//挂起队列</span><br><span class="line">NSLog(@&quot;++++挂起队列&quot;);</span><br><span class="line">dispatch_suspend(queue);</span><br><span class="line"></span><br><span class="line">//延时10秒</span><br><span class="line">NSLog(@&quot;++++延时10秒&quot;);</span><br><span class="line">sleep(10);</span><br><span class="line"></span><br><span class="line">//恢复队列</span><br><span class="line">NSLog(@&quot;++++恢复队列&quot;);</span><br><span class="line">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>
<p>输出日志为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:31:03.496471  ++++延时1秒</span><br><span class="line">00:31:04.497948  ++++挂起队列</span><br><span class="line">00:31:04.498351  ++++延时10秒</span><br><span class="line">00:31:08.501901  ++++第1个任务 延时5秒咯</span><br><span class="line">00:31:14.500083  ++++恢复队列</span><br><span class="line">00:31:19.506005  ++++第2个任务 延时5秒咯</span><br></pre></td></tr></table></figure>
<p>可以看出，在 <code>dispatch_suspend</code> 挂起队列后，第一个 block 还是在运行，并且正常输出。</p>
<h3 id="12、dispatch-set-target-queue"><a href="#12、dispatch-set-target-queue" class="headerlink" title="12、dispatch_set_target_queue"></a>12、dispatch_set_target_queue</h3><p>1、给目标队列设置优先级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.xx.xx&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</span><br><span class="line"></span><br><span class="line">//第一个参数是目标队列，第二个参数是参考队列；</span><br><span class="line">dispatch_set_target_queue(serialQueue, globalQueue);</span><br></pre></td></tr></table></figure>
<p>2、修改用户队列的目标队列，把需要执行的任务对象指定到另一队列中去处理。<br>&emsp;</p>
<p>一个串行队列中的任务，如果被拆分成了3个串行队列，但实际还需要这个任务同步执行，那么就会有问题。因为拆分出的这3个串行队列之间其实是并发运行的。这时使用 <code>dispatch_set_target_queue</code> 将这3个串行的队列指定到了同一目标，那么这3个串行队列在目标队列上就是同步执行的，不再是并发执行。<br>&emsp;</p>
<p>#示例12.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t targetQueue = dispatch_queue_create(&quot;targetQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue2 = dispatch_queue_create(&quot;queue2&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t queue3 = dispatch_queue_create(&quot;queue3&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">dispatch_set_target_queue(queue3, targetQueue);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue1, ^&#123;</span><br><span class="line">    NSLog(@&quot;++++任务1开始&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:3.f];</span><br><span class="line">    NSLog(@&quot;++++任务1结束&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue2, ^&#123;</span><br><span class="line">    NSLog(@&quot;++++任务2开始&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:2.f];</span><br><span class="line">    NSLog(@&quot;++++任务2结束&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue3, ^&#123;</span><br><span class="line">    NSLog(@&quot;++++任务3开始&quot;);</span><br><span class="line">    [NSThread sleepForTimeInterval:1.f];</span><br><span class="line">    NSLog(@&quot;++++任务3结束&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">20:33:46.163510 ++++任务1开始</span><br><span class="line">20:33:49.168193 ++++任务1结束</span><br><span class="line">20:33:49.168610 ++++任务2开始</span><br><span class="line">20:33:51.174090 ++++任务2结束</span><br><span class="line">20:33:51.174507 ++++任务3开始</span><br><span class="line">20:33:52.179501 ++++任务3结束</span><br></pre></td></tr></table></figure>
<p><code>dispatch_set_target_queue</code> 这个过程可以是动态的，可以实现队列的动态调度管理。执行这个操作后，<code>queue1</code> 上已经在执行的任务会继续在 <code>queue1</code> 执行，尚未执行的任务会在 <code>targetQueue</code> 上继续执行。</p>
<h3 id="13、设置队列标志"><a href="#13、设置队列标志" class="headerlink" title="13、设置队列标志"></a>13、设置队列标志</h3><p>作用：<code>dispatch_queue_set_specific</code>用来向指定队列里面设置一个标识，配合<code>dispatch_get_specific</code>使用。<br>&emsp;</p>
<p>#示例13.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    static const void *key = &quot;queueKey&quot;;</span><br><span class="line">    void *context = &quot;myQueueContext&quot;;</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t queue1 = dispatch_queue_create(&quot;queue1&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_queue_set_specific(queue1, key,context, NULL);</span><br><span class="line">    </span><br><span class="line">    if (dispatch_get_specific(key)) &#123;</span><br><span class="line">        //当前队列是主队列，不是queue1，所以取不到key对应的值。</span><br><span class="line">        NSLog(@&quot;++++主队列++queue1？：YES&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;++++主队列++queue1？：NO&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(queue1, ^&#123;</span><br><span class="line">        if (dispatch_get_specific(key)) &#123;</span><br><span class="line">            //当前队列是queue1，所以能取到specificKey对应的值。</span><br><span class="line">            NSLog(@&quot;++++异步串行队列++queue1？：YES&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;++++异步串行队列++queue1？：NO&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++++主队列++queue1？：NO</span><br><span class="line">++++异步串行队列++queue1？：YES</span><br></pre></td></tr></table></figure>
<h3 id="14、dispatch-block-cancel"><a href="#14、dispatch-block-cancel" class="headerlink" title="14、dispatch_block_cancel"></a>14、dispatch_block_cancel</h3><p>GCD中，任务是以block的形式被加入到队列中。iOS8之后新增<code>dispatch_block_cancel</code>方法，用以取消已加入队列但尚未执行的任务。需要注意的是，这个任务必须是用<code>dispatch_block_create</code>创建<code>dispatch_block_t</code>。再者，此方法只对尚未执行的block有效，对正在执行中的任务无效。<br>&emsp;</p>
<p>#示例14.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//取消任务3</span><br><span class="line">dispatch_queue_t conQueue = dispatch_queue_create(&quot;com.xxx.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block1 = dispatch_block_create(0, ^&#123;</span><br><span class="line">    sleep(5);</span><br><span class="line">    NSLog(@&quot;++++block1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block2 = dispatch_block_create(0, ^&#123;</span><br><span class="line">    NSLog(@&quot;++++block2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_t block3 = dispatch_block_create(0, ^&#123;</span><br><span class="line">    NSLog(@&quot;++++block3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(conQueue, block1);</span><br><span class="line">dispatch_async(conQueue, block2);</span><br><span class="line">dispatch_async(conQueue, block3);</span><br><span class="line">dispatch_block_cancel(block3);</span><br></pre></td></tr></table></figure>
<p>输出日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19:13:32.744754+0800 ++++block2</span><br><span class="line">19:13:37.749986+0800 ++++block1</span><br></pre></td></tr></table></figure>
<h3 id="15、dispatch-semaphore"><a href="#15、dispatch-semaphore" class="headerlink" title="15、dispatch_semaphore"></a>15、dispatch_semaphore</h3><p>信号量：就是一种可用来控制访问资源的数量的标识。当一个线程在进入一段关键代码之前，线程必须获取一个信号量，一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待前面的线程释放信号量。<br>&emsp;</p>
<p>有一个经典的停车场的例子：信号量的值就相当于剩余车位的数目，<code>dispatch_semaphore_wait</code>就相当于来了一辆车，<code>dispatch_semaphore_signal</code>就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create(value:Int)）），调用一次<code>dispatch_semaphore_signal</code>，剩余的车位就增加一个；调用一次<code>dispatch_semaphore_wait</code>剩余车位就减少一个；当剩余车位为0时，再来车（即调用<code>dispatch_semaphore_wait</code>）就只能等待。有耐心的车主会一直等下去，没耐心的车主在等待“一段时间”之后就会离开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建信号量，参数：信号量的初值，如果小于0则会返回NULL</span><br><span class="line">dispatch_semaphore_create（信号量值）</span><br><span class="line"></span><br><span class="line">//减少信号量，时间：DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER</span><br><span class="line">dispatch_semaphore_wait（信号量，等待时间）</span><br><span class="line"></span><br><span class="line">//释放信号量</span><br><span class="line">dispatch_semaphore_signal(信号量)</span><br></pre></td></tr></table></figure>
<p>#示例15.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//.控制并发数量</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(2);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;++++%i&quot;,i);</span><br><span class="line">        sleep(2);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;++++完成&quot;);</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">23:50:32.522688+0800  ++++0</span><br><span class="line">23:50:32.522688+0800  ++++1</span><br><span class="line">23:50:34.523953+0800  ++++2</span><br><span class="line">23:50:34.524072+0800  ++++3</span><br><span class="line">23:50:36.525054+0800  ++++4</span><br><span class="line">23:50:36.525415+0800  ++++5</span><br><span class="line">23:50:38.526054+0800  ++++6</span><br><span class="line">23:50:38.526064+0800  ++++7</span><br><span class="line">23:50:40.528645+0800  ++++8</span><br><span class="line">23:50:40.528668+0800  ++++9</span><br><span class="line">23:50:42.531713+0800  ++++完成</span><br></pre></td></tr></table></figure>
<p>上面代码中创建了初始值=2的信号量，每次for循环都会创建一个新的线程，线程结束时会增加一个信号，线程创建之前会检测信号量，当同时创建了2个线程之后，for循环就会阻塞，等待有线程结束之后会增加一个信号才继续执行，如此就形成了对并发的控制，如上就是一个并发数为 10 的一个线程队列。<br>&emsp;</p>
<p>#示例15.2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//初始信号量</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line">dispatch_queue_t quene = dispatch_queue_create(&quot;com.M.D&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">//任务1</span><br><span class="line">dispatch_async(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;任务1&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;完成任务1&quot;);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//任务2</span><br><span class="line">dispatch_async(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;任务2&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;完成任务2&quot;);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//任务3</span><br><span class="line">dispatch_async(quene, ^&#123;</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    NSLog(@&quot;任务3&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;完成任务3&quot;);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">18:48:55.203016 任务1</span><br><span class="line">18:48:56.208454 完成任务1</span><br><span class="line">18:48:56.208867 任务2</span><br><span class="line">18:48:57.210500 完成任务2</span><br><span class="line">18:48:57.210993 任务3</span><br><span class="line">18:48:58.213194 完成任务3</span><br></pre></td></tr></table></figure>
<h3 id="16、GCD-实现倒计时"><a href="#16、GCD-实现倒计时" class="headerlink" title="16、GCD 实现倒计时"></a>16、GCD 实现倒计时</h3><p>#示例16.1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void) GCDTimer</span><br><span class="line">&#123;</span><br><span class="line">    __block int timeout = 60; //倒计时时间</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    dispatch_source_t aTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);</span><br><span class="line">    </span><br><span class="line">    dispatch_source_set_timer(aTimer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行</span><br><span class="line">    </span><br><span class="line">    dispatch_source_set_event_handler(aTimer, ^&#123;</span><br><span class="line">        if(timeout&lt;=0)&#123; //倒计时结束，关闭</span><br><span class="line">            dispatch_source_cancel(aTimer);</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                //设置界面的按钮显示 根据自己需求设置</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                //设置界面的按钮显示 根据自己需求设置</span><br><span class="line">            &#125;);</span><br><span class="line">            timeout--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(aTimer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#多线程" >
    <span class="tag-code">多线程</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/11/07/nsthread.html">
        <span class="nav-arrow">← </span>
        
          多线程：NSThread
        
      </a>
    
    
      <a class="nav-right" href="/2017/11/17/nsoperation.html">
        
          多线程：NSOperation
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-简介"><span class="toc-nav-text">1.简介</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-同步与异步"><span class="toc-nav-text">2.同步与异步</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-串行与并发队列"><span class="toc-nav-text">3.串行与并发队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-任务-队列-的组合"><span class="toc-nav-text">3.1.任务+队列 的组合</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-死锁问题"><span class="toc-nav-text">3.2.死锁问题</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-3-线程间的通信"><span class="toc-nav-text">3.3.线程间的通信</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-栅栏：dispatch-barrier-async"><span class="toc-nav-text">4.栅栏：dispatch_barrier_async</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5、dispatch-barrier-sync"><span class="toc-nav-text">5、dispatch_barrier_sync</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6、延时：dispatch-after"><span class="toc-nav-text">6、延时：dispatch_after</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7、一次性代码：dispatch-once"><span class="toc-nav-text">7、一次性代码：dispatch_once</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8、迭代：dispatch-apply"><span class="toc-nav-text">8、迭代：dispatch_apply</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9、队列组：dispatch-group"><span class="toc-nav-text">9、队列组：dispatch_group</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10、dispatch-group-enter"><span class="toc-nav-text">10、dispatch_group_enter</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11、线程挂起-恢复："><span class="toc-nav-text">11、线程挂起/恢复：</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12、dispatch-set-target-queue"><span class="toc-nav-text">12、dispatch_set_target_queue</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#13、设置队列标志"><span class="toc-nav-text">13、设置队列标志</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#14、dispatch-block-cancel"><span class="toc-nav-text">14、dispatch_block_cancel</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15、dispatch-semaphore"><span class="toc-nav-text">15、dispatch_semaphore</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16、GCD-实现倒计时"><span class="toc-nav-text">16、GCD 实现倒计时</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/11/08/gcd.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "多线程：GCD",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>