

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Davidli">
  <meta name="keywords" content="Davidli">
  
    <meta name="description" content="1.简介GCD是在线程池模式基础上开发的一套多核编程的较新的解决方案：  底层由C语言实现，API使用时简洁明了； 为多核处理器而设计，会自动利用更多的CPU内核进行运算，执行效率高； 自动管理线程生命周期，无需手写线程管理的代码，只需告诉它我们想要执行的任务。  2.同步与异步同步和异步是将任务以 block 形式提交到指定队列中时所使用的两种方式。 1dispatch_sync(dispatc">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD">
<meta property="og:url" content="https://davidlii.cn/2017/11/08/gcd.html">
<meta property="og:site_name" content="Davidli">
<meta property="og:description" content="1.简介GCD是在线程池模式基础上开发的一套多核编程的较新的解决方案：  底层由C语言实现，API使用时简洁明了； 为多核处理器而设计，会自动利用更多的CPU内核进行运算，执行效率高； 自动管理线程生命周期，无需手写线程管理的代码，只需告诉它我们想要执行的任务。  2.同步与异步同步和异步是将任务以 block 形式提交到指定队列中时所使用的两种方式。 1dispatch_sync(dispatc">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-11-08T15:40:22.000Z">
<meta property="article:modified_time" content="2019-11-03T11:56:22.000Z">
<meta property="article:author" content="Davidli">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>GCD - Davidli</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"davidlii.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>嵇风</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="GCD"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-11-08 23:40" pubdate>
          2017年11月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          244 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">GCD</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><code>GCD</code>是在<code>线程池模式</code>基础上开发的一套多核编程的较新的解决方案：</p>
<ul>
<li>底层由C语言实现，API使用时简洁明了；</li>
<li>为多核处理器而设计，会自动利用更多的CPU内核进行运算，执行效率高；</li>
<li>自动管理线程生命周期，无需手写线程管理的代码，只需告诉它我们想要执行的任务。</li>
</ul>
<h3 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2.同步与异步"></a>2.同步与异步</h3><p>同步和异步是将任务以 block 形式提交到指定队列中时所使用的两种方式。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dispatch<span class="hljs-constructor">_sync(<span class="hljs-params">dispatch_queue_t</span> <span class="hljs-params">queue</span>, <span class="hljs-params">dispatch_block_t</span> <span class="hljs-params">block</span>)</span>;<br></code></pre></td></tr></table></figure>

<p><code>dispatch_sync</code>用于同步地执行任务。函数会一直等到 blcok 执行完才返回，这会阻塞当前线程。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dispatch<span class="hljs-constructor">_async(<span class="hljs-params">dispatch_queue_t</span> <span class="hljs-params">queue</span>, <span class="hljs-params">dispatch_block_t</span> <span class="hljs-params">block</span>)</span>;<br></code></pre></td></tr></table></figure>

<p><code>dispatch_async</code>用于异步地执行任务。函数在提交完任务后不等待 block 执行完就立刻返回了，不会阻塞当前线程。</p>
<h3 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h3><h4 id="1-串行与并发队列"><a href="#1-串行与并发队列" class="headerlink" title="1.串行与并发队列"></a>1.串行与并发队列</h4><p>当有多个任务时，可以将它们放在队列中执行，队列分为串行和并发两种：</p>
<p><strong>串行队列</strong>：任务是按照FIFO的顺序执行的，先提交的任务先执行，后提交的任务须等前一个任务执行完成才能开始。对于不同的串行队列，系统会为它们创建不同的线程来执行任务。</p>
<p><strong>并发队列</strong>：任务也是按照FIFO的顺序执行，不同的是，任务不是必须等到前一个执行完才开始，同一时间可能会有多个任务在执行。GCD 会动态分配多条线程来执行这些任务，具体几条线程取决于当前内存状况和线程池中线程数等因素。</p>
<p>#<strong>特殊的串行队列：</strong> main_queue</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>主队列本身是系统提供的一种特殊的串行队列<br><span class="hljs-regexp">//</span>放在主队列中的任务都会在主线程中执行<br>dispatch_queue_t mainQueue   = dispatch_get_main_queue();<br></code></pre></td></tr></table></figure>

<p>#<strong>特殊的并发队列：</strong> global_queue</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>全局队列是系统提供的一种特殊并发队列<br><span class="hljs-regexp">//</span>第一个参数指定queue的优先级,分为HIGH\DEFAULT\LOW\BACKGROUND四种;<br><span class="hljs-regexp">//</span>第二个参数，目前只能为<span class="hljs-number">0</span>或NULL;<br>dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_ PRIORITY_DEFAULT,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<h4 id="2-任务-队列-的组合"><a href="#2-任务-队列-的组合" class="headerlink" title="2.任务+队列 的组合"></a>2.任务+队列 的组合</h4><table>
<thead>
<tr>
<th>.</th>
<th>并发队列</th>
<th>串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody><tr>
<td>同步</td>
<td>不能开启新线程,串行执行任务</td>
<td>不能开启新线程,串行执行任务</td>
<td>不能开启新线程,串行执行任务</td>
</tr>
<tr>
<td>异步</td>
<td>可以开启新线程,并发执行任务</td>
<td>可以开启新线程,串行执行任务</td>
<td>不能开启新线程,串行执行任务</td>
</tr>
</tbody></table>
<p>注释：不能开启新线程，就要继续在当前线程中运行。</p>
<p>#示例3.2.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;concurrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <span class="hljs-built_in">dispatch_sync</span>(concurrentQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动后输出结果为：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">+++Thread:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x6000000dca40</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml">,main?:1</span><br></code></pre></td></tr></table></figure>

<p>分析：示例中向并发队列<code>concurrentQueue</code>中同步的提交了一个打印日志的任务，虽然并发队列具有开辟新线程的能力，但是结合上<code>dispatch_sync</code>之后，就不行了，任务会继续运行在当前的主线程上。输出结果中“name &#x3D; main” 且 “main?:1”也印证了这一点。</p>
<p>再注意：可以开启新线程，也不一定就真的会开辟新线程执行新的任务，系统要根据线程池中的状况来决定是开辟新线程，还是继续在当前空闲的线程上执行任务。</p>
<p>#示例3.2.2：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;concurrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <span class="hljs-comment">//step.1</span><br>    <span class="hljs-built_in">dispatch_async</span>(concurrentQueue, ^&#123;<span class="hljs-comment">//具有开启新线程的能力</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread1:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>        <span class="hljs-comment">//step.2</span><br>        <span class="hljs-built_in">dispatch_async</span>(concurrentQueue, ^&#123;<span class="hljs-comment">//具有开启新线程的能力</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread2:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>            <span class="hljs-comment">//step.3</span><br>            <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread3:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>            &#125;);<br>        &#125;);<br>        <span class="hljs-comment">//step.4</span><br><span class="hljs-comment">//        for (int i = 0; i&lt; 0xffffffff; i++)&#123;//for循环很多次，模拟大量运算</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行后日志为：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">+++Thread1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003bd5500</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003bd5500</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread3:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003bb1900</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml">,main?:1</span><br></code></pre></td></tr></table></figure>

<p><code>step1</code>处，异步+并发，已具备开启新线程的能力，从日志来看 Thread1 “main?:0”，已经不在主线程，开启了新线程；</p>
<p><code>step2</code>处，异步+并发，也具备开启新线程的能力，从日志来看线程 Thread2 的内存地址与 step1 时一样，说明继续运行在当前线程上，并没有开辟新线程~</p>
<p>不过，如果把<code>step4</code>处的注释去掉，模拟一次复杂运算，则输出结果就不一样了：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">+++Thread1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600000c98ec0</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600000cab140</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 4, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread3:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600000cfd900</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml">,main?:1</span><br></code></pre></td></tr></table></figure>

<p><code>Thread2</code>与<code>Thread1</code>的地址已经不一样了。这是因为<code>Thread1</code>中有大量运算，<code>Thread2</code>要开启一个新线程执行任务。</p>
<p>所以，同&#x2F;异步 + 串&#x2F;并行的组合，只是说明了任务所在队列，任务的提交方式和是否具备开辟新线程的能力。<strong>当具备开辟新线程的能力时，是否真的开辟新线程要由线程池的状况来确定</strong>。</p>
<h4 id="3-死锁问题"><a href="#3-死锁问题" class="headerlink" title="3.死锁问题"></a>3.死锁问题</h4><p>不能在主队列中使用“同步+主队列”的组合，下面就是典型的死锁</p>
<p>#示例3.3.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br>    <span class="hljs-comment">//step.1</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务开始&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();<br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(mainQueue, ^&#123;<span class="hljs-comment">//step.2</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++处理任务A&quot;</span>);<br>    <span class="hljs-comment">//do something</span><br>    &#125;);<br><br>    <span class="hljs-comment">//step.3</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码行后，只会输出“++++任务开始”，并卡死在<code>dispatch_sync</code>这一行。这是因为：<code>viewDidAppear</code>默认是在主队列中，当主队列执行到 step2 时，<code>dispatch_sync</code>函数向主队列中提交了一个任务A。需要说明的是，主队列是运行在主线程中的，且是一个串行队列，它里面的任务按照FIFO的顺序依次执行；<code>dispatch_sync</code>提交任务的特点是会阻塞当前线程，并立刻开始执行其中的任务。那么问题就来了，主线程本来要按顺序执行step1、2、3，结果执行到<code>dispatch_sync</code>函数时被强行阻塞，并被要求立刻去执行任务A。而这是不可能的，因为主队列中的后续任务step3尚未完成，不能先执行后加入进来的任务A。所以形成一种局面：主队列在等待任务A完成，任务A又在等待主队列完成后续任务stp3，从而形成了死锁问题。</p>
<p>#示例3.3.2：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//当前在主线程</span><br><span class="hljs-built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="hljs-string">&quot;seria&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><span class="hljs-built_in">dispatch_async</span>(serialQueue, ^&#123;<span class="hljs-comment">//block1</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_sync</span>(serialQueue, ^&#123;<span class="hljs-comment">// block2</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>&#125;);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>上述示例中会先打印日志“4”，后打印“1”，之后在 <code>dispatch_sync</code> 这一行卡死。这其实与示例1 类似：因为 block1 是异步执行，所以函数立刻返回并打印“4”；但是 block1 内任务是在一个串行队列中，执行到<code>dispatch_sync</code>处时线程被阻塞，并被要求立刻在当前串行队列中再执行一个新任务 block2。这当然也行不通，因为当前线程已被block2阻塞，block2又在等待队列完成后续任务。这样也造成了相互等待的情况，形成了死锁。</p>
<p>小结：在当前串行队列中再同步地提交一个新任务到队列中会造成死锁！</p>
<h4 id="4-线程间的通信"><a href="#4-线程间的通信" class="headerlink" title="4.线程间的通信"></a>4.线程间的通信</h4><p>通常为了避免UI阻塞，我们可以在异步线程中做一些耗时的任务，完成后回到主线程中更新UI。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-comment">//图片的网络路径</span><br>    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;xxx.jpg&quot;</span>];<br>    <span class="hljs-comment">//加载图片</span><br>    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];<br>    <span class="hljs-comment">//生成图片</span><br>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];<br><br>    <span class="hljs-comment">//回到主线程，刷新UI，显示图片。</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        [<span class="hljs-keyword">self</span>.imageView setImage:image];<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>例子在主线程中调用，dispatch_async配合全局并发队列，开辟了一个新线程用来加载图片资源；加载完成后再通过dispatch_get_main_queue返回到主队列中更新视图。因为主队列默认在主线程中，所以更新视图的任务会在主线程中进行。</p>
<h4 id="5-线程与队列"><a href="#5-线程与队列" class="headerlink" title="5.线程与队列"></a>5.线程与队列</h4><p><code>线程</code>和<code>队列</code>是两个不同的概念~</p>
<p><code>队列</code>是一种任务组织方式，任务被以 block 的形式提交到<code>队列</code>中，并最终在某个线程上执行，具体在哪个线程上执行是由<code>队列类型</code>和<code>提交任务时的方式</code>决定的。如#3.2小节中列出的那样，如果是<code>同步</code>的方式提交任务，则任务会继续在当前线程上执行；如果是<code>异步+并发队列</code>的方式提交的任务，那么内核会根据系统资源创建新线程来执行任务。</p>
<p><code>线程</code>是 CPU 调度和分派任务的基本单位，一个<code>线程</code>中可以执行多个<code>队列</code>中的任务。线程是可以重复利用的，这由线程池和系统资源状况来决定。</p>
<p><code>主线程</code>不等于<code>主队列</code>。主线程只有一个，主线程上既可以执行<code>主队列</code>中的任务，也可以执行<code>全局并发队列</code>或你<code>自定义队列</code>中的任务。</p>
<p>#示例：主线程执行非主队列的任务</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++1.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<span class="hljs-comment">//同步的提交任务，模拟任务还在当前线程执行</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++2.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>主队列</code>的任务一定在<code>主线程</code>中执行，全局并发队列或自定义队列中的任务可以在<code>子线程</code>中执行。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++1.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    <br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<span class="hljs-comment">//虽然异步提交主队列中的任务，但任务还是在主线程中执行</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++2.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很多跟 UI 相关的操作，一般都会放到<code>main_queue</code>主队列中进行，比如常见的<code>AFN</code>从子线程回到主队列更新图片。这是因为<code>UIKit</code>本身不是线程安全的，这些操作需要在系统提供的<code>主队列</code>这么一个<code>串行队列</code>中进行，保证操作的顺序和完整性。</p>
<h3 id="4-栅栏"><a href="#4-栅栏" class="headerlink" title="4.栅栏"></a>4.栅栏</h3><h4 id="1-dispatch-barrier-async"><a href="#1-dispatch-barrier-async" class="headerlink" title="1.dispatch_barrier_async"></a>1.dispatch_barrier_async</h4><p><strong>作用：</strong>让队列中排在它前面任务先执行完毕，再执行自己，最后再执行后续任务。</p>
<p><strong>场景：</strong>向并发队列中加入5个异步任务：1、2、3、4、5。由于是异步+并发，所以任务实际执行时并不一定按照 12345 的顺序来。如果我们要求执行完任务 3 之后才能执行任务 4 和 5，此时就可以使用<code>栅栏</code>这个功能。</p>
<p>#示例4.1：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- (void)barrier&#123;<br>    <span class="hljs-comment">//自定义并发队列</span><br>    dispatch_queue_t cQueue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;Name1&quot;</span>,DISPATCH_QUEUE_CONCURRENT)</span>;<br>    <br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务1:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务2:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务3栅栏:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++1&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务4:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++2&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务5:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">++++<span class="hljs-number">1</span><br>++++<span class="hljs-number">2</span><br>++++任务<span class="hljs-number">2</span>:&lt;NSThread: <span class="hljs-number">0x600003453f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">4</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">1</span>:&lt;NSThread: <span class="hljs-number">0x600003455f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">3</span>栅栏:&lt;NSThread: <span class="hljs-number">0x600003455f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">4</span>:&lt;NSThread: <span class="hljs-number">0x600003455f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">5</span>:&lt;NSThread: <span class="hljs-number">0x600003453f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">4</span>, name = (<span class="hljs-literal">null</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>从日志来看，任务的执行顺序正常：</p>
<ul>
<li>栅栏之前的任务1和2先执行;</li>
<li>随后是栅栏本身的任务3;</li>
<li>最后是栅栏之后的任务4和5。</li>
</ul>
<p>注意：栅栏只是用来控制同一并发队列中栅栏前后任务的整体执行顺序；至于栅栏前面的任务与后面的任务它们具体在哪个线程执行，这不是栅栏能决定的。</p>
<p>结合日志中任务所在线程的内存地址来看：</p>
<ul>
<li>栅栏之前的<code>任务1</code>和<code>任务2</code>并没在同一个线程中执行；</li>
<li>栅栏之后的<code>任务4</code>和<code>任务5</code>也没有在同一个线程中执行；</li>
<li>甚至栅栏前的<code>任务1</code>和栅栏<code>任务3</code>及栅栏之后的<code>任务4</code>使用了同一个线程；</li>
</ul>
<p>所以，栅栏后的任务具体是在哪个线程上执行，还是要看这些任务的提交方式和队列类型，之后交给线程池来决定。</p>
<p>但是，如果任务都是通过栅栏提交的，那么栅栏就能保证它们按照来时的顺序先后执行，且是在同一线程上：</p>
<p>#示例4.2：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- (void)barrier2&#123;<br>    <span class="hljs-comment">//自定义并发队列</span><br>    dispatch_queue_t cQueue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;Name1&quot;</span>,DISPATCH_QUEUE_CONCURRENT)</span>;<br>    <br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务1:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务2:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务3栅栏:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++1&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123; <span class="hljs-comment">//注意，这里换成了栅栏，不仅仅是异步了</span><br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务4:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++2&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123; <span class="hljs-comment">// 这里也是</span><br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务5:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">++++<span class="hljs-number">1</span><br>++++<span class="hljs-number">2</span><br>++++任务<span class="hljs-number">1</span>:&lt;NSThread: <span class="hljs-number">0x60000132cb80</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">2</span>:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">3</span>栅栏:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">4</span>:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">5</span>:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，提交到栅栏中的任务3、4、5是按照提交时的顺序执行的，且在同一个线程中。</p>
<p>另外，该函数需要同<code>dispatch_queue_create()</code>生成的并发队列一起用。如果示例4.1中换成全局队列则效果如下：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3栅栏</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务4</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务5</span><br></code></pre></td></tr></table></figure>

<p>任务1、2在栅栏3之后执行了，<strong>栅栏并未起效！！！</strong>，所以实际中须注意这一点~</p>
<h4 id="2-dispatch-barrier-sync"><a href="#2-dispatch-barrier-sync" class="headerlink" title="2.dispatch_barrier_sync"></a>2.dispatch_barrier_sync</h4><p>将示例4.1中栅栏替换为<code>dispatch_barrier_sync</code>后，日志如下：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3栅栏</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务4</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务5</span><br></code></pre></td></tr></table></figure>

<p>对比日志，两种情况下：</p>
<p>1、任务都是按照栅栏3之前的先执行，再是3本身，最后是45；</p>
<p>2、“++++数字”日志都是按照12的顺序执行，只是在异步栅栏中“++++数字” 与 “++++任务x”的打印了顺序不同。</p>
<p><strong>两者的区别：</strong></p>
<p>1、同步栅栏：将栅栏任务插入队列时，需等待栅栏任务结束后，才会继续插入并执行被写在它后面的任务；</p>
<p>2、异步栅栏：将栅栏任务插入队列后，不会等待栅栏任务结束，而是继续把后续任务插入队列中，栅栏任务结束后才执行后面的任务；</p>
<p>3、栅栏不论异步还是同步，都只会给自己并发队列中的任务设置栅栏，不会阻碍主线程的代码。</p>
<h3 id="5-延时：dispatch-after"><a href="#5-延时：dispatch-after" class="headerlink" title="5.延时：dispatch_after"></a>5.延时：dispatch_after</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">dispatch_after</span>(<br>dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">2.0</span> * NSEC_PER_SEC)),<br><span class="hljs-built_in">dispatch_get_main_queue</span>(), ^&#123;<br>    <span class="hljs-comment">//2秒后的延时任务 do something</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="6-dispatch-once"><a href="#6-dispatch-once" class="headerlink" title="6.dispatch_once"></a>6.dispatch_once</h3><p><strong>作用：</strong>广泛使用在单例中，用以保证初始化方法中的任务只执行一次。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> ASDFSingleton *mSingleton = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-comment">// 声明单例的方式1：</span><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance<br>&#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> alloc] init];<br>&#125;<br><br><span class="hljs-comment">//防止外部通过alloc或new的方式错误的创建了实例对象</span><br>+ (<span class="hljs-keyword">instancetype</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        mSingleton = [<span class="hljs-variable language_">super</span> allocWithZone:zone];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> mSingleton;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-dispatch-apply"><a href="#7-dispatch-apply" class="headerlink" title="7.dispatch_apply"></a>7.dispatch_apply</h3><p>作用：按指定的次数将任务追加到指定的队列中，并等到全部的处理执行结束。</p>
<p>#示例7.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 并发队列</span><br><span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;Name&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><span class="hljs-built_in">NSArray</span> *array = @[<span class="hljs-string">@&quot;a&quot;</span>, <span class="hljs-string">@&quot;b&quot;</span>, <span class="hljs-string">@&quot;c&quot;</span>, <span class="hljs-string">@&quot;d&quot;</span>, <span class="hljs-string">@&quot;e&quot;</span>, <span class="hljs-string">@&quot;f&quot;</span>, <span class="hljs-string">@&quot;g&quot;</span>, <span class="hljs-string">@&quot;h&quot;</span>, <span class="hljs-string">@&quot;i&quot;</span>, <span class="hljs-string">@&quot;j&quot;</span>];<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++开始&quot;</span>);<br><br>dispatch_apply([array count], concurrentQueue, ^(size_t index) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%zu,%@,ON:%@&quot;</span>, index, [array objectAtIndex:index], [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++结束&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">++++开始<br>++<span class="hljs-number">1</span>,b,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">0</span>,a,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++<span class="hljs-number">2</span>,c,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">3</span>,d,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++<span class="hljs-number">4</span>,e,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x600001055700</span>&gt;&#123;number = <span class="hljs-number">5</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">5</span>,f,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">7</span>,h,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x600001055700</span>&gt;&#123;number = <span class="hljs-number">5</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">6</span>,g,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++<span class="hljs-number">8</span>,i,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">9</span>,j,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++++结束<br></code></pre></td></tr></table></figure>

<p>多运行几次，可以从日志中发现：</p>
<ul>
<li>打印的索引值并非完全按照 0~9 的升序排列；</li>
<li>遍历元素的操作并非都在同一个线程中；</li>
</ul>
<p>如果希望索引值完全按照 0~9 的升序排列，可以使用串行队列，这样就类似于<code>for</code>循环了。</p>
<p>#示例7.2：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 串行队列</span><br><span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;Name&quot;</span>,DISPATCH_QUEUE_SERIAL);<br><span class="hljs-built_in">NSArray</span> *array = @[<span class="hljs-string">@&quot;a&quot;</span>, <span class="hljs-string">@&quot;b&quot;</span>, <span class="hljs-string">@&quot;c&quot;</span>, <span class="hljs-string">@&quot;d&quot;</span>, <span class="hljs-string">@&quot;e&quot;</span>, <span class="hljs-string">@&quot;f&quot;</span>, <span class="hljs-string">@&quot;g&quot;</span>, <span class="hljs-string">@&quot;h&quot;</span>, <span class="hljs-string">@&quot;i&quot;</span>, <span class="hljs-string">@&quot;j&quot;</span>];<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++开始&quot;</span>);<br><br>dispatch_apply([array count], concurrentQueue, ^(size_t index) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%zu,%@,ON:%@&quot;</span>, index, [array objectAtIndex:index], [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++结束&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">++++开始</span><br><span class="language-xml">++0,a,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++1,b,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++2,c,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++3,d,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++4,e,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++5,f,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++6,g,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++7,h,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++8,i,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++9,j,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++结束</span><br></code></pre></td></tr></table></figure>

<p>不论使用串行还是并发队列，<code>dispatch_apply</code>函数都不会立刻返回，它会阻塞当前线程并在循环完成后再继续执行后续代码。所以可以推测它使用了同步的方式提交遍历元素的任务，这一点类似于<code>for</code>循环。</p>
<h3 id="8-任务组"><a href="#8-任务组" class="headerlink" title="8.任务组"></a>8.任务组</h3><h4 id="1-dispatch-group"><a href="#1-dispatch-group" class="headerlink" title="1.dispatch_group"></a>1.dispatch_group</h4><p><strong>场景：</strong>在并发队列的N个任务执行完毕后，继续执行某任务。</p>
<p>#示例8.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//自定义的并发队列1</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue1 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">//自定义的并发队列2</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue2 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue2&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t dispatchGroup = dispatch_group_create();<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++1:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br><br><span class="hljs-comment">//并发队列1上执行任务1</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">888</span> == i) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//并发队列1上执行任务2</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-comment">//并发队列2上执行任务3</span><br>dispatch_group_async(dispatchGroup, dispatchQueue2, ^()&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(dispatchGroup,dispatch_get_main_queue(), ^()&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务完成:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++稍等一哈:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br><span class="hljs-built_in">dispatch_async</span>(dispatchQueue2, ^&#123;<br>    dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++哈~就不等:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++2:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br></code></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">++++1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++稍等一哈:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003164780</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 5, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务3:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003153cc0</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 6, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003176480</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务完成:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++哈~就不等:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003176880</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 4, name = (null)&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<p>1、一个Group可以和多个queue关联。</p>
<p>2、如果提交到队列中的与Group关联起来的任务全都执行完毕，则会调用dispatch_group_notify并且dispatch_group_wait会停止等待；</p>
<p>3、假设一个队列中有2个任务，只有第二个与Group进行了关联，则只要第二个任务完成，不论第一个任务是否已完成，都会收到dispatch_group_notify通知。</p>
<p>4、dispatch_group_wait会阻塞当前线程，直到任务全部完成或等待时间超过设置的超时时间，所以不能在主线程调用。</p>
<h4 id="2-dispatch-group-enter"><a href="#2-dispatch-group-enter" class="headerlink" title="2.dispatch_group_enter"></a>2.dispatch_group_enter</h4><p><code>dispatch_group_enter</code>+<code>dispatch_group_leave</code>成对使用，作用与<code>dispatch_group_async</code>类似:</p>
<p>#示例8.2.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//自定义的并发队列</span><br><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t group = dispatch_group_create();<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++1&quot;</span>);<br><br><span class="hljs-comment">//并发队列上执行任务1</span><br>dispatch_group_enter(group);<br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">888</span> == i) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1&quot;</span>);<br>        &#125;<br>    &#125;<br>    dispatch_group_leave(group);<br>&#125;);<br><br><span class="hljs-comment">//并发队列上执行任务2</span><br>dispatch_group_enter(group);<br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2&quot;</span>);<br>    dispatch_group_leave(group);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(group, dispatch_get_main_queue(), ^()&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务完成&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>与 dispatch_group_async 的区别（线程同步问题）:</strong></p>
<p>如果 <code>dispatch_group_async</code> 里执行的是异步代码，<code>dispatch_group_notify</code> 会直接触发而不会等待异步任务完成；而 <code>dispatch_group_enter</code>、和 <code>dispatch_group_leave</code> 则不会有这个问题，它们只需要在任务开始前 <code>enter</code> 结束后 <code>leave</code> 即可达到线程同步的效果。</p>
<p>#示例8.2.2：<code>dispatch_group_async</code> 执行异步任务时的效果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//自定义的并发队列1</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue1 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">//自定义的并发队列2</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue2 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue2&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t dispatchGroup = dispatch_group_create();<br><br><span class="hljs-comment">//并发队列1上执行任务1</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatchQueue2, ^&#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1&quot;</span>);<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">//并发队列1上执行任务2</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatchQueue2, ^&#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">8</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2&quot;</span>);<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(dispatchGroup,dispatch_get_main_queue(), ^()&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务完成&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>输出日志为:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务完成</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br></code></pre></td></tr></table></figure>

<p><code>notify</code>在任务开始时就触发了~</p>
<p>#示例8.2.3：<code>dispatch_group_enter</code> 与 <code>leave</code> 执行异步任务时的效果：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//自定义的并发队列</span><br>dispatch_queue_t queue = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t <span class="hljs-keyword">group</span> = dispatch_group_create();<br><br>dispatch_group_enter(<span class="hljs-keyword">group</span>);<br>dispatch_async(queue, ^&#123;<br>    [<span class="hljs-meta">NSThread sleepForTimeInterval:5</span>];<br>    NSLog(<span class="hljs-string">@&quot;++++任务1&quot;</span>);<br>    dispatch_group_leave(<span class="hljs-keyword">group</span>);<br>&#125;);<br><br><span class="hljs-comment">//并发队列1上执行任务2</span><br>dispatch_group_enter(<span class="hljs-keyword">group</span>);<br>dispatch_async(queue, ^&#123;<br>    [<span class="hljs-meta">NSThread sleepForTimeInterval:8</span>];<br>    NSLog(<span class="hljs-string">@&quot;++++任务2&quot;</span>);<br>    dispatch_group_leave(<span class="hljs-keyword">group</span>);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(<span class="hljs-keyword">group</span>,dispatch_get_main_queue(), ^()&#123;<br>    NSLog(<span class="hljs-string">@&quot;++++任务完成&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>日志:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务完成</span><br></code></pre></td></tr></table></figure>

<p><code>notify</code> 在任务结束时才触发!</p>
<h4 id="3-其他方案"><a href="#3-其他方案" class="headerlink" title="3.其他方案"></a>3.其他方案</h4><p>通过组合GCD已有的其他API，等效实现<code>dispatch_group</code>的功能：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-comment">// 需要执行的任务总数</span><br><span class="hljs-built_in">NSUInteger</span> totalTasks = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 当前已经完成的任务数量</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-built_in">NSUInteger</span> completedTasks = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 最大并发数</span><br><span class="hljs-built_in">NSUInteger</span> maxConcurrentTasks = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 创建一个串行队列，用于等待所有任务完成后执行接下来的任务</span><br><span class="hljs-built_in">dispatch_queue_t</span> completionQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.example.completion&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><br><span class="hljs-comment">// 创建一个并发队列，用于执行耗时任务</span><br><span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.example.concurrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">// 定义一个任务完成的回调函数</span><br><span class="hljs-type">void</span> (^taskCompletionBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>    <span class="hljs-comment">// 原子操作，累加已完成任务数</span><br>    <span class="hljs-built_in">NSUInteger</span> count = OSAtomicIncrement64(&amp;completedTasks);<br>    <span class="hljs-keyword">if</span> (count == totalTasks) &#123;<br>        <span class="hljs-comment">// 所有任务都已完成，执行接下来的任务</span><br>        <span class="hljs-built_in">dispatch_async</span>(completionQueue, ^&#123;<br>            <span class="hljs-comment">// 在这里执行接下来的任务</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;所有任务都已完成&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 循环提交所有任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; totalTasks; i++) &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(concurrentQueue, ^&#123;<br>        <span class="hljs-comment">// 在这里执行耗时任务，比如网络请求</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务 %lu 开始执行&quot;</span>, i);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.0</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务 %lu 完成&quot;</span>, i);<br>        taskCompletionBlock(); <span class="hljs-comment">// 调用任务完成的回调函数</span><br>    &#125;);<br>    <span class="hljs-keyword">if</span> (i % maxConcurrentTasks == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前并发任务已达到最大并发数，等待所有并发任务完成后再继续提交</span><br>        dispatch_barrier_sync(concurrentQueue, ^&#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9-挂起-x2F-恢复："><a href="#9-挂起-x2F-恢复：" class="headerlink" title="9.挂起&#x2F;恢复："></a>9.挂起&#x2F;恢复：</h3><p><code>dispatch_suspend</code>，<code>dispatch_resume</code> 提供了“挂起、恢复”队列的功能，可以暂停、恢复队列上的任务。但是这里的“挂起”，并不能保证可以立即停止队列上正在运行的 block。</p>
<p>#示例9.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;Queue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><br><span class="hljs-comment">//提交第一个任务，延时5秒输出日志</span><br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++第1个任务 延时5秒咯&quot;</span>);<br>&#125;);<br><span class="hljs-comment">//提交第二个任务，延时5秒输出日志</span><br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++第2个任务 延时5秒咯&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">//延时1秒</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++延时1秒&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//挂起队列</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++挂起队列&quot;</span>);<br>dispatch_suspend(queue);<br><br><span class="hljs-comment">//延时10秒</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++延时10秒&quot;</span>);<br>sleep(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//恢复队列</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++恢复队列&quot;</span>);<br>dispatch_resume(queue);<br></code></pre></td></tr></table></figure>

<p>日志:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11</span>.<span class="hljs-number">187713</span> ++++延时<span class="hljs-number">1</span>秒<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">12</span>.<span class="hljs-number">189074</span> ++++挂起队列<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">12</span>.<span class="hljs-number">189450</span> ++++延时<span class="hljs-number">10</span>秒<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">16</span>.<span class="hljs-number">193140</span> ++++第<span class="hljs-number">1</span>个任务 延时<span class="hljs-number">5</span>秒咯<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">22</span>.<span class="hljs-number">190424</span> ++++恢复队列<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">27</span>.<span class="hljs-number">192363</span> ++++第<span class="hljs-number">2</span>个任务 延时<span class="hljs-number">5</span>秒咯<br></code></pre></td></tr></table></figure>

<p>可以看出，在<code>dispatch_suspend</code>挂起队列后，第一个 block 还是在运行，并且正常输出。</p>
<h3 id="10-dispatch-set-target-queue"><a href="#10-dispatch-set-target-queue" class="headerlink" title="10.dispatch_set_target_queue"></a>10.dispatch_set_target_queue</h3><h4 id="1-设置队列优先级"><a href="#1-设置队列优先级" class="headerlink" title="1.设置队列优先级"></a>1.设置队列优先级</h4><p>我们自己创建的队列使用的是默认优先级，而系统提供的全局队列则可以指定优先级，通过<code>dispatch_set_target_queue</code>方法我们可以让自定义队列的优先级与全局队列保持一致，从而达到修改自定义队列优先级的目的。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dispatch_queue_t serialQueue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;com.xx.xx&quot;</span>,DISPATCH_QUEUE_SERIAL)</span>;<br><br>dispatch_queue_t globalQueue = dispatch<span class="hljs-constructor">_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0)</span>;<br><br><span class="hljs-comment">//第一个参数是目标队列，第二个参数是参考队列（全局队列）；</span><br>dispatch<span class="hljs-constructor">_set_target_queue(<span class="hljs-params">serialQueue</span>, <span class="hljs-params">globalQueue</span>)</span>;<br></code></pre></td></tr></table></figure>

<h4 id="2-任务调度"><a href="#2-任务调度" class="headerlink" title="2.任务调度"></a>2.任务调度</h4><p>修改队列中任务的目标队列，把需要执行的任务对象指定到目标队列中去处理。</p>
<p>#示例1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)seriaQues&#123;<br>    <span class="hljs-comment">//三个串行队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">&quot;queue2&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue3 = dispatch_queue_create(<span class="hljs-string">&quot;queue3&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue2, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue3, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3结束&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务2开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1结束</span><br></code></pre></td></tr></table></figure>

<p>多个串行队列异步执行时，block中各任务是并发执行的，它们之间开始和结束的顺序是不确定的。如果想让这些任务按照先后顺序一个个执行，则可以使用<code>dispatch_set_target_queue</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)seriaMultQue&#123;<br>    <span class="hljs-comment">//三个串行队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">&quot;queue2&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue3 = dispatch_queue_create(<span class="hljs-string">&quot;queue3&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-comment">//目标队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="hljs-string">&quot;targetQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-comment">//将三个串行队列合并到目标串行队列中</span><br>    dispatch_set_target_queue(queue1, targetQueue);<br>    dispatch_set_target_queue(queue2, targetQueue);<br>    dispatch_set_target_queue(queue3, targetQueue);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue2, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue3, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3结束&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务1开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3结束</span><br></code></pre></td></tr></table></figure>

<p>原先相互之间并发执行的三个任务，现在有序执行了~</p>
<p>另外，执行这个操作后，<code>queue1</code>上已在执行的任务会继续在<code>queue1</code>执行，尚未执行的任务会在<code>targetQueue</code>上执行。</p>
<h3 id="11-设置队列标志"><a href="#11-设置队列标志" class="headerlink" title="11.设置队列标志"></a>11.设置队列标志</h3><p>作用：<code>dispatch_queue_set_specific</code>用来向指定队列里面设置一个标识，配合<code>dispatch_get_specific</code>使用。</p>
<p>#示例11.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *key = <span class="hljs-string">&quot;queueKey&quot;</span>;<br>    <span class="hljs-type">void</span> *context = <span class="hljs-string">&quot;myQueueContext&quot;</span>;<br>    <br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    dispatch_queue_set_specific(queue1, key,context, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">if</span> (dispatch_get_specific(key)) &#123;<br>        <span class="hljs-comment">//当前队列是主队列，不是queue1，所以取不到key对应的值。</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++主队列++queue1？：YES&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++主队列++queue1？：NO&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;<br>        <span class="hljs-keyword">if</span> (dispatch_get_specific(key)) &#123;<br>            <span class="hljs-comment">//当前队列是queue1，所以能取到specificKey对应的值。</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++异步串行队列++queue1？：YES&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++异步串行队列++queue1？：NO&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">主队列</span><span class="hljs-literal">++</span><span class="hljs-comment">queue1？：NO</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">异步串行队列</span><span class="hljs-literal">++</span><span class="hljs-comment">queue1？：YES</span><br></code></pre></td></tr></table></figure>

<h3 id="12-dispatch-block-cancel"><a href="#12-dispatch-block-cancel" class="headerlink" title="12.dispatch_block_cancel"></a>12.dispatch_block_cancel</h3><p>作用：取消单个任务。</p>
<p>这个任务必须是用<code>dispatch_block_create</code>创建<code>dispatch_block_t</code>。再者，此方法只对尚未执行的block有效，对正在执行中的任务无效。</p>
<p>#示例12.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//取消任务3</span><br><span class="hljs-built_in">dispatch_queue_t</span> conQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.xxx.queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_block_t block1 = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++block1&quot;</span>);<br>&#125;);<br><br>dispatch_block_t block2 = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++block2&quot;</span>);<br>&#125;);<br><br>dispatch_block_t block3 = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++block3&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">dispatch_async</span>(conQueue, block1);<br><span class="hljs-built_in">dispatch_async</span>(conQueue, block2);<br><span class="hljs-built_in">dispatch_async</span>(conQueue, block3);<br>dispatch_block_cancel(block3);<br></code></pre></td></tr></table></figure>

<p>日志:</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">block2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">block1</span><br></code></pre></td></tr></table></figure>

<h3 id="13-dispatch-semaphore"><a href="#13-dispatch-semaphore" class="headerlink" title="13.dispatch_semaphore"></a>13.dispatch_semaphore</h3><p>信号量：就是一种可用来控制访问资源的数量的标识。当一个线程在进入一段关键代码之前，线程必须获取一个信号量，一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待前面的线程释放信号量。</p>
<p>有一个经典的停车场的例子：信号量的值就相当于剩余车位的数目，<code>dispatch_semaphore_wait</code>就相当于来了一辆车，<code>dispatch_semaphore_signal</code>就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create(value:Int)）），调用一次<code>dispatch_semaphore_signal</code>，剩余的车位就增加一个；调用一次<code>dispatch_semaphore_wait</code>剩余车位就减少一个；当剩余车位为0时，再来车（即调用<code>dispatch_semaphore_wait</code>）就只能等待。有耐心的车主会一直等下去，没耐心的车主在等待“一段时间”之后就会离开。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建信号量，参数：信号量的初值，如果小于<span class="hljs-number">0</span>则会返回NULL<br>dispatch_semaphore_create（信号量值）<br><br><span class="hljs-regexp">//</span>减少信号量，时间：DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER<br>dispatch_semaphore_wait（信号量，等待时间）<br><br><span class="hljs-regexp">//</span>释放信号量<br>dispatch_semaphore_signal(信号量)<br></code></pre></td></tr></table></figure>

<p>#示例13.1：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>semaphore&#123;<br>    dispatch_queue_t mQueue = dispatch_queue_create<span class="hljs-params">(<span class="hljs-string">&quot;concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT)</span>;<br>    dispatch_semaphore_t semaphore = dispatch_semaphore_create<span class="hljs-params">(<span class="hljs-number">0</span>)</span>;<br>    <br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++1&quot;</span>)</span>;<br>    dispatch_async<span class="hljs-params">(mQueue, ^&#123;</span><br><span class="hljs-params">        sleep(<span class="hljs-number">2</span>);</span><br><span class="hljs-params">        NSLog(@<span class="hljs-string">&quot;+++first task&quot;</span>);</span><br><span class="hljs-params">        dispatch_semaphore_signal(semaphore);</span><br><span class="hljs-params">    &#125;)</span>;<br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++2&quot;</span>)</span>;<br>    dispatch_semaphore_wait<span class="hljs-params">(semaphore, DISPATCH_TIME_FOREVER)</span>;<br>    <br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++3&quot;</span>)</span>;<br>    dispatch_async<span class="hljs-params">(mQueue, ^&#123;</span><br><span class="hljs-params">        sleep(<span class="hljs-number">2</span>);</span><br><span class="hljs-params">        NSLog(@<span class="hljs-string">&quot;+++second task&quot;</span>);</span><br><span class="hljs-params">        dispatch_semaphore_signal(semaphore);</span><br><span class="hljs-params">    &#125;)</span>;<br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++4&quot;</span>)</span>;<br>    dispatch_semaphore_wait<span class="hljs-params">(semaphore, DISPATCH_TIME_FOREVER)</span>;<br><br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++5&quot;</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">59</span> +++<span class="hljs-number">1</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">59</span> +++<span class="hljs-number">2</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">01</span> +++first task<br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">01</span> +++<span class="hljs-number">3</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">01</span> +++<span class="hljs-number">4</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">03</span> +++second task<br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">03</span> +++<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>示例中创建了初始值&#x3D;0的信号量，随后开始了两个异步打印数字的任务。从日志来看，“+++first task” 在”+++3” 之前，而“+++5”是最后才打印的，这是因为信号量&#x3D;0时<code>dispatch_semaphore_wait()</code>处自动阻塞了当前线程，两个打印任务执行完之后<code>dispatch_semaphore_signal()</code>使信号量&#x3D;1，当前线程才得以继续执行。</p>
<p>#示例13.2：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//初始信号量</span><br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">dispatch_queue_t</span> quene = dispatch_queue_create(<span class="hljs-string">&quot;com.M.D&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">//任务1</span><br><span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务1&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务1&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br><br><span class="hljs-comment">//任务2</span><br><span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务2&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务2&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br><br><span class="hljs-comment">//任务3</span><br><span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务3&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务3&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务3</span><br></code></pre></td></tr></table></figure>

<p><strong>ps</strong>，信号量的使用只保证了并发场景下每次只有一个线程执行任务，并不能保证任务的执行顺序，再运行一次后日志如下：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务2</span><br></code></pre></td></tr></table></figure>

<h3 id="14-GCD倒计时"><a href="#14-GCD倒计时" class="headerlink" title="14.GCD倒计时"></a>14.GCD倒计时</h3><p>#示例14.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//@property (strong, nonatomic) dispatch_source_t aTimer;</span><br><br>- (<span class="hljs-type">void</span>) GCDTimer<br>&#123;<br>    __block <span class="hljs-type">int</span> timeout = <span class="hljs-number">60</span>; <span class="hljs-comment">//倒计时时间</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br>    <br>    _aTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,queue);<br>    <br>    dispatch_source_set_timer(_aTimer,dispatch_walltime(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>),<span class="hljs-number">1.0</span>*<span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//每秒执行</span><br>    <br>    dispatch_source_set_event_handler(_aTimer, ^&#123;<br>        <span class="hljs-keyword">if</span>(timeout&lt;=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//倒计时结束，关闭</span><br>            dispatch_source_cancel(_aTimer);<br>            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                <span class="hljs-comment">//设置界面的按钮显示 根据自己需求设置</span><br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                <span class="hljs-comment">//设置界面的按钮显示 根据自己需求设置</span><br>            &#125;);<br>            timeout--;<br>        &#125;<br>    &#125;);<br>    dispatch_resume(_aTimer);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>GCD定时器并不是由NSTimer或者CFRunLoopTimer实现的，无需加入到RunloopMode中，所以不会出现因RunloopMode切换而失效的问题。</p>
<h3 id="15-GCD读写锁"><a href="#15-GCD读写锁" class="headerlink" title="15.GCD读写锁"></a>15.GCD读写锁</h3><p>为了保证数据访问或者方法调用时的线程安全，一般我们可以使用<code>锁</code>来实现同步机制，比如<code>@synchronized()</code>和<code>NSLock</code>等。但是，频繁的上锁、释放锁的操作会降低执行效率。所以我们可以考虑使用<code>dispatch_barrier_async</code>，通过 GCD 对任务的调度来达到相同的效果。</p>
<p>思路：<code>dispatch_barrier_async</code>能确保在其之前提交到队列的任务先执行，然后执行它自己提交的任务，最后执行其后提交的任务。利用这个特点，我们可以将数据的读写操作放入一个并发队列中，写数据的任务通过<code>栅栏</code>提交到队列中，读数据的任务则可以同步的提交到队列中。这样就能保证执行写操作时，读操作或其他写操作都被阻塞，而执行读操作时，写操作被阻塞，将读写分开从而避免数据的污染。</p>
<p>#示例15.1：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *mArr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">dispatch_queue_t</span> mPropertyConcurrentQueue;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br><span class="hljs-keyword">@synthesize</span> mArr = _mArr;<br><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    __block <span class="hljs-built_in">NSMutableArray</span> *tmpArr;<br>    <span class="hljs-built_in">dispatch_sync</span>(_mPropertyConcurrentQueue, ^&#123;<span class="hljs-comment">//并发队列+同步=串行，不能使用dispatch_async，会直接返回</span><br>        tmpArr = _mArr;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> tmpArr;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)setMArr:(<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    dispatch_barrier_async(_mPropertyConcurrentQueue, ^&#123;<br>        _mArr = mArr;<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//使用自己创建的并发队列，不能使用系统的dispatch_get_global_queue，上面章节中有讲到这一点</span><br>    _mPropertyConcurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;readWriteQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">dispatch_queue_t</span> tmpQueue = dispatch_queue_create(<span class="hljs-string">&quot;1&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>            <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">dispatch_async</span>(tmpQueue, ^&#123;<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Reset array,thread:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>                    <span class="hljs-keyword">self</span>.mArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br>                &#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">dispatch_async</span>(tmpQueue, ^&#123;<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++Add num:%d,thread:%@&quot;</span>,i,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>                    [<span class="hljs-keyword">self</span>.mArr addObject:@(i)];<br>                &#125;);<br>            &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">#多线程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>GCD</div>
      <div>https://davidlii.cn/2017/11/08/gcd.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Davidli</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年11月8日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/11/17/nsoperation.html" title="NSOperation">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">NSOperation</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/11/07/nsthread.html" title="NSThread">
                        <span class="hidden-mobile">NSThread</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/davidli-" target="_blank" rel="nofollow noopener"><span>嵇风</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
