

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Davidli">
  <meta name="keywords" content="Davidli">
  
    <meta name="description" content="1.概念临界资源：  在进程层面，一次仅允许一个进程使用的资源称为临界资源，如打印机等物理设备； 在线程层面，多线程环境中一次仅允许一个线程使用的变量等就是临界资源；  临界区： 一个访问共享资源的程序代码片段，当有线程进入临界区时，其他线程须保持等待。 锁： 是一种强行限制资源访问的同步机制，在并发控制中保证互斥的要求，用来防止多线程环境中对临界资源的脏读或者脏写。从某种角度而言，锁也可以看作是">
<meta property="og:type" content="article">
<meta property="og:title" content="八大锁">
<meta property="og:url" content="https://davidlii.cn/2017/11/21/lock.html">
<meta property="og:site_name" content="Davidli">
<meta property="og:description" content="1.概念临界资源：  在进程层面，一次仅允许一个进程使用的资源称为临界资源，如打印机等物理设备； 在线程层面，多线程环境中一次仅允许一个线程使用的变量等就是临界资源；  临界区： 一个访问共享资源的程序代码片段，当有线程进入临界区时，其他线程须保持等待。 锁： 是一种强行限制资源访问的同步机制，在并发控制中保证互斥的要求，用来防止多线程环境中对临界资源的脏读或者脏写。从某种角度而言，锁也可以看作是">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-11-20T17:13:57.000Z">
<meta property="article:modified_time" content="2019-07-13T16:50:57.000Z">
<meta property="article:author" content="Davidli">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>八大锁 - Davidli</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"davidlii.cn","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Davidlii</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/IMG_0.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="八大锁"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-11-21 01:13" pubdate>
          2017年11月21日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          106 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">八大锁</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>临界资源：</p>
<ul>
<li>在进程层面，一次仅允许一个进程使用的资源称为临界资源，如打印机等物理设备；</li>
<li>在线程层面，多线程环境中一次仅允许一个线程使用的变量等就是临界资源；</li>
</ul>
<p>临界区：</p>
<p>一个访问共享资源的程序代码片段，当有线程进入临界区时，其他线程须保持等待。</p>
<p>锁：</p>
<p>是一种强行限制资源访问的同步机制，在并发控制中保证互斥的要求，用来防止多线程环境中对临界资源的脏读或者脏写。从某种角度而言，锁也可以看作是临界资源，线程获取到该锁对象之后才能执行里面的代码。</p>
<h3 id="2-锁的分类"><a href="#2-锁的分类" class="headerlink" title="2.锁的分类"></a>2.锁的分类</h3><ul>
<li>Mutex 互斥锁</li>
<li>Spin lock 自旋锁</li>
<li>Condition Variable 条件变量</li>
<li>Read&#x2F;Write lock 读写锁</li>
</ul>
<h4 id="2-1-互斥锁"><a href="#2-1-互斥锁" class="headerlink" title="2.1.互斥锁"></a>2.1.互斥锁</h4><p>属于<code>sleep-waiting</code>类型，在申请上锁时如果锁已经被别的单元持有，则会让该线程睡眠，待锁释放时被唤醒。但线程的休眠和唤醒需要大量的CPU指令，因此需要花费一些时间。</p>
<h4 id="2-2-自旋锁"><a href="#2-2-自旋锁" class="headerlink" title="2.2.自旋锁"></a>2.2.自旋锁</h4><p>属于<code>busy-waiting</code>类型，在申请上锁时如果锁已经被别的单元保持，并不是睡眠等待唤醒，而是循环检测保持者是否释放了锁。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。相对的，由于自旋锁一直占用CPU，所以如果长时间不能获得锁，则会降低CPU的使用效率。此锁比较适用于锁的持有者保存时间较短的情况下。</p>
<p>场景举例：</p>
<p>互斥锁：在某双核心的机器上有AB两个线程，分别运行在<code>核心0</code>与<code>核心1</code>上。若线程A想要通过<code>pthread_mutex_lock</code>去得到一个临界区的锁，而这个锁此时正被线程B所持有，则线程A就会被阻塞，<code>核心0</code>会切换上下文，将线程A置于等待队列中不再占用<code>核心0</code>，此时<code>核心0</code>就可以运行其他的任务，例如另一个线程C的任务。</p>
<p>自旋锁：如果线程A是使用<code>pthread_spin_lock</code>操作去请求锁，那么线程A就会一直在<code>核心0</code>上忙等待并不停的请求锁，直到得到这个锁为止。</p>
<h4 id="2-3-读写锁"><a href="#2-3-读写锁" class="headerlink" title="2.3.读写锁"></a>2.3.读写锁</h4><p>高级别锁，区分读和写：</p>
<ul>
<li>一个读写锁允许多个线程同时读某共享资源；</li>
<li>写操作具有排他性，写入数据时不允许其他线程对共享资源进行读或写。</li>
</ul>
<p>读写锁适用于大量读少量写的环境，其效率相对普通的互斥锁和自旋锁要慢一个数量级。</p>
<h3 id="3-八大锁"><a href="#3-八大锁" class="headerlink" title="3.八大锁"></a>3.八大锁</h3><p>按照性能排序，从高到低：</p>
<ol>
<li>OSSpinLock</li>
<li>dispatch_semaphore</li>
<li>pthread_mutex</li>
<li>NSLock</li>
<li>NSCondition</li>
<li>NSRecursiveLock</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ol>
<h3 id="4-自旋锁"><a href="#4-自旋锁" class="headerlink" title="4.自旋锁"></a>4.自旋锁</h3><h4 id="4-1-OSSpinLock"><a href="#4-1-OSSpinLock" class="headerlink" title="4.1.OSSpinLock"></a>4.1.OSSpinLock</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//需要导入：#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="hljs-comment">//OSSpinLock 自旋锁</span><br>- (void)OSSpinLock<br>&#123;<br>    __block OSSpinLock oslock = OS_SPINLOCK_INIT;<br>    <span class="hljs-comment">//线程1</span><br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程1 上锁&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockLock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        sleep(<span class="hljs-number">4</span>);<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程1执行任务....&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockUnlock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程1 解锁&quot;</span>)</span>;<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程2</span><br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程2 上锁&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockLock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程2执行任务....&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockUnlock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程2 解锁&quot;</span>)</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 解锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 解锁</span><br></code></pre></td></tr></table></figure>

<p><strong>ps：</strong>此自旋锁存在优先级反转问题，iOS10 之后苹果推出了<code>os_unfair_lock</code>来替代它。</p>
<p>关于优先级反转问题，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC/4945202">百度百科</a> 有更详细的介绍：</p>
<blockquote>
<p>优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</p>
</blockquote>
<blockquote>
<p>例如：有优先级为A、B和C三个任务，优先级A&gt;B&gt;C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。</p>
</blockquote>
<h4 id="4-2-os-unfair-lock"><a href="#4-2-os-unfair-lock" class="headerlink" title="4.2.os_unfair_lock"></a>4.2.os_unfair_lock</h4><p><code>OSSpinLock</code>自旋锁存在优先级反转的问题，iOS10.0之后被废弃，由os_unfair_lock（不公平的锁）代替。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">os_unfair_lock_t unfairLock;<br>unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);<br>os<span class="hljs-constructor">_unfair_lock_lock(<span class="hljs-params">unfairLock</span>)</span>;<br>os<span class="hljs-constructor">_unfair_lock_unlock(<span class="hljs-params">unfairLock</span>)</span>;<br></code></pre></td></tr></table></figure>


<h3 id="5-互斥锁"><a href="#5-互斥锁" class="headerlink" title="5.互斥锁"></a>5.互斥锁</h3><h4 id="5-1-pthread-mutex"><a href="#5-1-pthread-mutex" class="headerlink" title="5.1.pthread_mutex"></a>5.1.pthread_mutex</h4><p>pthread_mutex 是 C 语言下多线程加互斥锁的方式，需要 <code>#import &lt;pthread.h&gt;</code></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss">- (void)pthread_mutex_Test<br>&#123;<br>    static pthread_mutex_t pLock;<br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;pLock, NULL);<br>    <span class="hljs-comment">//线程1</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">1</span> 上锁&quot;);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pLock);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">1</span> 执行任务....&quot;);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pLock);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">1</span> 解锁&quot;);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程2</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">2</span> 上锁&quot;);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pLock);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">2</span> 执行任务....&quot;);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pLock);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">2</span> 解锁&quot;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 解锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 解锁</span><br></code></pre></td></tr></table></figure>

<p><strong>使用案例：开源图片下载和缓存框架PINRemoteImage</strong>。</p>
<h4 id="5-2-NSLock"><a href="#5-2-NSLock" class="headerlink" title="5.2.NSLock"></a>5.2.NSLock</h4><p>NSLock 遵循 NSLocking 协议的互斥锁，通过<code>lock</code>与<code>unlock</code>配合使用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSLock</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSLocking</span>&gt;</span><br>&#123;<br><span class="hljs-keyword">@private</span><br><span class="hljs-type">void</span> *_priv;<br>&#125;<br>- (<span class="hljs-type">BOOL</span>)tryLock;<br>- (<span class="hljs-type">BOOL</span>)lockBeforeDate:(<span class="hljs-built_in">NSDate</span> *)limit;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>互斥锁会使得线程阻塞，阻塞的过程又分两个阶段，第一阶段是会先空转，可以理解成跑一个 while 循环，不断地去申请加锁，在空转一定时间之后，线程会进入 <code>waiting</code> 状态，此时线程就不占用CPU资源了，等锁可用的时候，这个线程会立即被唤醒。</p>
<p><code>tryLock</code> 则不会阻塞线程，如果获取锁成功则返回YES，获取失败则返回NO。这个方法无论如何都会立即返回，在拿不到锁时不会一直在那等待。</p>
<p><code>lockBeforeDate:</code> 方法会在所指定 Date 之前尝试加锁，会阻塞线程。</p>
<p><strong>ps:</strong> 如果使用 NSLock 连续锁定两次，则会造成死锁。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)nslockTest<br>&#123;<br>    <span class="hljs-built_in">NSLock</span> *nslock = [<span class="hljs-built_in">NSLock</span> new];<br>    <span class="hljs-comment">//线程1</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程1 上锁&quot;</span>);<br>        [nslock lock];<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程1执行任务....&quot;</span>);<br>        [nslock unlock];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程1 解锁&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程2</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2 上锁&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">BOOL</span> succed = [nslock tryLock];<br>        <span class="hljs-keyword">if</span> (succed) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2上锁成功&quot;</span>);<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2执行任务....&quot;</span>);<br>            [nslock unlock];<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2 解锁&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2上锁失败&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程3</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程3 上锁&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        [nslock lock];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程3执行任务....&quot;</span>);<br>        [nslock unlock];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程3 解锁&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程3 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2上锁失败</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 解锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程3执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程3 解锁</span><br></code></pre></td></tr></table></figure>

<p><strong>使用案例：AFNetworking</strong>。</p>
<h4 id="5-3-NSRecursiveLock"><a href="#5-3-NSRecursiveLock" class="headerlink" title="5.3.NSRecursiveLock"></a>5.3.NSRecursiveLock</h4><p>与NSLock不同，递归锁可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。只有当所有的锁被释放之后，其他线程才可以获得锁。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)recursivelock<br>&#123;<br>    NSLock *<span class="hljs-keyword">lock</span> = [NSLock <span class="hljs-built_in">new</span>];<br>    //NSRecursiveLock *<span class="hljs-keyword">lock</span> = [NSRecursiveLock <span class="hljs-built_in">new</span>];<br>    <br>    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <br>       static <span class="hljs-type">void</span> (^RecursiveBlock)(<span class="hljs-type">int</span>);<br>       <br>       RecursiveBlock = ^(<span class="hljs-type">int</span> <span class="hljs-keyword">value</span>) &#123;<br>           [<span class="hljs-keyword">lock</span> <span class="hljs-keyword">lock</span>];<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &gt; <span class="hljs-number">0</span>) &#123;<br>               NSLog(@&quot;++++循环：%d&quot;, <span class="hljs-keyword">value</span>);<br>               sleep(<span class="hljs-number">1</span>);<br>               RecursiveBlock(<span class="hljs-keyword">value</span> - <span class="hljs-number">1</span>);<br>           &#125;<br>           [<span class="hljs-keyword">lock</span> unlock];<br>       &#125;;<br>       RecursiveBlock(<span class="hljs-number">5</span>);<br>   &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就是一个死锁的情况，RecursiveBlock被递归的调用，从第二次开始，由于锁已经被使用且没有被解锁，所以需要等待解锁，造成死锁。运行后的日志就可以看出：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">循环：5</span><br></code></pre></td></tr></table></figure>

<p>这种情况下，如果把上片代码第二行注释取消，把NSLock替换为NSRecursiveLock，使用递归锁，则不会出现死锁。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">循环：5</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：4</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：3</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：1</span><br></code></pre></td></tr></table></figure>

<p><strong>使用案例：PINRemoteImage</strong>。</p>
<h4 id="5-4-synchronized"><a href="#5-4-synchronized" class="headerlink" title="5.4.@synchronized"></a>5.4.@synchronized</h4><p><code>@synchronized(obj)</code>的作用是根据给定对象，自动创建一个互斥锁，块中的代码执行完后才会释放锁。相比于使用<code>NSLock</code>等创建锁对象、加锁和解锁来说，@synchronized 用着更方便。但它也是这几个锁里效率最低的，因为一般我们会将<code>self</code>等作为代码块的加锁对象，这会造成其他共用此锁的同步块的阻塞。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *mArr;<br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *mDic;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br><span class="hljs-keyword">@synthesize</span> mArr = _mArr;<br><span class="hljs-keyword">@synthesize</span> mDic = _mDic;<br><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!_mArr) &#123;<br>            _mArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        &#125;<br>        <span class="hljs-keyword">return</span> _mArr;<br>    &#125;<br>&#125;<br>- (<span class="hljs-type">void</span>)setMArr:(<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _mArr = mArr;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++mArr updated~&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<span class="hljs-comment">//模拟延时</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++mArr block released~&quot;</span>);<br>    &#125;<br>&#125;<br>-(<span class="hljs-built_in">NSMutableDictionary</span> *)mDic&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!_mDic) &#123;<br>            _mDic = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        &#125;<br>        <span class="hljs-keyword">return</span> _mDic;<br>    &#125;<br>&#125;<br>-(<span class="hljs-type">void</span>)setMDic:(<span class="hljs-built_in">NSMutableDictionary</span> *)mDic&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _mDic = mDic;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++mDic updated~&quot;</span>);<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++111&quot;</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++222&quot;</span>);<br>        <span class="hljs-keyword">self</span>.mArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObject:@(<span class="hljs-number">0</span>)];<br>        <span class="hljs-keyword">self</span>.mDic = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithObject:<span class="hljs-string">@&quot;v1&quot;</span> forKey:<span class="hljs-string">@&quot;k&quot;</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++333&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">111</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">222</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">mArr updated~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">mArr block released~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">mDic updated~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">333</span><br></code></pre></td></tr></table></figure>

<p>本示例中，数组属性<code>mArr</code>的存取器中都使用了<code>@synchronized(self)</code>来加锁，保证了数组读写的原子性，但字典属性<code>mDic</code>的存取函数中也使用了<code>@synchronized(self)</code>，且加锁对象也是<code>self</code>，这就会导致在访问<code>mArr</code>的同时访问<code>mDic</code>时后者会被阻塞，造成没必要的等待。实际上，这种方式的效果与属性修饰符<code>atomic</code>一样，都存在效率的问题~</p>
<h3 id="6-条件锁"><a href="#6-条件锁" class="headerlink" title="6.条件锁"></a>6.条件锁</h3><h4 id="6-1-NSCondition"><a href="#6-1-NSCondition" class="headerlink" title="6.1.NSCondition"></a>6.1.NSCondition</h4><p>NSCondition 扮演着两个角色：</p>
<blockquote>
<p>A condition object acts as both a lock and a checkpoint in a given thread. The lock protects your code while it tests the condition and performs the task triggered by the condition. The checkpoint behavior requires that the condition be true before the thread proceeds with its task. While the condition is not true, the thread blocks. It remains blocked until another thread signals the condition object.</p>
</blockquote>
<p><strong>角色1：锁</strong></p>
<p>NSCondition 实现了<code>NSLocking</code>协议，与<code>NSLock</code>一样可用来处理线程同步问题。</p>
<p><strong>角色2：检查点</strong></p>
<p>检查当前线程是否满足某个条件：条件不满足时线程会阻塞，直到另一个线程向该条件发送通知。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSCondition</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSLocking</span>&gt; </span>&#123;<br><br>- (<span class="hljs-type">void</span>)wait;<br>- (<span class="hljs-type">BOOL</span>)waitUntilDate:(<span class="hljs-built_in">NSDate</span> *)limit;<br>- (<span class="hljs-type">void</span>)signal;<br>- (<span class="hljs-type">void</span>)broadcast;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>NSCondition 提供了 wait 和 signal 接口，接口命名与信号量类似。</p>
<p>场景：开启两个线程，线程A下载图片，线程B对图片做解码操作。</p>
<ul>
<li>线程B的要求是：如果没有图片则自动阻塞；</li>
<li>当线程A下载完成后，则满足了线程B的需求，发送信号给B线程让其继续处理图片。</li>
</ul>
<p>这样的场景就是生产者消费者模式（收发同步问题）。</p>
<p>原理：</p>
<ul>
<li>消费者取得锁，取产品，如果没有，则wait，直到有线程唤醒它去消费产品；</li>
<li>生产者制造产品，首先也要取得锁，然后生产，再发signal，唤醒wait的消费者。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- (<span class="hljs-keyword">void</span>)nsConditonTest<br>&#123;<br>    NSCondition *condition = [[NSCondition alloc] <span class="hljs-keyword">init</span>];<br>    NSMutableArray *products = [NSMutableArray array];<br>    <span class="hljs-comment">// 线程1，消费者</span><br>    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            [<span class="hljs-meta">condition lock</span>];<br>            <span class="hljs-keyword">if</span> ([products count] == <span class="hljs-number">0</span>) &#123;<br>                NSLog(<span class="hljs-string">@&quot;+++等待商品..&quot;</span>);<br>                [<span class="hljs-meta">condition wait</span>]; <span class="hljs-comment">//不满足条件 阻塞线程</span><br>            &#125;<br>            [<span class="hljs-meta">products removeObjectAtIndex:0</span>];<br>            NSLog(<span class="hljs-string">@&quot;+++成功消费1个商品&quot;</span>);<br>            [<span class="hljs-meta">condition unlock</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 线程2，生产者</span><br>    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            [<span class="hljs-meta">condition lock</span>];<br>            [<span class="hljs-meta">products addObject:[[NSObject alloc</span>] <span class="hljs-keyword">init</span>]];<br>            NSLog(<span class="hljs-string">@&quot;+++生产一个商品，现总量:%zi&quot;</span>,products.count);<br>            [<span class="hljs-meta">condition signal</span>]; <span class="hljs-comment">//满足条件，通知其他线程</span><br>            [<span class="hljs-meta">condition unlock</span>];<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">等待商品</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">生产一个商品，现总量:1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">成功消费1个商品</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">等待商品</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">生产一个商品，现总量:1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">成功消费1个商品</span><br></code></pre></td></tr></table></figure>

<p><strong>使用案例：PINRemoteImage</strong>。</p>
<h4 id="6-2-NSConditionLock"><a href="#6-2-NSConditionLock" class="headerlink" title="6.2.NSConditionLock"></a>6.2.NSConditionLock</h4><p>相比于 NSLock 多了个 condition 参数，可以理解为一个条件标识。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)conditionlock&#123;<br><span class="hljs-comment">//初始锁对象 条件=0</span><br><span class="hljs-built_in">NSConditionLock</span> *contidionlock = [[<span class="hljs-built_in">NSConditionLock</span> alloc] initWithCondition:<span class="hljs-number">0</span>];<br><span class="hljs-comment">//线程1</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-keyword">if</span>([contidionlock tryLockWhenCondition:<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行线程1&quot;</span>);<br>        [contidionlock unlockWithCondition:<span class="hljs-number">1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++上锁失败&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//线程2</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    [contidionlock lockWhenCondition:<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行线程2&quot;</span>);<br>    [contidionlock unlockWithCondition:<span class="hljs-number">2</span>];<br>&#125;);<br><br><span class="hljs-comment">//线程3</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    [contidionlock lockWhenCondition:<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行线程3&quot;</span>);<br>    [contidionlock unlockWithCondition:<span class="hljs-number">3</span>];<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">执行线程1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行线程3</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行线程2</span><br></code></pre></td></tr></table></figure>

<p>上片代码中，初始化 NSConditionLock 对象时，标识设置为0；运行后：</p>
<ul>
<li>线程1执行 <code>tryLockWhenCondition:</code>时，传入标识“0”，所以 线程1 加锁成功。</li>
<li>线程1执行 <code>unlockWithCondition:</code>时，<code>condition</code>由 0 被修改为 1。</li>
<li>因为<code>condition</code>修改为了 1，线程3 符合条件并成功上锁，之后线程3将<code>condition</code> 修改为3。</li>
<li>最后线程2执行。</li>
</ul>
<p>从上面的结果可以发现，NSConditionLock 还可以实现任务之间的依赖。</p>
<p><strong>使用案例：PINRemoteImage</strong>。</p>
<h4 id="6-3-dispatch-semaphore"><a href="#6-3-dispatch-semaphore" class="headerlink" title="6.3.dispatch_semaphore"></a>6.3.dispatch_semaphore</h4><p>信号量：是一种用来控制资源是否可访问的数量标识，0表示没有可用信号量，&gt;&#x3D;1表是有可用信号量。在进入一段临界区代码之前，线程须获取一个信号量；临界区代码段执行完成后，该线程须释放信号量。在无可用信号量时，其它想进入该临界区的线程必须等待前面的线程释放信号量。</p>
<p>经典的停车场案例：</p>
<ul>
<li>信号量的值相当于剩余车位的数量；</li>
<li><code>dispatch_semaphore_wait</code>相当于来了一辆车；</li>
<li><code>dispatch_semaphore_signal</code>相当于走了一辆车；</li>
</ul>
<p>停车位的剩余数目在初始化时就已经指明了（<code>dispatch_semaphore_create(value:Int)）</code>），调用一次<code>dispatch_semaphore_signal</code>，剩余的车位就增加一个；调用一次<code>dispatch_semaphore_wait</code>剩余车位就减少一个；当剩余车位为0时，再来车（即调用<code>dispatch_semaphore_wait</code>）就只能等待。有耐心的车主会一直等下去，没耐心的车主在等待“一段时间”之后就会离开。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建信号量，参数：信号量的初值，如果小于<span class="hljs-number">0</span>则会返回NULL<br>dispatch_semaphore_create（信号量值）<br><br><span class="hljs-regexp">//</span>减少信号量，时间：DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER<br>dispatch_semaphore_wait（信号量，等待时间）<br><br><span class="hljs-regexp">//</span>释放信号量<br>dispatch_semaphore_signal(信号量)<br></code></pre></td></tr></table></figure>

<p>#示例</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)Segmaphore<br>&#123;<br>    <span class="hljs-comment">//初始信号量</span><br>    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> quene = dispatch_queue_create(<span class="hljs-string">&quot;com.M.D&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <br>    <span class="hljs-comment">//任务1</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务1&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务1&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//任务2</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务2&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务2&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//任务3</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务3&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务3&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务3</span><br></code></pre></td></tr></table></figure>

<p><strong>使用案例：AFN、GPUImage</strong>。</p>
<h3 id="7-读写锁"><a href="#7-读写锁" class="headerlink" title="7.读写锁"></a>7.读写锁</h3><p>一个读写锁其读是可并发的，写是排他的，因此实现读写锁可以使用具有类似特性的GCD<code>栅栏</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ASDLockTool</span> ()</span><br><span class="hljs-comment">// 读写锁示范</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">dispatch_queue_t</span> mQueue;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ASDLockTool</span></span><br><br><span class="hljs-keyword">@synthesize</span> name = _name;<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        _mQueue = dispatch_queue_create(<span class="hljs-string">&quot;mQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// getter 需要同步，因为要立刻返回属性的值</span><br>- (<span class="hljs-built_in">NSString</span> *)name&#123;<br>    __block <span class="hljs-built_in">NSString</span> *bName;<br>    <span class="hljs-built_in">dispatch_sync</span>(_mQueue, ^&#123;<br>        bName = _name;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bName;<br>&#125;<br><br><span class="hljs-comment">// setter 需要排他性，写时不允许其他写操作或者读操作，所以使用栅栏</span><br>- (<span class="hljs-type">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name&#123;<br>    dispatch_barrier_async(_mQueue, ^&#123;<br>        _name = name;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>因为getter需要立刻返回当前属性的值，所以对于属性的读操作使用了“同步+并发队列”；而写操作是排他的，所以使用了“异步栅栏+并发队列”，这样就能保证写入时其他操作都自动等待。</p>
<hr>
<p>相关参考：</p>
<p>#<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC/4945202">©百度百科-优先级反转</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">#多线程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>八大锁</div>
      <div>https://davidlii.cn/2017/11/21/lock.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Davidli</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年11月21日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/11/23/js-native.html" title="js-Native交互">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">js-Native交互</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/11/17/nsoperation.html" title="NSOperation">
                        <span class="hidden-mobile">NSOperation</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/davidli-" target="_blank" rel="nofollow noopener"><span>Davidlii</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
