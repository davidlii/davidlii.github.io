<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"/> 
  
  <title>
    
      Runloop | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Runloop</h2>
  <p class="post-date">2017-09-09</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="1-Runloop"><a href="#1-Runloop" class="headerlink" title="1.Runloop"></a>1.Runloop</h2><blockquote>
<p>Run loops are part of the fundamental infrastructure associated with threads.A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events.The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p>
</blockquote>
<p>Runloop 正如其字面意思，是处理事件的循环，它的本质是一个<code>do-while</code>循环。</p>
<h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1.作用"></a>1.1.作用</h3><ol>
<li>保持程序的持续运行；</li>
<li>处理App中的各种事件(如触摸事件、定时器事件、Selector事件)；</li>
<li>使线程有任务时执行任务，无任务时休眠,以节省CPU资源,提高程序性能；</li>
</ol>
<h3 id="1-2-工作原理"><a href="#1-2-工作原理" class="headerlink" title="1.2.工作原理"></a>1.2.工作原理</h3><p>在线程中启动了 Runloop，相当于让线程一直处在 do-while 循环中，线程一直不会销。如果要销毁这个线程，必须停止这个 Runloop。Runloop 的目的就是为了保持一个线程在有任务时持续运行，在没任务时进入休眠状态。</p>
<h3 id="1-3-与线程的关系"><a href="#1-3-与线程的关系" class="headerlink" title="1.3.与线程的关系"></a>1.3.与线程的关系</h3><p>每个线程，包括主线程，都有与之相关的 Runloop 对象。Cocoa 与Core Foundation都提供了<code>run loop objects</code>，来帮助配置和管理线程的 Runloop，我们不需要显式的去创建这些对象。</p>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>在程序启动的过程中，系统会自动在<code>主线程</code>上设置并启动了一个 Runloop。具体入口是在 main 文件中的如下代码中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>UIApplicationMain()</code>内部为主线程启动了一个runloop。我们的APP能在无任何操作时休眠，监听到输入事件时立马响应，就是因为有这个runloop在。</p>
<h4 id="其他线程"><a href="#其他线程" class="headerlink" title="其他线程"></a>其他线程</h4><p>除主线程外，其他线程在执行任务时是一条直线类型，从起点到终点，执行完任务后线程就会销毁掉。这是因为其他线程的 runloop 默认都是没有开启的，如果想让子线程保活并继续执行任务，则可自行配置并启动其runloop。<br>&emsp;</p>
<p>#示例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//自定义ASDFThread</span><br><span class="line">@interface ASDFThread : NSThread</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ASDFThread</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;++++THREAD IS DEALLOCED~&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//AppDelegate 在自定义线程中执行任务</span><br><span class="line">#import &quot;ASDFThread.h&quot;</span><br><span class="line">@implementation AppDelegate</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    ASDFThread *th = [[ASDFThread alloc] initWithTarget:self selector:@selector(onHandleEvent) object:nil];</span><br><span class="line">    [th start];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)onHandleEvent&#123;</span><br><span class="line">    NSLog(@&quot;++++当前线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++++当前线程:&lt;ASDFThread: 0x600003575e80&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">++++THREAD IS DEALLOCED~</span><br></pre></td></tr></table></figure>
<p>可以看到，自定义的 ASDFThread 线程对象在执行完任务之后，自动销毁了。<br>&emsp;</p>
<p>如果要线程执行完任务后，仍不销毁可以在当前线程中开启 Runloop：<br>&emsp;</p>
<p>#示例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)onHandleEvent&#123;</span><br><span class="line">    NSLog(@&quot;++++当前线程:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    //开启runloop</span><br><span class="line">    CFRunLoopSourceContext context = &#123;0&#125;;</span><br><span class="line">    CFRunLoopSourceRef source = CFRunLoopSourceCreate(NULL, 0, &amp;context);</span><br><span class="line">    CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes);</span><br><span class="line">    CFRunLoopRun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过往子线程所在的runloop中加入一个<code>source</code>并调用<code>CFRunLoopRun()</code>，线程执行完任务后，就不会自动销毁。<br>&emsp;</p>
<p>PS：线程刚创建时并没有RunLoop，只有在第一次获取时才会创建，RunLoop会在线程结束时销毁。</p>
<h2 id="2-RunLoopMode"><a href="#2-RunLoopMode" class="headerlink" title="2.RunLoopMode"></a>2.RunLoopMode</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">CFStringRef _name;   //Mode的名字</span><br><span class="line"></span><br><span class="line">CFMutableSetRef _sources0;</span><br><span class="line">CFMutableSetRef _sources1;</span><br><span class="line"></span><br><span class="line">CFMutableArrayRef _observers;//观察者</span><br><span class="line">CFMutableArrayRef _timers;//计时器</span><br><span class="line">.....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Runloop 对象可以和若干个 <code>mode</code> 关联起来。但同一时间 Runloop 只能运行在一种模式下。在运行过程中，只有指定模式下的输入源才会被监听。同理，也只有指定模式下的观察者才会被通知关于当前loop的进度。当需要切换 mode 时，必须先退出当前的 RunLoop，再重新启动一个新的。</p>
<h3 id="2-1-具体模式"><a href="#2-1-具体模式" class="headerlink" title="2.1.具体模式"></a>2.1.具体模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDefaultRunLoopMode</span><br></pre></td></tr></table></figure>
<p>系统默认模式，系统不做任何操作、空闲状态；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UITrackingRunLoopMode</span><br></pre></td></tr></table></figure>
<p>界面跟踪模式，用以在拖动界面时限制其他事件的进入；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoopCommonModes</span><br></pre></td></tr></table></figure>
<p>这是个可配置的模式集合，默认包括了 <code>Default</code> 和 <code>EventTracking</code> 模式。将 <code>输入源</code> 与该模式关联，实质是将<code>输入源</code>与该组中的每个模式进行了关联。</p>
<h3 id="2-2-定时器失效"><a href="#2-2-定时器失效" class="headerlink" title="2.2.定时器失效"></a>2.2.定时器失效</h3><p>定时器默认使用<code>default</code>模式，而拖拽滚动 scrollview 时 Runloop 处于 <code>Tracking</code> 模式。由于 Runloop 一次只能运行在一种模式下，所以滚动过程中无法处理定时器事件，定时器不会触发。<br>&emsp;</p>
<p>解决方案1：将定时器标记为<code>common</code>模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *aTimer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(repeat:) userInfo:nil repeats:true];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:aTimer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p>解决方案2：将定时器放入子线程中并开启此线程的 runloop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(aSelector:) userInfo:nil repeats:true];</span><br><span class="line">    [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="3-事件来源"><a href="#3-事件来源" class="headerlink" title="3.事件来源"></a>3.事件来源</h2><p><img src="https://davidlii.nos-eastchina1.126.net/pic_runloop.jpg" alt="image"></p>
<h3 id="3-1-输入源"><a href="#3-1-输入源" class="headerlink" title="3.1.输入源"></a>3.1.输入源</h3><p>输入源事件分为<code>source0</code>和<code>source1</code>两种:</p>
<ul>
<li>source0：诸如UIEvent（触摸，滑动等），performSelector这种需要手动触发的事件。</li>
<li>source1：基于端口的事件，处理系统内核的mach_msg事件。诸如唤醒RunLoop或者让RunLoop进入休眠节省资源等。</li>
</ul>
<h4 id="3-1-1-基于端口的输入源"><a href="#3-1-1-基于端口的输入源" class="headerlink" title="3.1.1.基于端口的输入源"></a>3.1.1.基于端口的输入源</h4><p><code>Source1</code>类型，能主动唤醒线程的 RunLoop。内核中进程间的通信通过在两个端口之间传递消息来实现，Source1 监听这些端口。<br>&emsp;</p>
<p>#示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (void)runloopPortTest</span><br><span class="line">&#123;</span><br><span class="line">    //创建端口</span><br><span class="line">    NSPort *PORT1 = [NSMachPort new];</span><br><span class="line">    NSPort *PORT2 = [NSMachPort port];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;\nPORT1:%@ \nPORT2:%@&quot;,PORT1, PORT2);</span><br><span class="line"></span><br><span class="line">    //设置端口的代理</span><br><span class="line">    PORT1.delegate = self;</span><br><span class="line">    PORT2.delegate = self;</span><br><span class="line"></span><br><span class="line">    //给主线程runloop加一个端口</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:PORT1 forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">    //给子线程添加端口并启动其runloop</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        [[NSRunLoop currentRunLoop] addPort:PORT2 forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //component参数数组中只能包含两种类型的数据：一种是NSPort的子类，一种是NSData的子类；</span><br><span class="line">    NSString *STR = @&quot;III&quot;;</span><br><span class="line">    NSData   *data = [STR dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    NSMutableArray *array = [NSMutableArray arrayWithArray:@[PORT1,data]];</span><br><span class="line"></span><br><span class="line">    //2秒后向PORT2发送消息</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [PORT2 sendBeforeDate:[NSDate date] msgid:101 components:array from:PORT1 reserved:0];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -NSPortDelegate</span><br><span class="line">- (void)handlePortMessage:(NSMessagePort*)message&#123;</span><br><span class="line">    //1. 消息id</span><br><span class="line">    NSUInteger msgId = [[message valueForKeyPath:@&quot;msgid&quot;] integerValue];</span><br><span class="line">    //2. 当前主线程的port</span><br><span class="line">    NSPort *localPort = [message valueForKeyPath:@&quot;localPort&quot;];</span><br><span class="line">    //3. 接收到消息的port（来自其他线程）</span><br><span class="line">    NSPort *remotePort = [message valueForKeyPath:@&quot;remotePort&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;\n执行端口代理回调：\n端口ID = %lu \nlocalPort:%@ \nremotePort:%@&quot;,(unsigned long)msgId, localPort, remotePort);</span><br><span class="line"></span><br><span class="line">    if (101 == msgId)&#123;</span><br><span class="line">        //向子线的port发送消息</span><br><span class="line">        [remotePort sendBeforeDate:[NSDate date] msgid:102 components:nil from:localPort reserved:0];</span><br><span class="line">    &#125; else if (102 == msgId)&#123;</span><br><span class="line">    //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">19:30:24.335</span><br><span class="line">PORT1:&lt;NSMachPort: 0x600000549d70&gt;</span><br><span class="line">PORT2:&lt;NSMachPort: 0x600000340370&gt;</span><br><span class="line">19:30:26.337</span><br><span class="line">执行端口代理回调：</span><br><span class="line">端口ID = 101</span><br><span class="line">localPort:&lt;NSMachPort: 0x600000340370&gt;</span><br><span class="line">remotePort:&lt;NSMachPort: 0x600000549d70&gt;</span><br><span class="line">19:30:26.337</span><br><span class="line">执行端口代理回调：</span><br><span class="line">端口ID = 102</span><br><span class="line">localPort:&lt;NSMachPort: 0x600000549d70&gt;</span><br><span class="line">remotePort:&lt;NSMachPort: 0x600000340370&gt;</span><br></pre></td></tr></table></figure>
<p>示例中两个线程间互相发送了一条消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)sendBeforeDate:(NSDate *)limitDate msgid:(NSUInteger)msgID components:(NSMutableArray *)components from:(NSPort *)receivePort reserved:(NSUInteger)headerSpaceReserved;</span><br></pre></td></tr></table></figure>
<p>上面方法中，参数components数组中只能传NSPort、NSData类型的数据，所以除了NSPort对象外，其他数据需要先转成NSData类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSPortDelegate &lt;NSObject&gt;</span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">- (void)handlePortMessage:(NSPortMessage *)message;</span><br><span class="line">// This is the delegate method that subclasses should send</span><br><span class="line">// to their delegates, unless the subclass has something</span><br><span class="line">// more specific that it wants to try to send first</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>消息回调之后，通过上面的代理接收，其中的 NSMessagePort 类型只能用 <code>KVC</code> 的方式取值。</p>
<h4 id="3-1-2-自定义的输入源"><a href="#3-1-2-自定义的输入源" class="headerlink" title="3.1.2.自定义的输入源"></a>3.1.2.自定义的输入源</h4><p><code>Source0</code>类型，它并不能主动触发事件。使用时要先调用 <code>CFRunLoopSourceSignal()</code>，将此 Source 标记为待处理。然后看当前 Runloop 是否在休眠中，如果是则手动调用 <code>CFRunLoopWakeUp()</code> 来唤醒 RunLoop，让其处理这个事件。<br>&emsp;</p>
<p>#示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void sourcePerformor(void* info)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;处理自定义输入源事件&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)customInputsource</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;开启线程.......&quot;);</span><br><span class="line">    _mRunLoopRef = CFRunLoopGetCurrent();</span><br><span class="line"></span><br><span class="line">    //创建CFRunLoopSourceContext对象</span><br><span class="line">    CFRunLoopSourceContext mContext;</span><br><span class="line">    bzero(&amp;mContext, sizeof(mContext));</span><br><span class="line"></span><br><span class="line">    //给context对象绑定一个函数</span><br><span class="line">    mContext.perform = sourcePerformor;</span><br><span class="line">    mContext.info = &quot;information&quot;;</span><br><span class="line"></span><br><span class="line">    //创建CFRunLoopSourceRef对象</span><br><span class="line">    _mSourceRef = CFRunLoopSourceCreate(NULL, 0, &amp;mContext);</span><br><span class="line"></span><br><span class="line">    //将source添加到当前RunLoop中</span><br><span class="line">    CFRunLoopAddSource(_mRunLoopRef, _mSourceRef, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    //开启Runloop</span><br><span class="line">    CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10000, YES);</span><br><span class="line">    NSLog(@&quot;线程结束.......&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //2秒后执行</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">    if (CFRunLoopIsWaiting(_mRunLoopRef)) &#123;</span><br><span class="line">        NSLog(@&quot;RunLoop正在等待事件输入+++&quot;);</span><br><span class="line">        //添加输入事件</span><br><span class="line">        CFRunLoopSourceSignal(_mSourceRef);</span><br><span class="line">        //唤醒线程，线程唤醒后发现由事件需要处理，于是立即处理事件</span><br><span class="line">        CFRunLoopWakeUp(_mRunLoopRef);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;RunLoop正在处理事件+++&quot;);</span><br><span class="line">        //添加输入事件，当前正在处理一个事件，当前事件处理完成后，立即处理当前新输入的事件</span><br><span class="line">        CFRunLoopSourceSignal(_mSourceRef);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后，输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00:32:21.497879+0800  开启线程.......</span><br><span class="line">00:32:24.663180+0800  RunLoop正在等待事件输入+++</span><br><span class="line">00:32:24.663498+0800  处理自定义输入源事件</span><br><span class="line">00:32:24.663881+0800  线程结束.......</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-Perform-Selector"><a href="#3-1-3-Perform-Selector" class="headerlink" title="3.1.3.Perform Selector"></a>3.1.3.Perform Selector</h4><p><code>Source0</code>类型，是 Cocoa 提供的一种自定义的源，允许你在任何线程上执行一个selector。下面列举了<code>NSObject</code>分类中定义的三种<code>performSelector</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (NSThreadPerformAdditions)</span><br><span class="line"></span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector </span><br><span class="line">withObject:(id)arg </span><br><span class="line">waitUntilDone:(BOOL)wait </span><br><span class="line">modes:(NSArray&lt;NSString *&gt; *)array;</span><br><span class="line"></span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector </span><br><span class="line">withObject:(id)arg </span><br><span class="line">waitUntilDone:(BOOL)wait;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector </span><br><span class="line">onThread:(NSThread *)thr </span><br><span class="line">withObject:(id)arg </span><br><span class="line">waitUntilDone:(BOOL)wait </span><br><span class="line">modes:(NSArray&lt;NSString *&gt; *)array;</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector </span><br><span class="line">onThread:(NSThread *)thr </span><br><span class="line">withObject:(id)arg </span><br><span class="line">waitUntilDone:(BOOL)wait;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector </span><br><span class="line">withObject:(id)arg;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>OnMainThread</code> 是在主线程上执行任务；</li>
<li><code>onThread</code> 是在你指定的线程中执行任务，可以是主线程也可以是子线程；</li>
<li><code>InBackground</code> 则是在由系统自动分配的一个子线程中执行任务；</li>
<li><code>withObject</code> 是 selector 方法的参数；</li>
<li><code>waitUntilDone</code> 表示 <code>performSelector</code> 所处的线程是否等 <code>selector</code> 中的任务执行完再继续执行下一行；</li>
</ul>
<p>#示例：</p>
<ul>
<li>自定义的子线程工具类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@interface ASDFThreadHelper : NSObject</span><br><span class="line"></span><br><span class="line">-(NSThread *)getThread;</span><br><span class="line">- (void)finish;</span><br><span class="line">-(instancetype)initWithName:(NSString*)name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface ASDFThreadHelper()</span><br><span class="line">@property (nonatomic, strong) NSThread *thread;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ASDFThreadHelper</span><br><span class="line"></span><br><span class="line">-(instancetype)initWithName:(NSString*)name&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _thread = [[NSThread alloc] initWithTarget:self selector:@selector(onThreadInit:) object:nil];</span><br><span class="line">        _thread.name = name;</span><br><span class="line">        [_thread start];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSThread *)getThread&#123;</span><br><span class="line">    return _thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)onThreadInit:(id)obj&#123;</span><br><span class="line">    //因为是子线程，所以需要启动其runloop，不然子线程启动后就立刻退出，performselector时会崩溃</span><br><span class="line">    CFRunLoopRun();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)start&#123;</span><br><span class="line">    [_thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)finish&#123;</span><br><span class="line">    CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>调用performSelector</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface AppDelegate()</span><br><span class="line">@property (nonatomic, strong) ASDFThreadHelper *threadHelper;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AppDelegate</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;+++before:%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">    _threadHelper = [[ASDFThreadHelper alloc] initWithName:@&quot;asdf&quot;];</span><br><span class="line">    [self performSelector:@selector(onSelector:) onThread:[_threadHelper getThread] withObject:nil waitUntilDone:YES];</span><br><span class="line">    NSLog(@&quot;+++after:%ld&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self)));</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)onSelector:(id)obj&#123;</span><br><span class="line">    NSLog(@&quot;+++excute:%ld,thread:%@,&quot;,(long)CFGetRetainCount((__bridge CFTypeRef)(self)),[NSThread currentThread]);</span><br><span class="line">    [_threadHelper finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++before:1</span><br><span class="line">+++excute:2,thread:&lt;NSThread: 0x600001850c40&gt;&#123;number = 3, name = asdf&#125;,</span><br><span class="line">+++after:1</span><br></pre></td></tr></table></figure>
<p>从日志来看：</p>
<ul>
<li>selector 会在我们指定的子线程中执行任务；</li>
<li>如果 <code>waitUntilDone=YES</code>，执行到 [self perform..onThread..] 时，主线程会等待 selector 执行完之后才继续执行下一行；</li>
<li>给 selector 指定的线程一定要有效，不能是已经退出的，所以我们需要在工具类中将子线程中的 runloop 启动起来；</li>
</ul>
<h3 id="3-2-定时源"><a href="#3-2-定时源" class="headerlink" title="3.2.定时源"></a>3.2.定时源</h3><h4 id="3-2-1-NSTimer"><a href="#3-2-1-NSTimer" class="headerlink" title="3.2.1.NSTimer"></a>3.2.1.NSTimer</h4><p>在预设的时间点或重复的时间间隔，触发某个操作。</p>
<ul>
<li>Cocoa中使用定时器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti </span><br><span class="line">target:(id)aTarget </span><br><span class="line">selector:(SEL)aSelector </span><br><span class="line">userInfo:(id)userInfo </span><br><span class="line">repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval </span><br><span class="line">repeats:(BOOL)repeats </span><br><span class="line">block:(void (^)(NSTimer *timer))block;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti </span><br><span class="line">invocation:(NSInvocation *)invocation </span><br><span class="line">repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFireDate:(NSDate *)date </span><br><span class="line">interval:(NSTimeInterval)interval </span><br><span class="line">repeats:(BOOL)repeats </span><br><span class="line">block:(void (^)(NSTimer *timer))block;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFireDate:(NSDate *)date </span><br><span class="line">interval:(NSTimeInterval)ti </span><br><span class="line">target:(id)t </span><br><span class="line">selector:(SEL)s </span><br><span class="line">userInfo:(nullable id)ui </span><br><span class="line">repeats:(BOOL)rep;</span><br></pre></td></tr></table></figure>
<p>以上五种方法，是创建一个<code>NSTimer</code>对象，分别使用<code>selector</code>与<code>block</code>作为方法体。通过这五种方式创建的<code>NSTimer</code>对象需要被手动加入 Runloop 中并指定模式。NSRunloop 提供了<code>-addTimer:forMode:</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti</span><br><span class="line">target:(id)aTarget </span><br><span class="line">selector:(SEL)aSelector </span><br><span class="line">userInfo:(id)userInfo </span><br><span class="line">repeats:(BOOL)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">repeats:(BOOL)repeats </span><br><span class="line">block:(void (^)(NSTimer *timer))block;</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti </span><br><span class="line">invocation:(NSInvocation *)invocation </span><br><span class="line">repeats:(BOOL)yesOrNo;</span><br></pre></td></tr></table></figure>
<p>以上三种方式会自动创建一个<code>NSTimer</code>对象并以<code>DefaultMode</code>加入到 Runloop 中。</p>
<ul>
<li>Core Foundation 中配置定时器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopTimerContext context = &#123;0, NULL, NULL, NULL, NULL&#125;;</span><br><span class="line"></span><br><span class="line">CFRunLoopTimerRef aTimerRef = CFRunLoopTimerCreate(</span><br><span class="line">kCFAllocatorDefault, </span><br><span class="line">1, //fireDate</span><br><span class="line">1, //interval</span><br><span class="line">0, //flags</span><br><span class="line">0,</span><br><span class="line">&amp;onScheduleTimer, //CFRunLoopTimerCallBack 回调函数</span><br><span class="line">&amp;context);</span><br><span class="line"></span><br><span class="line">CFRunLoopAddTimer(runLoop, aTimerRef, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>
<ul>
<li>定时器引起的内存释放问题</li>
</ul>
<p>在一个界面中启动了<code>NSTimer</code>，离开界面前如果<code>NSTimer</code>还没执行完，那么这个界面就无法释放，即使把这个<code>NSTimer</code>对象置为nil。这是因为<code>NSTimer</code>对象会<code>强引用</code>它的 target，Runloop 中还保有这个对象。所以记得把<code>NSTimer</code>置为<code>invalidate</code>。</p>
<blockquote>
<p>定时器可以产生基于时间的通知，但它并不是一种real-time的机制。</p>
</blockquote>
<ul>
<li>如果子线程的 Runloop 根本没有运行，那么定时器也不会触发；</li>
<li>定时器也和 Runloop 的 mode 相关。如果定时器所在的模式当前未被 Runloop 监视，那么定时器将不会触发；</li>
<li>重复类型的定时器，添加到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。比如t，t + 5，t + 10。。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。</li>
</ul>
<p>#示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Timer-Runloop.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Timer_Runloop</span><br><span class="line"></span><br><span class="line">- (void)scheduleTimer</span><br><span class="line">&#123;</span><br><span class="line">    //创建timer 间隔1秒</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(onScheduleTimer) userInfo:nil repeats:YES];</span><br><span class="line">    //在第3秒的时 模拟一个复杂运算</span><br><span class="line">    [self performSelector:@selector(onMassTasks) withObject:nil afterDelay:3];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)onScheduleTimer</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;++++1秒重复定时执行++++&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)onMassTasks</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;+++开始处理复杂运算+++&quot;);</span><br><span class="line">    for (int i = 0; i&lt; 0xffffffff; i++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;++++++复杂运算完成++++++&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>调用之后输入日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">20:30:10.952360 ++++1秒重复定时执行++++</span><br><span class="line">20:30:11.952263 ++++1秒重复定时执行++++</span><br><span class="line">20:30:12.952284 ++++1秒重复定时执行++++</span><br><span class="line">20:30:12.952628 +++开始处理复杂运算+++</span><br><span class="line">20:30:24.104517 ++++++复杂运算完成++++++</span><br><span class="line">20:30:24.104825 ++++1秒重复定时执行++++</span><br><span class="line">20:30:24.952362 ++++1秒重复定时执行++++</span><br><span class="line">20:30:25.951624 ++++1秒重复定时执行++++</span><br><span class="line">20:30:26.951637 ++++1秒重复定时执行++++</span><br></pre></td></tr></table></figure>
<p>从日志可以看到：当线程空闲的时候定时器的消息触发还是比较准确的，但是在30分12秒开始线程一直忙着做大量运算，直到30分24秒该运算才结束，这时候定时器回调才触发。这个线程繁忙的过程超过了一个周期，但是定时器并没有连着触发两次消息，而是只触发了一次。也就是说繁忙期间的几次回调都跳过了，繁忙过后立刻执行了一次回调，之后又正常1秒执行一次回调。</p>
<h4 id="3-2-2-特殊的定时器"><a href="#3-2-2-特殊的定时器" class="headerlink" title="3.2.2.特殊的定时器"></a>3.2.2.特殊的定时器</h4><p><code>NSTimer</code>是最常见的定时器，除此之外<code>NSObject</code>的分类中还定义了一些特殊的定时器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (NSDelayedPerforming)</span><br><span class="line"></span><br><span class="line">//延时</span><br><span class="line">- (void)performSelector:(SEL)aSelector </span><br><span class="line">withObject:(id)anArgument </span><br><span class="line">afterDelay:(NSTimeInterval)delay </span><br><span class="line">inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector </span><br><span class="line">withObject:(id)anArgument </span><br><span class="line">afterDelay:(NSTimeInterval)delay;</span><br><span class="line"></span><br><span class="line">//取消延时</span><br><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget </span><br><span class="line">selector:(SEL)aSelector </span><br><span class="line">object:(nullable id)anArgument;</span><br><span class="line"></span><br><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>#示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application</span><br><span class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;+++runloop:%@&quot;,[NSRunLoop currentRunLoop]);</span><br><span class="line">        [self performSelector:@selector(onSelector:) withObject:nil afterDelay:1];</span><br><span class="line">        CFRunLoopRun();//启动子线程的runloop</span><br><span class="line">    &#125;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)onSelector:(id)obj&#123;</span><br><span class="line">    NSLog(@&quot;+++thread:%@,++runloop:%@&quot;,[NSThread currentThread],[NSRunLoop currentRunLoop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出日志(有删减，保留了主要内容)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00:37:32.940571+0800  +++runloop:&lt;CFRunLoop 0x6000003a6700 [0x10f518b68]&gt;</span><br><span class="line">。。。</span><br><span class="line">entries =&gt;</span><br><span class="line">    2 : &lt;CFRunLoopMode 0x6000004bd380 [0x10f518b68]&gt;&#123;name = kCFRunLoopDefaultMode, port set = 0x6107, queue = 0x6000011ae580, source = 0x6000011ae800 (not fired), timer port = 0x6303, </span><br><span class="line">    sources0 = (null),</span><br><span class="line">    sources1 = (null),</span><br><span class="line">    observers = (null),</span><br><span class="line">    timers = (null),</span><br><span class="line">    currently 567103053 (93847654758052) / soft deadline in: 1.84466502e+10 sec (@ -1) / hard deadline in: 1.84466502e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">00:37:33.946446+0800 +++thread:&lt;NSThread: 0x600002acc780&gt;</span><br><span class="line">。。。</span><br><span class="line">entries =&gt;</span><br><span class="line">    2 : &lt;CFRunLoopMode 0x6000004bd380 [0x10f518b68]&gt;&#123;name = kCFRunLoopDefaultMode, port set = 0x6107, queue = 0x6000011ae580, source = 0x6000011ae800 (not fired), timer port = 0x6303, </span><br><span class="line">    sources0 = (null),</span><br><span class="line">    sources1 = (null),</span><br><span class="line">    observers = (null),</span><br><span class="line">    timers = &lt;CFArray 0x600001ba25e0 [0x10f518b68]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;,</span><br><span class="line">    currently 567103054 (93848660601765) / soft deadline in: 1.84466502e+10 sec (@ -1) / hard deadline in: 1.84466502e+10 sec (@ -1)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>从日志可以看到，在调用<code>performSelector..afterDelay</code>之后，子线程 runloop 的 CFRunLoopMode 中<code>timers</code>有了对象！它就是系统为延时操作创建的一个定时器~<br>&emsp;</p>
<p>另外，在调用<code>-onSelector:</code>时打断点，可得到如下的堆栈信息：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_perform_afterDelay.png" alt="pic_perform_afterDelay"></p>
<p>从堆栈上可以看到，<strong>延时操作的本质实现是运行时在当前线程的 runloop 中添加了一个<code>定时源</code></strong>~<br>&emsp;</p>
<p>需要注意的是：<strong>在子线程中使用这种延时执行方法时，如果不主动启动子线程的 runloop，那么 selector 是不会执行的</strong>。这也印证了前面提到的“如果子线程的 Runloop 根本没有运行，那么定时器也不会触发”，实际的开发中一定要注意这一点。<br>&emsp;</p>
<p>另外：这两个方法都只是将<code>selector</code>的调用延迟某个时间长度，并不影响调用方法时所处的线程，即在什么线程调用这两个<code>performSelector</code>，延迟后的<code>selector</code>还是在这个线程中执行。</p>
<h2 id="4-观察者"><a href="#4-观察者" class="headerlink" title="4.观察者"></a>4.观察者</h2><p>Runloop在处理输入事件的同时，在其运行的特定阶段还会触发通知。我们可以使用 CF 的方法，注册观察者来接收通知并在某个特定时期处理一些事情。<br>&emsp;<br>Runloop可以被观察的状态包括以下阶段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0),         //runloop进入时；</span><br><span class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),  //将要处理Timer时;</span><br><span class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //将要处理Source0时；</span><br><span class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //将要进入睡眠时；</span><br><span class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),  //将要被唤醒时；</span><br><span class="line">kCFRunLoopExit = (1UL &lt;&lt; 7),          //runloop即将退出时；</span><br><span class="line">kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-事件序列"><a href="#5-事件序列" class="headerlink" title="5.事件序列"></a>5.事件序列</h2><p>1、通知观察者 Runloop 已经启动;</p>
<p>2、通知观察者 <code>Timers</code> 即将触发;</p>
<p>3、通知观察者 将要处理 <code>Source0</code>;</p>
<p>4、触发 <code>Source0</code> 回调;</p>
<p>5、如果有 <code>Source1</code> 处于 <code>ready</code> 状态，直接处理该 <code>Source1</code> 并进入步骤9;</p>
<p>6、通知观察者 线程即将休眠;</p>
<p>7、线程休眠 等待以下情形的唤醒：</p>
<ul>
<li>某一事件到达基于端口的源(Source1);</li>
<li>定时器时间到了;</li>
<li>Runloop 设置的时间已经超时;</li>
<li>Runloop 被手动唤醒;</li>
</ul>
<p>8、通知观察者线程将被唤醒;</p>
<p>9、处理唤醒时收到的消息：</p>
<ul>
<li>如果消息是<code>Timer</code>类型，则触发该<code>Timer</code>的回调；</li>
<li>如果消息是 dispatch 到 <code>main_ queue</code> 的block，执行block；</li>
<li>如果消息是<code>Source1</code>类型，则处理<code>Source1</code>回调；</li>
</ul>
<p>10、以下条件中满足时候退出循环，否则从（2）继续循环：</p>
<ul>
<li>事件处理完毕而且启动 RunLoop 的时候参数设置为一次性执行；</li>
<li>启动 RunLoop 时设置的最大运行时间到期；</li>
<li>RunLoop 被外部调用强行停止；</li>
<li>启动 RunLoop 的 mode items为空；</li>
</ul>
<p>11、通知观察者 Runloop 结束。</p>
<p>&emsp;</p>
<p>上面逻辑对应的 <a href="https://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c.auto.html" target="_blank" rel="noopener">CFRunLoop.c源码</a> 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">CFRunLoopRunSpecific(CFRunLoopGetCurrent(), </span><br><span class="line">kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, </span><br><span class="line">CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), </span><br><span class="line">modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName,</span><br><span class="line">seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">/// 首先根据modeName找到对应mode</span><br><span class="line">CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">/// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line"></span><br><span class="line">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">/// 内部函数，进入loop</span><br><span class="line">__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">Boolean sourceHandledThisLoop = NO;</span><br><span class="line">int retVal = 0;</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">/// 执行被加入的block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">/// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">/// 执行被加入的block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">if (hasMsg) goto handle_msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">if (!sourceHandledThisLoop) &#123;</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">/// • 一个基于 port 的Source 的事件。</span><br><span class="line">/// • 一个 Timer 到时间了</span><br><span class="line">/// • RunLoop 自身的超时时间到了</span><br><span class="line">/// • 被其他什么调用者手动唤醒</span><br><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">/// 收到消息，处理消息。</span><br><span class="line">handle_msg:</span><br><span class="line"></span><br><span class="line">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">if (msg_is_timer) &#123;</span><br><span class="line">__CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">else if (msg_is_dispatch) &#123;</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">else &#123;</span><br><span class="line">CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop,</span><br><span class="line">currentMode, livePort);</span><br><span class="line"></span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, </span><br><span class="line">currentMode, source1, msg);</span><br><span class="line"></span><br><span class="line">if (sourceHandledThisLoop) &#123;</span><br><span class="line">mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 执行加入到Loop的block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">/// 进入loop时参数说处理完事件就返回。</span><br><span class="line">retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">&#125; else if (timeout) &#123;</span><br><span class="line">/// 超出传入参数标记的超时时间了</span><br><span class="line">retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">/// 被外部调用者强制停止了</span><br><span class="line">retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">/// source/timer/observer一个都没有了</span><br><span class="line">retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">&#125; while (retVal == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个<code>do-while</code> 循环。当你调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。RunLoop 的核心是 <code>mach_msg()</code> 函数(见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。</p>
<h2 id="6-什么时候用？"><a href="#6-什么时候用？" class="headerlink" title="6.什么时候用？"></a>6.什么时候用？</h2><ol>
<li>开启常驻线程时，需要在当前线程中启动 runloop，如AFN；</li>
<li>在子线程中使用定时器时，需要在子线程中启动 runloop，定时器才能正常启动；</li>
<li>设置定时器，在当前 runloop 的特定模式下执行；</li>
<li>让某些行为在当前 runloop 的特定模式下才执行，如滑动时的定时器、default模式下设置图片、加载缓存等。</li>
<li>添加观察者，在 runloop 的特定时刻处理某些事情；</li>
<li>使用端口或自定义输入源来和其他线程通信；</li>
</ol>
<h2 id="7-Runloop对象"><a href="#7-Runloop对象" class="headerlink" title="7.Runloop对象"></a>7.Runloop对象</h2><p>Runloop 对象提供了添加输入源、定时器、观察者以及启动 Runloop 的接口。每个线程都有唯一的与之关联的 Runloop对象。Cocoa和 CF 都有相应的接口可以操作 RunLoop：</p>
<ul>
<li>Cocoa中对应的是 NSRunLoop；</li>
<li>CF 中对应的是 CFRunLoopRef；</li>
</ul>
<h3 id="7-1-获取-RunLoop对象"><a href="#7-1-获取-RunLoop对象" class="headerlink" title="7.1.获取 RunLoop对象"></a>7.1.获取 RunLoop对象</h3><ul>
<li>CFRunLoopRef <a href="https://developer.apple.com/documentation/corefoundation/cfrunloop-rht" target="_blank" rel="noopener">（官方文档）</a></li>
</ul>
<p>这是 CF 框架提供的，它提供了纯C函数的API，这些API都是线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef *aCFRunloopObjRef = CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure>
<ul>
<li>NSRunLoop<a href="https://developer.apple.com/documentation/foundation/nsrunloop" target="_blank" rel="noopener">（官方文档）</a></li>
</ul>
<p>这是Cocoa框架提供的，它提供了面向对象的 API，是基于CFRunLoopRef的一层封装，但这些API是非线程安全的；苹果官方文档说，我们不能在当前线程中去call另外一个线程中 NSRunLoop 对象的方法，那样很可能会造成意想不到的后果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *aRunloopObj = [NSRunLoop currentRunLoop];</span><br></pre></td></tr></table></figure>
<p>不过，两种类型的 Runloop 可以混合使用。鉴于 CFRunLoopRef 是线程安全的，所以，可以通过 NSRunLoop 类的实例方法获取对应的 CFRunLoopRef 对象，进而达到线程安全的目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *aRunloopObj = [NSRunLoop currentRunLoop];</span><br><span class="line">CFRunLoopRef *aCFRunloopObjRef = [aRunloopObj getCFRunLoop];</span><br></pre></td></tr></table></figure>
<h3 id="7-2-启动RunLoop"><a href="#7-2-启动RunLoop" class="headerlink" title="7.2.启动RunLoop"></a>7.2.启动RunLoop</h3><h4 id="7-2-1-NSRunLoop的启动"><a href="#7-2-1-NSRunLoop的启动" class="headerlink" title="7.2.1.NSRunLoop的启动"></a>7.2.1.NSRunLoop的启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)run; //无条件的启动</span><br></pre></td></tr></table></figure>
<p>不建议使用，因为这个接口会导致Run Loop永久性的在NSDefaultRunLoopMode模式。<br>即使用CFRunLoopStop()函数也无法停止Run Loop的运行，除非能移除这个runloop上的所有事件源，不然这个子线程就无法停止，只能永久运行下去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)runUntilDate:(NSDate *)limitDate;//设置超时时间</span><br></pre></td></tr></table></figure>
<p>比上面的接口好点，有个超时时间，可以控制每次 Runloop 的运行时间，也是运行在<code>NSDefaultRunLoopMode</code>模式。这个方法运行 Runloop 一段时间会退出给你检查运行条件的机会，如果需要可以再次运行 Runloop。<br>&emsp;</p>
<p>注意：使用这种方式启动runloop时，CFRunLoopStop()函数也无法停止这个run Loop。<br>&emsp;</p>
<p>#示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL finished = NO;</span><br><span class="line"></span><br><span class="line">while(!finished) &#123;</span><br><span class="line">[[NSRunLoop currentRunLoop] runUntilDate:</span><br><span class="line">[NSDate dateWithTimeIntervalSinceNow: 1]];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;exit runloop ......&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个finished是我们自定义的一个Bool值，用来控制是否还需要开启下一次 Runloop。<br>&emsp;</p>
<p>上面例子所做的事：while循环内部有个 RunLoop 每秒循环一次，Runloop 结束后会输出<code>exit Runloop ……</code>。while循环会根据 finished 值来判断是否再去运行 Runloop。<br>&emsp;</p>
<p>输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">21:20:20.980211+0800 exit runloop ......</span><br><span class="line">21:20:21.981915+0800 exit runloop ......</span><br><span class="line">21:20:22.983668+0800 exit runloop ......</span><br><span class="line">21:20:23.984748+0800 exit runloop ......</span><br><span class="line">21:20:24.986541+0800 exit runloop ......</span><br><span class="line">21:20:25.988267+0800 exit runloop ......</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;//特定的模式</span><br></pre></td></tr></table></figure>
<p>比上面的方法多了mode参数，不同的是，这种运行方式是可以被<code>CFRunLoopStop()</code>函数停止的。</p>
<h4 id="7-2-2-CFRunLoopRef的启动"><a href="#7-2-2-CFRunLoopRef的启动" class="headerlink" title="7.2.2.CFRunLoopRef的启动"></a>7.2.2.CFRunLoopRef的启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRun();</span><br></pre></td></tr></table></figure>
<p>使用这种方式启动后，Runloop 会一直运行，直到显示地调用<code>CFRunLoopStop()</code>才会停止。另外，删除 RunLoop 的所有事件源后，也能停止这个 Runloop。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SInt32 CFRunLoopRunInMode(mode, second, returnAfterSourceHandled);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数mode：模式；</li>
<li>参数second：runloop的循环时间；</li>
<li>参数returnAfterSourceHandled：是否在处理事件后让Run Loop退出返回；</li>
</ul>
<p>这种方式启动的 Runloop 也可以使用<code>CFRunLoopStop()</code>来主动停止。NSRunloop 中的第三种启动方式，实质上就是基于这种方式的封装，只不过指定了最后一个<code>returnAfterSourceHandled</code>参数为YES。</p>
<ul>
<li>Runloop的返回值</li>
</ul>
<p>启动 Runloop 后，代码是停在这一行不返回的。当有值返回时，Runloop 就结束了。这个返回值就是 Runloop 结束原因。枚举如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Reasons for CFRunLoopRunInMode() to Return */</span><br><span class="line">typedef CF_ENUM(SInt32, CFRunLoopRunResult) &#123;</span><br><span class="line">kCFRunLoopRunFinished = 1,  //Runloop结束，所有的Sources都已被移除，无事件源可监听；</span><br><span class="line">kCFRunLoopRunStopped = 2,   //Runloop被使用CFRunLoopStop函数停止；</span><br><span class="line">kCFRunLoopRunTimedOut = 3,  //超时；</span><br><span class="line">kCFRunLoopRunHandledSource = 4 //Runloop已处理完事件；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>回头看看NSRunloop的第三种启动方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (Bool)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</span><br></pre></td></tr></table></figure>
<p>返回值为一个Bool值，如果是”performSelector” 事件或者其他 Input Source 事件触发并处理完成后，Runloop会退出并返回YES，其他情况下返回NO。<br>&emsp;</p>
<p>#示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">- (void)runloopReturnTest</span><br><span class="line">&#123;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">NSRunLoop *mRunloop = [NSRunLoop currentRunLoop];</span><br><span class="line"></span><br><span class="line">// 创建一个观察者.</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(</span><br><span class="line">kCFAllocatorDefault,</span><br><span class="line">kCFRunLoopAllActivities,</span><br><span class="line">YES, 0,</span><br><span class="line">^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) </span><br><span class="line">&#123;</span><br><span class="line">switch (activity) &#123;</span><br><span class="line">case kCFRunLoopEntry:</span><br><span class="line">NSLog(@&quot;observer： kCFRunLoopEntry...&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopBeforeTimers:</span><br><span class="line">NSLog(@&quot;observer： kCFRunLoopBeforeTimers...&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopBeforeSources:</span><br><span class="line">NSLog(@&quot;observer： kCFRunLoopBeforeSources...&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopBeforeWaiting:</span><br><span class="line">NSLog(@&quot;observer： kCFRunLoopBeforeWaiting...&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopAfterWaiting:</span><br><span class="line">NSLog(@&quot;observer： kCFRunLoopAfterWaiting...&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopExit:</span><br><span class="line">NSLog(@&quot;observer： kCFRunLoopExit...&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (observer)</span><br><span class="line">&#123;</span><br><span class="line">//把观察者附加到runloop上</span><br><span class="line">CFRunLoopRef cfLoop = [mRunloop getCFRunLoop];</span><br><span class="line">CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;This thread starting.......&quot;);</span><br><span class="line"></span><br><span class="line">//新增计时器源并加入runloop</span><br><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:5</span><br><span class="line">target:self</span><br><span class="line">selector:@selector(onHandleTask:)</span><br><span class="line">userInfo:nil</span><br><span class="line">repeats:NO];</span><br><span class="line">[mRunloop addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">//最后一个参数：是否处理完事件返回，结束runLoop</span><br><span class="line">SInt32 result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 100, YES);</span><br><span class="line"></span><br><span class="line">switch (result) &#123;</span><br><span class="line">case kCFRunLoopRunFinished:</span><br><span class="line">NSLog(@&quot;kCFRunLoopRunFinished&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopRunStopped:</span><br><span class="line">NSLog(@&quot;kCFRunLoopRunStopped&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopRunTimedOut:</span><br><span class="line">NSLog(@&quot;kCFRunLoopRunTimedOut&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case kCFRunLoopRunHandledSource:</span><br><span class="line">NSLog(@&quot;kCFRunLoopRunHandledSource&quot;);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;This thread end.......&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)onHandleTask:(NSTimer *)timer</span><br><span class="line">&#123;</span><br><span class="line">[timer invalidate];</span><br><span class="line">NSLog(@&quot;timer Fired...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，执行到<code>CFRunLoopRunInMode</code>时，程序卡在这一行。5秒后计时器触发，计时器<code>invalidate</code>后，Runloop 中没有了任何事件源，所以退出并返回了result值，程序继续向下运行，输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">23:48:10.831  This thread starting.......</span><br><span class="line">23:48:10.831  observer： kCFRunLoopEntry...</span><br><span class="line">23:48:10.832  observer： kCFRunLoopBeforeTimers...</span><br><span class="line">23:48:10.832  observer： kCFRunLoopBeforeSources...</span><br><span class="line">23:48:10.833  observer： kCFRunLoopBeforeWaiting...</span><br><span class="line">23:48:15.834  observer： kCFRunLoopAfterWaiting...</span><br><span class="line">23:48:15.835  timer Fired...</span><br><span class="line">23:48:15.835  observer： kCFRunLoopExit...</span><br><span class="line">23:48:15.836  kCFRunLoopRunFinished</span><br><span class="line">23:48:15.836  This thread end.......</span><br></pre></td></tr></table></figure>
<h3 id="7-3-退出RunLoop"><a href="#7-3-退出RunLoop" class="headerlink" title="7.3.退出RunLoop"></a>7.3.退出RunLoop</h3><p>上面也有提到，有三种方法可以让 Runloop 处理事件之前退出:</p>
<ul>
<li>指定超时时间：</li>
</ul>
<p>这可以使 Runloop 退出前完成所有正常操作，包括发送消息给 Runloop 观察者，如果可以配置的话，推荐使用这种方法。</p>
<ul>
<li>使用CFRunLoopStop：</li>
</ul>
<p>这可以显式的停止 Runloop，Runloop 会把所有剩余的通知发送出去再退出。</p>
<ul>
<li>移除 Runloop 的输入源和定时器：</li>
</ul>
<p>尽管这种方式也可能导致 Runloop 退出，但这并不是可靠的退出 Runloop 的方法。一些系统例程会添加输入源到 Runloop 里面来处理所需事件。因为你的代码未必会考虑到这些输入源，这样可能导致你无法移除它们，从而导致退出 Runloop 失败。</p>
<h2 id="8-应用场景："><a href="#8-应用场景：" class="headerlink" title="8.应用场景："></a>8.应用场景：</h2><ul>
<li>AutoreleasePool</li>
<li>事件响应</li>
<li>手势识别</li>
<li>界面更新</li>
<li>定时器</li>
<li>GCD</li>
<li>网络请求</li>
<li>APP卡顿检测</li>
</ul>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">ibireme</a>的这篇博客里讲解的很详细，膜拜一哈~</p>
<hr>
<p>相关参考：</p>
<p>#<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">©官方文档</a></p>
<p>#<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">©ibireme</a></p>
<p>#<a href="http://blog.csdn.net/u011619283/article/details/53666009" target="_blank" rel="noopener">©微信卡顿检测</a></p>
<p>#<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">©百度孙源-优化UITableViewCell高度计算的那些事</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#runloop" >
    <span class="tag-code">runloop</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/09/01/runtime_addClass.html">
        <span class="nav-arrow">← </span>
        
          Runtime：动态增加新类、方法、属性
        
      </a>
    
    
      <a class="nav-right" href="/2017/11/07/nsthread.html">
        
          多线程：NSThread
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-Runloop"><span class="toc-nav-text">1.Runloop</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-1-作用"><span class="toc-nav-text">1.1.作用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-2-工作原理"><span class="toc-nav-text">1.2.工作原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-3-与线程的关系"><span class="toc-nav-text">1.3.与线程的关系</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#主线程"><span class="toc-nav-text">主线程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#其他线程"><span class="toc-nav-text">其他线程</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-RunLoopMode"><span class="toc-nav-text">2.RunLoopMode</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-1-具体模式"><span class="toc-nav-text">2.1.具体模式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-2-定时器失效"><span class="toc-nav-text">2.2.定时器失效</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-事件来源"><span class="toc-nav-text">3.事件来源</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-1-输入源"><span class="toc-nav-text">3.1.输入源</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-1-基于端口的输入源"><span class="toc-nav-text">3.1.1.基于端口的输入源</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-2-自定义的输入源"><span class="toc-nav-text">3.1.2.自定义的输入源</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-1-3-Perform-Selector"><span class="toc-nav-text">3.1.3.Perform Selector</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-2-定时源"><span class="toc-nav-text">3.2.定时源</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-1-NSTimer"><span class="toc-nav-text">3.2.1.NSTimer</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#3-2-2-特殊的定时器"><span class="toc-nav-text">3.2.2.特殊的定时器</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-观察者"><span class="toc-nav-text">4.观察者</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-事件序列"><span class="toc-nav-text">5.事件序列</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-什么时候用？"><span class="toc-nav-text">6.什么时候用？</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-Runloop对象"><span class="toc-nav-text">7.Runloop对象</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-1-获取-RunLoop对象"><span class="toc-nav-text">7.1.获取 RunLoop对象</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-2-启动RunLoop"><span class="toc-nav-text">7.2.启动RunLoop</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-2-1-NSRunLoop的启动"><span class="toc-nav-text">7.2.1.NSRunLoop的启动</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#7-2-2-CFRunLoopRef的启动"><span class="toc-nav-text">7.2.2.CFRunLoopRef的启动</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-3-退出RunLoop"><span class="toc-nav-text">7.3.退出RunLoop</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#8-应用场景："><span class="toc-nav-text">8.应用场景：</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/09/09/runloop.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Runloop",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>