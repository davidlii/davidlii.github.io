<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter状态管理</title>
    <link href="/2023/08/10/flutter-state.html"/>
    <url>/2023/08/10/flutter-state.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-初识状态"><a href="#1-初识状态" class="headerlink" title="1.初识状态"></a>1.初识状态</h3><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_ui-equals-function-of-state.jpg" alt="声明式UI-中文社区"></p><p>Flutter是声明式编程，通过构建用户界面来反应状态的变化，如上图：</p><ul><li><code>f</code>对应着<code>build()</code>函数;</li><li><code>state</code>是构建应用界面时所需的状态，即数据。</li></ul><p>Flutter中通过修改状态，触发界面的重绘，而非直接修改界面对象本身。</p><h4 id="1-1-原生-命令式"><a href="#1-1-原生-命令式" class="headerlink" title="1.1.原生-命令式"></a>1.1.原生-命令式</h4><p>原生开发中，点击按钮并修改一个组件的属性从而改变其状态时，通常情况下，我们会在按钮回调中找到此组件的对象，直接修改其对应属性的值，由runloop在合适的时机会重新绘制。代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">onClick</span>() &#123;<br>    myView.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>.white;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，也可以结合RX以响应式编程实现此功能，这里不作展开~</p><h4 id="1-2-Flutter-响应式"><a href="#1-2-Flutter-响应式" class="headerlink" title="1.2.Flutter-响应式"></a>1.2.Flutter-响应式</h4><p>同样的功能，在 Flutter 这种响应式框架中，一般是在按钮组件的回调中修改某个变量，再以某种方式告诉框架：我已经修改了状态值，你去重绘对应的组件树从而响应状态的变化。以计算器为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;<br>  int _counter = 0; // 1.定义变量<br><br>  void _incrementCounter() &#123;<br>    setState(() &#123;<br>      _counter++; // 3.修改状态<br>    &#125;);<br>  &#125;<br><br>  @override<br>  Widget build(BuildContext context) &#123; // 4.重绘以响应状态变化<br>    return Scaffold(<br>      //省略。。。<br>      body: Center(<br>        child: Column(<br>          children: &lt;Widget&gt;[<br>            Text(&#x27;$_counter&#x27;), // 5.获取最新_counter构建新Text<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter, // 2.执行回调函数<br>        tooltip: &#x27;Increment&#x27;,<br>        child: const Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改状态的流程是这样：</p><ol><li>按钮回调函数中对状态<code>_counter</code>做自增运算；</li><li>通过<code>setState</code>告诉框架：我已修改，你去重新绘制整个组件树；</li><li>重绘工作交给了<code>build(context)</code>函数；</li><li><code>build</code>中新建所有子树，其中子组件<code>Text</code>使用最新<code>_counter</code>展示数值。</li></ol><h3 id="2-状态分类"><a href="#2-状态分类" class="headerlink" title="2.状态分类"></a>2.状态分类</h3><p>Flutter 中状态可分两种：<code>短时状态</code>和<code>全局状态</code>。</p><h4 id="2-1-短时状态"><a href="#2-1-短时状态" class="headerlink" title="2.1.短时状态"></a>2.1.短时状态</h4><p>也称局部状态或临时状态，独立于某个组件中，只影响该组件自己的行为。</p><p>例子：</p><ul><li>前文计时器案例中的数值<code>_counter</code>；</li><li>一个 PageView 组件中的当前页面<code>_index</code>；</li><li>一个复杂动画中当前进度；</li><li>一个 BottomNavigationBar 中当前被选中的 tab；</li></ul><p>因为其他组件不需要访问此状态，也就无需状态管理架构去管理这种状态，你需要用的只是一个<code>StatefulWidget</code>。</p><h4 id="2-2-全局状态"><a href="#2-2-全局状态" class="headerlink" title="2.2.全局状态"></a>2.2.全局状态</h4><p>在多组件甚至整个应用之间共享的、在用户会话期间保留的状态，就是全局状态或称共享状态。</p><p>例子：</p><ul><li>用户偏好设置；</li><li>登录信息；</li><li>电商应用中的购物车；</li></ul><p>通常，我们可借助不同的技术实现跨组件共享状态，如传参、回调、控制器，也可以使用Flutter框架内置的<code>InheritedWidget</code>、<code>ChangeNotifier</code>、<code>StreamBuilder</code>等，还有一些优秀的三方库<code>flutter_bloc</code>、<code>Provider</code>等。</p><h3 id="3-提升状态"><a href="#3-提升状态" class="headerlink" title="3.提升状态"></a>3.提升状态</h3><p>原生开发中，兄弟组件通常以成员变量或属性的形式存在于共同的父组件中，想与对方通信(如传值或修改状态)时，一般是由前者在父组件中提供一个回调函数，在回调函数中获取对方组件的对象，通过<code>对象.setxx</code>的方式修改对方的属性值，或者调用对方提供的相关接口来处理具体业务。</p><p>而声明式框架中，通过这样的方式实现组件之间的通信是没有必要的。因为任何修改对方属性状态的行为，都相当于修改了对方的配置，会引起对方组件的重构，即对方组件会创建新的实例，以<code>对象.setxx</code>形式的修改就没有意义了，直接修改对方的 state 即可。</p><p>在声明式框架里，组件之间一般只能由上而下地传递数据，兄弟组件之间无法直接通信。Flutter 框架采用了 Facebook 在 React 中提出的<code>Lift State Up</code>理念：将需要传递的数据从子组件移到某个共同的父组件，在那里修改它，再将它传递给其他子组件。</p><h4 id="示例：购物车"><a href="#示例：购物车" class="headerlink" title="示例：购物车"></a>示例：购物车</h4><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_state-management-explainer.gif" alt="提升状态-中文社区"></p><p><code>商品目录</code>与<code>购物车</code>两组件之间传递数据的思路：</p><ol><li>两个组件之间需要共享<code>CART</code>(已加购商品)这个<code>State</code>；</li><li>提升<code>State</code>到必要的高度，直到两组件都能读取到它；</li><li>最近最合适的节点是两者共同的父组件<code>MyApp</code>；</li><li><code>MyApp</code>保存<code>State</code>对象，并分发给商品目录与购物车组件；</li><li>商品目录中通过回调等方式在<code>MyApp</code>中修改<code>State</code>；</li><li>进入购物车页面时以入参形式接收<code>MyApp</code>中的<code>State</code>；</li></ol><p>代码实现1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">void main() &#123;<br>  runApp(DakMyApp());<br>&#125;<br><br>class DakMyApp extends StatelessWidget &#123;<br>  final _cart = DakCart(); //共同父组件中共享状态<br>  DakMyApp(&#123;Key? key&#125;) : super(key: key);<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakMyApp build&#x27;);<br>    return MaterialApp(<br>      home: DakCatelogPage(<br>        cart: _cart, // 以参数形式传递数据<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>// 购物车model<br>class DakCart &#123;<br>  // 已加购商品列表<br>  final List&lt;DakItem&gt; _items = [];<br>  List get items =&gt; _items;<br>  //商品总价<br>  int get totalPrice =&gt; _items.length * 42;<br><br>  // 增加商品<br>  void add(DakItem item) &#123;<br>    _items.add(item);<br>  &#125;<br><br>  // 删除商品<br>  void delete(DakItem item) &#123;<br>    int index = _items.indexOf(item);<br>    _items.removeAt(index);<br>  &#125;<br>&#125;<br><br>// 商品model<br>class DakItem &#123;<br>  //商品名<br>  String name;<br>  //是否已加购<br>  bool selected;<br><br>  DakItem(&#123;<br>    required this.name,<br>    required this.selected,<br>  &#125;);<br>&#125;<br><br>// 商品目录页面<br>class DakCatelogPage extends StatefulWidget &#123;<br>  final DakCart cart; // 传入共享的状态<br>  const DakCatelogPage(&#123;<br>    Key? key,<br>    required this.cart,<br>  &#125;) : super(key: key);<br><br>  @override<br>  State&lt;DakCatelogPage&gt; createState() =&gt; _DakCatelogPageState();<br>&#125;<br><br>class _DakCatelogPageState extends State&lt;DakCatelogPage&gt; &#123;<br>  static final items = [<br>    &#x27;Apple&#x27;,<br>    &#x27;Banana&#x27;,<br>    &#x27;Cherry&#x27;,<br>    &#x27;Damson&#x27;,<br>    &#x27;Grape&#x27;,<br>    &#x27;Haw&#x27;,<br>    &#x27;Kiwifruit&#x27;,<br>    &#x27;Lemon&#x27;,<br>    &#x27;Mango&#x27;,<br>    &#x27;Orange&#x27;<br>  ].map((e) =&gt; DakItem(name: e, selected: false)).toList(); //模拟商品列表<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCatelogPage build&#x27;);<br>    return Scaffold(<br>      appBar: AppBar(<br>        backgroundColor: Colors.yellow,<br>        title: const Text(<br>          &#x27;Catelog&#x27;,<br>          style: TextStyle(<br>            fontSize: 28,<br>            fontWeight: FontWeight.bold,<br>            color: Colors.black,<br>          ),<br>        ),<br>        actions: [<br>          TextButton.icon(<br>            onPressed: () &#123;<br>              Navigator.of(context).push(<br>                MaterialPageRoute(<br>                  builder: (context) =&gt; DakCartPage(provider: widget.cart),<br>                ),<br>              );<br>            &#125;,<br>            icon: const Icon(<br>              Icons.shopping_cart,<br>              color: Colors.black,<br>            ),<br>            label: DakCartCounter(provider: widget.cart),<br>          ),<br>        ],<br>      ),<br>      body: ListView.builder(<br>        itemCount: items.length,<br>        itemBuilder: (context, index) &#123;<br>          return DakListCell(<br>            aItem: items[index],<br>            callback: (item) &#123;<br>              // callback 处理状态变化<br>              item.selected = !item.selected;<br>              item.selected ? widget.cart.add(item) : widget.cart.delete(item);<br>              setState(() &#123;&#125;); //刷新AppBar中的商品数量<br>            &#125;,<br>          );<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>//商品总数<br>class DakCartCounter extends StatelessWidget &#123;<br>  final DakCart provider;<br>  const DakCartCounter(&#123;<br>    Key? key,<br>    required this.provider,<br>  &#125;) : super(key: key);<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCartCounter build&#x27;);<br>    return Text(<br>      &#x27;共$&#123;provider.items.length&#125;件&#x27;,<br>      style: const TextStyle(<br>        color: Colors.black,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>// 定义cell中按钮点击的回调函数<br>typedef DakCallback = Function(DakItem);<br><br>// Row cell<br>class DakListCell extends StatefulWidget &#123;<br>  final DakItem aItem;<br>  final DakCallback callback;<br>  const DakListCell(&#123;Key? key, required this.aItem, required this.callback&#125;)<br>      : super(key: key);<br><br>  @override<br>  State&lt;DakListCell&gt; createState() =&gt; _DakListCellState();<br>&#125;<br><br>class _DakListCellState extends State&lt;DakListCell&gt; &#123;<br>  _updateState() &#123;<br>    setState(() &#123;<br>      //item.selected = !item.selected; // Cell内部处理<br>      widget.callback(widget.aItem); //执行回调，在父组件中处理数据逻辑<br>    &#125;);<br>  &#125;<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    return Container(<br>      padding: const EdgeInsets.all(10),<br>      color: Colors.white,<br>      child: Row(<br>        children: [<br>          Expanded(<br>            child: Row(<br>              children: [<br>                Container(<br>                  margin: const EdgeInsets.symmetric(horizontal: 10),<br>                  width: 50,<br>                  height: 50,<br>                  color: Colors.yellow,<br>                ),<br>                Text(<br>                  widget.aItem.name,<br>                  style: const TextStyle(<br>                    fontSize: 18,<br>                    fontWeight: FontWeight.bold,<br>                  ),<br>                ),<br>              ],<br>            ),<br>          ),<br>          Builder(<br>            builder: (context) &#123;<br>              return widget.aItem.selected<br>                  ? IconButton(<br>                      onPressed: _updateState,<br>                      icon: const Icon(Icons.check),<br>                    )<br>                  : ElevatedButton(<br>                      onPressed: _updateState,<br>                      style: ButtonStyle(<br>                        backgroundColor:<br>                            MaterialStateProperty.all(Colors.white),<br>                        elevation: MaterialStateProperty.all(0),<br>                      ),<br>                      child: const Text(<br>                        &#x27;ADD&#x27;,<br>                        style: TextStyle(color: Colors.black),<br>                      ),<br>                    );<br>            &#125;,<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>// 购物车页面<br>class DakCartPage extends StatelessWidget &#123;<br>  final DakCart provider; // 传入共享的状态<br>  const DakCartPage(&#123;Key? key, required this.provider&#125;) : super(key: key);<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCartPage build&#x27;);<br>    return Scaffold(<br>      appBar: AppBar(<br>        backgroundColor: Colors.yellow,<br>        title: const Text(<br>          &#x27;Cart&#x27;,<br>          style: TextStyle(<br>            fontSize: 28,<br>            fontWeight: FontWeight.bold,<br>            color: Colors.black,<br>          ),<br>        ),<br>      ),<br>      body: Container(<br>        color: Colors.yellow,<br>        child: Column(<br>          children: [<br>            Expanded(<br>              child: ListView.builder(<br>                itemCount: provider.items.length,<br>                itemBuilder: (context, index) &#123;<br>                  final item = provider.items[index];<br>                  return Container(<br>                    padding: const EdgeInsets.fromLTRB(20, 10, 20, 10),<br>                    child: Text(<br>                      &#x27;· $&#123;item.name&#125;&#x27;,<br>                      style: const TextStyle(<br>                        color: Colors.black,<br>                        fontSize: 18,<br>                        fontWeight: FontWeight.bold,<br>                      ),<br>                    ),<br>                  );<br>                &#125;,<br>              ),<br>            ),<br>            Container(<br>              height: 2,<br>              color: Colors.black,<br>            ),<br>            Container(<br>              padding: const EdgeInsets.symmetric(vertical: 100),<br>              child: Center(<br>                child: Row(<br>                  mainAxisAlignment: MainAxisAlignment.center,<br>                  children: [<br>                    Text(<br>                      &#x27;\$ $&#123;provider.totalPrice&#125;&#x27;,<br>                      style: const TextStyle(<br>                        fontSize: 28,<br>                        fontWeight: FontWeight.bold,<br>                      ),<br>                    ),<br>                    const SizedBox(<br>                      width: 50,<br>                    ),<br>                    ElevatedButton(<br>                      onPressed: () &#123;&#125;,<br>                      style: ButtonStyle(<br>                        backgroundColor:<br>                            MaterialStateProperty.all(Colors.white),<br>                      ),<br>                      child: const Text(<br>                        &#x27;BUY&#x27;,<br>                        style: TextStyle(<br>                          fontSize: 18,<br>                          fontWeight: FontWeight.bold,<br>                          color: Colors.black,<br>                        ),<br>                      ),<br>                    ),<br>                  ],<br>                ),<br>              ),<br>            ),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中，</p><ul><li><code>DakCatelogPage</code>是商品目录页；</li><li><code>DakCartPage</code>是购物车页；</li><li><code>DakMyApp</code>为商品目录与购物车的共同父组件;</li><li><code>DakCart</code>为已加购商品的实体类；</li></ul><p>在商品目录页中选择或删除商品后，保存已加购商品信息到<code>DakCart</code>中；</p><p>为了让购物车页面获取已加购商品信息，状态控制类<code>DakCart</code>被提升到<code>DakMyApp</code>中。在商品目录与购物车页面初始化时，父组件<code>DakMyApp</code>以入参形式将此状态对象传递给二者。</p><p>注：此示例不是最优代码实现范例，还需要考虑局部刷新等问题~</p><h3 id="4-读写状态"><a href="#4-读写状态" class="headerlink" title="4.读写状态"></a>4.读写状态</h3><p>提升后的状态在父组件中，AB作为兄弟组件相互独立，访问或修改对方的状态需要以下方式：</p><ul><li>对方提供的回调函数；</li><li>对方提供的处理状态的控制器；</li><li>框架内置的传递状态的组件；</li><li>社区提供的一些优秀三方库。</li></ul><h4 id="4-1-回调"><a href="#4-1-回调" class="headerlink" title="4.1.回调"></a>4.1.回调</h4><ol><li>A组件<code>访问</code>B组件的状态：</li></ol><p>将B的状态提升到AB共同的父组件中，在父组件<code>build</code>并创建A组件时，以参数形式将状态传给A；</p><ol start="2"><li>A组件<code>修改</code>B组件的状态：</li></ol><p>将B的状态提升到AB共同的父组件中，A定义回调函数并由父组件在初始化A时传入；</p><p>在位于父组件中的回调函数中修改B组件的状态。</p><p>代码实现2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">// 父组件<br>class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;<br>  int _count = 0; // 状态 在共同的父组件MyHome中<br><br>  // 回调函数 修改状态<br>  void _increment() &#123;<br>    setState(() &#123;<br>      _count++;<br>    &#125;);<br>  &#125;<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    return Scaffold(<br>      appBar: AppBar(<br>        title: Text(widget.title),<br>      ),<br>      body: Center(<br>        child: Column(<br>          children: &lt;Widget&gt;[<br>            // 组件A<br>            DakUpdater(<br>              count: _count, //访问外部状态<br>              callback: _increment, // 传入回调函数，以便在父组件中修改外部状态_count<br>            ),<br>            // 组件B<br>            Text(&#x27;$_count&#x27;), // 使用状态_count<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>// 组件A<br>class DakUpdater extends StatelessWidget &#123;<br>  final int count; //传入外部状态<br>  final void Function() callback; //给外部用的回调函数<br><br>  const DakUpdater(&#123;Key? key,required this.count,required this.callback&#125;) : super(key: key);<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    return Container(<br>      width: 100,<br>      margin: const EdgeInsets.only(top: 20),<br>      color: Colors.green,<br>      child: Column(<br>        children: [<br>          Text(<br>            &#x27;$count&#x27;, <br>            style: const TextStyle(color: Colors.white),<br>          ),<br>          ElevatedButton(<br>            onPressed: callback, // 修改外部状态<br>            child: const Text(&#x27;+1+&#x27;),<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中<code>DakUpdater</code>在创建时以参数(值拷贝)形式访问了外部状态<code>_count</code>；</p><p><code>DakUpdater</code>组件中<code>ElevatedButton</code>按钮点击之后，执行外部传入的回调函数，在父组件中修改了<code>_count</code>状态值并在重新 build 时再次传给<code>DakUpdater</code>展示最新值。</p><h4 id="4-2-控制器"><a href="#4-2-控制器" class="headerlink" title="4.2.控制器"></a>4.2.控制器</h4><p>对于内部状态比较复杂的组件，可将修改状态的业务封装成控制器，再将控制器对象提升到父组件中供外部调用。</p><p>很多Flutter框架内置组件都使用了这种方式，对外提供控制器以修改组件内部状态。</p><p>A组件想访问或修改B组件的状态，一般是由B组件提供一个<code>controller</code>处理自身状态变化的业务，再将此控制器提升到AB组件的共同父组件中，在那里调用控制器的接口触发状态变化。</p><p>代码实现3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakBoxController &#123;<br>  Color color = Colors.pink;<br>  DakBoxController(&#123;Key? key&#125;);<br>  // 提供接口 修改状态<br>  changeColor(Color value) &#123;<br>    color = value;<br>  &#125;<br>&#125;<br><br>// 自定义的组件，主要是为了看颜色变化<br>class DakBox extends StatelessWidget &#123;<br>  final DakBoxController controller;<br>  const DakBox(&#123;<br>    Key? key,<br>    required this.controller,<br>  &#125;) : super(key: key);<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&quot;DakBox rebuild&quot;); // 打印日志<br>    return Container(<br>      height: 50,<br>      width: 50,<br>      color: controller.color,<br>    ); // 使用controller中的状态<br>  &#125;<br>&#125;<br><br>//省略。。<br><br>class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;<br>  int _counter = 0; <br>  // 1.框架内置的控制器<br>  final _editController = TextEditingController(text: &#x27;Hello world&#x27;);<br>  final _listController = ScrollController();<br>  // 我们自定义的控制器<br>  final _boxController = DakBoxController();<br><br>  void _incrementCounter() &#123;<br>    // 3.修改状态<br>    setState(() &#123;<br>      _counter++;<br>      _boxController.changeColor(Colors.green); // 改颜色<br>      _editController.clear(); // 清空文本<br>      _listController.animateTo(100,<br>          duration: const Duration(microseconds: 300), curve: Curves.bounceIn,); //滑动位置<br>    &#125;);<br>  &#125;<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    // 4.重绘以响应状态变化<br>    return Scaffold(<br>      //省略。。<br>      body: Center(<br>        child: Column(<br>          children: &lt;Widget&gt;[<br>            //计算器数值<br>            Text(&#x27;$_counter&#x27;),<br>            //自定义控件<br>            DakBox(controller: _boxController),//使用自定义的控制器<br>            //输入框<br>            TextField(controller: _editController), //使用内置控制器<br>            //ListView<br>            SizedBox(<br>              height: 200,<br>              child: ListView.builder(<br>                controller: _listController, //使用内置控制器<br>                itemCount: 100,<br>                itemBuilder: (context, index) &#123;<br>                  return Text(&#x27;$index&#x27;);<br>                &#125;,<br>              ),<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: _incrementCounter, // 2.执行回调函数<br>        tooltip: &#x27;Increment&#x27;,<br>        child: const Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中，视图中间我们放置了数值Text、自定义的DakBox、文本输入框、列表4个组件，点击底部按钮修改它们的状态。其中数值Text的状态是直接传值，DakBox、TextField、ListView都是由控制器处理具体状态变化逻辑。可以看出，控制器实际上只是对修改状态的逻辑做了一层封装，外部组件要修改本组件内部状态时使用接口即可，属于命令式编程，本质上与<code>Callback</code>方式差不多。</p><h3 id="5-InheritedWidget"><a href="#5-InheritedWidget" class="headerlink" title="5.InheritedWidget"></a>5.InheritedWidget</h3><p>理论上，<code>访问</code>状态使用传参，<code>修改</code>状态使用回调函数或控制器，通过这种方式已经可以实现几乎所有场景下的状态管理了。但现实项目中通常会有很多组件，且组件之间的树形关系可能会非常复杂，在使用状态提升后，如果只是依赖上述最简单的传参的方式，那么每个组件在构造函数中可能需要传入大量的参数才能将顶层的状态一层层传递到后续节点中。</p><p>那么有没有什么方法，能让底部的组件直接访问到被我们提升到顶部的状态呢？Flutter框架给出的方案是继承式组件<code>InheritedWidget</code>。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">/// Base class for widgets that efficiently propagate information down the tree.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// To obtain the nearest instance of a particular type of inherited widget from</span><br><span class="hljs-comment">/// a build context, use [BuildContext.dependOnInheritedWidgetOfExactType].</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Inherited widgets, when referenced in this way, will cause the consumer to</span><br><span class="hljs-comment">/// rebuild when the inherited widget itself changes state.</span><br></code></pre></td></tr></table></figure><p><code>InheritedWidget</code>也是一个<code>组件</code>，用于在组件树中高效的往下传递信息。</p><p>实际上这种机制的案例很常见：</p><ul><li>Theme.of(context).primaryColor；</li><li>MediaQuery.of(context).size；</li><li>Navigator.of(context)；</li></ul><p>这些全局共享的状态，被提升到了整个应用组件树的最顶层，下面任意节点都能方便的访问到。</p><h5 id="5-1-示例"><a href="#5-1-示例" class="headerlink" title="5.1.示例"></a>5.1.示例</h5><p>我们使用<code>InheritedWidget</code>改造购物车案例中<code>已加购商品</code>的传值方式：</p><p>代码实现4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">//注：此示例不是最优代码实现范例，还需要考虑局部刷新等问题~<br>void main() &#123;<br>  runApp(const DakMyApp());<br>&#125;<br><br>class DakMyApp extends StatefulWidget &#123;<br>  const DakMyApp(&#123;Key? key&#125;) : super(key: key);<br>  @override<br>  State&lt;DakMyApp&gt; createState() =&gt; _DakMyAppState();<br>&#125;<br><br>class _DakMyAppState extends State&lt;DakMyApp&gt; &#123;<br>  //购物车实体在顶层<br>  var cart = DakCart(items: []);<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakMyAPP build&#x27;);<br>    return DakCartInheritedWidget(<br>      cart: cart,<br>      child: MaterialApp(<br>        home: DakCatelogPage(<br>          callback: (item) &#123;<br>            //重绘<br>            setState(() &#123;<br>              if (item != null) &#123;<br>                final newItems =<br>                    item.selected ? cart.add(item) : cart.delete(item);<br>                cart = DakCart(items: newItems);<br>              &#125; else &#123;<br>                print(&#x27;单纯setState，未更新数据&#x27;);<br>              &#125;<br>            &#125;);<br>          &#125;,<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>// 传递数据组件<br>class DakCartInheritedWidget extends InheritedWidget &#123;<br>  //状态<br>  final DakCart cart;<br><br>  const DakCartInheritedWidget(&#123;<br>    Key? key,<br>    required this.cart,<br>    required Widget child, //必须传入child<br>  &#125;) : super(<br>          key: key,<br>          child: child,<br>        );<br><br>  // 便捷获取共享对象<br>  static DakCartInheritedWidget? of(BuildContext context) &#123;<br>    return context.dependOnInheritedWidgetOfExactType&lt;DakCartInheritedWidget&gt;();<br>  &#125;<br><br>  // 重写<br>  @override<br>  bool updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>    final update = oldWidget.cart != cart;<br>    print(&#x27;shoudl update? $update&#x27;);<br>    return update;<br>  &#125;<br>&#125;<br><br>// 购物车Model<br>class DakCart &#123;<br>  // 已加购商品<br>  List&lt;DakItem&gt; items = [];<br>  // 商品总价<br>  int get totalPrice =&gt; items.length * 42;<br>  DakCart(&#123;required this.items&#125;);<br>  //加入购物车<br>  List&lt;DakItem&gt; add(DakItem item) &#123;<br>    items.add(item);<br>    return items;<br>  &#125;<br><br>  //移出购物车<br>  List&lt;DakItem&gt; delete(DakItem item) &#123;<br>    int index = items.indexOf(item);<br>    items.removeAt(index);<br>    return items;<br>  &#125;<br><br>  // 重写==操作符，用于后续判断购物车是否发生了变化<br>  @override<br>  bool operator ==(Object other) &#123;<br>    if (other is! DakCart) &#123;<br>      return false;<br>    &#125;<br>    if (!identical(this, other)) &#123;<br>      return false;<br>    &#125;<br>    bool same =<br>        listEquals(items, other.items) &amp;&amp; (other.totalPrice == totalPrice);<br>    return same;<br>  &#125;<br><br>  @override<br>  int get hashCode =&gt; Object.hashAll([items, totalPrice]);<br>&#125;<br><br>// 商品Model<br>class DakItem &#123;<br>  String name;<br>  bool selected;<br><br>  DakItem(&#123;<br>    required this.name,<br>    required this.selected,<br>  &#125;);<br>&#125;<br><br>// 商品列表页面<br>class DakCatelogPage extends StatelessWidget &#123;<br>  final DakCallback callback;<br>  const DakCatelogPage(&#123;<br>    Key? key,<br>    required this.callback,<br>  &#125;) : super(key: key);<br>  static final items = [<br>    &#x27;Apple&#x27;,<br>    &#x27;Banana&#x27;,<br>    &#x27;Cherry&#x27;,<br>    &#x27;Damson&#x27;,<br>    &#x27;Grape&#x27;,<br>    &#x27;Haw&#x27;,<br>    &#x27;Kiwifruit&#x27;,<br>    &#x27;Lemon&#x27;,<br>    &#x27;Mango&#x27;,<br>    &#x27;Orange&#x27;<br>  ].map((e) =&gt; DakItem(name: e, selected: false)).toList();<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCatelogPage build&#x27;);<br>    return Scaffold(<br>      appBar: AppBar(<br>        backgroundColor: Colors.yellow,<br>        centerTitle: true,<br>        title: const Text(<br>          &#x27;Catelog&#x27;,<br>          style: TextStyle(<br>            fontSize: 28,<br>            fontWeight: FontWeight.bold,<br>            color: Colors.black,<br>          ),<br>        ),<br>        actions: [<br>          TextButton.icon(<br>            onPressed: () &#123;<br>              Navigator.of(context).push(<br>                MaterialPageRoute(<br>                  builder: (context) =&gt; const DakCartPage(),<br>                ),<br>              );<br>            &#125;,<br>            icon: const Icon(<br>              Icons.shopping_cart,<br>              color: Colors.black,<br>            ),<br>            label: const DakCartCounter(),<br>          ),<br>        ],<br>      ),<br>      body: ListView.builder(<br>        itemCount: items.length,<br>        itemBuilder: (context, index) &#123;<br>          return DakListCell(<br>            item: items[index],<br>            callback: (item) &#123;<br>              callback(item); // 将已修改状态的商品回调给最顶层的DakCartInheritedWidget组件<br>            &#125;,<br>          );<br>        &#125;,<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        backgroundColor: Colors.yellow,<br>        onPressed: () &#123;<br>          callback(null);<br>        &#125;,<br>        child: const Icon(<br>          Icons.refresh,<br>          color: Colors.black,<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>//商品总数<br>class DakCartCounter extends StatefulWidget &#123;<br>  const DakCartCounter(&#123;Key? key&#125;) : super(key: key);<br><br>  @override<br>  State&lt;DakCartCounter&gt; createState() =&gt; _DakCartCounterState();<br>&#125;<br><br>class _DakCartCounterState extends State&lt;DakCartCounter&gt; &#123;<br>  @override<br>  void didChangeDependencies() &#123;<br>    super.didChangeDependencies();<br>    print(&#x27;DakCartCounter didChangeDependencies&#x27;);<br>  &#125;<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCartCounter build&#x27;);<br>    var provider = DakCartInheritedWidget.of(context); // 这里直接读取共享的数据 不再靠参数传递<br>    return Text(<br>      &#x27;共$&#123;provider?.cart.items.length&#125;件&#x27;,<br>      style: const TextStyle(<br>        color: Colors.black,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>// Cell点击回调<br>typedef DakCallback = void Function(DakItem?);<br><br>// 商品cell<br>class DakListCell extends StatefulWidget &#123;<br>  final DakItem item;<br>  final DakCallback callback;<br>  const DakListCell(&#123;<br>    Key? key,<br>    required this.item,<br>    required this.callback,<br>  &#125;) : super(key: key);<br><br>  @override<br>  State&lt;DakListCell&gt; createState() =&gt; _DakListCellState();<br>&#125;<br><br>class _DakListCellState extends State&lt;DakListCell&gt; &#123;<br>  _updateState() &#123;<br>    setState(() &#123;<br>      widget.item.selected = !widget.item.selected;<br>    &#125;);<br>    widget.callback(widget.item); // 将修改状态后的item回调给商品列表组件<br>  &#125;<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    return Container(<br>      padding: const EdgeInsets.all(10),<br>      color: Colors.white,<br>      child: Row(<br>        children: [<br>          Expanded(<br>            child: Row(<br>              children: [<br>                Container(<br>                  margin: const EdgeInsets.symmetric(horizontal: 10),<br>                  width: 50,<br>                  height: 50,<br>                  color: Colors.yellow,<br>                ),<br>                Text(<br>                  widget.item.name,<br>                  style: const TextStyle(<br>                    fontSize: 18,<br>                    fontWeight: FontWeight.bold,<br>                  ),<br>                ),<br>              ],<br>            ),<br>          ),<br>          Builder(<br>            builder: (context) &#123;<br>              return widget.item.selected<br>                  ? IconButton(<br>                      // 已选中<br>                      onPressed: _updateState,<br>                      icon: const Icon(Icons.check),<br>                    )<br>                  : ElevatedButton(<br>                      //未选中<br>                      onPressed: _updateState,<br>                      style: ButtonStyle(<br>                        backgroundColor:<br>                            MaterialStateProperty.all(Colors.white),<br>                        elevation: MaterialStateProperty.all(0),<br>                      ),<br>                      child: const Text(<br>                        &#x27;ADD&#x27;,<br>                        style: TextStyle(color: Colors.black),<br>                      ),<br>                    );<br>            &#125;,<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>// 购物车页面<br>class DakCartPage extends StatelessWidget &#123;<br>  const DakCartPage(&#123;<br>    Key? key,<br>  &#125;) : super(key: key);<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCartPage build&#x27;);<br>    var provider = DakCartInheritedWidget.of(context); // 这里直接读取共享的数据 不再靠参数传递<br>    return Scaffold(<br>      appBar: AppBar(<br>        backgroundColor: Colors.yellow,<br>        title: const Text(<br>          &#x27;Cart&#x27;,<br>          style: TextStyle(<br>            fontSize: 28,<br>            fontWeight: FontWeight.bold,<br>            color: Colors.black,<br>          ),<br>        ),<br>      ),<br>      body: Container(<br>        color: Colors.yellow,<br>        child: Column(<br>          children: [<br>            Expanded(<br>              child: ListView.builder(<br>                itemCount: provider?.cart.items.length,<br>                itemBuilder: (context, index) &#123;<br>                  final item = provider?.cart.items[index];<br>                  return Container(<br>                    padding: const EdgeInsets.fromLTRB(20, 10, 20, 10),<br>                    child: Text(<br>                      &#x27;· $&#123;item?.name&#125;&#x27;,<br>                      style: const TextStyle(<br>                        color: Colors.black,<br>                        fontSize: 18,<br>                        fontWeight: FontWeight.bold,<br>                      ),<br>                    ),<br>                  );<br>                &#125;,<br>              ),<br>            ),<br>            Container(<br>              height: 2,<br>              color: Colors.black,<br>            ),<br>            Container(<br>              padding: const EdgeInsets.symmetric(vertical: 100),<br>              child: Center(<br>                child: Row(<br>                  mainAxisAlignment: MainAxisAlignment.center,<br>                  children: [<br>                    Text(<br>                      &#x27;\$ $&#123;provider?.cart.totalPrice&#125;&#x27;,<br>                      style: const TextStyle(<br>                        fontSize: 28,<br>                        fontWeight: FontWeight.bold,<br>                      ),<br>                    ),<br>                    const SizedBox(<br>                      width: 50,<br>                    ),<br>                    ElevatedButton(<br>                      onPressed: () &#123;&#125;,<br>                      style: ButtonStyle(<br>                        backgroundColor:<br>                            MaterialStateProperty.all(Colors.white),<br>                      ),<br>                      child: const Text(<br>                        &#x27;BUY&#x27;,<br>                        style: TextStyle(<br>                          fontSize: 18,<br>                          fontWeight: FontWeight.bold,<br>                          color: Colors.black,<br>                        ),<br>                      ),<br>                    ),<br>                  ],<br>                ),<br>              ),<br>            ),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中，我们增加了一个<code>DakCartInheritedWidget</code>类，它继承自<code>InheritedWidget</code>并重写了必要的方法，同时提供了一个全局便捷访问此对象的<code>of()</code>方法。</p><p>之前的方案中，已加购商品<code>items</code>保存在 DakMyApp 中，通过传参的方式传给 DakCatelogPage 与 DakCartPage；现在已加购商品状态仍保存在 DakMyApp 中，但不需要手动传递了，DakMyApp 的任意子节点内都可以直接通过以下两种方式获取到这个状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">// 方式1<br>var provider = context.dependOnInheritedWidgetOfExactType&lt;DakCartInheritedWidget&gt;();<br>// 方式2：便捷方法<br>var provider = DakCartInheritedWidget.of(context);<br></code></pre></td></tr></table></figure><p>后者是对前者的封装，它们会在组件树上返回当前节点之前且离当前节点【最近的】一个【指定类型的】共享组件，即 DakMyApp 中创建的<code>DakCartInheritedWidget</code>，接着读取其中的状态即可。</p><p>通过<code>InheritedWidget</code>组件，我们将状态提升到合适的顶部某一组件中，在其下面的组件可随时通过指定方法获取这一状态，从而省去了传参的麻烦~</p><h5 id="5-2-机制原理"><a href="#5-2-机制原理" class="headerlink" title="5.2.机制原理"></a>5.2.机制原理</h5><p><code>InheritedWidget</code>是基于观察者模式实现的：</p><ul><li>注册：利用 BuildContext 注册监听；</li><li>读取：通过 BuildContext 读取数据；</li><li>通知：<code>InheritedWidget</code>发生改变，通知监听者重绘；</li></ul><h6 id="i-注册"><a href="#i-注册" class="headerlink" title="i.注册"></a>i.注册</h6><p>使用<code>InheritedWidget</code>时，注册实际上是伴随着读取一起进行的，通过下面这种方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">// 方式1</span><br><span class="hljs-keyword">static</span> DakCartInheritedWidget? of(BuildContext context) &#123;<br>  context.dependOnInheritedWidgetOfExactType&lt;SomeInheritedWidget&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>与之对应的还有另一种读取方式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">// 方式2</span><br><span class="hljs-keyword">static</span> DakCartInheritedWidget? of(BuildContext context) &#123;<br>  context.getElementForInheritedWidgetOfExactType&lt;SomeInheritedWidget&gt;()?.widget <span class="hljs-keyword">as</span> SomeInheritedWidget;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式2是真正的读取，没有额外的注册监听操作。</p><p><code>dependOnxx</code>与<code>getxx</code>都是 Element 根类中的成员方法，这两种方式都能读取到共享的数据。</p><p>但当<code>InheritedWidget</code>中的状态发生改变时，其下层依赖者能否感知到这种变化，在这二者上就有很大的不同了。</p><p>这是二者不同的实现逻辑导致的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@override</span><br>InheritedElement? getElementForInheritedWidgetOfExactType&lt;T <span class="hljs-keyword">extends</span> InheritedWidget&gt;() &#123;<br>  <span class="hljs-keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());<br>  <span class="hljs-keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : _inheritedWidgets![T];<br>  <span class="hljs-keyword">return</span> ancestor;<br>&#125;<br><br><span class="hljs-meta">@override</span><br>T? dependOnInheritedWidgetOfExactType&lt;T <span class="hljs-keyword">extends</span> InheritedWidget&gt;(&#123;<span class="hljs-built_in">Object?</span> aspect&#125;) &#123;<br>  <span class="hljs-keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());<br>  <span class="hljs-keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : _inheritedWidgets![T];<br>  <span class="hljs-comment">//差别在以下部分</span><br>  <span class="hljs-keyword">if</span> (ancestor != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> dependOnInheritedElement(ancestor, aspect: aspect) <span class="hljs-keyword">as</span> T;<br>  &#125;<br>  _hadUnsatisfiedDependencies = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>区别在于：</p><ul><li><code>get</code>直接返回一个<code>InheritedElement</code>，即<code>_inheritedWidgets</code>字典中与<code>T</code>类型对应的那个；</li><li><code>dependOn</code>返回一个<code>Widget</code>对象并继续调用了<code>dependOnInheritedElement()</code>方法：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@override</span><br>InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="hljs-built_in">Object?</span> aspect &#125;) &#123;<br>  <span class="hljs-keyword">assert</span>(ancestor != <span class="hljs-keyword">null</span>);<br>  _dependencies ??= HashSet&lt;InheritedElement&gt;();<br>  _dependencies!.add(ancestor);<br>  ancestor.updateDependencies(<span class="hljs-keyword">this</span>, aspect);<br>  <span class="hljs-keyword">return</span> ancestor.widget;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法中，查找祖先<code>InheritedElement</code>节点中的<code>_dependencies</code>字典，并将自己<code>this</code>加入进去。</p><ul><li><code>this</code>是调用<code>dependOn</code>方法的<code>BuildContext</code>，实质是<code>BuildContext</code>对应的<code>Element</code>；</li><li><code>ancestor</code>是指定<code>InheritedWidget</code>子类型对应的<code>InheritedElement</code>；</li></ul><p>继续跟踪<code>updateDependencies</code>方法进入<code>InheritFromElement</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProxyElement</span> </span>&#123;<br>  <span class="hljs-comment">/// <span class="language-markdown">Creates an element that uses the given widget as its configuration.</span></span><br>  InheritedElement(InheritedWidget widget) : <span class="hljs-keyword">super</span>(widget);<br><br>  <span class="hljs-meta">@override</span><br>  InheritedWidget <span class="hljs-keyword">get</span> widget =&gt; <span class="hljs-keyword">super</span>.widget <span class="hljs-keyword">as</span> InheritedWidget;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Element</span>, <span class="hljs-built_in">Object?</span>&gt; _dependents = HashMap&lt;<span class="hljs-built_in">Element</span>, <span class="hljs-built_in">Object?</span>&gt;();<br>  <span class="hljs-comment">//省略...</span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> updateDependencies(<span class="hljs-built_in">Element</span> dependent, <span class="hljs-built_in">Object?</span> aspect) &#123;<br>    setDependencies(dependent, <span class="hljs-keyword">null</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> setDependencies(<span class="hljs-built_in">Element</span> dependent, <span class="hljs-built_in">Object?</span> value) &#123;<br>    _dependents[dependent] = value;<br>  &#125;<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-built_in">Object?</span> getDependencies(<span class="hljs-built_in">Element</span> dependent) &#123;<br>    <span class="hljs-keyword">return</span> _dependents[dependent];<br>  &#125;<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> notifyDependent(<span class="hljs-keyword">covariant</span> InheritedWidget oldWidget, <span class="hljs-built_in">Element</span> dependent) &#123;<br>    dependent.didChangeDependencies();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> updated(InheritedWidget oldWidget) &#123;<br>    <span class="hljs-keyword">if</span> (widget.updateShouldNotify(oldWidget))<br>      <span class="hljs-keyword">super</span>.updated(oldWidget);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> notifyClients(InheritedWidget oldWidget) &#123;<br>    <span class="hljs-keyword">assert</span>(_debugCheckOwnerBuildTargetExists(<span class="hljs-string">&#x27;notifyClients&#x27;</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> dependent <span class="hljs-keyword">in</span> _dependents.keys) &#123;<br>      <span class="hljs-keyword">assert</span>(() &#123;<br>        <span class="hljs-comment">// check that it really is our descendant</span><br>        <span class="hljs-built_in">Element?</span> ancestor = dependent._parent;<br>        <span class="hljs-keyword">while</span> (ancestor != <span class="hljs-keyword">this</span> &amp;&amp; ancestor != <span class="hljs-keyword">null</span>)<br>          ancestor = ancestor._parent;<br>        <span class="hljs-keyword">return</span> ancestor == <span class="hljs-keyword">this</span>;<br>      &#125;());<br>      <span class="hljs-comment">// check that it really depends on us</span><br>      <span class="hljs-keyword">assert</span>(dependent._dependencies!.contains(<span class="hljs-keyword">this</span>));<br>      notifyDependent(oldWidget, dependent);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>_dependents</code>是一个Map，存放着所有的依赖者，只有在这个字典中的依赖者，才有机会在<code>InheritedWidget</code>发生变化时获得更新通知。<code>dependOn</code>最终调用了<code>setDependencies()</code>将调用者<code>context</code>对应的<code>Element</code>加入<code>_dependents</code>字典中。即当依赖者使用<code>of()</code>方法中的<code>dependOn</code>函数获取自定义<code>InheritedWidget</code>时，会将自己加到依赖者集合中，而<code>get</code>则不会添加依赖和监听。</p><p>以购物车为例，通过<code>dependOn</code>读取数据，就是以<code>DakCartInheritedWidget</code>的类型为键，找到其对应的 InheritedElement 祖先节点对象，再把<code>DakCartCounter</code>的 BuildContext 对应的 Element 注册到祖先节点 InheritedElement 的<code>_dependencies</code>字典中，即右上角商品数量组件依赖和监听了 DakCartInheritedWidget，有机会获取后续更新通知。</p><h6 id="ii-读取"><a href="#ii-读取" class="headerlink" title="ii.读取"></a>ii.读取</h6><p>子节点是如何读取<code>InheritedWidget</code>中数据的呢？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProxyElement</span> </span>&#123;<br>  <span class="hljs-comment">/// <span class="language-markdown">Creates an element that uses the given widget as its configuration.</span></span><br>  InheritedElement(InheritedWidget widget) : <span class="hljs-keyword">super</span>(widget);<br><br>  <span class="hljs-meta">@override</span><br>  InheritedWidget <span class="hljs-keyword">get</span> widget =&gt; <span class="hljs-keyword">super</span>.widget <span class="hljs-keyword">as</span> InheritedWidget;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Element</span>, <span class="hljs-built_in">Object?</span>&gt; _dependents = HashMap&lt;<span class="hljs-built_in">Element</span>, <span class="hljs-built_in">Object?</span>&gt;();<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> _updateInheritance() &#123;<br>    <span class="hljs-keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets;<br>    <span class="hljs-keyword">if</span> (incomingWidgets != <span class="hljs-keyword">null</span>)<br>      _inheritedWidgets = HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;.from(incomingWidgets);<br>    <span class="hljs-keyword">else</span><br>      _inheritedWidgets = HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;();<br>    _inheritedWidgets![widget.runtimeType] = <span class="hljs-keyword">this</span>;<br>  &#125;<br>  <span class="hljs-comment">//省略。。。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Map&lt;Type, InheritedElement&gt;? _inheritedWidgets</strong></li></ul><p>这是从<code>Element</code>根类中继承的属性，保存着所有祖先节点中出现过的<code>InheritedWidget</code>与<code>InheritedElement</code>对象的映射关系。字典的键是<code>InheritedWidget</code>子类的<code>Type</code>，值是<code>InheritedElement</code>对象。</p><p>在使用<code>get</code>或<code>dependOn</code>时，二者方法内部都会调用以下内容：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : _inheritedWidgets![T];<br></code></pre></td></tr></table></figure><p><code>ancestor</code>是根据<code>InheritedWidget</code>类型从<code>_inheritedWidgets</code>中取出的<code>InheritedElement</code>对象，通过<code>ancestor.widget</code>就能获取对应的<code>InheritedWidget</code>，进而读取其内部数据。</p><p>这就是读取数据的原理~</p><p>需要注意的是，<code>_inheritedWidgets</code>中给相同的键赋值会覆盖原<code>InheritedElement</code>对象，注意这一点，后面会用到。</p><h6 id="iii-传递"><a href="#iii-传递" class="headerlink" title="iii.传递"></a>iii.传递</h6><p>为什么<code>InheritedWidget</code>能一直向下传递数据呢？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-keyword">void</span> _updateInheritance() &#123;<br>  <span class="hljs-keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);<br>  _inheritedWidgets = _parent?._inheritedWidgets;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是<code>Element</code>根类中提供的函数，<code>Element</code>中在<code>mount()</code>的最后一步会调用此函数，以便更新<code>_inheritedWidgets</code>字段。</p><p>对于非<code>InheritedWidget</code>组件，调用的是上面的默认实现，即把父节点的<code>_inheritedWidgets</code>赋给自己，从而将父组件上的共享数据传递给自己。</p><p>对于<code>InheritedElement</code>，它重写了此函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> _updateInheritance() &#123;<br>  <span class="hljs-keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets;<br>  <span class="hljs-keyword">if</span> (incomingWidgets != <span class="hljs-keyword">null</span>) &#123;<br>    _inheritedWidgets = HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;.from(incomingWidgets);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    _inheritedWidgets = HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;();<br>  &#125;<br>  _inheritedWidgets![widget.runtimeType] = <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样保留了父节点中的<code>_inheritedWidgets</code>，但又多了一步：将当前<code>InheritedWidget</code>与其<code>InheritedElement</code>的映射关系加入进来。</p><p>这样在<code>Element</code>树中，<code>InheritedElement</code>中的数据会通过<code>_inheritedWidgets</code>字典，在其<code>InheritedWidget</code>或非<code>InheritedWidget</code>子节点中，层层往下传递~</p><h6 id="iv-覆盖"><a href="#iv-覆盖" class="headerlink" title="iv.覆盖"></a>iv.覆盖</h6><p>还记得前面的提醒吗：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;? _inheritedWidgets;<br></code></pre></td></tr></table></figure><p>这个Map的键是<code>InheritedWidget</code>的类型，值是<code>InheritedElement</code>对象。由于_inheritedWidgets会在组件树上层层往下传递，所以在遇到子组件也是<code>InheritedWidget</code>节点时，祖节点中的<code>_inheritedWidgets</code>会被继承下来并添加新的键值对。给键值对赋值时如果使用相同的键，那么后来的值就会替换前值，即下层的共享数据覆盖上一层的共享数据。</p><p>在组件树中传递数据时，可能会出现某个子节点<code>A</code>的上层有多个相同类型的<code>InheritedWidget</code>父节点，但携带的数据不同的情况，那<code>A</code>节点取到的是哪一层父节点共享的数据呢？以购物车案例为基础，我们稍作修改：</p><p>代码实现5：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">void main() &#123;<br>  runApp(DakMyApp());<br>&#125;<br><br>class DakMyApp extends StatefulWidget &#123;<br>  const DakMyApp(&#123;Key? key&#125;) : super(key: key);<br>  @override<br>  State&lt;DakMyApp&gt; createState() =&gt; _DakMyAppState();<br>&#125;<br><br>class _DakMyAppState extends State&lt;DakMyApp&gt; &#123;<br>  //顶级状态<br>  final cart1 = DakCart(items: []);<br>  //次级状态<br>  var cart2 = DakCart(items: [DakItem(name: &#x27;Pineapple&#x27;, selected: true)]);<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakMyAPP build&#x27;);<br>    return DakCartInheritedWidget( //看这里：父节点1<br>      cart: cart1,<br>      child: DakCartInheritedWidget( //看这里：父节点2<br>        cart: cart2,<br>        child: MaterialApp(<br>          home: DakCatelogPage(<br>            callback: (item) &#123;<br>              //重绘<br>              setState(() &#123;<br>                if (item != null) &#123;<br>                  final newItems =<br>                      item.selected ? cart2.add(item) : cart2.delete(item);<br>                  cart2 = DakCart(items: newItems);<br>                &#125; else &#123;<br>                  print(&#x27;单纯setState，未更新数据&#x27;);<br>                &#125;<br>              &#125;);<br>            &#125;,<br>          ),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br>// 省略。。。<br>// 购物车<br>class DakCartPage extends StatelessWidget &#123;DakCartInheritedWidget<br>  // 省略。。。<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    // 获取顶部最近的一份共享数据<br>    var provider = DakCartInheritedWidget.of(context);<br>    return Scaffold(<br>      // 省略。。。<br>      body: Container(<br>        child: Column(<br>          children: [<br>            Expanded(<br>              child: ListView.builder(<br>                itemCount: provider?.items.length,<br>                itemBuilder: (context, index) &#123;<br>                  final item = provider?.items[index];<br>                  return Container(<br>                    padding: const EdgeInsets.fromLTRB(20, 10, 20, 10),<br>                    child: Text(&#x27;· $&#123;item?.name&#125;&#x27;),<br>                  );<br>                &#125;,<br>              ),<br>            ),<br>            // 省略。。。<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在原<code>DakCartInheritedWidget</code>的下层，又套了一个<code>DakCartInheritedWidget</code>，其中上层共享的<code>cart1</code>是空的，下层的<code>cart2</code>则包含了一个已选水果“Pineapple”。此时我们直接进入购物车页面就会发现，购物车中列表中显示了“Pineapple”，即购物车组件获取到的是在它之前且离它最近的已经包含一个水果的<code>cart2</code>对象。</p><p>这是因为，两层继承式组件<code>DakCartInheritedWidget</code>是父子组件的关系，在构建时会各自执行一遍<code>_updateInheritance()</code>函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> _updateInheritance() &#123;<br>  <span class="hljs-keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets;<br>  <span class="hljs-keyword">if</span> (incomingWidgets != <span class="hljs-keyword">null</span>) &#123;<br>    _inheritedWidgets = HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;.from(incomingWidgets);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    _inheritedWidgets = HashMap&lt;<span class="hljs-built_in">Type</span>, InheritedElement&gt;();<br>  &#125;<br>  _inheritedWidgets![widget.runtimeType] = <span class="hljs-keyword">this</span>; <span class="hljs-comment">//注意看，是这里</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上层执行时，<code>_inheritedWidgets</code>中保存了<code>DakCartInheritedWidget</code>与<code>InheritedElement</code>的映射关系并往下传递，假设为<code>[w:e1]</code>；下层执行时，<code>_inheritedWidgets</code>先保留了父节点的<code>[w:e1]</code>，再将自己加入进去，但由于<code>widget.runtimeType</code>没变，即键<code>w</code>没变，导致字典的值<code>e1</code>被覆盖掉，替换成当前<code>InheritedElement</code>对象，从而变成<code>[w:e2]</code>。</p><p>购物车页面是第二级<code>DakCartInheritedWidget</code>的子节点，所以它读取共享数据时，读到的是离自己最近的<code>DakCartInheritedWidget</code>中的<code>cart2</code>。</p><p>这只是基于源码的一种推理验证，实际项目中应该不会真的有必要这么用~</p><h6 id="v-更新"><a href="#v-更新" class="headerlink" title="v.更新"></a>v.更新</h6><p>对<code>InheritedWidget</code>来说，如果只是在某个依赖者里修改<code>InheritedWidget</code>中共享的数据，是不会触发其他依赖者更新的。只有满足以下条件才行：</p><ol><li>子节点调用<code>context.dependOnInheritedWidgetOfExactType</code>注入依赖；</li><li>重写<code>InheritedWidget</code>的<code>updateShouldNotify()</code>方法，比较新旧<code>InheritedWidget</code>中的共享数据是否发生了变化，最终返回 true 时依赖者才会同步更新；</li><li>修改<code>InheritedWidget</code>中共享的数据：对值类型的共享数据，可直接修改其值；对引用类型的共享数据，需要将其替换成新对象，而非在原指针的基础上修改其某个属性，必要时还需重写共享数据对象的<code>==</code>操作符与<code>hashCode</code>以定义新旧数据对象是否相同。只有新旧数据对象不相同，<code>updateShouldNotify()</code>中对二者做比较时才能返回 true；</li><li>调用<code>setState</code>（比如在在父节点中），触发<code>InheritedWidget</code>的重绘，从而调用 Element 的<code>update()</code>函数，走<code>notifyClients</code>流程；</li></ol><p>这些都是<code>InheritedWidget</code>实现源码中相关逻辑要求的，主要是在<code>InheritedElement</code>中，而<code>InheritedElement</code>继承自<code>ProxyElement</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ComponentElement</span> </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  ProxyWidget <span class="hljs-keyword">get</span> widget =&gt; <span class="hljs-keyword">super</span>.widget <span class="hljs-keyword">as</span> ProxyWidget;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build() =&gt; widget.child;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> update(ProxyWidget newWidget) &#123;<br>    <span class="hljs-keyword">final</span> ProxyWidget oldWidget = widget;<br>    <span class="hljs-keyword">super</span>.update(newWidget);<br>    updated(oldWidget);<br>    _dirty = <span class="hljs-keyword">true</span>;<br>    rebuild();<br>  &#125;<br><br>  <span class="hljs-comment">/// <span class="language-markdown">Called during build when the [widget] has changed.</span></span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// <span class="language-markdown">By default, calls [notifyClients]. Subclasses may override this method to</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">avoid calling [notifyClients] unnecessarily (e.g. if the old and new</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">widgets are equivalent).</span></span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> updated(<span class="hljs-keyword">covariant</span> ProxyWidget oldWidget) &#123;<br>    notifyClients(oldWidget);<br>  &#125;<br><br>  <span class="hljs-comment">/// <span class="language-markdown">Notify other objects that the widget associated with this element has</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">changed.</span></span><br>  <span class="hljs-comment">///</span><br>  <span class="hljs-comment">/// <span class="language-markdown">Called during [update] (via [updated]) after changing the widget</span></span><br>  <span class="hljs-comment">/// <span class="language-markdown">associated with this element but before rebuilding this element.</span></span><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> notifyClients(<span class="hljs-keyword">covariant</span> ProxyWidget oldWidget);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Element</code>树已构建完成后，某个<code>InheritedElement</code>节点的配置发生变化时（通常是内部的共享数据变化了），在父节点调用<code>setState</code>重新构建widget树时，会复用当前位置上的<code>Element</code>，更新它的配置信息(newWidget)，而非创建新的。此时会调用<code>InheritedElement</code>的<code>update()</code>函数。</p><p><code>update</code>内会调用<code>updated</code>方法，而<code>InheritedElement</code>从<code>ProxyElement</code>继承并重写了此方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> updated(InheritedWidget oldWidget) &#123;<br>  <span class="hljs-keyword">if</span> (widget.updateShouldNotify(oldWidget))<br>    <span class="hljs-keyword">super</span>.updated(oldWidget);<br>&#125;<br></code></pre></td></tr></table></figure><p>通常，我们会在自定义<code>InheritedWidget</code>时重写这里的<code>updateShouldNotify()</code>方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">// 重写<br>@override<br>bool updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>  return (oldWidget.items != items); //自定义判断逻辑<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的返回值可根据具体业务而定，返回 true 则继续调用上面所说的<code>updated</code>方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">/// <span class="language-markdown">Called during build when the [widget] has changed.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">By default, calls [notifyClients]. Subclasses may override this method to</span></span><br><span class="hljs-comment">/// <span class="language-markdown">avoid calling [notifyClients] unnecessarily (e.g. if the old and new</span></span><br><span class="hljs-comment">/// <span class="language-markdown">widgets are equivalent).</span></span><br><span class="hljs-meta">@protected</span><br><span class="hljs-keyword">void</span> updated(<span class="hljs-keyword">covariant</span> ProxyWidget oldWidget) &#123;<br>  notifyClients(oldWidget);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>updated</code>里默认调用<code>notifyClients</code>方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">/// <span class="language-markdown">Notifies all dependent elements that this inherited widget has changed, by</span></span><br><span class="hljs-comment">/// <span class="language-markdown">calling [Element.didChangeDependencies].</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">This method must only be called during the build phase. Usually this</span></span><br><span class="hljs-comment">/// <span class="language-markdown">method is called automatically when an inherited widget is rebuilt, e.g.</span></span><br><span class="hljs-comment">/// <span class="language-markdown">as a result of calling [State.setState] above the inherited widget.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> notifyClients(InheritedWidget oldWidget) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> dependent <span class="hljs-keyword">in</span> _dependents.keys) &#123;<br>    notifyDependent(oldWidget, dependent); <span class="hljs-comment">//看这里</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它会遍历<code>_dependents</code>字典，为每个依赖者调用<code>notifyDependent</code>方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">/// <span class="language-markdown">Called by [notifyClients] for each dependent.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">Calls <span class="hljs-code">`dependent.didChangeDependencies()`</span> by default.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">Subclasses can override this method to selectively call</span></span><br><span class="hljs-comment">/// <span class="language-markdown">[didChangeDependencies] based on the value of [getDependencies].</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-meta">@protected</span><br><span class="hljs-keyword">void</span> notifyDependent(<span class="hljs-keyword">covariant</span> InheritedWidget oldWidget, <span class="hljs-built_in">Element</span> dependent) &#123;<br>  dependent.didChangeDependencies();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>notifyDependent</code>最终调用依赖者(Element)的<code>didChangeDependencies</code>方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@mustCallSuper</span><br><span class="hljs-keyword">void</span> didChangeDependencies() &#123;<br>  markNeedsBuild();<br>&#125;<br></code></pre></td></tr></table></figure><p>ps：只有<code>StatefulWidget</code>才有<code>didChangeDependencies</code>回调，如果依赖者对应的组件是<code>StatelessWidget</code>类型，那么组件还是会重绘，只不过没有<code>didChangeDependencies</code>调用而已~</p><p>到这里，依赖者Element就已经能感知自己依赖的数据发生了变化，使用最新数据等待重绘即可。</p><p>由于<code>getInheritedWidgetOfExactType</code>不会往<code>_dependents</code>中注入依赖，也就不会调用<code>notifyDependent</code>方法，所以调用<code>get</code>时的组件没机会获得通知，也就不会重绘~</p><p><code>InheritedWidget</code>中重写<code>updateShouldNotify</code>返回 false 时，就不会调用<code>updated</code>，不走<code>notifyClients</code>流程，依赖者也就不会获得通知和重绘。</p><hr><p>以购物车为例，正常情况下选中并加购商品时，会输出以下日志：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">DakMyAPP <span class="hljs-keyword">build</span><br><span class="hljs-keyword"></span>DakCatelogPage <span class="hljs-keyword">build</span><br><span class="hljs-keyword"></span>DakCartCounter <span class="hljs-keyword">didChangeDependencies</span><br><span class="hljs-keyword"></span>DakCartCounter <span class="hljs-keyword">build</span><br></code></pre></td></tr></table></figure><p>其中最后两行是<code>DakCartInheritedWidget</code>的依赖者<code>DakCartCounter</code>组件的日志 ，setState时，因为<code>DakCartCounter</code>继承自<code>StatefulWidget</code>，所以它的<code>didChangeDependencies</code>函数会触发，并发生重绘。</p><p>当我们将 DakCartInheritedWidget 中<code>updateShouldNotify</code>的返回值始终设置为 false 时：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 重写</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>    <span class="hljs-keyword">const</span> update = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;shoudl update? <span class="hljs-subst">$update</span>&#x27;</span>);<br>    <span class="hljs-keyword">return</span> update;<br>  &#125;<br></code></pre></td></tr></table></figure><p>加购商品并在<code>MyApp</code>中<code>setState</code>时，会得到以下日志：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">DakMyAPP <span class="hljs-keyword">build</span><br>shoudl <span class="hljs-keyword">update</span>? <span class="hljs-literal">false</span><br>DakCatelogPage <span class="hljs-keyword">build</span><br></code></pre></td></tr></table></figure><p>即：虽然<code>DakCartInheritedWidget</code>组件发生了重绘，但其依赖者 Element 对应的<code>DakCartCounter</code>组件的<code>didChangeDependencies()</code>函数并未触发，组件本身也没重绘！</p><p><code>didChangeDependencies</code>没触发可以理解，因为<code>updateShouldNotify</code>返回了 false，依赖者不走<code>notifyClients</code>流程；没重绘（build）是为啥呢？尤其是在其父节点都已发生重绘的情况下！</p><p>这里，看下我们使用<code>DakCartCounter</code>组件的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">actions: [<br>  TextButton.icon(<br>    onPressed: () &#123;<br>      Navigator.of(context).push(<br>        MaterialPageRoute(<br>          builder: (context) =&gt; const DakCartPage(),<br>        ),<br>      );<br>    &#125;,<br>    icon: const Icon(<br>      Icons.shopping_cart,<br>      color: Colors.black,<br>    ),<br>    label: const DakCartCounter(), // 注意看这里的const<br>  ),<br>]<br></code></pre></td></tr></table></figure><p>代码标注处，我们使用的是<code>const</code>修饰依赖者组件，在完成第一次构建之后，它就不再参与重绘了，除非其依赖的共享数据发生了变化。你可以尝试将<code>const</code>关键字去掉并查看新的日志，你会发现依赖者这次会跟着重绘了，即使是<code>updateShouldNotify</code>返回了 false。因为非<code>const</code>组件在父节点 build 时，要跟着重新构建。</p><p>所以这就是节省性能的一个小技巧：必要时使用<code>const</code>关键字！</p><p>另外在本小结开头处，我们提到让依赖者同步更新时需要满足的条件3：修改共享数据时，数据对象本身要发生变化。这里<code>变化</code>的标准是以<code>hashCode</code>和<code>==</code>操作符来定义的。以购物车为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class _DakMyAppState extends State&lt;DakMyApp&gt; &#123;<br>  var cart = DakCart(items: []);<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakMyAPP build&#x27;);<br>    return DakCartInheritedWidget(<br>      cart: cart,<br>      child: MaterialApp(<br>        home: DakCatelogPage(<br>          callback: (item) &#123;<br>            //重绘<br>            setState(() &#123;<br>              if (item != null) &#123;<br>                final newItems =<br>                    item.selected ? cart.add(item) : cart.delete(item);<br>                //cart = DakCart(items: newItems); //看这里<br>              &#125; else &#123;<br>                print(&#x27;单纯setState，未更新数据&#x27;); <br>              &#125;<br>            &#125;);<br>          &#125;,<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当<code>callback</code>中返回的参数<code>item</code>不为空时，我们会去修改<code>cart</code>对象，即通过<code>cart.add</code>或<code>cart.delete</code>增减响应商品。实际上到这一步，我们还只是对原共享数据对象<code>cart</code>内的<code>items</code>数组做了修改，并未改变<code>cart</code>对象的指针。如果此时注释掉“cart &#x3D; DakCart(items: newItems)”这一行，直接调用<code>setState</code>，那么<code>DakCartInheritedWidget</code>会重绘，但其<code>updateShouldNotify</code>方法会触发并返回<code>false</code>，依赖者们不会重绘！</p><p>这是因为，我们在重写<code>updateShouldNotify</code>时设置的更新逻辑如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>  <span class="hljs-keyword">final</span> update = oldWidget.cart != cart; <span class="hljs-comment">// 比对新旧cart对象，比的是二者的指针</span><br>  <span class="hljs-keyword">return</span> update;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DakCart</span> </span>&#123;<br>  <span class="hljs-comment">// 省略。。</span><br>  <span class="hljs-comment">// 重写==操作符，用于后续判断购物车是否发生了变化</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-built_in">Object</span> other) &#123;<br>    <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">is</span>! DakCart) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!identical(<span class="hljs-keyword">this</span>, other)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">bool</span> same =<br>        listEquals(items, other.items) &amp;&amp; (other.totalPrice == totalPrice);<br>    <span class="hljs-keyword">return</span> same;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> hashCode =&gt; <span class="hljs-built_in">Object</span>.hashAll([items, totalPrice]);<br>&#125;<br></code></pre></td></tr></table></figure><p>setState 时会创建新的<code>DakCartInheritedWidget</code>对象<code>this</code>并调用其内部<code>updateShouldNotify</code>方法，此时<code>this</code>中持有的<code>cart</code>对象与<code>oldWidget</code>的相同。在没有重写<code>DakCart</code>类中<code>==</code>操作符与<code>hashCode</code>的情况下，<code>!=</code>操作符默认比对的是对象的内存地址，即新widget与oldWidget中<code>cart</code>对象的<code>指针</code>。而<code>cart.add</code>或<code>cart.delete</code>只是修改了<code>cart</code>内部<code>items</code>数组，并未改变<code>cart</code>对象本身的指针，<code>this</code>与<code>oldWidget</code>持有的<code>cart</code>对象指向同一片内存地址，<code>updateShouldNotify</code>返回 false，依赖者们也就不会去重绘！</p><p>购物车示例中，我对<code>DakCart</code>类的<code>==</code>操作符与<code>hashCode</code>进行了重写，但也只是作为演示，仅仅比对了新旧对象的内存地址。在实际业务中，你可以设置自己的判断标准，比如当<code>InheritedWidget</code>中共享数据为指针类型的<code>User</code>对象时，只要<code>name</code>字段相同就可以认为两个<code>User</code>对象<code>==</code>；而对于简单的值类型，如<code>int counter</code>，直接给 counter 赋值就能让<code>updateShouldNotify</code>返回false，触发依赖者更新。</p><p>可以这么做个小结：依赖者能否同步更新，要根据<code>updateShouldNotify</code>中的判断逻辑、共享数据是否重写<code>==</code>与<code>hashCode</code>等情况而定。如果根据我们设置的标准，数据确实发生变化则 setState 时依赖者们会跟随<code>InheritedWidet</code>重绘，否则仅<code>InheritedWidet</code>重绘而依赖者们不重绘。</p><hr><h5 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3.总结"></a>5.3.总结</h5><p><code>InheritedWidet</code>的使用步骤总结：</p><p>1.自定义<code>InheritedWidget</code>子类，提供共享数据与<code>of</code>方法，重写<code>updateShouldNotify</code>方法；</p><p>2.使用依赖者作为<code>InheritedWidet</code>的子孙节点，在依赖者内调用<code>of</code>方法获取共享数据，同时将依赖者注入<code>InheritedElement</code>的<code>_dependents</code>字典中；</p><p>3.<code>InheritedWidget</code>内共享数据变化时，在父节点中调用setState，触发自身重绘，通知依赖者们执行<code>didChangeDependencies</code>和重绘；</p><h3 id="6-局部刷新"><a href="#6-局部刷新" class="headerlink" title="6.局部刷新"></a>6.局部刷新</h3><p>在<code>代码实现4</code>的开头有个声明，这种实现不是最优方案，因为在<code>InheritedWidget</code>中的数据发生改变时，我们在<code>MyApp</code>这里调用了<code>setState</code>，这就导致几乎整个应用都执行了重绘！这是严重的性能浪费，所以需要考虑局部刷新问题，在小范围内只让依赖了<code>InheritedWidget</code>的组件重绘即可。那么接下来我们将使用 Flutter 框架内置的一些支持局部刷新的小组件继续完善代码~</p><h4 id="6-1-ChangeNotifier"><a href="#6-1-ChangeNotifier" class="headerlink" title="6.1.ChangeNotifier"></a>6.1.ChangeNotifier</h4><p>这是一个在所监听内容发生变化时，能产生通知的类，下面结合源码进行分析：</p><h5 id="1-Listenable"><a href="#1-Listenable" class="headerlink" title="1.Listenable"></a>1.Listenable</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Listenable</span> </span>&#123;<br><br>  <span class="hljs-keyword">const</span> Listenable();<br><br>  <span class="hljs-keyword">factory</span> Listenable.merge(<span class="hljs-built_in">List</span>&lt;Listenable?&gt; listenables) = _MergingListenable;<br><br>  <span class="hljs-keyword">void</span> addListener(VoidCallback listener);<br><br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Listenable</code>这是一个抽象类，用于维护着监听者列表，对外提供了增、删、合并监听者的接口。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeNotifier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Listenable</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _count = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">List</span>&lt;VoidCallback?&gt; _listeners = <span class="hljs-built_in">List</span>&lt;VoidCallback?&gt;.filled(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> hasListeners &#123;<br>    <span class="hljs-keyword">return</span> _count &gt; <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> addListener(VoidCallback listener) &#123;<br>    <span class="hljs-comment">//省略。。</span><br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _removeAt(<span class="hljs-built_in">int</span> index) &#123;<br>    <span class="hljs-comment">//省略。。</span><br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> removeListener(VoidCallback listener) &#123;<br>    <span class="hljs-comment">//省略。。</span><br>  &#125;<br><br>  <span class="hljs-meta">@protected</span><br>  <span class="hljs-keyword">void</span> notifyListeners() &#123;<br>    <span class="hljs-keyword">if</span> (_count == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span>;<br>    _notificationCallStackDepth++;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> end = _count;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; end; i++) &#123;<br>      _listeners[i]?.call();<br>    &#125;<br>    <span class="hljs-comment">//省略。。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是精简之后的<code>ChangeNotifier</code>源码，它实现了<code>Listenable</code>抽象类，提供了<code>notifyListeners</code>方法，在数据变化时供我们调用以便给监听者们发送通知。</p><p>看上去这个类并不复杂，下面就用它来改造购物车案例，实现局部刷新功能，再结合案例代码看看这个类的实现路径。</p><h5 id="2-基本用法"><a href="#2-基本用法" class="headerlink" title="2.基本用法"></a>2.基本用法</h5><ul><li>共享数据类继承<code>ChangeNotifier</code>；</li><li>依赖者中通过<code>xxxBuilder</code>注册数据变化的回调；</li><li>触发共享数据的更新，执行<code>notifyListeners()</code>；</li><li>接收通知，局部重绘组件。</li></ul><ol><li>定义共享数据类</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakCart extends ChangeNotifier &#123; // 继承ChangeNotifier<br>  <br>  final List&lt;DakItem&gt; _items = [];<br><br>  UnmodifiableListView&lt;DakItem&gt; get items =&gt; UnmodifiableListView(_items);<br><br>  add(DakItem item) &#123;<br>    _items.add(item);<br>    notifyListeners(); // 修改数据后，发出通知<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>初始化共享数据实例</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakMyApp extends StatelessWidget &#123;<br>  DakMyApp(&#123;Key? key&#125;) : super(key: key);<br><br>  final cart = DakCart(); //创建Model实例<br>  <br>  @override<br>  Widget build(BuildContext context) &#123;<br>    return DakCartInheritedWidget(<br>      cart: cart,<br>      child: const MaterialApp(<br>        home: DakCatelogPage(),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>class DakCartInheritedWidget extends InheritedWidget &#123;<br>  。。。<br>  <br>  final DakCart cart;<br>  <br>  static DakCartInheritedWidget? of(BuildContext context) &#123;<br>    return context.getElementForInheritedWidgetOfExactType&lt;DakCartInheritedWidget&gt;()<br>        ?.widget as DakCartInheritedWidget;<br>  &#125;<br><br>  @override<br>  bool updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>    return false;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.读取共享的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakCartCounter extends StatelessWidget &#123;<br>  。。。<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    <br>    var cart = DakCartInheritedWidget.of(context)!.cart;<br>    <br>    return AnimatedBuilder(<br>      animation: cart, //使用AnimatedBuilder监听共享数据的变化<br>      builder: (context, child) &#123;<br>        return Text(<br>          &#x27;共$&#123;cart.items.length&#125;件&#x27;, // 数据变化时会重建此处组件<br>        );<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>更新共享的数据</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_DakListCellState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State&lt;DakListCell&gt;</span> </span>&#123;<br>  _updateState() &#123;<br>    <span class="hljs-keyword">var</span> cart = <span class="hljs-type">DakCartInheritedWidget</span>.of(context)!.cart;<br>    <span class="hljs-comment">// 调用接口修改共享数据</span><br>    widget.item.selected ? cart.add(widget.item) : cart.delete(widget.item);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-示例改造"><a href="#3-示例改造" class="headerlink" title="3.示例改造"></a>3.示例改造</h5><p>代码实现6：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">import &#x27;dart:collection&#x27;;<br>import &#x27;package:flutter/foundation.dart&#x27;;<br>import &#x27;package:flutter/material.dart&#x27;;<br><br>class DakMyApp extends StatelessWidget &#123;<br>  DakMyApp(&#123;Key? key&#125;) : super(key: key);<br><br>  final cart = DakCart();<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakMyAPP build&#x27;);<br>    return DakCartInheritedWidget(<br>      cart: cart,<br>      child: const MaterialApp(<br>        home: DakCatelogPage(),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>class DakCartInheritedWidget extends InheritedWidget &#123;<br>  //状态<br>  final DakCart cart;<br><br>  const DakCartInheritedWidget(&#123;<br>    Key? key,<br>    required this.cart,<br>    required Widget child,<br>  &#125;) : super(<br>          key: key,<br>          child: child,<br>        );<br><br>  // 便捷获取共享对象<br>  static DakCartInheritedWidget? of(BuildContext context) &#123;<br>    // 这里变了<br>    return context.getElementForInheritedWidgetOfExactType&lt;DakCartInheritedWidget&gt;()<br>        ?.widget as DakCartInheritedWidget;<br>  &#125;<br><br>  // 重写<br>  @override<br>  bool updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>    return false; // 这里变了<br>  &#125;<br>&#125;<br><br>// 购物车Model<br>class DakCart extends ChangeNotifier &#123; // 这里变了<br>  // 已加购商品<br>  final List&lt;DakItem&gt; _items = [];<br><br>  UnmodifiableListView&lt;DakItem&gt; get items =&gt; UnmodifiableListView(_items);<br><br>  // 商品总价<br>  int get totalPrice =&gt; items.length * 42;<br><br>  //加入购物车<br>  add(DakItem item) &#123;<br>    _items.add(item);<br>    notifyListeners(); // 这里变了<br>  &#125;<br><br>  //移出购物车<br>  delete(DakItem item) &#123;<br>    int index = _items.indexOf(item);<br>    _items.removeAt(index);<br>    notifyListeners(); // 这里变了<br>  &#125;<br>&#125;<br><br>// 商品Model<br>class DakItem &#123;<br>  String name;<br>  bool selected;<br><br>  DakItem(&#123;<br>    required this.name,<br>    required this.selected,<br>  &#125;);<br>&#125;<br><br>// 商品列表页面<br>class DakCatelogPage extends StatelessWidget &#123;<br>  const DakCatelogPage(&#123;<br>    Key? key,<br>  &#125;) : super(key: key);<br>  static final items = [<br>    &#x27;Apple&#x27;,<br>    &#x27;Banana&#x27;,<br>    &#x27;Cherry&#x27;,<br>    &#x27;Damson&#x27;,<br>    &#x27;Grape&#x27;,<br>    &#x27;Haw&#x27;,<br>    &#x27;Kiwifruit&#x27;,<br>    &#x27;Lemon&#x27;,<br>    &#x27;Mango&#x27;,<br>    &#x27;Orange&#x27;<br>  ].map((e) =&gt; DakItem(name: e, selected: false)).toList();<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCatelogPage build&#x27;);<br>    return Scaffold(<br>      appBar: AppBar(<br>        backgroundColor: Colors.yellow,<br>        centerTitle: true,<br>        title: const Text(<br>          &#x27;Catelog&#x27;,<br>          style: TextStyle(<br>            fontSize: 28,<br>            fontWeight: FontWeight.bold,<br>            color: Colors.black,<br>          ),<br>        ),<br>        actions: [<br>          TextButton.icon(<br>            onPressed: () &#123;&#125;,<br>            icon: const Icon(<br>              Icons.shopping_cart,<br>              color: Colors.black,<br>            ),<br>            label: const DakCartCounter(),<br>          ),<br>        ],<br>      ),<br>      body: ListView.builder(<br>        itemCount: items.length,<br>        itemBuilder: (context, index) &#123;<br>          return DakListCell(<br>            item: items[index],<br>          );<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>//商品总数<br>class DakCartCounter extends StatelessWidget &#123;<br>  const DakCartCounter(&#123;<br>    Key? key,<br>  &#125;) : super(key: key);<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCartCounter build&#x27;);<br>    var cart = DakCartInheritedWidget.of(context)!.cart;<br>    return AnimatedBuilder(<br>      // 推荐使用最新的 ListenableBuilder<br>      animation: cart,<br>      builder: (context, child) &#123;<br>        print(&#x27;AnimatedBuilder Go&#x27;);<br>        return Text(<br>          &#x27;共$&#123;cart.items.length&#125;件&#x27;,<br>          style: const TextStyle(<br>            color: Colors.black,<br>          ),<br>        );<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br><br>// 商品cell<br>class DakListCell extends StatefulWidget &#123;<br>  final DakItem item;<br>  const DakListCell(&#123;<br>    Key? key,<br>    required this.item,<br>  &#125;) : super(key: key);<br><br>  @override<br>  State&lt;DakListCell&gt; createState() =&gt; _DakListCellState();<br>&#125;<br><br>class _DakListCellState extends State&lt;DakListCell&gt; &#123;<br>  _updateState() &#123;<br>    setState(() &#123;<br>      widget.item.selected = !widget.item.selected;<br>    &#125;);<br>    var cart = DakCartInheritedWidget.of(context)!.cart;<br>    // 修改共享数据<br>    widget.item.selected ? cart.add(widget.item) : cart.delete(widget.item);<br>  &#125;<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    return Container(<br>      padding: const EdgeInsets.all(10),<br>      color: Colors.white,<br>      child: Row(<br>        children: [<br>          Expanded(<br>            child: Row(<br>              children: [<br>                Container(<br>                  margin: const EdgeInsets.symmetric(horizontal: 10),<br>                  width: 50,<br>                  height: 50,<br>                  color: Colors.yellow,<br>                ),<br>                Text(<br>                  widget.item.name,<br>                  style: const TextStyle(<br>                    fontSize: 18,<br>                    fontWeight: FontWeight.bold,<br>                  ),<br>                ),<br>              ],<br>            ),<br>          ),<br>          Builder(<br>            builder: (context) &#123;<br>              return widget.item.selected<br>                  ? IconButton(<br>                      // 已选中<br>                      onPressed: _updateState,<br>                      icon: const Icon(Icons.check),<br>                    )<br>                  : ElevatedButton(<br>                      //未选中<br>                      onPressed: _updateState,<br>                      style: ButtonStyle(<br>                        backgroundColor:<br>                            MaterialStateProperty.all(Colors.white),<br>                        elevation: MaterialStateProperty.all(0),<br>                      ),<br>                      child: const Text(<br>                        &#x27;ADD&#x27;,<br>                        style: TextStyle(color: Colors.black),<br>                      ),<br>                    );<br>            &#125;,<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与<code>代码实现4</code>相比，主要的变化是：</p><ul><li>现在 DakMyApp 与 DakCartCounter 是 StatelessWidget 了；</li><li>DakCartInheritedWidget 中<code>updateShouldNotify()</code>方法直接返回了 false，后续数据的更新通过 ChangeNotifier 实现，不再需要走<code>notifyClients</code>流程了；</li><li>静态方法<code>of()</code>中<code>dependOn..</code>变成了<code>get..</code>，也是因为后续数据的更新通过 ChangeNotifier 实现，不再需要注入依赖；</li><li>DakCatelogPage 与 DakListCell 中传递的 DakCallback 参数都不需要了，加购商品时直接在 DakListCell 的<code>_updateState()</code>回调里调用<code>cart.add()</code>或<code>cart.delete</code>更新共享数据；</li><li>共享数据使用者 DakCartCounter 中通过<code>AnimatedBuilder</code>来监听数据变化，并且在数据变化后使用已变化的数据仅局部重绘<code>Text</code>节点即可。</li></ul><p>为了做个验证，加购一件商品，此时控制台输出日志：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">AnimatedBuilder Go</span><br></code></pre></td></tr></table></figure><p>共享数据变化后，仅局部重绘了依赖者中使用此数据的的<code>Text</code>节点。</p><h5 id="4-实现原理"><a href="#4-实现原理" class="headerlink" title="4.实现原理"></a>4.实现原理</h5><h6 id="i-注册-1"><a href="#i-注册-1" class="headerlink" title="i.注册"></a>i.注册</h6><p>实现代码6中，我在依赖者的<code>Text</code>节点使用了<code>AnimatedBuilder</code>注册监听并构建组件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs DART">AnimatedBuilder(<br>animation: cart,<br>builder: (context, child) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AnimatedBuilder Go&#x27;</span>);<br>  <span class="hljs-keyword">return</span> Text(<br>    <span class="hljs-string">&#x27;共<span class="hljs-subst">$&#123;cart.items.length&#125;</span>件&#x27;</span>,<br>    style: <span class="hljs-keyword">const</span> TextStyle(<br>      color: Colors.black,<br>    ),<br>  );<br> &#125;,<br>)<br></code></pre></td></tr></table></figure><p>其实用它是因为我的MAC系统较老，暂时没有升级 Flutter 版本，如果你的系统比较新，这里最好是使用2.15版本之后新出的<code>ListenableBuilder</code>，不过它俩在功能上类似，我权且用它做演示了。</p><p><code>AnimatedBuilder</code>是<code>AnimatedWidget</code>的子类，用于在监听的数据变化时重绘依赖者组件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimatedBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnimatedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> AnimatedBuilder(&#123;<br>    Key? key,<br>    <span class="hljs-keyword">required</span> Listenable animation,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.builder,<br>    <span class="hljs-keyword">this</span>.child,<br>  &#125;) : <span class="hljs-keyword">super</span>(key: key, listenable: animation);<br><br>  <span class="hljs-keyword">final</span> TransitionBuilder builder;<br>  <span class="hljs-keyword">final</span> Widget? child;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> builder(context, child);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数1是个<code>Listenable</code>类型，对应购物车示例中的共享数据<code>cart</code>对象；</li><li>参数2是构造组件的回调函数，每当监听的数据发生变化时，都会执行自己的<code>build()</code>函数，构建并返回我们自定义的组件，即购物车示例中<code>DakCartCounter</code>的<code>Text</code>组件。</li></ul><p>构建<code>AnimatedBuilder</code>时，<code>animation</code>将传递给其父类<code>AnimatedWidget</code>的<code>listenable</code>字段：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AnimatedState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">AnimatedWidget</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    widget.listenable.addListener(_handleChange);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _handleChange() &#123;<br>    setState(() &#123;<br>      <span class="hljs-comment">// The listenable&#x27;s state is our build state, and it changed already.</span><br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) =&gt; widget.build(context);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>listenable</code>在<code>initState()</code>阶段注册了通知的回调<code>_handleChange</code>，至此完成了注册这一步。</p><h6 id="ii-修改"><a href="#ii-修改" class="headerlink" title="ii.修改"></a>ii.修改</h6><p>在商品分类页面，点击Cell中加购按钮后，先读取共享数据再修改它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">_updateState() &#123;<br>  setState(() &#123;<br>    widget.item.selected = !widget.item.selected;<br>    // 1.读取共享数据<br>    var cart = DakCartInheritedWidget.of(context)!.cart;<br>    // 2.修改共享数据<br>    widget.item.selected ? cart.add(widget.item) : cart.delete(widget.item);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="iii-通知"><a href="#iii-通知" class="headerlink" title="iii.通知"></a>iii.通知</h6><p><code>cart</code>对象在执行<code>add()</code>或者<code>delete()</code>的最后，都调用了<code>notifyListeners()</code>函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">//加入购物车<br>add(DakItem item) &#123;<br>  _items.add(item);<br>  notifyListeners();<br>&#125;<br><br>//移出购物车<br>delete(DakItem item) &#123;<br>  int index = _items.indexOf(item);<br>  _items.removeAt(index);<br>  notifyListeners();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@protected</span><br><span class="hljs-keyword">void</span> notifyListeners() &#123;<br>  <span class="hljs-keyword">if</span> (_count == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span>;<br>  _notificationCallStackDepth++;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> end = _count;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; end; i++) &#123;<br>    _listeners[i]?.call(); <span class="hljs-comment">// 重点在这里</span><br>  &#125;<br>  <span class="hljs-comment">//省略。。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>即调用<code>ChangeNotifier</code>中的<code>_listeners[i]?.call()</code>，执行监听者的<code>_handleChange</code>回调。而这个回调正是前文在<code>i.注册</code>阶段里<code>_AnimatedState</code>中定义的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-keyword">void</span> _handleChange() &#123;<br>    setState(() &#123;<br>      <span class="hljs-comment">// The listenable&#x27;s state is our build state, and it changed already.</span><br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><p>其默认实现是执行<code>setState</code>，即重绘<code>AnimatedWidget</code>组件，执行其<code>build()</code>函数，即执行我们在<code>AnimatedBuilder</code>中提供的第二个参数<code>builder</code>，也就是构建<code>Text</code>组件的回调。</p><p>这样，<code>DakCartCounter</code>就成功接收到通知，并且通过<code>AnimatedBuilder</code>局部重绘了<code>Text</code>组件。</p><h4 id="6-2-ValueNotifier"><a href="#6-2-ValueNotifier" class="headerlink" title="6.2. ValueNotifier"></a>6.2. ValueNotifier</h4><p><code>ChangeNotifier</code>已经很方便的帮我们实现局部重绘了，而Flutter框架想给你的还不止如此，它还提供了某些场景下更精简、方便的<code>ValueNotifier</code>。</p><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/// A [ChangeNotifier] that holds a single value.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// When [value] is replaced with something that is not equal to the old</span><br><span class="hljs-comment">/// value as evaluated by the equality operator ==, this class notifies its</span><br><span class="hljs-comment">/// listeners.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueNotifier</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">ChangeNotifier</span></span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">ValueListenable</span></span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">/// Creates a [ChangeNotifier] that wraps this value.</span><br>  ValueNotifier(<span class="hljs-built_in">this</span>._value);<br><br>  T _value;<br><br>  @<span class="hljs-keyword">override</span><br>  T <span class="hljs-keyword">get</span> value =&gt; _value;<br><br>  <span class="hljs-keyword">set</span> value(T <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (_value == <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br>      <span class="hljs-keyword">return</span>;<br>    _value = <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>;<br>    notifyListeners();<br>  &#125;<br><br>  @<span class="hljs-keyword">override</span><br>  <span class="hljs-keyword">String</span> toString() =&gt; <span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;describeIdentity(this)&#125;</span>(<span class="hljs-subst">$value)&#x27;;</span></span><br><span class="hljs-subst"><span class="hljs-string">&#125;</span></span><br></code></pre></td></tr></table></figure><p>它是<code>ChangeNotifier</code>的子类，可以很方便的帮我们在共享数据外包裹一层<code>ChangeNotifier</code>，为共享数据提供<code>getter</code>、<code>setter</code>，并在<code>setter</code>内帮我们叫<code>notifyListeners()</code>。</p><p>单看这些介绍，是不是发现它与 Swift 中属性包装器<code>@propertyWrapper</code>很像！</p><h5 id="2-基本用法-1"><a href="#2-基本用法-1" class="headerlink" title="2.基本用法"></a>2.基本用法</h5><ol><li>定义ValueNotifier数据及操作数据的接口</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakCartInheritedWidget extends InheritedWidget &#123;<br><br>  // 定义ValueNotifier并指定其监听数据的类型<br>  late final ValueNotifier&lt;DakCart&gt; _valueNotifier;<br><br>  ValueNotifier&lt;DakCart&gt; get valueNotifier =&gt; _valueNotifier;<br><br>  DakCartInheritedWidget(<br>    DakCart cart, &#123;Key? key, required Widget child,<br>  &#125;) : super(key: key, child: child,) &#123;<br>    _valueNotifier = ValueNotifier(cart);<br>  &#125;<br><br>  // 更新监听的数据对象<br>  void updateData(DakCart cart) &#123;<br>    _valueNotifier.value = cart;<br>  &#125;<br><br>  static DakCartInheritedWidget? of(BuildContext context) &#123;<br>    return context<br>        .getElementForInheritedWidgetOfExactType&lt;DakCartInheritedWidget&gt;()<br>        ?.widget as DakCartInheritedWidget;<br>  &#125;<br><br>  @override<br>  bool updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>    return false;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>初始化共享的数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakMyApp extends StatelessWidget &#123;<br>  DakMyApp(&#123;Key? key&#125;) : super(key: key);<br>  //初始化共享数据<br>  final cart = DakCart(items: []);<br>  @override<br>  Widget build(BuildContext context) &#123;<br>    return DakCartInheritedWidget(<br>      cart,<br>      child: const MaterialApp(<br>        home: DakCatelogPage(),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>读取共享的数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakCartCounter extends StatelessWidget &#123;<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br><br>    var valueNotifier = DakCartInheritedWidget.of(context)!.valueNotifier;<br><br>    return ValueListenableBuilder(// 使用ValueListenableBuilder监听共享数据的变化<br>      valueListenable: valueNotifier,<br>      builder: (context, DakCart value, child) &#123;<br><br>        return Text(<br>          &#x27;共$&#123;value.items.length&#125;件&#x27;,<br>          style: const TextStyle(<br>            color: Colors.black,<br>          ),<br>        );<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>更新共享的数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class _DakListCellState extends State&lt;DakListCell&gt; &#123;<br>  _updateState() &#123;<br>    setState(() &#123;<br>      widget.item.selected = !widget.item.selected;<br>    &#125;);<br>    // 修改共享数据<br>    final inherit = DakCartInheritedWidget.of(context)!;<br>    final valueNotifier = inherit.valueNotifier;<br>    final newItems = widget.item.selected<br>        ? valueNotifier.value.add(widget.item)<br>        : valueNotifier.value.delete(widget.item);<br>    final newCart = DakCart(items: newItems);<br>    inherit.updateData(newCart); <br>  &#125;<br>  。。。<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-示例改造-1"><a href="#3-示例改造-1" class="headerlink" title="3.示例改造"></a>3.示例改造</h5><p>接下来用它来继续改造<code>代码实现4</code>。</p><p>代码实现7：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs FLUTTER">class DakMyApp extends StatelessWidget &#123;<br>  DakMyApp(&#123;Key? key&#125;) : super(key: key);<br><br>  final cart = DakCart(items: []); //初始化共享数据<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakMyAPP build&#x27;);<br>    return DakCartInheritedWidget(<br>      cart,<br>      child: const MaterialApp(<br>        home: DakCatelogPage(),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br>class DakCartInheritedWidget extends InheritedWidget &#123;<br><br>  late final ValueNotifier&lt;DakCart&gt; _valueNotifier;  // 这里变了<br>  ValueNotifier&lt;DakCart&gt; get valueNotifier =&gt; _valueNotifier;<br><br>  DakCartInheritedWidget(<br>    DakCart cart, &#123;<br>    Key? key,<br>    required Widget child,<br>  &#125;) : super(<br>          key: key,<br>          child: child,<br>        ) &#123;<br>    _valueNotifier = ValueNotifier(cart);<br>  &#125;<br><br>  // 更新监听的数据对象<br>  void updateData(DakCart cart) &#123;<br>    _valueNotifier.value = cart;<br>  &#125;<br><br>  static DakCartInheritedWidget? of(BuildContext context) &#123;<br>    return context<br>        .getElementForInheritedWidgetOfExactType&lt;DakCartInheritedWidget&gt;()<br>        ?.widget as DakCartInheritedWidget;<br>  &#125;<br><br>  @override<br>  bool updateShouldNotify(DakCartInheritedWidget oldWidget) &#123;<br>    return false;<br>  &#125;<br>&#125;<br><br>class DakCart &#123;<br><br>  List&lt;DakItem&gt; items = [];<br><br>  int get totalPrice =&gt; items.length * 42;<br>  DakCart(&#123;required this.items&#125;);<br><br>  List&lt;DakItem&gt; add(DakItem item) &#123;<br>    items.add(item);<br>    return items;<br>  &#125;<br><br>  List&lt;DakItem&gt; delete(DakItem item) &#123;<br>    int index = items.indexOf(item);<br>    items.removeAt(index);<br>    return items;<br>  &#125;<br><br>  @override<br>  bool operator ==(Object other) &#123;<br>    if (other is! DakCart) &#123;<br>      return false;<br>    &#125;<br>    if (!identical(this, other)) &#123;<br>      return false;<br>    &#125;<br>    bool same =<br>        listEquals(items, other.items) &amp;&amp; (other.totalPrice == totalPrice);<br>    return same;<br>  &#125;<br><br>  @override<br>  int get hashCode =&gt; Object.hashAll([items, totalPrice]);<br>&#125;<br><br>// 商品Model<br>。。。<br>// 商品列表页面<br>。。。<br><br>//商品总数<br>class DakCartCounter extends StatelessWidget &#123;<br>  const DakCartCounter(&#123;Key? key&#125;) : super(key: key);<br><br>  @override<br>  Widget build(BuildContext context) &#123;<br>    print(&#x27;DakCartCounter build&#x27;);<br><br>    var valueNotifier = DakCartInheritedWidget.of(context)!.valueNotifier;<br><br>    return ValueListenableBuilder(// 这里变了 使用共享数据<br>      valueListenable: valueNotifier,<br>      builder: (context, DakCart value, child) &#123;<br>        print(&#x27;DakCartCounter build Text&#x27;);<br>        return Text(<br>          &#x27;共$&#123;value.items.length&#125;件&#x27;,<br>          style: const TextStyle(<br>            color: Colors.black,<br>          ),<br>        );<br>      &#125;,<br>    );<br>  &#125;<br>&#125;<br><br>class DakListCell extends StatefulWidget &#123;<br>  final DakItem item;<br>  const DakListCell(&#123;<br>    Key? key,<br>    required this.item,<br>  &#125;) : super(key: key);<br><br>  @override<br>  State&lt;DakListCell&gt; createState() =&gt; _DakListCellState();<br>&#125;<br><br>class _DakListCellState extends State&lt;DakListCell&gt; &#123;<br>  _updateState() &#123;<br>    setState(() &#123;<br>      widget.item.selected = !widget.item.selected;<br>    &#125;);<br>    // 这里变了<br>    final inherit = DakCartInheritedWidget.of(context)!;<br>    final valueNotifier = inherit.valueNotifier;<br>    final newItems = widget.item.selected<br>        ? valueNotifier.value.add(widget.item)<br>        : valueNotifier.value.delete(widget.item);<br>    final newCart = DakCart(items: newItems);<br>    inherit.updateData(newCart); // 修改共享数据<br>  &#125;<br>  。。。<br>&#125;<br></code></pre></td></tr></table></figure><p>主要的变化是：</p><ul><li>现在 DakMyApp 与 DakCartCounter 是<code>StatelessWidget</code>了；</li><li>DakCartInheritedWidget 中共享数据由 DakCart 类型变为了<code>ValueNotifier&lt;DakCart&gt;</code>类型，同时增加了更新数据的方法<code>updateData()</code>；</li><li><code>updateShouldNotify()</code>方法直接返回了 false，后续数据的更新通过<code>ValueNotifier</code>实现，不再需要走<code>notifyClients</code>流程；</li><li>静态方法<code>of()</code>中<code>dependOn..</code>变成了<code>get..</code>，也是因为后续数据的更新通过<code>ValueNotifier</code>实现，不再需要注入依赖；</li><li>DakCatelogPage 与 DakListCell 中的 DakCallback 参数都不需要了，加购商品时直接在 DakListCell 的<code>_updateState()</code>回调里调用<code>inherit.updateData(newCart)</code>更新数据；</li><li>共享数据使用者 DakCartCounter 中通过<code>ValueListenableBuilder</code>来监听数据变化，并且在数据变化后直接使用回调中的<code>value</code>局部重绘<code>Text</code>节点即可。</li></ul><p>为了做个验证，加购一件商品，此时控制台输出日志：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">DakCartCounter build <span class="hljs-built_in">Text</span><br></code></pre></td></tr></table></figure><p>这次，借助<code>ValueNotifier</code>的能力，MyApp、DakCatelogPage、DakCartCounter 也都没重绘，只有使用了共享数据的<code>Text</code>组件重绘了！</p><h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><p>本文介绍了原生开发与响应式编程中对于状态管理的不同处理方式，着重讲解了Flutter中对<code>提升状态</code>的实践及其产生的问题与解决方案。其中重点讲解了<code>InheritedWidget</code>在组件树中从上而下传递数据的机制原理，<code>ChangeNotifier</code>与<code>ValueNotifier</code>实现局部重绘的原理与实践。其实除了这些，还有<code>provider</code>等三方库可以实现局部刷新，后面的文章里再接着介绍吧~</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter手势拦截</title>
    <link href="/2023/07/15/flutter-pointer.html"/>
    <url>/2023/07/15/flutter-pointer.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>这两天在学习手势相关的知识点，想实现一个Listview带可点击的背景视图。使用的是<code>Stack</code>布局，上层为<code>Listview</code>，下层为背景与按钮。因为<code>Listview</code>在上，点击手势无法穿透并向下传递，导致背景中的按钮无法响应点击事件。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_tableback.png" alt="点击穿透"></p><p>几经查询，了解到<code>IgnorePointer</code>、<code>AbsorbPointer</code>组件，其中的前者就可以实现点击穿透的效果。以下就是对研究点击穿透原理过程的整理记录。</p><h3 id="2-PointerEvents"><a href="#2-PointerEvents" class="headerlink" title="2.PointerEvents"></a>2.PointerEvents</h3><blockquote><p>指针事件（Pointer Events）是一种用于处理来自各种输入设备（例如鼠标、触控笔和触摸屏等）输入信息的现代化解决方案。</p></blockquote><p>早期web时代只有鼠标，通过鼠标可完成<code>mousedown</code>、<code>mouseover</code>、<code>mouseup</code>等「鼠标事件」；如今手机平板等触屏设备普及，轻触屏幕即可与设备上的应用交互，因此又引入了「触摸事件」，如<code>touchstart</code>、<code>touchend</code>和<code>touchmove</code>。为解决同时维护两份事件代码的问题，人们又引入了全新的规范「指针事件」。它为各种指针输入设备提供了一套统一的事件，会自动兼容web端与移动端的事件，并返回<code>pointerType</code>等表明触发此事件的设备类型（鼠标&#x2F;触控笔&#x2F;触摸等）。</p><p>对移动端来说，指针事件可分三个阶段：手指按下、移动、抬起。</p><p>以Flutter为例，框架针对手指的按下、移动、抬起这些事件，分别封装了对应的事件对象：</p><table><thead><tr><th align="center"><strong>事件类型</strong></th><th align="center"><strong>事件对象</strong></th></tr></thead><tbody><tr><td align="center">按下</td><td align="center">PointerDownEvent</td></tr><tr><td align="center">移动</td><td align="center">PointerMoveEvent</td></tr><tr><td align="center">抬起</td><td align="center">PointerUpEvent</td></tr></tbody></table><p>需要指出的是，「指针事件」与「手势」不完全是一回事，手势是由指针事件构成的，但有更丰富的内涵，如单击、双击、拖动、旋转等。</p><h3 id="3-HitTest"><a href="#3-HitTest" class="headerlink" title="3.HitTest"></a>3.HitTest</h3><p>触发指针事件时，Flutter会在渲染树中执行<code>命中测试</code>(HitTest)，以确定触摸的是哪些渲染对象。</p><h4 id="3-1-hitTest"><a href="#3-1-hitTest" class="headerlink" title="3.1.hitTest"></a>3.1.hitTest</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">/// <span class="language-markdown">Determines the set of render objects located at the given position.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">Returns true, and adds any render objects that contain the point to the</span></span><br><span class="hljs-comment">/// <span class="language-markdown">given hit test result, if this render object or one of its descendants</span></span><br><span class="hljs-comment">/// <span class="language-markdown">absorbs the hit (preventing objects below this one from being hit).</span></span><br><span class="hljs-comment">/// <span class="language-markdown">Returns false if the hit can continue to other objects below this one.</span></span><br><br><span class="hljs-built_in">bool</span> hitTest(BoxHitTestResult result, &#123; <span class="hljs-keyword">required</span> Offset position &#125;) &#123;<br>    <span class="hljs-comment">//省略...</span><br><span class="hljs-keyword">if</span> (_size!.contains(position)) &#123;<br>  <span class="hljs-keyword">if</span> (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123;<br>      result.add(BoxHitTestEntry(<span class="hljs-keyword">this</span>, position));<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是[RenderBox.hitTest]的源码注释，是否命中逻辑的如下：</p><ol><li>先检测点击是否在当前渲染对象(self)的size范围内；</li><li>再对子树递归执行命中测试，有子树命中通过则将self加入测试结果列表(result)中；</li><li>若子树未通过命中测试，则对self执行命中测试；</li><li>若self声明自己通过命中测试，则把self添加进测试结果列表。</li></ol><p>测试结果列表<code>result</code>中储存的是所有通过命中测试的RenderBox，即触摸点下的渲染对象，这些对象将能接收和处理指针事件。</p><hr><p>需要说明的是，不同的渲染对象对hitTest有不同的实现，以[Listener]为例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-built_in">bool</span> hitTest(BoxHitTestResult result, &#123; Offset position &#125;) &#123;<br>    <span class="hljs-built_in">bool</span> hitTarget =<span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (size.contains(position)) &#123;<br>      hitTarget = hitTestChildren(result, position: position) || hitTestSelf(position);<br>      <span class="hljs-keyword">if</span> (hitTarget || behavior == HitTestBehavior.translucent)<br>        result.add(BoxHitTestEntry(<span class="hljs-keyword">this</span>, position));<br>    &#125;<br>    <span class="hljs-keyword">return</span> hitTarget;<br>&#125;<br></code></pre></td></tr></table></figure><p>其命中测试的逻辑与[RenderBox]大致相同，只是多了一条对<code>behavior</code>属性的判断。</p><table><thead><tr><th align="center">behavior</th><th align="left">作用</th></tr></thead><tbody><tr><td align="center">deferToChild</td><td align="left">自己是否通过命中测试取决于子组件是否通过命中测试</td></tr><tr><td align="center">opaque</td><td align="left">自己必然会通过命中测试，同时其 hitTest 返回值始终为true</td></tr><tr><td align="center">translucent</td><td align="left">自己必然会通过命中测试，但其 hitTest 返回值不一定为true</td></tr></tbody></table><h4 id="3-2-hitTestChildren"><a href="#3-2-hitTestChildren" class="headerlink" title="3.2.hitTestChildren"></a>3.2.hitTestChildren</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">/// <span class="language-markdown">Override this method to check whether any children are located at the</span></span><br><span class="hljs-comment">/// <span class="language-markdown">given position.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">Subclasses should return true if at least one child reported a hit at the</span></span><br><span class="hljs-comment">/// <span class="language-markdown">specified position.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">Typically children should be hit-tested in reverse paint order so that</span></span><br><span class="hljs-comment">/// <span class="language-markdown">hit tests at locations where children overlap hit the child that is</span></span><br><span class="hljs-comment">/// <span class="language-markdown">visually &quot;on top&quot; (i.e., paints later).</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-meta">@protected</span><br><span class="hljs-built_in">bool</span> hitTestChildren(BoxHitTestResult result, &#123; <span class="hljs-keyword">required</span> Offset position &#125;) =&gt; <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure><p>此方法的作用是，判断是否有子节点通过了命中测试。</p><p>如果有，则将子组件添加到<code>HitTestResult</code>中，方法返回值<code>true</code>；</p><p>如果没有，则方法返回<code>false</code>。</p><hr><p>对包含多个子组件的组件，该方法会递归调用子组件的<code>hitTest</code>方法，且是<code>逆序</code>进行的：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">// RenderBoxContainerDefaultsMixin 中的实现：</span><br><span class="hljs-comment">// 子类的 hitTestChildren() 中直接调用此方法</span><br><span class="hljs-built_in">bool</span> defaultHitTestChildren(BoxHitTestResult result, &#123; <span class="hljs-keyword">required</span> Offset position &#125;) &#123;<br>  <span class="hljs-comment">// 1.从后向前逆序遍历所有子组件</span><br>  ChildType? child = lastChild;<br>  <span class="hljs-keyword">while</span> (child != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">final</span> ParentDataType childParentData = child.parentData! <span class="hljs-keyword">as</span> ParentDataType;<br>    <span class="hljs-comment">// 2.当前子节点调用hitTest</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> isHit = result.addWithPaintOffset(<br>      offset: childParentData.offset,<br>      position: position,<br>      hitTest: (BoxHitTestResult result, Offset? transformed) &#123;<br>        <span class="hljs-keyword">return</span> child!.hitTest(result, position: transformed!);<br>      &#125;,<br>    );<br>    <span class="hljs-comment">// 3.有一个子节点通过命中测试，则终止遍历，返回true</span><br>    <span class="hljs-keyword">if</span> (isHit) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    child = childParentData.previousSibling;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br>  <span class="hljs-comment">// 子节点调用hitTest</span><br><span class="hljs-built_in">bool</span> addWithPaintOffset(&#123;<br>  <span class="hljs-keyword">required</span> Offset? offset,<br>  <span class="hljs-keyword">required</span> Offset position,<br>  <span class="hljs-keyword">required</span> BoxHitTest hitTest,<br>&#125;) &#123;<br>  <span class="hljs-comment">// 省略...</span><br>  <span class="hljs-comment">// 子节点调用hitTest</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> isHit = hitTest(<span class="hljs-keyword">this</span>, transformedPosition);<br>  <span class="hljs-keyword">return</span> isHit;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>如果子节点A未通过命中测试，则继续逆序对其前面的兄弟节点进行命中测试；</p></li><li><p>只要有某个子节点<code>X</code>通过命中测试，则终止其剩余兄弟节点的遍历过程：</p></li></ol><ul><li>X前面的兄弟节点将没有机会通过命中测试，事件被X拦截；</li><li>X父节点的<code>hitTestChildren</code>&#x3D;true；</li><li>进而使X父节点的<code>hitTest</code>&#x3D;true，X的父节点通过命中测试；</li></ul><ol start="3"><li>如果所有子节点都未命中，则父节点调用<code>hitTestSelf</code>，父节点是否命中根据此返回值而定。</li></ol><hr><p>为什么存在中断机制？</p><p>因为在大多数布局中兄弟节点间不重叠，触摸点下往往只会有一个节点。因此命中测试时一旦某个节点通过测试即由它响应事件，没必要继续遍历检测其他节点了。</p><p>为什么兄弟节点间要逆序检测？</p><p>因为对于<code>Stack</code>这种布局，兄弟节点重叠时，后面的组件会在前面组件之上。点击时应该是上面的组件响应事件，下面的组件被遮住不能响应此事件。因此命中测试应该优先对后面的节点进行测试，一旦命中通过则不再继续遍历检测了。</p><h4 id="3-3-hitTestSelf"><a href="#3-3-hitTestSelf" class="headerlink" title="3.3.hitTestSelf"></a>3.3.hitTestSelf</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">/// <span class="language-markdown">Override this method if this render object can be hit even if its</span></span><br><span class="hljs-comment">/// <span class="language-markdown">children were not hit.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// <span class="language-markdown">Returns true if the specified <span class="hljs-code">`position`</span> should be considered a hit</span></span><br><span class="hljs-comment">/// <span class="language-markdown">on this render object.</span></span><br><span class="hljs-comment">///</span><br><span class="hljs-meta">@protected</span><br><span class="hljs-built_in">bool</span> hitTestSelf(Offset position) =&gt; <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure><p>声明自己是否通过命中测试。</p><p>想强制自己通过命中测试时，可重写此方法并返回<code>true</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-built_in">bool</span> hitTestSelf(Offset position) =&gt; behavior == HitTestBehavior.opaque;<br></code></pre></td></tr></table></figure><p>以上是<code>Listener</code>中的实现，字段&#x3D;<code>opaque</code>即可确保自己一定通过测试。</p><h4 id="3-4-iOS响应者链"><a href="#3-4-iOS响应者链" class="headerlink" title="3.4.iOS响应者链"></a>3.4.iOS响应者链</h4><p>无论在原理还是具体实现上，Flutter的<code>命中测试</code>与iOS开发中的<code>响应者链</code>都十分相似：</p><ul><li>触摸点下哪些组件能响应事件，都是由命中测试决定的；</li><li>命中测试都是从根节点开始，之后在子树中递归进行；</li><li>同级子树的命中测试都是按从后往前的顺序(逆序)进行；</li><li>父节点未通过命中测试，则子节点一定不会通过测试；</li><li>子节点通过命中测试，则父节点也一定通过命中测试；</li></ul><p>注：这里说的是默认实现，即子类未重写原始方法的情况下！</p><h3 id="4-事件分发"><a href="#4-事件分发" class="headerlink" title="4.事件分发"></a>4.事件分发</h3><p>命中测试完毕后，通过测试的所有渲染节点都已加入<code>HitTestResult</code>列表。</p><p>完成了这一步，就确定了谁可以响应这些事件。那么节点具体是怎么处理事件的呢？这就涉及到Flutter的<code>事件分发</code>(Event Dispatch)。</p><p>框架会遍历<code>HitTestResult</code>列表，调用每个渲染对象的<code>handleEvent</code>方法分发处理指针事件：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">// 事件分发</span><br><span class="hljs-keyword">void</span> dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) &#123;<br>  <span class="hljs-comment">//省略... </span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> HitTestEntry entry <span class="hljs-keyword">in</span> hitTestResult.path) &#123;<br>    entry.target.handleEvent(event.transformed(entry.transform), entry);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意：在命中检测时先递归检测子节点，再检测父节点。所以 HitTestResult 列表中：</p><ul><li>子节点在父节点之前；</li><li>同级子节点间呈倒序排列。</li></ul><p>所以，事件分发时也是按照此顺序进行：</p><ul><li>子节点先于父节点处理事件；</li><li>同级子节点间按倒序处理事件。</li></ul><p>这些也都与iOS中，事件的传递链相同~</p><hr><p>需要说明的是，通过命中测试是以<code>hitTest</code>的返回值为标准。但具体能否响应指针事件，是以渲染对象是否被加入<code>BoxHitTestResult</code>列表为标准。上面也说过，不同的渲染对象会重写<code>hitTest</code>并提供自己版本的实现，以[ Listener ]为例:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-built_in">bool</span> hitTest(BoxHitTestResult result, &#123; Offset position &#125;) &#123;<br>    <span class="hljs-built_in">bool</span> hitTarget =<span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (size.contains(position)) &#123;<br>      hitTarget = hitTestChildren(result, position: position) || hitTestSelf(position);<br>      <span class="hljs-keyword">if</span> (hitTarget || behavior == HitTestBehavior.translucent)<br>        result.add(BoxHitTestEntry(<span class="hljs-keyword">this</span>, position));<br>    &#125;<br>    <span class="hljs-keyword">return</span> hitTarget;<br>&#125;<br><br><span class="hljs-built_in">bool</span> hitTestSelf(Offset position) =&gt; behavior == HitTestBehavior.opaque;<br></code></pre></td></tr></table></figure><p>当 behavior &#x3D;<code>translucent</code>时，无论触摸点是否在 Listener 区域内，其<code>hitTestSelf</code>都会返回false，即 self 未通过命中测试。尽管如此，Listener还是能拦截并响应此事件，因为根据源码中的逻辑，此时 self 会被加入<code>BoxHitTestResult</code>列表中，在事件分发时 Listener 依然会响应此事件。</p><p>这种情况与iOS中的动态方法决议相似：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">+ (BOOL)resolveClassMethod:(SEL)name;    <span class="hljs-regexp">//</span>类方法<br>+ (BOOL)resolveInstanceMethod:(SEL)name; <span class="hljs-regexp">//</span>实例方法<br></code></pre></td></tr></table></figure><p>表面上看，方法决议是否成功是以函数的返回值为标志，但实际上在不涉及消息转发的情况下：</p><ul><li>若函数内为指定的SEL提供实现，无论返回YES或NO，编译都会正常进行；</li><li>若函数内并没有为SEL提供实现，无论返回YES或NO，编译都会crash；</li></ul><p>综上，判断节点是否响应事件时，须依实际类型而定，看节点是否在<code>BoxHitTestResult</code>列表中。</p><h3 id="5-拦截组件"><a href="#5-拦截组件" class="headerlink" title="5.拦截组件"></a>5.拦截组件</h3><p>回到开头「点击穿透」的问题，实现此功能须先研究下Flutter提供的两个组件：</p><ul><li>IgnorePointer</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">/// A widget that is invisible during hit testing.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// When [ignoring] is true, this widget (and its subtree) is invisible</span><br><span class="hljs-comment">/// to hit testing. It still consumes space during layout and paints its child</span><br><span class="hljs-comment">/// as usual. It just cannot be the target of located events, because it returns</span><br><span class="hljs-comment">/// false from [RenderBox.hitTest].</span><br></code></pre></td></tr></table></figure><ul><li>AbsorbPointer</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">/// A widget that absorbs pointers during hit testing.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// When [absorbing] is true, this widget prevents its subtree from receiving</span><br><span class="hljs-comment">/// pointer events by terminating hit testing at itself. It still consumes space</span><br><span class="hljs-comment">/// during layout and paints its child as usual. It just prevents its children</span><br><span class="hljs-comment">/// from being the target of located events, because it returns true from</span><br><span class="hljs-comment">/// [RenderBox.hitTest].</span><br></code></pre></td></tr></table></figure><p>二者的区别以图表形式展示如下：</p><table><thead><tr><th align="center"><strong>IgnorePointer</strong></th><th align="center"><strong>true</strong></th><th align="center"><strong>false</strong></th></tr></thead><tbody><tr><td align="center"><strong>child</strong></td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center"><strong>self</strong></td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center"><strong>back</strong></td><td align="center">✅</td><td align="center">❎</td></tr></tbody></table><table><thead><tr><th align="center"><strong>AbsorbPointer</strong></th><th align="center"><strong>true</strong></th><th align="center"><strong>false</strong></th></tr></thead><tbody><tr><td align="center"><strong>child</strong></td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center"><strong>self</strong></td><td align="center">❎</td><td align="center">✅</td></tr><tr><td align="center"><strong>back</strong></td><td align="center">❎</td><td align="center">❎</td></tr></tbody></table><p>属性&#x3D;<code>false</code>时，</p><p>作为普通容器组件，自身与子树可接收点击事件，且不会再往下传递。</p><p>属性&#x3D;<code>true</code>时,</p><p>共同作用：</p><ul><li>禁止子树接收指针事件；</li></ul><p>不同的是：</p><ul><li><p>IgnorePointer会<code>忽略</code>指针事件，自己和子树都不响应点击事件，事件会穿透自己，传递给位于其下面被其挡住的组件，因此下面的组件可以响应此指针事件；</p></li><li><p>AbsorbPointer会<code>吸收</code>指针事件，即自己会拦截并响应点击事件，事件无法穿透自己，因此位于其下面被其挡住的组件无法响应此指针事件；</p></li></ul><h3 id="6-组件源码"><a href="#6-组件源码" class="headerlink" title="6.组件源码"></a>6.组件源码</h3><p>下面通过源码看看二者在实现上的区别：</p><h4 id="6-1-IgnorePointer"><a href="#6-1-IgnorePointer" class="headerlink" title="6.1.IgnorePointer"></a>6.1.IgnorePointer</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> hitTest(BoxHitTestResult result, &#123;<span class="hljs-keyword">required</span> Offset position&#125;) &#123;<br>    <span class="hljs-keyword">return</span> !ignoring &amp;&amp; <span class="hljs-keyword">super</span>.hitTest(result, position: position);<br>  &#125;<br></code></pre></td></tr></table></figure><p>当<code>ignoring</code>字段&#x3D;true时：</p><ul><li>hitTest 直接返回 false，IgnorePointer自己和子节点的命中测试失败；</li><li>super.hitTest 被截断，自己和子节点没机会加入HitTestResult列表，都不能响应事件。</li></ul><p>由于IgnorePointer节点的<code>hitTest</code>返回 false，hitTest过程会继续遍历其兄弟节点和下层节点，从而使事件有机会<code>穿透</code>自己，传给兄弟节点或下面的组件。</p><h4 id="6-2-AbsorbPointer"><a href="#6-2-AbsorbPointer" class="headerlink" title="6.2.AbsorbPointer"></a>6.2.AbsorbPointer</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> hitTest(BoxHitTestResult result, &#123;<span class="hljs-keyword">required</span> Offset position&#125;) &#123;<br>    <span class="hljs-keyword">return</span> absorbing<br>        ? size.contains(position)<br>        : <span class="hljs-keyword">super</span>.hitTest(result, position: position);<br>  &#125;<br></code></pre></td></tr></table></figure><p>当<code>absorbing</code>&#x3D;true，且触摸点在size范围内时：</p><ul><li>hitTest返回true，当前AbsorbPointer组件通过命中测试，事件不再往下传递；</li><li>当前AbsorbPointer的父组件也能通过命中测试，因为父组件的child的hitTest返回true；</li><li>AbsorbPointer自己与子树不能响应指针事件，因为hitTest直接返回 true，自己与子节点并没有加入HitTestResult列表中。</li></ul><p>所以，<code>AbsorbPointer</code>可以被用来作为拦截指针事件的组件来使用。</p><h3 id="7-穿透示例"><a href="#7-穿透示例" class="headerlink" title="7.穿透示例"></a>7.穿透示例</h3><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_pointer_event.png" alt="点击穿透"></p><p>测试代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DakTestPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> DakTestPage(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Stack(<br>      alignment: Alignment.center,<br>      children: [_buildBack(), _buildFront()],<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">//绿色按钮</span><br>  Widget _buildBack() &#123;<br>    <span class="hljs-keyword">return</span> Listener(<br>        onPointerDown: (event) =&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;++++listen back&#x27;</span>),<br>        behavior: HitTestBehavior.deferToChild,<br>        child: ElevatedButton(<br>            style: ButtonStyle(<br>                padding: MaterialStateProperty.all(<span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">10</span>)),<br>                foregroundColor: MaterialStateProperty.all(Colors.white),<br>                backgroundColor: MaterialStateProperty.all(Colors.green)),<br>            onPressed: () =&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;**** 有事吗? ***&#x27;</span>),<br>            child: <span class="hljs-keyword">const</span> Text(<br>              <span class="hljs-string">&#x27;+Click+&#x27;</span>,<br>              style:<br>                  TextStyle(color: Colors.white, fontWeight: FontWeight.bold),<br>            )));<br>  &#125;<br><br>  <span class="hljs-comment">//灰色区域</span><br>  Widget _buildFront() &#123;<br>    <span class="hljs-keyword">const</span> mHeit = <span class="hljs-number">100.0</span>;<br>    <span class="hljs-keyword">return</span> Listener(<br>        onPointerDown: (event) =&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;++listen front&#x27;</span>),<br>        behavior: HitTestBehavior.deferToChild, <span class="hljs-comment">//注意：跟这里也有关系</span><br>        <span class="hljs-comment">// 替换-1(AbsorbPointer)</span><br>        child: IgnorePointer(<br>          <span class="hljs-comment">// 替换-2(absorbing)</span><br>          ignoring: <span class="hljs-keyword">true</span>,<br>          child: Listener(<br>            onPointerDown: (event) =&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++listen child&quot;</span>),<br>            child: Container(<br>              color: Colors.black26,<br>              width: <span class="hljs-number">200.0</span>,<br>              height: mHeit,<br>              child: Row(<br>                children: [<br>                  Expanded(<br>                      child: Container(height: mHeit, color: Colors.black38)),<br>                  Expanded(<br>                      child: Container(height: mHeit, color: Colors.white38))<br>                ],<br>              ),<br>            ),<br>          ),<br>        ));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>点击灰色且不与绿色按钮重合的区域时，不会有任何日志打印；</li></ul><p>这说明：<code>IgnorePointer</code>禁止了子树与自己参与响应点击事件；</p><ul><li>点击灰色与绿色重叠区域时，打印以下日志：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs DART">++++listen back<br>**** 有事吗? ***<br></code></pre></td></tr></table></figure><p>这说明：点击手势穿透<code>IgnorePointer</code>组件，传递给了下面的绿色按钮；</p><hr><p>修改代码“替换-1”、“替换-2”之后，点击灰色区域或者二者重叠区域时，打印日志：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs DART">++listen front<br></code></pre></td></tr></table></figure><p>即：<code>AbsorbPointer</code>禁止子树响应点击事件，但其自己可响应；同时，点击事件被拦截，下面的组件无法再响应此事件。</p><hr><p>代码的<code>//注意:</code>这里我做了标注，使用<code>Listener</code>时，需要结合<code>behavior</code>的具体值，才能确定点击能否穿透到下层组件上去。比如示例代码中，设置<code>behavior=opaque</code>时，点击就无法穿透。</p><h3 id="8-前文实现"><a href="#8-前文实现" class="headerlink" title="8.前文实现"></a>8.前文实现</h3><p>回到开头的问题，为了使背景组件可点击，给<code>Listview</code>套一层<code>IgrorePointer</code>，并在背景显示完时，将<code>ignoring</code>属性设置为<code>true</code>即可。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DakAITeacherPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DakAITeacherPage</span>(&#123;Key? key&#125;) : <span class="hljs-title function_ invoke__">super</span>(<span class="hljs-attr">key</span>: key);<br><br>  @override<br>  State&lt;DakAITeacherPage&gt; <span class="hljs-title function_ invoke__">createState</span>() =&gt; <span class="hljs-title function_ invoke__">_DakAITeacherPageState</span>();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_DakAITeacherPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">DakAITeacherPage</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-title">with</span> <span class="hljs-title">AutomaticKeepAliveClientMixin</span> </span>&#123;<br>  <span class="hljs-comment">// 。。。</span><br>  <span class="hljs-keyword">bool</span> mIgnore = <span class="hljs-literal">false</span>; <span class="hljs-comment">//控制手势是否能穿透Listview</span><br><br>  @override<br>  Widget <span class="hljs-title function_ invoke__">build</span>(BuildContext context) &#123;<br>    super.<span class="hljs-title function_ invoke__">build</span>(context);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Scaffold</span>(<br>      <span class="hljs-attr">drawer</span>: <span class="hljs-keyword">const</span> <span class="hljs-title function_ invoke__">DakSideDraw</span>(),<br>      <span class="hljs-attr">body</span>: <span class="hljs-title function_ invoke__">Stack</span>(<br>        <span class="hljs-attr">children</span>: [<span class="hljs-title function_ invoke__">_buildBack</span>(), <span class="hljs-title function_ invoke__">_buildList</span>()],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">// 背景视图</span><br>  Widget <span class="hljs-title function_ invoke__">_buildBack</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Listener</span>(<br>      <span class="hljs-attr">behavior</span>: HitTestBehavior.deferToChild,<br>      <span class="hljs-attr">onPointerDown</span>: (event) &#123;<br>        <span class="hljs-title function_ invoke__">setState</span>(() &#123;<br>          mIgnore = !mIgnore; <span class="hljs-comment">// 重置ignoring属性</span><br>        &#125;);<br>      &#125;,<br>      child: <span class="hljs-title function_ invoke__">Container</span>(<br>        <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Center</span>(<br>            <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Container</span>(<br>          <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>,<br>          <span class="hljs-attr">height</span>: <span class="hljs-number">50</span>,<br>          <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">TextButton</span>(<br>              <span class="hljs-attr">onPressed</span>: () &#123;<br>                <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;**** Hi? ***&#x27;</span>);<br>              &#125;,<br>              <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title function_ invoke__">Text</span>(<br>                <span class="hljs-string">&#x27;Click&#x27;</span>,<br>                <span class="hljs-attr">style</span>:<br>                    <span class="hljs-title function_ invoke__">TextStyle</span>(<span class="hljs-attr">color</span>: Colors.white, <span class="hljs-attr">fontWeight</span>: FontWeight.bold),<br>              )),<br>        )),<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">// 构建列表视图</span><br>  Widget <span class="hljs-title function_ invoke__">_buildList</span>() &#123;<br>    <span class="hljs-comment">// ！！！重点在这里</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">IgnorePointer</span>(<br>      <span class="hljs-attr">ignoring</span>: mIgnore,<br>      <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Column</span>(<br>        <span class="hljs-attr">children</span>: [<br>          MediaQuery.<span class="hljs-title function_ invoke__">removePadding</span>(<br>            <span class="hljs-attr">context</span>: context,<br>            <span class="hljs-attr">removeTop</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Expanded</span>(<br>                <span class="hljs-attr">child</span>: NotificationListener&lt;ScrollNotification&gt;(<br>                    <span class="hljs-attr">onNotification</span>: (notification) &#123;<br>                      <span class="hljs-title function_ invoke__">_handleScrollNotification</span>(notification);<br>                      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;,<br>                    <span class="hljs-attr">child</span>: ListView.<span class="hljs-title function_ invoke__">builder</span>(<br>                        <span class="hljs-attr">padding</span>: EdgeInsets.<span class="hljs-title function_ invoke__">fromLTRB</span>(<span class="hljs-number">0</span>, mScrollTopInset, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>                        <span class="hljs-attr">itemCount</span>: <span class="hljs-number">30</span>,<br>                        <span class="hljs-attr">itemExtent</span>: <span class="hljs-number">50.0</span>,<br>                        <span class="hljs-attr">controller</span>: _scrollController,<br>                        <span class="hljs-attr">itemBuilder</span>: (context, index) &#123;<br>                          <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Container</span>(<br>                            <span class="hljs-attr">color</span>: Colors.white,<br>                            <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">ListTile</span>(<br>                              <span class="hljs-attr">title</span>: <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$index</span>&quot;</span>),<br>                            ),<br>                          );<br>                        &#125;))),<br>          )<br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-comment">// 处理滑动通知</span><br>  <span class="hljs-title function_ invoke__">_handleScrollNotification</span>(ScrollNotification notification) &#123;<br>    <span class="hljs-comment">// 4.滑动结束</span><br>    <span class="hljs-comment">// 重置ignoring属性</span><br>    mIgnore = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 。。。</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-后记"><a href="#9-后记" class="headerlink" title="9.后记"></a>9.后记</h3><p>以上<code>点击穿透</code>案例是对<code>PointerEvents</code>一次很好的实践，后续还有很多需要学习，继续期待~</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集成Flutter模块</title>
    <link href="/2023/04/23/flutter-embed.html"/>
    <url>/2023/04/23/flutter-embed.html</url>
    
    <content type="html"><![CDATA[<h4 id="1-集成方式"><a href="#1-集成方式" class="headerlink" title="1.集成方式"></a>1.集成方式</h4><p>现有iOS工程中，可以添加<code>flutter_module</code>以集成flutter模块。这些模块会以framework的形式被集成到iOS工程中。同时在集成flutter模块前，需要导入依赖的Flutter engine等。为完成这些工作，Flutter根据不同需求提供了三种方式：</p><p>1.全自动</p><p>CocoaPods管理依赖，这种方式下每次我们build应用时，<code>flutter_module</code>模块中的文件都会被自动编译。这相当于懒人模式，CocoaPods帮我们一键导入，这也是Flutter官方推荐的方式。</p><p>2.全手动</p><p>对于并非每个人都安装了CocoaPods的团队，可以选择在flutter模块中手动执行<code>flutter build ios-framework</code>命令，为Flutter engine、 你的Dart代码、Flutter插件创建framework，集成这些framework到现有工程并手动更新工程配置。</p><p>3.半自动</p><p>手动为你的Dart代码、Flutter插件创建framework，同时将Flutter engine作为podspec，用Cocoapods自动集成到工程中。</p><h4 id="2-创建flutter模块"><a href="#2-创建flutter模块" class="headerlink" title="2.创建flutter模块"></a>2.创建flutter模块</h4><p>首先要切换到现有iOS工程的根目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /Desktop/Hello<br></code></pre></td></tr></table></figure><p>在根目录中创建Flutter模块：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">flutter create --template module flutters  //我这里给flutter模块起名flutters<br></code></pre></td></tr></table></figure><p>执行命令行之后，会在<code>/flutters</code>目录中创建flutter模块的子工程。其目录结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">└── flutters<br>├── .ios/<br>│   ├── Runner<span class="hljs-selector-class">.xcworkspace</span><br>│   └── Flutter/podhelper<span class="hljs-selector-class">.rb</span><br>├── README<span class="hljs-selector-class">.md</span><br>├── analysis_options<span class="hljs-selector-class">.yaml</span><br>├── build<br>│   └── b6b68957fc5ed9202596a46ebc5bde9b<br>├── flutters<span class="hljs-selector-class">.iml</span><br>├── flutters_android<span class="hljs-selector-class">.iml</span><br>├── lib<br>│   ├── login<span class="hljs-selector-class">.dart</span> <span class="hljs-comment">//这是我后期创建的Flutter UI代码</span><br>│   └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.dart</span><br>├── pubspec<span class="hljs-selector-class">.lock</span><br>├── pubspec<span class="hljs-selector-class">.yaml</span><br>└── test<br>    └── widget_test.dart<br></code></pre></td></tr></table></figure><p>其中的<code>/lib</code>目录用于存放我们的Dart代码，例如<code>login.dart</code>就是我后面创建的登录UI。</p><p><code>pubspec.yaml</code>是Flutter用到的依赖，如包和插件。</p><p>有个隐藏的<code>/.ios</code>目录，需解除隐藏后才能看到(快捷键<code>command</code>+<code>shift</code>+<code>.</code>)。这里存放的是与我们编写的Flutter UI对应的iOS工程，它通过脚本把Dart代码编译成<code>framework</code>，并用CocoaPods把我们的 Flutter 模块自动集成到现有iOS工程中。这个目录下的代码是Flutter自动生成的，无需加入Git管理中。在新设备中运行我们的iOS原生工程前，需要先在<code>/flutters</code>目录中执行以下命令，以便重新生成该<code>/.ios</code>目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">flutter pub get<br></code></pre></td></tr></table></figure><h4 id="3-导入framework到iOS工程中"><a href="#3-导入framework到iOS工程中" class="headerlink" title="3.导入framework到iOS工程中"></a>3.导入framework到iOS工程中</h4><p>推荐使用CocoaPods的方式导入，原生项目中Podfile文件的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Pods">//配置flutter模块的路径<br>flutter_application_path = &#x27;./flutters/&#x27;<br>load File.join(flutter_application_path, &#x27;.ios&#x27;, &#x27;Flutter&#x27;, &#x27;podhelper.rb&#x27;)<br><br>target &#x27;Hello&#x27; do<br>  use_frameworks!<br>  #这里是原生工程的依赖库<br>  pod &#x27;RxSwift&#x27;<br>  pod &#x27;RxCocoa&#x27;<br>  pod &#x27;RxAlamofire&#x27;<br><br>  #每个需要集成Flutter的target都需要下面这条<br>  install_all_flutter_pods(flutter_application_path)<br>end<br></code></pre></td></tr></table></figure><p>在原生项目根目录下执行命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pods">pod install`<br></code></pre></td></tr></table></figure><p>这里 podhelper.rb 脚本会把Flutter模块中的插件、Flutter.framework、App.framework 嵌入到我们的原生工程里。其中：</p><ul><li>Flutter.framework 是 Flutter engine 所在的目录；</li><li>App.framework 是 Flutter 子项目编译后的 Dart 代码所在目录；</li></ul><p>注意，通过CocoaPods这种方式集成时，需要本地安装好<code>Flutter SDK</code>。</p><p>如果 pubspec.yaml 中更新了依赖的插件，则需要在Flutter模块的目录<code>/flutters</code>中执行以下代码来更新 podhelper.rb 要用到的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">flutter pub get<br></code></pre></td></tr></table></figure><p>接着在iOS原生项目的根目录下执行一次<code>pod install</code>，同步 Flutter 模块的更新。</p><h4 id="4-创建flutter页面"><a href="#4-创建flutter页面" class="headerlink" title="4.创建flutter页面"></a>4.创建flutter页面</h4><p><code>/lib</code>目录下<code>main.dart</code>是Flutter自动帮我们生成的一个页面，是默认的flutter页面主入口：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;login.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() =&gt; runApp(<span class="hljs-keyword">const</span> MyApp());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> MyApp(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      title: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>      theme: ThemeData(<br>        primarySwatch: Colors.blue,<br>      ),<br>      home: <span class="hljs-keyword">const</span> LoginPage(), <span class="hljs-comment">//展示登录页</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们自定义一个登录页面<code>login.dart</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/services.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> LoginPage(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  _LoginPageState createState() =&gt; _LoginPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_LoginPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">LoginPage</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// 控制器</span><br>  <span class="hljs-keyword">final</span> TextEditingController _usernameController = TextEditingController();<br>  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<br><br>  <span class="hljs-comment">// 原生Swift接口</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> platform = MethodChannel(<span class="hljs-string">&#x27;com.Hello.flutters&#x27;</span>);<br><br>  <span class="hljs-comment">// 登录按钮的回调函数</span><br>  <span class="hljs-keyword">void</span> _handleLogin() <span class="hljs-keyword">async</span> &#123;<br><br>    <span class="hljs-built_in">String</span> username = _usernameController.text;<br>    <span class="hljs-built_in">String</span> password = _passwordController.text;<br>    <span class="hljs-built_in">String</span> response;<br><br>    <span class="hljs-comment">// 调用原生Swift接口</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> result = <span class="hljs-keyword">await</span> platform.invokeMethod(<span class="hljs-string">&#x27;login&#x27;</span>,<br>                                                        &#123;<span class="hljs-string">&#x27;username&#x27;</span>: username,<br>                                                         <span class="hljs-string">&#x27;password&#x27;</span>: password&#125;<br>                                                       );<br>      response = <span class="hljs-string">&#x27;登录成功，欢迎回来，<span class="hljs-subst">$result</span>！&#x27;</span>;<br>    &#125; <span class="hljs-keyword">on</span> PlatformException <span class="hljs-keyword">catch</span> (e) &#123;<br>      response = <span class="hljs-string">&#x27;登录失败：<span class="hljs-subst">$&#123;e.message&#125;</span>&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在控制台中打印响应信息</span><br>    <span class="hljs-built_in">print</span>(response);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回按钮的回调函数 </span><br>  <span class="hljs-keyword">void</span> _handleBack() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      platform.invokeMethod(<span class="hljs-string">&quot;back&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;error: <span class="hljs-subst">$e</span>.message&#x27;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        leading: IconButton(<br>            icon: <span class="hljs-keyword">const</span> Icon(Icons.arrow_back_ios), onPressed: _handleBack),<br>        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;用户登录&#x27;</span>),<br>      ),<br>      body: Padding(<br>        padding: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">16.0</span>),<br>        child: Column(<br>          mainAxisAlignment: MainAxisAlignment.center,<br>          children: [<br>            TextField(<br>              controller: _usernameController,<br>              decoration: <span class="hljs-keyword">const</span> InputDecoration(<br>                hintText: <span class="hljs-string">&#x27;请输入用户名&#x27;</span>,<br>              ),<br>            ),<br>            <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">20.0</span>),<br>            TextField(<br>              controller: _passwordController,<br>              obscureText: <span class="hljs-keyword">true</span>,<br>              decoration: <span class="hljs-keyword">const</span> InputDecoration(<br>                hintText: <span class="hljs-string">&#x27;请输入密码&#x27;</span>,<br>              ),<br>            ),<br>            <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">20.0</span>),<br>            ElevatedButton(<br>              onPressed: _handleLogin,<br>              child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;登录&#x27;</span>),<br>            ),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-集成flutter页面"><a href="#5-集成flutter页面" class="headerlink" title="5.集成flutter页面"></a>5.集成flutter页面</h4><p>集成flutter页面到iOS工程需要<code>FlutterEngine</code>和<code>FlutterViewController</code>。<code>FlutterEngine</code>充当Dart VM和Flutter运行时的主机，<code>FlutterViewController</code>用来向Flutter传递用户输入事件和展示<code>FlutterEngine</code>渲染的画面。</p><h5 id="1-注册FlutterEngine"><a href="#1-注册FlutterEngine" class="headerlink" title="1.注册FlutterEngine"></a>1.注册FlutterEngine</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">import</span> UIKit<br><span class="hljs-keyword">import</span> Flutter<br><span class="hljs-keyword">import</span> FlutterPluginRegistrant<br><br><span class="hljs-keyword">@UIApplicationMain</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppDelegate</span>: <span class="hljs-title class_">FlutterAppDelegate</span> &#123;<br>    <br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> flutterEngine <span class="hljs-operator">=</span> <span class="hljs-type">FlutterEngine</span>(name: <span class="hljs-string">&quot;FlutterInSwift&quot;</span>)<br>   <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">application</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">application</span>: <span class="hljs-type">UIApplication</span>, <span class="hljs-params">didFinishLaunchingWithOptions</span> <span class="hljs-params">launchOptions</span>: [<span class="hljs-type">UIApplication</span>.<span class="hljs-params">LaunchOptionsKey</span>: <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <br>        <span class="hljs-comment">// 注册Flutter引擎</span><br>        flutterEngine.run()<br>        <span class="hljs-type">GeneratedPluginRegistrant</span>.register(with: flutterEngine)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-展示FlutterViewController"><a href="#2-展示FlutterViewController" class="headerlink" title="2.展示FlutterViewController"></a>2.展示FlutterViewController</h5><p>创建Swift页面，提供入口以便跳转到flutter页面：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">import</span> UIKit<br><span class="hljs-keyword">import</span> Flutter<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DKFlutterInSwiftController</span>: <span class="hljs-title class_">UIViewController</span> &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        <br>        <span class="hljs-keyword">let</span> button <span class="hljs-operator">=</span> <span class="hljs-type">UIButton</span>.<span class="hljs-keyword">init</span>(type: .custom)<br>        button.setTitle(<span class="hljs-string">&quot;Click to flutter page&quot;</span>, for: .normal)<br>        button.setTitleColor(<span class="hljs-type">UIColor</span>.white, for: .normal)<br>        button.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>.systemBlue<br>        button.layer.cornerRadius <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br>        button.addTarget(<span class="hljs-keyword">self</span>, action: <span class="hljs-keyword">#selector</span>(handleClick), for: .touchUpInside)<br>        button.sizeToFit()<br>        view.addSubview(button)<br>        view.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>.white<br>        <br>        <span class="hljs-keyword">let</span> width:<span class="hljs-type">CGFloat</span>  <span class="hljs-operator">=</span> button.frame.size.width<span class="hljs-operator">+</span><span class="hljs-number">20</span><br>        <span class="hljs-keyword">let</span> height:<span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">45.0</span><br>        <span class="hljs-keyword">let</span> frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>.<span class="hljs-keyword">init</span>(x: (view.frame.size.width <span class="hljs-operator">-</span> width) <span class="hljs-operator">/</span> <span class="hljs-number">2.0</span>, y: (view.frame.size.height <span class="hljs-operator">-</span> height) <span class="hljs-operator">/</span> <span class="hljs-number">2.0</span>, width: width, height: height)<br>        button.frame <span class="hljs-operator">=</span> frame<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewWillAppear</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">animated</span>: <span class="hljs-type">Bool</span>) &#123;<br>        <span class="hljs-keyword">super</span>.viewWillAppear(animated)<br>        navigationController<span class="hljs-operator">?</span>.setNavigationBarHidden(<span class="hljs-literal">false</span>, animated: <span class="hljs-literal">true</span>)<br>    &#125;<br>        <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">handleClick</span>()&#123;<br>        <span class="hljs-comment">//跳转Flutter页面</span><br>        <span class="hljs-keyword">let</span> flutterEngine <span class="hljs-operator">=</span> (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as!</span> <span class="hljs-type">AppDelegate</span>).flutterEngine<br>        <span class="hljs-keyword">let</span> flutterController <span class="hljs-operator">=</span> <span class="hljs-type">FlutterViewController</span>(engine: flutterEngine, nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)<br>        navigationController<span class="hljs-operator">?</span>.setNavigationBarHidden(<span class="hljs-literal">true</span>, animated: <span class="hljs-literal">true</span>)<br>        navigationController<span class="hljs-operator">?</span>.pushViewController(flutterController, animated: <span class="hljs-literal">true</span>)<br><br>        <span class="hljs-comment">//Swift与Flutter通信</span><br>        <span class="hljs-keyword">let</span> channel <span class="hljs-operator">=</span> <span class="hljs-type">FlutterMethodChannel</span>(name: <span class="hljs-string">&quot;com.Hello.flutters&quot;</span>, binaryMessenger: flutterController <span class="hljs-keyword">as!</span> <span class="hljs-type">FlutterBinaryMessenger</span>)<br>        channel.setMethodCallHandler &#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (call:<span class="hljs-type">FlutterMethodCall</span>, result:<span class="hljs-keyword">@escaping</span> <span class="hljs-type">FlutterResult</span>) <span class="hljs-keyword">in</span><br>           <span class="hljs-comment">//登录返回</span><br>           <span class="hljs-keyword">if</span> (call.method <span class="hljs-operator">==</span> <span class="hljs-string">&quot;back&quot;</span>) &#123;<br>               <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.navigationController<span class="hljs-operator">?</span>.popViewController(animated: <span class="hljs-literal">true</span>)<br>           &#125;<br>           <span class="hljs-comment">//登录</span><br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (call.method <span class="hljs-operator">==</span> <span class="hljs-string">&quot;login&quot;</span>) &#123;<br>               result(<span class="hljs-string">&quot;This is a response from Swift&quot;</span>);<br>           &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Swift页面中放置了一个按钮，点击后会跳转到flutter页面。具体是哪个flutter页面呢？这是由Dart的主入口函数决定的。<code>FlutterEngine</code>默认会加载flutter模块下 lib&#x2F;main.dart 文件中的主入口<code>main()</code>函数。前面的flutter模块代码中，我们在<code>main.dart</code>中显示的是一个自定义的登录页面<code>login.dart</code>。因此，<code>FlutterViewController</code>最终展示的就是这个登录页面。</p><p>至此，我们已经将flutter模块中的登录页面集成到iOS工程中了~</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutterinios_login.gif" alt="flutter登录页"></p><h4 id="6-修改启动配置"><a href="#6-修改启动配置" class="headerlink" title="6.修改启动配置"></a>6.修改启动配置</h4><p>上面集成flutter页面时使用的是默认的启动配置，即加载<code>main()</code>入口，展示其<code>home</code>：登录页。</p><p>有时我们需要自定义Dart入口，或者加载<code>home</code>以外的其他flutter页面。这时我们就需要修改对应的启动配置。</p><h5 id="1-修改入口"><a href="#1-修改入口" class="headerlink" title="1.修改入口"></a>1.修改入口</h5><p>使用<code>lib/main.dart</code>文件中<code>main()</code>以外的函数作为主入口时，需要对此函数做特殊标记：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Dart"><span class="hljs-comment">//当前在main2.dart文件中</span><br><br><span class="hljs-meta">@pragma</span>(<span class="hljs-string">&#x27;vm:entry-point&#x27;</span>)<br><span class="hljs-keyword">void</span> myNewEntry() &#123; ... &#125;;<br></code></pre></td></tr></table></figure><h5 id="2-重新指定入口"><a href="#2-重新指定入口" class="headerlink" title="2.重新指定入口"></a>2.重新指定入口</h5><p>默认情况下，我们使用<code>flutterEngine.run()</code>来加载默认入口函数<code>main()</code>。标记并修改入口函数后，我们可以在Swift中使用<code>run(withEntrypoint:)</code>来重新指定入口：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift">flutterEngine.run(withEntrypoint: <span class="hljs-string">&quot;myNewEntry&quot;</span>, libraryURI: <span class="hljs-string">&quot;main2.dart&quot;</span>)<br></code></pre></td></tr></table></figure><p>这样最终展示的就是<code>myNewEntry</code>函数中设置的根路由页面了。</p><h5 id="3-修改默认路由"><a href="#3-修改默认路由" class="headerlink" title="3.修改默认路由"></a>3.修改默认路由</h5><p>Dart中除了根路由外还有其他页面，可以给这些页面命名并注册到路由表中，以便通过名字直接加载这些页面。我们在iOS工程中展示的flutter页面肯定也不止一个，使用命名路由可以方便我们指定需要跳转的页面。</p><p>下面我们再自定义一个flutter页面：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WelcomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> WelcomePage(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        leading: IconButton(<br>            icon: <span class="hljs-keyword">const</span> Icon(Icons.arrow_back_ios), onPressed: () &#123;&#125;),<br>        title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;新路由&#x27;</span>),<br>      ),<br>      body: <span class="hljs-keyword">const</span> Center(<br>        child: Text(<br>          <span class="hljs-string">&quot;欢迎~&quot;</span>,<br>          style: TextStyle(<br>              fontSize: <span class="hljs-number">25</span>, fontWeight: FontWeight.bold, color: Colors.blue),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这只是一个简单的欢迎页面，接下来我们修改<code>main()</code>中的路由配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;login.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;welcome.dart&#x27;</span>;<br><br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>() =&gt; <span class="hljs-title function_">runApp</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyApp</span>());<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyApp</span>(&#123;<span class="hljs-title class_">Key</span>? key&#125;) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);<br><br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MaterialApp</span>(<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Flutter Demo&#x27;</span>,<br>        <span class="hljs-attr">theme</span>: <span class="hljs-title class_">ThemeData</span>(<br>          <span class="hljs-attr">primarySwatch</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span>,<br>        ),<br>        <span class="hljs-attr">initialRoute</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>        <span class="hljs-comment">//注册路由表</span><br>        <span class="hljs-attr">routes</span>: &#123;<br>          <span class="hljs-string">&quot;/&quot;</span>: <span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">LoginPage</span>(), <span class="hljs-comment">//注册首页路由</span><br>          <span class="hljs-string">&quot;welcome&quot;</span>: <span class="hljs-function">(<span class="hljs-params">context</span>) =&gt;</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">WelcomePage</span>(),<br>        &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就可以通过名字<code>welcome</code>来加载这个flutter欢迎页了。</p><p>第一是种修改<code>FlutterEngine</code>的<code>run</code>方法；</p><p>第二是种修改<code>FlutterViewController</code>的初始化方法。</p><p>二者选其一即可，比如：</p><h6 id="3-1-修改FlutterEngine"><a href="#3-1-修改FlutterEngine" class="headerlink" title="3.1.修改FlutterEngine"></a>3.1.修改FlutterEngine</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">import</span> Flutter<br><span class="hljs-keyword">import</span> FlutterPluginRegistrant<br><br><span class="hljs-keyword">@UIApplicationMain</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppDelegate</span>: <span class="hljs-title class_">FlutterAppDelegate</span> &#123;<br>    <br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> flutterEngine <span class="hljs-operator">=</span> <span class="hljs-type">FlutterEngine</span>(name: <span class="hljs-string">&quot;FlutterInSwift&quot;</span>)<br>   <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">application</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">application</span>: <span class="hljs-type">UIApplication</span>, <span class="hljs-params">didFinishLaunchingWithOptions</span> <span class="hljs-params">launchOptions</span>: [<span class="hljs-type">UIApplication</span>.<span class="hljs-params">LaunchOptionsKey</span>: <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <br>        <span class="hljs-comment">// 给Flutter引擎指定路由名</span><br>        flutterEngine.run(withEntrypoint: <span class="hljs-string">&quot;main&quot;</span>, initialRoute: <span class="hljs-string">&quot;welcome&quot;</span>)<br>        <span class="hljs-comment">//这里&quot;main&quot;是Dart主入口，&quot;welcome&quot;是flutter页面名</span><br>        <span class="hljs-type">GeneratedPluginRegistrant</span>.register(with: flutterEngine)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是修改了FlutterEngine的<code>run</code>方法，<code>FlutterViewController</code>处不做修改。</p><h6 id="3-2-修改FlutterViewController"><a href="#3-2-修改FlutterViewController" class="headerlink" title="3.2.修改FlutterViewController"></a>3.2.修改FlutterViewController</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">handleClick</span>()&#123;<br>    <span class="hljs-comment">//跳转Flutter页面</span><br>    <span class="hljs-keyword">let</span> flutterController <span class="hljs-operator">=</span> <span class="hljs-type">FlutterViewController</span>(<br>            project: <span class="hljs-literal">nil</span>, initialRoute: <span class="hljs-string">&quot;welcome&quot;</span>, nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)<br>    navigationController<span class="hljs-operator">?</span>.setNavigationBarHidden(<span class="hljs-literal">true</span>, animated: <span class="hljs-literal">true</span>)<br>    navigationController<span class="hljs-operator">?</span>.pushViewController(flutterController, animated: <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是给FlutterViewController指定加载名字为<code>welcome</code>的flutter页面。AppDelegate的FlutterEngine处不作修改。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutterinios_welcome.gif" alt="flutter欢迎页"></p><p>以上就是在iOS工程中集成flutter页面的思路总结。完结撒花~</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter attach</title>
    <link href="/2023/03/29/flutter-attach.html"/>
    <url>/2023/03/29/flutter-attach.html</url>
    
    <content type="html"><![CDATA[<h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h4><p><code>hot-reload</code>，热重载，允许开发者在应用运行时更改源代码，并实时观看效果。目前<code>SwiftUI</code>与<code>Flutter</code>都具备热重载的能力，开发阶段调试UI的效率极高。在原生iOS应用中混编<code>flutter</code>模块时，原生部分(非SwiftUI的)在修改后还是需要通过重新<code>Run</code>来查看效果，而其中的 Flutter 部分则是可以基于<code>flutter attach</code>实现热重载的，本文就简单的做一次配置记录。</p><h4 id="2-配置Info-plist"><a href="#2-配置Info-plist" class="headerlink" title="2.配置Info.plist"></a>2.配置Info.plist</h4><p>On iOS 14 and higher, enable the Dart multicast DNS service in the Debug version of your app to add <a href="https://docs.flutter.dev/development/add-to-app/debugging">debugging functionalities such as hot-reload and DevTools</a> via flutter attach.</p><p>配置本地网络使用权限：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&lt;key&gt;NSBonjourServices&lt;/key&gt;<br>        &lt;array&gt;<br>            &lt;string&gt;_dartobservatory._tcp&lt;/string&gt;<br>        &lt;/array&gt;<br>    &lt;key&gt;NSLocalNetworkUsageDescription&lt;/key&gt;<br>    &lt;string&gt;需要访问本地网络权限&lt;/string&gt;<br></code></pre></td></tr></table></figure><p>上架前须删掉以上配置，否则审核会被拒。</p><p>为方便起见，可配置两份<code>Info.plist</code>，只在开发环境中保留上述配置。</p><p><strong>配置步骤：</strong></p><ol><li><p>复制Info.plist文件并分别重命名为<code>Info-dubug.plist</code>和<code>Info-release.plist</code>；</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_attach_2list.png" alt="复制plist"></p></li><li><p>在<code>Info-dubug.plist</code>中加入上述配置，<code>Info-release.plist</code>保持原样不变：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_attach_Info-dubug.png" alt="debug配置"></p></li><li><p><strong>TARGET-&gt;Build Settings</strong> 中搜索<code>INFOPLIST_FILE</code>，配置如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_attach_infoplist.png" alt="区分环境"></p></li><li><p><strong>Build Settings -&gt; Build Phases -&gt; Copy Bundle Resources</strong>中移除多余的plist资源；</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_attach_copybundleres.png" alt="移除多余plist"></p></li></ol><h4 id="3-Run原生应用"><a href="#3-Run原生应用" class="headerlink" title="3.Run原生应用"></a>3.Run原生应用</h4><p>运行原生应用并跳转到 flutter 所在模块，以便后面观看热重载后的效果。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_flutter_attach_reload_demo.png" alt="原生中的flutter模块"></p><h4 id="4-flutter-attach"><a href="#4-flutter-attach" class="headerlink" title="4.flutter attach"></a>4.flutter attach</h4><p>打开终端，cd到原生项目的flutter模块所在根目录，我的是<code>flutters</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── Hello<br>│   ├── Hello<br>│   │   ├── Assets.xcassets<br>│   │   ├── Base.lproj<br>│   ├── Hello.xcodeproj<br>│   │   ├── project.xcworkspace<br>│   ├── Hello.xcworkspace<br>│   │   ├── xcshareddata<br>│   ├── Pods<br>│   │   ├── RxSwift<br>│   └── flutters<br>│       ├── build<br>│       ├── lib<br>│       └── <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>在<code>Hello/flutters</code>目录下执行<code>flutter attach</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">% flutter attach<br><br>Syncing files to device 12...                                      36.2s<br><br>Flutter run key commands.<br>r Hot reload. 🔥🔥🔥<br>R Hot restart.<br>h List all available interactive commands.<br>d Detach (terminate <span class="hljs-string">&quot;flutter run&quot;</span> but leave application running).<br>c Clear the screen<br>q Quit (terminate the application on the device).<br><br>💪 Running with sound null safety 💪<br></code></pre></td></tr></table></figure><p>之后就可以修改 flutter 模块中的代码了，记得保存；</p><p>第一次修改完之后，终端里输入<code>R</code> - Hot restart 页面查看效果;</p><p>之后再修改时，输入<code>r</code> - Hot reload 即可查看效果；</p><h4 id="5-注意事项："><a href="#5-注意事项：" class="headerlink" title="5.注意事项："></a>5.注意事项：</h4><p>经测试，APP运行时，第一次修改完Flutter模块后，须在终端输入<code>R</code>重启才能查看修改效果，输入小写的<code>r</code>时页面会报错。经过第一次的<code>R</code>重启后，再修改Flutter模块，直接<code>r</code>就能正常热加载了。</p><p>Run了应用并且执行<code>flutter attach</code>之后，如果关闭了应用，则终端里会提示”Lost connection to device”，如果再想看Flutter模块修改后的效果，则要重新执行<code>Run</code>-&gt;<code>flutter attach</code>-&gt;<code>R</code>-&gt;<code>r</code>这一流程。</p><hr><p>相关参考：</p><p>#<a href="https://docs.flutter.dev/development/add-to-app/ios/project-setup#local-network-privacy-permissions">©Apple-Add Flutter to existing app</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dart空安全?</title>
    <link href="/2022/09/05/nullsafety.html"/>
    <url>/2022/09/05/nullsafety.html</url>
    
    <content type="html"><![CDATA[<h4 id="1-空安全"><a href="#1-空安全" class="headerlink" title="1.空安全"></a>1.空安全</h4><p>最近打开很早之前的Flutter工程，发现大面积报错，无法运行。看了下报错信息，很多都是说变量不能为空，构造函数中命名参数不能为空。一番搜索之后，发现是Dart2.1.2和Flutter2.0版本开始推出一个重大更新：支持<code>null safety</code>了，这是一个与Swift中<code>optional</code>类似的<code>空安全</code>特性。它是编译阶段对属性、参数、返回值等可能为空<code>null</code>的类型的特殊处理。</p><h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h4><p>在空安全机制下：</p><ul><li><strong>默认所有类型都是非空的</strong>；</li><li>除非你明确指出变量可以为空，否则它就不能是null；</li><li>一旦非空变量为null，编译器即会报错；</li></ul><p>例如，在没有空安全机制之前，我们写代码通常是这样：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 没有 null safety 机制前：</span><br><span class="hljs-built_in">bool</span> is<span class="hljs-constructor">Empty(String <span class="hljs-params">string</span>)</span> =&gt; <span class="hljs-built_in">string</span>.length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>;<br><br>main<span class="hljs-literal">()</span> &#123;<br>  is<span class="hljs-constructor">Empty(<span class="hljs-params">null</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在编译时不会报错，但运行起来后就会在<code>string.length</code>处报错<code>NoSuchMethodError</code>，因为我们传递给<code>isEmpty()</code>方法的是个null，而null没有<code>length</code>方法。</p><p>在支持空安全之后，编译器会在调用<code>isEmpty(null)</code>时明确告诉你<code>The argument type &#39;Null&#39; can&#39;t be assigned to the parameter type &#39;String&#39;</code>，即string参数声明为<code>String</code>类型，不能接收为<code>null</code>的参数。这样利用空安全机制，我们就能提前发现并改正传值为<code>null</code>的情况。</p><h4 id="3-用法"><a href="#3-用法" class="headerlink" title="3.用法"></a>3.用法</h4><h5 id="3-1"><a href="#3-1" class="headerlink" title="3.1.?"></a>3.1.?</h5><p>与Swift一样，声明变量时，如果此变量可以为空，在类型后面加<code>?</code>号：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span>? b = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>同理，参数或返回值可以为null时，也是在类型前加<code>?</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NullableIdx</span>&#123;<br>  <br>  int? idxText;<br>  <br>  <span class="hljs-comment">//工厂方法</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title class_">NullableIdx</span>? <span class="hljs-title function_">setParam</span>(<span class="hljs-params">&#123;int? idxText&#125;</span>)&#123;<br>    <span class="hljs-keyword">if</span> (idxText == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//可能返回空对象</span><br>    &#125;<br>    <span class="hljs-title class_">NullableIdx</span> obj = <span class="hljs-title class_">NullableIdx</span>();<br>    obj.<span class="hljs-property">idxText</span> = idxText;<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;<br>  <br>  <span class="hljs-comment">//返回值可能为空</span><br>  int? <span class="hljs-title function_">retIdx</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (idxText == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">idxText</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">NullableIdx</span>? obj = <span class="hljs-title class_">NullableIdx</span>.<span class="hljs-title function_">setParam</span>(<span class="hljs-attr">idxText</span>:<span class="hljs-literal">null</span>);<br>  <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;$&#123;obj?.retIdx()&#125;&#x27;</span>); <span class="hljs-comment">//调用可空对象的方法时加?</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的示例中还展示了另一个用法，即调用可空对象的方法<code>obj?.retIdx()</code>时，也需要对象后加<code>?</code>，与Swift中的可选链类似。</p><h5 id="3-2"><a href="#3-2" class="headerlink" title="3.2.!"></a>3.2.!</h5><p>如果你确定一个变量、参数或返回值不为空，则使用<code>!</code>取其值，有点类似Swift中可选值的强制拆包：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">int?</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">int?</span> retIdx(<span class="hljs-built_in">String?</span> idxText) &#123;<br>  <span class="hljs-keyword">if</span> (idxText == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>.parse(idxText);<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;a!&#125;</span>&#x27;</span>);            <span class="hljs-comment">//强制拆包</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;retIdx(<span class="hljs-string">&#x27;5&#x27;</span>)!&#125;</span>&#x27;</span>);  <span class="hljs-comment">//强制拆包</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;retIdx(<span class="hljs-string">&#x27;xx&#x27;</span>)!&#125;</span>&#x27;</span>); <span class="hljs-comment">//闪退</span><br>&#125;<br></code></pre></td></tr></table></figure><p>被<code>!</code>标记为的值如果为<code>null</code>，则会直接闪退。</p><h5 id="3-3-late"><a href="#3-3-late" class="headerlink" title="3.3.late"></a>3.3.late</h5><p>在声明变量时，如果你确定它不能为空，但是又不想在声明时初始化它，你可以将其标注为<code>late</code>，告诉编译器：“稍后在使用这个变量前，我保证会先将其初始化”。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtData</span> </span>&#123;<br>  <span class="hljs-built_in">int?</span> noSymptom;<br>  <span class="hljs-keyword">late</span> <span class="hljs-built_in">int</span> allNum;<br><br>  <span class="hljs-comment">// 构造函数</span><br>  ExtData(&#123;<span class="hljs-keyword">this</span>.noSymptom&#125;)&#123;<br>    <span class="hljs-comment">//1.构造函数内初始化late变量</span><br>    allNum = <span class="hljs-number">2</span>; <span class="hljs-comment">// 这里不初始化被标记为late的allNum时，运行时访问此变量会闪退</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  ExtData data = ExtData();<br>  <span class="hljs-comment">//2.访问late变量之前初始化</span><br>  data.allNum = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;data.allNum&#125;</span>&#x27;</span>); <span class="hljs-comment">//访问late变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果你不遵守自己的保证，在访问<code>late</code>变量之前没有将其初始化，会直接闪退。</p><h5 id="3-4-required"><a href="#3-4-required" class="headerlink" title="3.4.required"></a>3.4.required</h5><p>构造函数中，如果命名参数参数不能为空，则你可通过两种方式显示的告诉编译器：</p><ul><li>在命名参数前加<code>required</code>关键字；</li><li>给参数提供一个默认值；</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtData</span> </span>&#123;<br>  <span class="hljs-built_in">int?</span> noSymptom;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> incrNoSymptom; <br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> defaultInt; <br><br>  <span class="hljs-comment">// 构造函数</span><br>  ExtData(<span class="hljs-keyword">this</span>.noSymptom, <span class="hljs-comment">//未命名参数</span><br>         &#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.incrNoSymptom, <span class="hljs-comment">//命名参数</span><br>         <span class="hljs-keyword">this</span>.defaultInt = <span class="hljs-number">2</span>&#125;); <span class="hljs-comment">//命名参数 给默认值</span><br>&#125;<br><br><span class="hljs-keyword">void</span> main()&#123;<br>  ExtData data = ExtData(<span class="hljs-number">0</span>,incrNoSymptom:<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;data.incrNoSymptom&#125;</span>,<span class="hljs-subst">$&#123;data.defaultInt&#125;</span>&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<code>required</code>只能加在函数命名参数的类型之前。</p><h5 id="3-4"><a href="#3-4" class="headerlink" title="3.4.??"></a>3.4.??</h5><p><code>??</code>是空或运算符，与Swift中的一样，表示如果变量为空，则给其一个默认值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span>? a = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">int</span> b = a ?? <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  print(<span class="hljs-string">&#x27;$b&#x27;</span>); <span class="hljs-comment">//1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-迁移到空安全"><a href="#4-迁移到空安全" class="headerlink" title="4.迁移到空安全"></a>4.迁移到空安全</h4><p>Dart2.1.2之前的代码迁移到2.1.2之后，默认使用<code>null safety</code>特性，编译器会报很多错误，很多都是提示你变量未初始化，或者构造函数中命名参数不能为空。所以，你需要将代码进行迁移。迁移最好是按照顺序进行：</p><ol><li>将依赖库先迁移到空安全版本；</li><li>将自己的代码迁移到空安全版；</li><li>对自己的代码进行静态分析；</li><li>测试迁移后的代码已经生效；</li><li>如果是你自己的package，发布最新代码到pub.dev上；</li></ol><h5 id="4-1-迁移依赖库"><a href="#4-1-迁移依赖库" class="headerlink" title="4.1.迁移依赖库"></a>4.1.迁移依赖库</h5><p>1.首先确认本机Dart版本，至少要更新到2.1.2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">% dart <span class="hljs-comment">--version</span><br>Dart SDK <span class="hljs-built_in">version</span>: <span class="hljs-number">2.17</span><span class="hljs-number">.6</span><br></code></pre></td></tr></table></figure><p>2.CD到工程目录下，查看依赖库目前是否支持空安全。</p><p>输出结果中标记为绿色的即为支持<code>null safety</code>的版本。(博客里看不出来颜色，需要到终端里看~)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">% dart pub outdated <span class="hljs-attribute">--mode</span>=<span class="hljs-literal">null</span>-safety<br>Showing dependencies that are currently <span class="hljs-keyword">not</span> opted <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> null-safety.<br>[✗] indicates versions without <span class="hljs-literal">null</span> safety support.<br>[✓] indicates versions opting <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> <span class="hljs-literal">null</span> safety.<br><br>Package Name            Current          Upgradable  Resolvable    Latest        <br><br>direct dependencies:   <br>amap_location_fluttify  ✗0.12.0          ✗0.12.0     ✓0.22.0-rc.0  ✓0.22.0-rc.0  <br>charts_flutter          ✗0.9.0           ✗0.9.0      ✓0.12.0       ✓0.12.0       <br>cupertino_icons         ✗0.1.3           ✗0.1.3      ✓1.0.5        ✓1.0.5        <br>dio                     ✗3.0.9           ✗3.0.10     ✓4.0.6        ✓4.0.6        <br>english_words           ✗3.1.5           ✗3.1.5      ✓4.0.0        ✓4.0.0        <br>http                    ✗0.11.3+17       ✗0.11.3+17  ✓0.13.5       ✓0.13.5       <br>path_provider           ✗1.6.9           ✗1.6.28     ✓2.0.11       ✓2.0.11       <br>permission_handler      ✗5.0.0+hotfix.6  ✗5.1.0+2    ✓10.0.0       ✓10.0.0       <br>pull_to_refresh         ✗1.5.8           ✗1.6.5      ✓2.0.0        ✓2.0.0        <br>sqflite                 ✗1.3.0+1         ✗1.3.2+4    ✓2.0.3+1      ✓2.0.3+1      <br>webview_flutter         ✗0.3.22+1        ✗0.3.24     ✓3.0.4        ✓3.0.4        <br><br>6 upgradable dependencies are locked (<span class="hljs-keyword">in</span> pubspec.lock) <span class="hljs-keyword">to</span> older versions.<br><span class="hljs-keyword">To</span> update these dependencies, use `dart pub upgrade`.<br><br>11  dependencies are constrained <span class="hljs-keyword">to</span> versions that are older than a resolvable version.<br><span class="hljs-keyword">To</span> update these dependencies, <span class="hljs-built_in">edit</span> pubspec.yaml, <span class="hljs-keyword">or</span> <span class="hljs-built_in">run</span> `dart pub<span class="hljs-built_in"> upgrade </span>--null-safety`.<br></code></pre></td></tr></table></figure><p>3.更新各依赖库的版本号，以便支持<code>null safety</code>：</p><p>命令执行完成后，项目里<code>pubspec.yaml</code>文件中各依赖库的版本号会被自动修改到支持<code>null safety</code>版。</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"><span class="hljs-comment">% dart pub upgrade --null-safety</span><br></code></pre></td></tr></table></figure><p>4.更新依赖库的代码：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">% dart pub <span class="hljs-keyword">get</span><br></code></pre></td></tr></table></figure><p>5.更新完成后，检查一下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">% dart pub outdated <span class="hljs-comment">--mode=null-safety</span><br>Showing dependencies that are currently <span class="hljs-keyword">not</span> opted <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">null</span>-safety.<br>[✗] indicates versions <span class="hljs-keyword">without</span> <span class="hljs-keyword">null</span> safety support.<br>[✓] indicates versions opting <span class="hljs-keyword">in</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">null</span> safety.<br><br><span class="hljs-keyword">All</span> your dependencies <span class="hljs-keyword">declare</span> support <span class="hljs-keyword">for</span> <span class="hljs-keyword">null</span>-safety.<br></code></pre></td></tr></table></figure><p>这样，所有的依赖库就全部更新到<code>null safety</code>版本了，接下来就是迁移自己的代码了~</p><h5 id="4-2-自动迁移代码"><a href="#4-2-自动迁移代码" class="headerlink" title="4.2.自动迁移代码"></a>4.2.自动迁移代码</h5><p>Dart提供了两种方式迁移你自己的代码：</p><ul><li>使用迁移工具；</li><li>手动迁移；</li></ul><p>1.推荐使用迁移工具，它会帮你检测需要迁移的代码，并提供迁移建议，你可以通过添加<code>hint markers</code>控制迁移工具的转换。</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"><span class="hljs-comment">% dart migrate</span><br></code></pre></td></tr></table></figure><p>2.一轮查询之后，Dart会生成一个<code>http://127.0.0.1</code>开头的链接：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">% dart migrate<br>Migrating /Users/davidli/Desktop/flutter_demo<br><br>See https://dart.dev/go/<span class="hljs-keyword">null</span>-safety-migration <span class="hljs-keyword">for</span> a migration guide.<br><br>Analyzing project...<br>[<span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------/]No analysis issues found.</span><br><br>Generating migration suggestions...<br>[<span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------]</span><br><br>Compiling instrumentation information...<br>[<span class="hljs-comment">---------------------------------------------------------------------------------------------------------------------]</span><br><br><span class="hljs-keyword">View</span> the migration suggestions by visiting:<br><br>  http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">57135</span>/Users/davidli/Desktop/flutter_demo?authToken=LV4lkFuY10w%<span class="hljs-number">3</span>D<br><br><span class="hljs-keyword">Use</span> this interactive web <span class="hljs-keyword">view</span> <span class="hljs-keyword">to</span> review, improve, <span class="hljs-keyword">or</span> apply the results.<br><span class="hljs-keyword">When</span> finished <span class="hljs-keyword">with</span> the preview, hit ctrl-c <span class="hljs-keyword">to</span> terminate this <span class="hljs-keyword">process</span>.<br><br><span class="hljs-keyword">If</span> you make edits outside <span class="hljs-keyword">of</span> the web <span class="hljs-keyword">view</span> (<span class="hljs-keyword">in</span> your IDE), <span class="hljs-keyword">use</span> the <span class="hljs-symbol">&#x27;Rerun</span> from<br>sources&#x27; action.<br></code></pre></td></tr></table></figure><p>3.用Chrome打开这个链接：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_dart_tools.jpg" alt="迁移工具-Chrome"></p><p>蓝色标注的地方，就是迁移工具推荐的写法。点击其中某一个，右边<code>Edit Details</code>面板中会显示这么改的理由。</p><p>4.点击右上角的<code>APPLY MIGRATION</code>即可将代码迁移到空安全版本。同时，<code>pubspec.yaml</code>配置文件中Dart的版本号也会相应的被自动修改：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">environment</span>:<br>  <span class="hljs-attribute">sdk</span>: &#x27;&gt;=<span class="hljs-number">2</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span> &lt;<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>&#x27;<br></code></pre></td></tr></table></figure><p>5.做一次静态分析，检查代码是否有问题：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"><span class="hljs-comment">% dart analyze</span><br></code></pre></td></tr></table></figure><p>6.最后测试一下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">% </span><span class="language-bash">dart <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><h5 id="4-3-手动迁移代码"><a href="#4-3-手动迁移代码" class="headerlink" title="4.3.手动迁移代码"></a>4.3.手动迁移代码</h5><p>手动迁移代码最好从未依赖其他库的代码先入手，再迁移其他代码，大致顺序如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_null_miragate.jpg" alt="空安全-依赖迁移顺序"></p><p>具体迁移步骤：</p><p>1.修改<code>pubspec.yaml</code>文件：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">environment</span>:<br>  <span class="hljs-attribute">sdk</span>: &#x27;&gt;=<span class="hljs-number">2</span>.<span class="hljs-number">12</span>.<span class="hljs-number">0</span> &lt;<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>&#x27;<br></code></pre></td></tr></table></figure><p>2.更新依赖库，参考上面<code>4.1.迁移依赖库</code>章节。</p><p>3.打开你的工程，会出现大批编译错误，慢慢按照<code>null safety</code>的规则，修改相应的代码，如加<code>?</code>、<code>!</code>、<code>required</code>等。</p><p>4.执行静态分析：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl"><span class="hljs-comment">% dart analyze</span><br></code></pre></td></tr></table></figure><p>5.最后测试一下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">% </span><span class="language-bash">dart <span class="hljs-built_in">test</span></span><br></code></pre></td></tr></table></figure><p>至此，<code>null safety</code>的代码迁移就完成了。根据Dart官网的说法，整个工程和依赖库完全使用<code>空安全</code>后，包体会变小，运行速度也会得到提高。来给你的项目做个迁移吧~</p><hr>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dart语言一览</title>
    <link href="/2022/01/09/dart.html"/>
    <url>/2022/01/09/dart.html</url>
    
    <content type="html"><![CDATA[<h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h3><blockquote><p>Dart is a client-optimized language for fast apps on any platform.</p></blockquote><p><code>Dart</code>是谷歌开发的计算机编程语言，可用于移动应用、网页、服务器等领域。它是一门面向对象的语言，也是强类型的、类定义的、单继承的语言，支持接口、混入(Mixins)、抽象类、泛型、可选类型等。它融合了许多现代编程语言的优秀特性，从中能看到JavaScript、Swift等的影子。</p><h3 id="二-语法、特性"><a href="#二-语法、特性" class="headerlink" title="二.语法、特性"></a>二.语法、特性</h3><p>本篇主要用于记录接触<code>Dart</code>以来我个人比较感兴趣的一些特性和语法，部分内容会与Swift做比较，以便更好的理解其语法特性。Dart提供了一个基于浏览器的<a href="https://dartpad.cn/">DartPad</a>工具以便调试代码，本文所有代码均可在线调试。开讲~</p><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><p>Dart 语言支持以下内建类型：</p><ul><li>num</li><li>String</li><li>Boolean</li><li>List</li><li>Map</li><li>Set</li><li>Rune（表示字符串中的 UTF-32 编码字符）</li><li>Symbol（符号，如根号√￣）</li></ul><p><code>num</code>表示数值型，包括整型<code>int</code>和浮点型<code>double</code>，没有<code>float</code>。其中 int 可转为 double 类型，反之则不行。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">void main() &#123;<br>  var a <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span><span class="hljs-comment">;</span><br>  a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>  <br>  num b <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // 直接使用num</span><br>  b <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span><span class="hljs-comment">;</span><br>  <br>  var c <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>  c <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span><span class="hljs-comment">; //报错：A value of type &#x27;double&#x27; can&#x27;t be assigned to a variable of type &#x27;int&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>num</code>类型与<code>String</code>类型可相互转换：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1.0</span>;<br>  a = <span class="hljs-built_in">double</span>.parse(<span class="hljs-string">&#x27;2.0&#x27;</span>); <span class="hljs-comment">//字符转浮点</span><br>  <span class="hljs-built_in">print</span>(a);<br>  <span class="hljs-keyword">var</span> b = a.toString(); <span class="hljs-comment">//浮点转String</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;+++<span class="hljs-subst">$b</span>, type:<span class="hljs-subst">$&#123;b.runtimeType&#125;</span>&#x27;</span>); <span class="hljs-comment">//输出“+++2, type:String”</span><br>  <br>  <span class="hljs-built_in">int</span> c;<br>  c = <span class="hljs-built_in">int</span>.parse(<span class="hljs-string">&quot;3&quot;</span>);<br>  <span class="hljs-keyword">var</span> d = c.toString();<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;+++c:<span class="hljs-subst">$c</span>,d:<span class="hljs-subst">$d</span>, type:<span class="hljs-subst">$&#123;d.runtimeType&#125;</span>&#x27;</span>); <span class="hljs-comment">//输出&quot;+++c:3,d:3, type:String&quot;</span><br><br>  <span class="hljs-built_in">num</span> e = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">final</span> f = e.toString();  <span class="hljs-comment">//num转字符</span><br>  e = <span class="hljs-built_in">double</span>.parse(<span class="hljs-string">&#x27;5.0&#x27;</span>); <span class="hljs-comment">//字符转num</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;+++f:<span class="hljs-subst">$f</span>,e:<span class="hljs-subst">$e</span>&#x27;</span>); <span class="hljs-comment">//输出&quot;+++f:4,e:5&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Dart 中的集合与 Swift 相似，具备<code>自动推断类型</code>的能力：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>数组<br>var list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>assert(list.length == <span class="hljs-number">3</span>);<br>assert(list[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>);<br><span class="hljs-regexp">//</span>这里 Dart 会推断 list 的类型为 List&lt;int&gt; 。 <br><span class="hljs-regexp">//</span>如果将非整数对象添加到此 List 中， 则会报错。<br>list[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>assert(list[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>);<br><br><br><span class="hljs-regexp">//</span>字典<br><span class="hljs-regexp">//</span>key可以是任何类型-与Swift类似<br>var gifts = &#123;<br>  <span class="hljs-regexp">//</span> Key:    Value<br>  <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;partridge&#x27;</span>,<br>  <span class="hljs-string">&#x27;second&#x27;</span>: <span class="hljs-string">&#x27;turtledoves&#x27;</span>,<br>  <span class="hljs-string">&#x27;fifth&#x27;</span>: <span class="hljs-string">&#x27;golden rings&#x27;</span><br>&#125;; <span class="hljs-regexp">//gi</span>fts 的类型会被推断为 Map&lt;String, String&gt;<br><br>var nobleGases = &#123;<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;helium&#x27;</span>,<br>  <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;neon&#x27;</span>,<br>  <span class="hljs-number">18</span>: <span class="hljs-string">&#x27;argon&#x27;</span>,<br>&#125;; <span class="hljs-regexp">//</span>nobleGases 的类型推断为 Map&lt;int, String&gt;<br></code></pre></td></tr></table></figure><h4 id="2-万物皆对象"><a href="#2-万物皆对象" class="headerlink" title="2.万物皆对象"></a>2.万物皆对象</h4><p>Dart中万物皆对象，所有对象都直接或间接继承自<code>Object</code>类，无论是数字，函数还是 null 都是对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">enum</span> Color &#123;<br>  red,<br>  green,<br>  blue<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">//true</span><br>  <br>  a = <span class="hljs-keyword">null</span>;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;a.runtimeType&#125;</span>, <span class="hljs-subst">$&#123;a <span class="hljs-keyword">is</span> Object&#125;</span>&#x27;</span>); <span class="hljs-comment">//Null, true</span><br>  <br>  <span class="hljs-keyword">var</span> x = Color.blue;<br>  <span class="hljs-built_in">print</span>(x <span class="hljs-keyword">is</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">//true</span><br><br>  <span class="hljs-comment">//未初始化时默认值是null</span><br>  <span class="hljs-built_in">int</span> aInt;<br>  <span class="hljs-built_in">print</span>(aInt); <span class="hljs-comment">//null</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-动态类型"><a href="#3-动态类型" class="headerlink" title="3.动态类型"></a>3.动态类型</h4><p>一般声明变量时都会明确申明变量的类型，或者通过<code>类型推断</code>来自动识别变量的类型：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span>指定为<span class="hljs-keyword">int</span><br>var b = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span>推断为<span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure><p>但如果对象不限定为单个类型，或者暂时不知道是什么类型，则可以指定为<code>对象类型</code>或<code>动态类型</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">enum</span> Color &#123;<br>  red,<br>  green,<br>  blue<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <br>  <span class="hljs-comment">//指定为Object，类似于Swift中的Any或者OC中的id</span><br>  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt; arr;<br>  arr = [<span class="hljs-number">1</span>,<span class="hljs-string">&quot;x&quot;</span>,Color.red];<br>  <span class="hljs-keyword">var</span> x = arr[<span class="hljs-number">2</span>];<br>  <br>  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span>)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$x</span> is int&#x27;</span>);<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">is</span> <span class="hljs-built_in">String</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$x</span> is String&#x27;</span>);<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">is</span> Color) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$x</span> is enum&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 动态类型</span><br>  <span class="hljs-built_in">dynamic</span> name = <span class="hljs-string">&#x27;Bob&#x27;</span>;<br>  name = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以更改类型</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name is:<span class="hljs-subst">$name</span>&#x27;</span>); <span class="hljs-comment">//输出”name is:1“</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-常量"><a href="#4-常量" class="headerlink" title="4.常量"></a>4.常量</h4><h5 id="1-赋值时机"><a href="#1-赋值时机" class="headerlink" title="1.赋值时机"></a>1.赋值时机</h5><p>Dart中声明常量时有两种标识符<code>const</code>与<code>final</code>。</p><ul><li>const修饰编译时常量；</li><li>final可修饰编译时常量或运行时常量；</li></ul><p><code>编译时常量</code>是指常量的值在编译时就已经确定，而<code>运行时常量</code>的值在运行时才确定：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs abnf">class A &#123;  <br>&#125;<br>void main() &#123;<br>  num a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>  final b <span class="hljs-operator">=</span> a.toString()<span class="hljs-comment">;</span><br>  const c <span class="hljs-operator">=</span> a.toString()<span class="hljs-comment">; //报错：Const variables must be initialized with a constant value</span><br><br>  final c <span class="hljs-operator">=</span> A()<span class="hljs-comment">;</span><br>  const d <span class="hljs-operator">=</span> A()<span class="hljs-comment">; // 报错，因为创建A的实例时使用的构造函数在运行时才执行。</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-集合可变性"><a href="#2-集合可变性" class="headerlink" title="2.集合可变性"></a>2.集合可变性</h5><p>集合的可变性是由【其本身的修饰符】和【其字面量的修饰符】共同决定的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 基本类型<br>final name = <span class="hljs-string">&#x27;Bob&#x27;</span>; <span class="hljs-regexp">//</span> Without a type annotation<br>final String nickname = <span class="hljs-string">&#x27;Bobby&#x27;</span>;<br>name = <span class="hljs-string">&#x27;Alice&#x27;</span>; <span class="hljs-regexp">//</span> Error: 一个 final 变量只能被设置一次。<br><br><span class="hljs-regexp">//</span> 集合<br>var constantList = const [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-regexp">//</span> constantList[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 取消注释会引起编译时异常。<br><br>const constantList2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>constantList[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 取消注释会引起编译时异常。<br><br>final constantList2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>constantList2[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> 取消注释不会引起错误。<br><br>var constantList3 = final [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span>报错<br></code></pre></td></tr></table></figure><p>可以这么总结：</p><ul><li>final不能修饰字面量；</li><li>const可定义编译时常量，也可以用来定义不可变字面量；</li><li>final和const常量都只能赋值一次；</li><li>final集合变量不能重新赋值，但集合内的元素可修改；</li><li>const集合或字面量不能重新赋值，集合内元素也不可修改。</li></ul><h5 id="3-用const优化性能"><a href="#3-用const优化性能" class="headerlink" title="3.用const优化性能"></a>3.用const优化性能</h5><p><code>const</code>修饰的两个常量的值相同，则二者指向同一片内存空间：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">// 测试非const</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">Object</span>();<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">Object</span>();<br>  <span class="hljs-comment">//检查两个引用是否指向同一个对象</span><br>  <span class="hljs-built_in">print</span>(identical(a,b)); <span class="hljs-comment">//输出false</span><br>    <br>  <span class="hljs-comment">//测试const</span><br>  <span class="hljs-keyword">const</span> a1 = <span class="hljs-built_in">Object</span>();<br>  <span class="hljs-keyword">const</span> b1 = <span class="hljs-built_in">Object</span>();<br>  <span class="hljs-built_in">print</span>(identical(a1,b1)); <span class="hljs-comment">//输出true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用<code>const</code>创建多个相同的对象时，内存中只会保留一个对象。</p><p>因此，在优化性能时，可以考虑合理使用<code>const</code>关键字这个方法。</p><h4 id="5-函数-amp-可选参数"><a href="#5-函数-amp-可选参数" class="headerlink" title="5.函数&amp;可选参数"></a>5.函数&amp;可选参数</h4><ul><li>胖箭头语法</li></ul><p>如果函数体中只有一行<code>语句</code>或一个<code>表达式</code>时，可以使用<code>=&gt; expr</code>简写语法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 原写法</span><br><span class="hljs-keyword">void</span> printInt(<span class="hljs-built_in">int</span> i) &#123;<br>  <span class="hljs-built_in">print</span>(i); <span class="hljs-comment">// 函数体中只有一行语句</span><br>&#125;<br><span class="hljs-comment">// 胖箭头写法</span><br><span class="hljs-keyword">void</span> printInt1(<span class="hljs-built_in">int</span> i) =&gt; <span class="hljs-built_in">print</span>(i);<br><br><span class="hljs-comment">// 示例0：没返回值的函数</span><br>add0(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b)&#123;<br>  a+b; <span class="hljs-comment">//表达式</span><br>&#125;<br><br><span class="hljs-comment">// 示例1：带返回值的函数</span><br><span class="hljs-built_in">int</span> add1(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>  <span class="hljs-keyword">return</span> a+b; <span class="hljs-comment">//返回值</span><br>&#125;<br><br><span class="hljs-comment">// 示例2：add1的=&gt;写法</span><br><span class="hljs-built_in">int</span> add2(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) =&gt; a+b; <span class="hljs-comment">//=&gt;后为返回值</span><br><br><span class="hljs-comment">// 示例3：add1的=&gt;写法 注意函数前没带返回值类型&quot;int&quot;</span><br>add3(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) =&gt; a+b; <span class="hljs-comment">//=&gt;后为返回值</span><br><br><span class="hljs-comment">// 示例4：&#123;&#125;函数体内只有一个print表达式</span><br>add4() =&gt; (()&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++this is A block+++&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 示例4的胖箭头写法，=&gt;后为print表达式</span><br>add5() =&gt; (() =&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++this is B block+++&quot;</span>));<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">print</span>(add0(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)); <span class="hljs-comment">//null</span><br>  <span class="hljs-built_in">print</span>(add1(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)); <span class="hljs-comment">//1</span><br>  <span class="hljs-built_in">print</span>(add2(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)); <span class="hljs-comment">//1</span><br>  <span class="hljs-built_in">print</span>(add3(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)); <span class="hljs-comment">//1</span><br>  add4()();         <span class="hljs-comment">//++++this is A block+++</span><br>  add5()();         <span class="hljs-comment">//++++this is B block+++</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：<code>add0</code>不能改成胖箭头写法，否则<code>=&gt;</code>会把其后的数值变成返回值，从而改变函数类型。</p><p>也就是说：<code>=&gt; expr</code> !&#x3D; <code>&#123;return expr;&#125;</code></p><p>在箭头<code>=&gt;</code>和分号<code>;</code>之间只能使用一个表达式 ，不能是多语句。</p><ul><li>命名可选参数</li></ul><p>定义函数时，使用花括号 {param1, param2, …} 来指定命名参数；</p><ul><li>位置可选参数</li></ul><p>将参数放到 [] 中来标记参数是可选的；</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> tweet(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b)&#123; <span class="hljs-comment">//未命名参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tweet: JIO JIO JIO~&quot;</span>);<br>  &#125;<br>  <br>  <span class="hljs-built_in">int</span> tweet2(&#123;<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, <span class="hljs-built_in">int</span> c&#125;)&#123; <span class="hljs-comment">//命名可选参数，调用时类似于 swift 的外部参数</span><br>    <span class="hljs-keyword">if</span>(b <span class="hljs-keyword">is</span> <span class="hljs-built_in">Null</span>)&#123;<br>      b = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;tweet2: <span class="hljs-subst">$a</span> + <span class="hljs-subst">$b</span> + <span class="hljs-subst">$c</span> JIO JIO JIO~&quot;</span>);<br>    <span class="hljs-keyword">return</span> a+b;<br>  &#125;<br>  <br>  <span class="hljs-built_in">int</span> tweet3(<span class="hljs-built_in">int</span> a, [<span class="hljs-built_in">int</span> b, <span class="hljs-built_in">int</span> c])&#123; <span class="hljs-comment">//位置可选参数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tweet3: b:<span class="hljs-subst">$b</span>,c:<span class="hljs-subst">$c</span>&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> b = Bird();<br>  b.tweet(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);      <span class="hljs-comment">// 输出：tweet: JIO JIO JIO~</span><br>  b.tweet2(a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>); <span class="hljs-comment">// 输出：tweet2: 1 + 2 + null JIO JIO JIO~</span><br>  b.tweet2(a:<span class="hljs-number">1</span>);      <span class="hljs-comment">// 输出：tweet2: 1 + 0 + null JIO JIO JIO~</span><br>  b.tweet3(<span class="hljs-number">1</span>);        <span class="hljs-comment">// 输出：tweet3: b:null,c:null</span><br>  b.tweet3(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// 输出：tweet3: b:2,c:null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个参数只能选择【命名可选参数】和【位置可选参数】其中一种方式修饰。</p><ul><li>默认参数值</li></ul><p>和Swift一样，定义方法时使用 &#x3D; 来定义可选参数的默认值，默认值只能是编译时常量。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, [<span class="hljs-built_in">int</span> b = <span class="hljs-number">0</span>]</span>)</span> =&gt; a+b;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  print(<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出3</span><br>  print(<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span>));    <span class="hljs-comment">// 输出1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-函数是一等公民"><a href="#6-函数是一等公民" class="headerlink" title="6.函数是一等公民"></a>6.函数是一等公民</h4><p>与Swift一样，Dart中函数也是一等公民，这意味着一个函数可以作为另一个函数的参数。示例1：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printElement</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> element</span>)</span> &#123;<br>  print(element);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  <span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-comment">// 将 printElement 函数名作为参数传递</span><br>  list.forEach(printElement);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以将一个函数赋值给一个变量，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">String</span> <span class="hljs-title function_">printElement</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> element</span>) &#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;$element&#x27;</span>.<span class="hljs-title function_">toUpperCase</span>();<br>  <span class="hljs-title function_">print</span>(x);<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> loudify = printElement;<br>  <span class="hljs-title function_">print</span>(<span class="hljs-title function_">loudify</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) == <span class="hljs-string">&#x27;HELLO&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，Dart中函数作为参数时，会有个<em><strong>小困扰</strong></em>，示例2：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 定义方法</span><br><span class="hljs-built_in">int</span> math<span class="hljs-constructor">Add(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;      <span class="hljs-comment">//相加</span><br>  return a + b;<br>&#125;<br><span class="hljs-built_in">int</span> math<span class="hljs-constructor">Multiple(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123; <span class="hljs-comment">//相乘</span><br>  return a<span class="hljs-operator"> * </span>b;<br>&#125;<br><span class="hljs-built_in">int</span> math<span class="hljs-constructor">Increase(<span class="hljs-params">int</span> <span class="hljs-params">a</span>)</span> &#123;        <span class="hljs-comment">//自增1</span><br>  return ++a;<br>&#125;<br><span class="hljs-comment">// 方法作为参数</span><br><span class="hljs-built_in">int</span> math1(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, Function mathOperation) &#123; <span class="hljs-comment">// 接收2个参数</span><br>  return math<span class="hljs-constructor">Operation(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//调用具体做事的函数</span><br>&#125;<br><span class="hljs-built_in">int</span> math2(<span class="hljs-built_in">int</span> a, Function mathOperation) &#123;        <span class="hljs-comment">//接收1个参数</span><br>  return math<span class="hljs-constructor">Operation(<span class="hljs-params">a</span>)</span>;<br>&#125;<br><span class="hljs-comment">//调用</span><br>main<span class="hljs-literal">()</span> &#123;<br>  <span class="hljs-comment">// 向外层函数传递内层函数作为参数时，直接使用内层函数名</span><br>  print(math1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, mathAdd));<br>  print(math1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, mathMultiple));<br>  print(math2(<span class="hljs-number">1</span>, mathIncrease));<br>&#125;<br></code></pre></td></tr></table></figure><p>示例2中，当方法作为参数（mathOperation）时，Dart只是将mathOperation标注为<code>Function</code>类型：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">math1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, Function mathOperation)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">mathOperation</span><span class="hljs-params">(a, b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但从<code>Function</code>关键字上并看不出mathOperation代表的函数有几个参数，参数分别是什么类型，返回值是啥，这有时很容易让人困惑。相较而言，Swift中将函数作为参数时，会明确标明此函数的类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义作为参数的函数</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">addTwoInts</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> a <span class="hljs-operator">+</span> b<br>&#125;<br><span class="hljs-comment">// 定义作为参数的函数</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">multiplyTwoInts</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> a <span class="hljs-operator">*</span> b<br>&#125;<br><span class="hljs-comment">// 定义使用函数作为参数的函数（明确知道作为参数的函数是什么类型的）</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">printMathResult</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">mathFunction</span>: (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Result: <span class="hljs-subst">\(mathFunction(a, b))</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 调用并传递函数作为参数</span><br>printMathResult(addTwoInts, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// Prints &quot;Result: 8&quot;</span><br></code></pre></td></tr></table></figure><p>这里<code>(Int, Int) -&gt; Int</code>即明确指明了<code>mathFunction</code>参数的函数签名，清楚明了。</p><p>为了解决这个问题，Dart也提供了自己的解决方案：使用<code>Typedefs</code>为函数起一个别名， 别名可以用来声明字段及返回值类型。 当函数类型分配给变量时，typedef会保留类型信息。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">typedef aliasType = <span class="hljs-built_in">int</span> <span class="hljs-constructor">Function(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//给函数定义别名</span><br><br><span class="hljs-comment">// 定义方法</span><br><span class="hljs-built_in">int</span> math<span class="hljs-constructor">Add(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;      <span class="hljs-comment">//相加</span><br>  return a + b;<br>&#125;<br><span class="hljs-built_in">int</span> math<span class="hljs-constructor">Multiple(<span class="hljs-params">int</span> <span class="hljs-params">a</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123; <span class="hljs-comment">//相乘</span><br>  return a<span class="hljs-operator"> * </span>b;<br>&#125;<br><span class="hljs-comment">// 方法作为参数</span><br><span class="hljs-built_in">int</span> math1(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b, aliasType mathOperation) &#123; <span class="hljs-comment">//使用函数别名</span><br>  return math<span class="hljs-constructor">Operation(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//调用具体做事的函数</span><br>&#125;<br><br><span class="hljs-comment">//调用</span><br>main<span class="hljs-literal">()</span> &#123;<br>  print(math1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, mathAdd));<br>  print(math1(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, mathMultiple));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.闭包</h4><p>大部分方法都带有名字，你也可以创建没名字的方法，称之为<code>匿名函数</code>或者<code>闭包</code>。</p><p>匿名函数和命名函数看起来类似— 在括号之间可以定义一些参数或可选参数，参数使用逗号分割。</p><p>后面大括号中的代码为函数体：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">(<span class="hljs-string">[[Type] param1[, …]]</span>) &#123; <br>  codeBlock; <br>&#125;; <br></code></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> loudify = (msg) =&gt; <span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;msg.toUpperCase()&#125;</span>&#x27;</span>; <span class="hljs-comment">// 匿名函数/闭包，赋值给变量</span><br>  <span class="hljs-built_in">print</span>(loudify(<span class="hljs-string">&#x27;hello&#x27;</span>) == <span class="hljs-string">&#x27;HELLO&#x27;</span>); <span class="hljs-comment">//调用闭包，输出true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> list = [<span class="hljs-string">&#x27;apples&#x27;</span>, <span class="hljs-string">&#x27;bananas&#x27;</span>, <span class="hljs-string">&#x27;oranges&#x27;</span>];<br>list.forEach((item) &#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;list.indexOf(item)&#125;</span>: <span class="hljs-subst">$item</span>&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="8-链式-x2F-级联"><a href="#8-链式-x2F-级联" class="headerlink" title="8.链式&#x2F;级联"></a>8.链式&#x2F;级联</h4><p>级联运算符 <code>..</code>可以像RAC一样，实现对同一个对像的一系列链式操作。 除了调用函数，还可以访问同一对象上的字段属性。 </p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 一般情况下的操作</span><br>var <span class="hljs-keyword">button</span> = querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>);<br><span class="hljs-keyword">button</span>.<span class="hljs-keyword">text</span> = <span class="hljs-string">&#x27;Confirm&#x27;</span>;<br><span class="hljs-keyword">button</span>.classes.add(<span class="hljs-string">&#x27;important&#x27;</span>);<br><span class="hljs-keyword">button</span>.onClick.listen((e) =&gt; <span class="hljs-keyword">window</span>.alert(<span class="hljs-string">&#x27;Confirmed!&#x27;</span>));<br></code></pre></td></tr></table></figure><p>使用级联操作符：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">querySelector(<span class="hljs-string">&#x27;#confirm&#x27;</span>) <span class="hljs-comment">// 获取对象。</span><br>  ..<span class="hljs-built_in">text</span> = <span class="hljs-string">&#x27;Confirm&#x27;</span> <span class="hljs-comment">// 调用成员变量。</span><br>  ..classes.add(<span class="hljs-string">&#x27;important&#x27;</span>)<br>  ..onClick.listen(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> window.alert(<span class="hljs-string">&#x27;Confirmed!&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="9-switch的值"><a href="#9-switch的值" class="headerlink" title="9.switch的值"></a>9.switch的值</h4><p><code>switch</code>可比较整数、字符串、枚举。比较的对象必须都是同一个类的实例且类没有重写<code>==</code>。 </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 定义枚举</span><br><span class="hljs-built_in">enum</span> Color&#123;<br>  red,<br>  green,<br>  blue<br>&#125;<br><span class="hljs-comment">// 比较</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">var</span> a = Color.red;<br>  <span class="hljs-keyword">switch</span> (a)&#123;<br>    <span class="hljs-keyword">case</span> Color.red:<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;red&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Color.green:<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;green&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Color.blue:<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;blue&#x27;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;unknown&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 试错</span><br>  <span class="hljs-built_in">var</span> x = <span class="hljs-number">0.1</span>;<br>  <span class="hljs-keyword">switch</span> (x)&#123; <span class="hljs-comment">//报错 The switch case expression type &#x27;double&#x27; can&#x27;t override the == operator</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0.0</span>:<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;0.0&#x27;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0.1</span>:<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;0.1&#x27;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>      <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;default&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-可选链"><a href="#10-可选链" class="headerlink" title="10.可选链"></a>10.可选链</h4><p>与Swift一样，调用方法时使用<code>?.</code>来代替<code>.</code>， 可以避免因为左边对象可能为 null 导致的异常：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Point</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// 如果 p 为 non-null，设置它变量 y 的值为 4。</span><br>p?.y = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h4 id="11-构造函数"><a href="#11-构造函数" class="headerlink" title="11.构造函数"></a>11.构造函数</h4><ul><li>构造函数</li></ul><p>创建一个与类同名的函数来声明构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-built_in">num</span> x, y, z;<br>  <br>  Point(<span class="hljs-built_in">num</span> x, <span class="hljs-built_in">num</span> y) &#123; <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y; <br>    <span class="hljs-comment">//不要求所有成员变量都完成初始化</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;x:<span class="hljs-subst">$x</span>,y:<span class="hljs-subst">$y</span>,z:<span class="hljs-subst">$z</span>&#x27;</span>); <span class="hljs-comment">//x:0,y:1,z:null</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建实例</span><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> p = Point(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用语法糖对上面的构造函数进行简化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;<br>  num x, y, z;<br>  Point(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y); <span class="hljs-comment">// 将传入的参数的值赋值给对应的实例变量</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  <span class="hljs-keyword">var</span> p = Point(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认构造函数</li></ul><p>在【没有声明构造函数的情况下】， Dart 会提供一个默认的构造函数。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> &#123;<br>  num x, y, z;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span> &#123;<br>  <span class="hljs-keyword">var</span> p = Point(); <span class="hljs-comment">//默认构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>【子类不会自动继承父类的构造函数】。如果子类不声明构造函数，那么它就只有默认构造函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 父类</span><br>  num x, y;<br>  <span class="hljs-type">Point</span>(<span class="hljs-keyword">this</span>.x, <span class="hljs-keyword">this</span>.y); <span class="hljs-comment">//自定义构造函数</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 子类</span><br>  num z;<br>  <span class="hljs-comment">// 没有构造函数，所以只有默认构造函数SubPoint()</span><br>&#125;<br>void main() &#123;<br>  <span class="hljs-keyword">var</span> p  = <span class="hljs-type">SubPoint</span>(<span class="hljs-number">1</span>，<span class="hljs-number">2</span>); <span class="hljs-comment">// 报错1，因为子类不会自动继承父类的构造函数，所以这里调用无效</span><br>  <span class="hljs-keyword">var</span> p2 = <span class="hljs-type">SubPoint</span>();    <span class="hljs-comment">// 报错2，因为子类只有默认构造函数，而子类的默认构造函数会调用父类的无参构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例中会出现两处报错：</p><p>报错1是因为子类不会自动继承父类的构造函数，所以也就无法调用父类的构造函数；</p><p>报错2是因为<em><strong>子类的默认构造函数会自动调用父类的无参构造函数</strong></em>，而此时父类中因为提供了自定义构造函数，所以就没有无参构造函数，因此调用失败，所以子类想要调用默认构造参数。父类就不能自定义构造函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 父类</span><br>  num x, y;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 子类</span><br>  num z;<br>&#125;<br>void main() &#123;<br>  <span class="hljs-keyword">var</span> p = <span class="hljs-type">SubPoint</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>命名构造函数</li></ul><p>给构造函数命名，以便更清晰的表明函数的意图，格式为<code>【类名.函数名(参数..)】</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 父类</span><br>  <span class="hljs-built_in">num</span> x, y;<br>  Point.initWithXY(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;called super init,x:<span class="hljs-subst">$x</span>,y:<span class="hljs-subst">$y</span>&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 子类</span><br>  <span class="hljs-built_in">num</span> z;<br>  SubPoint.initWithXYZ(<span class="hljs-built_in">num</span> x, y, <span class="hljs-keyword">this</span>.z): <span class="hljs-keyword">super</span>.initWithXY(x,y)&#123; <span class="hljs-comment">//注意这里调用父类构造函数的语法</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;called sub init,x:<span class="hljs-subst">$x</span>,y:<span class="hljs-subst">$y</span>,z:<span class="hljs-subst">$z</span>&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> p = SubPoint.initWithXYZ(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里调用父类构造函数的语法：【在当前构造函数冒号 (:) 之后，函数体之前，声明调用父类构造函数】。</p><ul><li>常量构造函数</li></ul><p>常量构造函数以<code>const</code>修饰，用于成员变量都是<code>final</code>的的类。</p><p>用常量构造函数实例化多个对象时，若参数相同，则内存中只会保留一个对象，节省内存开销。</p><p>反例1：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">//使用非常量构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> </span>&#123;<br>  <span class="hljs-built_in">double</span> width;<br>  <span class="hljs-built_in">double</span> height;<br>  Box(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.width,<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.height&#125;);<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> a = Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">var</span> b = Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">print</span>(identical(a,b)); <span class="hljs-comment">//检查两个引用是否指向同一个对象，输出false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>正例2：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs DART"><span class="hljs-comment">//使用常量构造函数</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> width; <span class="hljs-comment">//运行时才传入，所以用final修饰，而非const</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">double</span> height;<br>  <span class="hljs-keyword">const</span> Box(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.width,<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.height&#125;); <span class="hljs-comment">// 这就是常量构造函数</span><br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-comment">//写法1</span><br>  Box a1 = <span class="hljs-keyword">const</span>  Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  Box b1 = <span class="hljs-keyword">const</span>  Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">print</span>(identical(a1,b1)); <span class="hljs-comment">//输出true</span><br>  <br>  <span class="hljs-comment">//写法2</span><br>  <span class="hljs-keyword">const</span> a2 = Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> b2 = Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">print</span>(identical(a2,b2)); <span class="hljs-comment">//输出true</span><br>  <br>  <span class="hljs-comment">//反例</span><br>  <span class="hljs-keyword">var</span> a3 = Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">var</span> b3 = Box(width:<span class="hljs-number">1</span>,height:<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">print</span>(identical(a3,b3)); <span class="hljs-comment">//输出false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，正例2中最后一条可以看出，调用常量构造函数创建对象时，如果不用const修饰，则这些对象不是常量实例，内存中会存在多份。</p><p>常量构造函数在<span style="color: yellow; font-weight: bold;">优化Flutter性能</span>时非常有用，因为每次构建组件树时，const修饰的组件只存在一份，并且不参与重新构建。</p><h4 id="12-初始化列表"><a href="#12-初始化列表" class="headerlink" title="12.初始化列表"></a>12.初始化列表</h4><p>与Swift不一样的是，Dart的构造函数中并不强制所有成员变量都完成初始化，那它们什么时候去初始化呢？Dart的解决方案是<code>初始化列表</code>，即在构造函数的方法体花括号<code>&#123;...&#125;</code>之前初始化实例变量【~~比较奇怪的语法~~】。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 父类</span><br>  <span class="hljs-built_in">num</span> x, y;<br>  Point.initWithXY(<span class="hljs-keyword">this</span>.x,<span class="hljs-keyword">this</span>.y)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;called super init,x:<span class="hljs-subst">$x</span>,y:<span class="hljs-subst">$y</span>&#x27;</span>);<br>  &#125;<br>  Point.initFromMap(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>&gt;dic)<br>    : x = dic[<span class="hljs-string">&#x27;x&#x27;</span>],<br>      y = dic[<span class="hljs-string">&#x27;y&#x27;</span>]&#123; <span class="hljs-comment">//初始化列表，初始化当前类的实例变量</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;called super.initFromMap,x:<span class="hljs-subst">$x</span>,y:<span class="hljs-subst">$y</span>&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">// 子类</span><br>  <span class="hljs-built_in">num</span> z;<br>  SubPoint.initList(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">int</span>&gt;dic)<br>    : z = dic[<span class="hljs-string">&#x27;z&#x27;</span>],<br>      <span class="hljs-keyword">super</span>.initFromMap(dic)&#123; <span class="hljs-comment">//调用父类构造函数要放在初始化列表的最后</span><br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>)&#123;<br>          x = <span class="hljs-number">0</span>; <span class="hljs-comment">// 函数体内可以继续修改变量的值</span><br>        &#125;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;called sub.initList,x:<span class="hljs-subst">$x</span>,y:<span class="hljs-subst">$y</span>&#x27;</span>);<br>  &#125;<br>  SubPoint.initWithXYZ(x,y,<span class="hljs-keyword">this</span>.z): <span class="hljs-keyword">super</span>.initWithXY(x,y)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;called sub init,x:<span class="hljs-subst">$x</span>,y:<span class="hljs-subst">$y</span>,z:<span class="hljs-subst">$z</span>&#x27;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-keyword">var</span> dic = &#123;<span class="hljs-string">&#x27;x&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;y&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-number">3</span>&#125;;<br>  <span class="hljs-keyword">var</span> p = SubPoint.initList(dic);<br>&#125;<br></code></pre></td></tr></table></figure><p>各参数的初始化用逗号分隔，且调用父类构造函数的语句要放在初始化列表的最后。</p><h4 id="13-Getter-x2F-Setter"><a href="#13-Getter-x2F-Setter" class="headerlink" title="13.Getter&#x2F;Setter"></a>13.Getter&#x2F;Setter</h4><p>和Swift一样，Dart中属性的Getter&#x2F;Setter也是为<code>计算属性</code>而存在的：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>  num left, top, width, height;<br><br>  <span class="hljs-built_in">Rectangle</span>(<span class="hljs-keyword">this</span>.left, <span class="hljs-keyword">this</span>.top, <span class="hljs-keyword">this</span>.width, <span class="hljs-keyword">this</span>.height);<br><br>  <span class="hljs-comment">// 定义两个计算属性： right 和 bottom。</span><br>  num get right =&gt; left + width;<br>  <span class="hljs-function">set <span class="hljs-title">right</span><span class="hljs-params">(num value)</span> </span>=&gt; left = value - width;<br>  num get bottom =&gt; top + height;<br>  <span class="hljs-function">set <span class="hljs-title">bottom</span><span class="hljs-params">(num value)</span> </span>=&gt; top = value - height;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  var rect = <span class="hljs-built_in">Rectangle</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>);<br>  <span class="hljs-built_in">print</span>(rect.left);    <span class="hljs-comment">//调用Getter 输出“3”</span><br>  rect.right = <span class="hljs-number">12</span>;     <span class="hljs-comment">//调用Setter</span><br>  <span class="hljs-built_in">print</span>(rect.right);   <span class="hljs-comment">//12</span><br>  <span class="hljs-built_in">print</span>(rect.left);    <span class="hljs-comment">//-8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过修改left，从而影响 left + width &#x3D; right，最终完成对right属性的修改。</p><h4 id="14-抽象类-amp-extends"><a href="#14-抽象类-amp-extends" class="headerlink" title="14.抽象类&amp;extends"></a>14.抽象类&amp;extends</h4><p>使用<code>abstract</code>来定义抽象类。抽象类不能被实例化，通常用来定义接口，以及部分实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>  <span class="hljs-comment">// 定义字段...</span><br>  <span class="hljs-keyword">var</span> name;<br>  <span class="hljs-keyword">var</span> hasValue = <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-comment">// 抽象方法。</span><br>  abstractMethod();<br>  <br>  <span class="hljs-comment">// 带实现的方法</span><br>  funcWithImplements()&#123;<br>    print(<span class="hljs-string">&quot;~~~~~~~&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span> </span>&#123; <span class="hljs-comment">// 单继承</span><br>  <span class="hljs-keyword">var</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> hasValue = <span class="hljs-number">2</span>;<br>  <br>  <span class="hljs-meta">@override</span><br>  abstractMethod()&#123; <span class="hljs-comment">// 提供方法实现，所以这里的方法就不是抽象方法了...</span><br>    print(&#x27;++call abstractMethod()&#x27;);<br>  &#125;<br>  <br>  <span class="hljs-meta">@override</span><br>  funcWithImplements()&#123; <span class="hljs-comment">// 重写</span><br>    print(<span class="hljs-string">&quot;~~~call funcWithImplements()&quot;</span>);<br>  &#125;<br>&#125;<br>void main() &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-type">ConcreteClass</span>();<br>  a.abstractMethod();       <span class="hljs-comment">//++call abstractMethod()</span><br>  a.funcWithImplements();   <span class="hljs-comment">//~~~call funcWithImplements()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Dart也和Swift一样，只允许单继承~</p><h4 id="15-接口-amp-implements"><a href="#15-接口-amp-implements" class="headerlink" title="15.接口&amp;implements"></a>15.接口&amp;implements</h4><p>Dart中移除了<code>interface</code>关键字，可以通过抽象类或<code>implements</code>普通类来实现接口的功能。</p><blockquote><p>每个类都隐式的定义了一个接口，接口包含了该类所有的实例成员及其实现的接口。 如果要创建一个 A 类，A 要支持 B 类的 API ，但是不需要继承 B 的实现， 那么可以通过 A 实现 B 的接口。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 抽象类1</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br>  <span class="hljs-comment">// 定义字段...</span><br>  <span class="hljs-keyword">var</span> name;<br>  <span class="hljs-keyword">var</span> hasValue = <span class="hljs-number">1</span>;<br>  <br>  <span class="hljs-comment">// 抽象方法。</span><br>  <span class="hljs-title function_">abstractMethod</span>();<br><br>  <span class="hljs-comment">// 带实现的方法</span><br>  <span class="hljs-title function_">funcWithImplements</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;~~~~~~~&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 抽象类2</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass2</span> &#123;<br>  <span class="hljs-title function_">abstractMethod2</span>();<br>&#125;<br><span class="hljs-comment">// 实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AbstractClass</span>, <span class="hljs-title class_">AbstractClass2</span> &#123; <span class="hljs-comment">//可以实现多个抽象类</span><br>  <span class="hljs-keyword">var</span> name = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> hasValue = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title function_">abstractMethod</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;++call abstractMethod()&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title function_">abstractMethod2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&#x27;++call abstractMethod2()&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-title function_">funcWithImplements</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;~~~call funcWithImplements()&quot;</span>);<br>  &#125;<br>&#125;<br><span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-title class_">ConcreteClass</span>();<br>  a.<span class="hljs-title function_">abstractMethod</span>();       <span class="hljs-comment">//++call abstractMethod()</span><br>  a.<span class="hljs-title function_">abstractMethod2</span>();      <span class="hljs-comment">//++call abstractMethod2()</span><br>  a.<span class="hljs-title function_">funcWithImplements</span>();   <span class="hljs-comment">//~~~call funcWithImplements()</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="16-Mixin"><a href="#16-Mixin" class="headerlink" title="16.Mixin"></a>16.Mixin</h4><p><code>Mixin</code>就是“混入”的意思，用于给当前类添加【新的】【可选】功能。</p><p>通常来说，我们可以通过<code>继承</code>或者实现<code>接口</code>来给现有类扩展新的功能。但这些都是带有侵入性的，你可能会获得这些父类或接口中一些多余的功能，并且你需要自己提供这些功能的实现；使用 Mixin 则你只需要定义可复用的 mixin 类，在其中定义API并提供具体实现，然后就可以将这些mixin类的API通过<code>with</code>关键字组合到当前类中。</p><blockquote><p>继承强调的是<code>is-a</code>，而 Mixin 强调的是<code>I can</code>。</p></blockquote><p><code>Mixin</code>是复用类代码的一种途径，复用的类可以在不同层级，可以不存在继承关系。</p><p>通过创建一个继承自<code>Object</code>且没有构造函数的类，来实现一个<code>Mixin</code>。 如果Mixin不希望作为常规类被使用，使用关键字<code>mixin</code>替换<code>class</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Devices</span> </span>&#123;<br>  void run() &#123;<br>    print(&#x27;++++开机&#x27;);<br>  &#125;<br>  void stop() &#123;<br>    print(&#x27;++++关机&#x27;);<br>  &#125;<br>&#125;<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Devices</span> </span>&#123;<br>  void run() &#123;<br>    <span class="hljs-keyword">super</span>.run();<br>    print(&#x27;++++iphone 开机&#x27;);<br>  &#125;<br>&#125;<br> <br><span class="hljs-comment">// 定义组件/能力</span><br>mixin iOS &#123; <br>  void call() &#123;<br>    print(&#x27;+++iOS running&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义组件/能力 </span><br><span class="hljs-comment">// 非mixin声明的类也可以通过with关键字混入</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppStore</span> </span>&#123;<br>  void download() &#123;<br>    print(&#x27;++++downloading&#x27;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 混入、拓展iPhone的功能</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">iPhoneX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">iPhone</span> <span class="hljs-keyword">with</span> <span class="hljs-title">iOS</span>, <span class="hljs-title">AppStore</span> </span>&#123;<br>  void run() &#123;<br>    <span class="hljs-keyword">super</span>.run();<br>    print(&#x27;iphoneX 开机&#x27;);<br>  &#125;<br>&#125;<br><br>void main() &#123;<br>  <span class="hljs-keyword">var</span> p = iPhoneX();<br>  p.run();<br>  p.call();     <span class="hljs-comment">//使用混入的能力</span><br>  p.download(); <span class="hljs-comment">//使用混入的能力</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Dart的这个功能还是挺强大的，根据我的掌握的知识，Swift 中尚没有与之对应的关键字。不过真要说的话，或许可以借道<code>protocol</code>+<code>extension</code>，在不增加某个类本身的代码量的前提下，给此类扩展额外的能力：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义组件/能力</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">call</span>()<br>&#125;<br><span class="hljs-comment">// 定义组件/能力</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AppStore</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">download</span>()<br>&#125;<br><span class="hljs-comment">// 扩展协议 </span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">call</span>()&#123; <span class="hljs-comment">//给接口添加默认行为</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++iOS running&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 扩展协议</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">AppStore</span>&#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">download</span>()&#123; <span class="hljs-comment">//给接口添加默认行为</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++downloading&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在不额外增加iPhone类本身代码的前提下，扩展其能力</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iPhone</span>: <span class="hljs-title class_">IOS</span>, <span class="hljs-title class_">AppStore</span>&#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>()&#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++iphone 开机&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用额外的能力</span><br><span class="hljs-keyword">let</span> iphone <span class="hljs-operator">=</span> iPhone()<br>iphone.run()<br>iphone.call()<br>iphone.download()<br></code></pre></td></tr></table></figure><h4 id="17-泛型"><a href="#17-泛型" class="headerlink" title="17.泛型"></a>17.泛型</h4><p>这里的泛型与 Swift 中的类似，都是使用<code>&lt;T&gt;</code>格式来表示。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span>&lt;T&gt; &#123;<br>  var <span class="hljs-built_in">map</span> = &#123;&#125;;<br>  T <span class="hljs-title function_">getByKey</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>)&#123;<br>    T value = <span class="hljs-built_in">map</span>[<span class="hljs-built_in">key</span>];<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setByKey</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, T value)&#123;<br>    <span class="hljs-built_in">map</span>[<span class="hljs-built_in">key</span>] = value;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() &#123;<br>  var aStore = <span class="hljs-title function_">Store</span>();<br>  aStore.<span class="hljs-property">setByKey</span>(<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">print</span>(aStore.<span class="hljs-property">getByKey</span>(<span class="hljs-string">&#x27;first&#x27;</span>));<br>  aStore.<span class="hljs-property">setByKey</span>(<span class="hljs-string">&#x27;second&#x27;</span>, <span class="hljs-string">&#x27;ii&#x27;</span>);<br>  <span class="hljs-built_in">print</span>(aStore.<span class="hljs-property">getByKey</span>(<span class="hljs-string">&#x27;second&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="18-is-amp-as"><a href="#18-is-amp-as" class="headerlink" title="18.is&amp;as"></a>18.is&amp;as</h4><p><code>is</code>用于进行类型检查，即类是否在某个类的继承树上。或者检查对象是否实现了某个接口：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  String name;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Speak</span> &#123;<br>  speak();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> <span class="hljs-keyword">implements</span> Speak&#123;<br>  <span class="hljs-built_in">int</span> identifier;<br>  speak()&#123;<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;Hello~&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">var</span> p = Person();<br>  <span class="hljs-built_in">var</span> s = Student();<br>  Person  x = Student(); <span class="hljs-comment">//父类指针指向子类对象</span><br>  <span class="hljs-comment">//Student y = Person();  //报错，不允许子类指针指向父类实例</span><br>  <br>  <span class="hljs-keyword">print</span>(p <span class="hljs-keyword">is</span> Person);  <span class="hljs-comment">//true，直属类</span><br>  <span class="hljs-keyword">print</span>(s <span class="hljs-keyword">is</span> Student); <span class="hljs-comment">//true，直属类</span><br>  <span class="hljs-keyword">print</span>(s <span class="hljs-keyword">is</span> Person);  <span class="hljs-comment">//true，父类</span><br>  <span class="hljs-keyword">print</span>(x <span class="hljs-keyword">is</span> Student); <span class="hljs-comment">//true，x实际就是Student</span><br>  <span class="hljs-keyword">print</span>(x <span class="hljs-keyword">is</span> Person);  <span class="hljs-comment">//true，x是Student，也是Person的子类</span><br>  <span class="hljs-keyword">print</span>(p <span class="hljs-keyword">is</span> Speak);   <span class="hljs-comment">//false，父类没实现Speak接口</span><br>  <span class="hljs-keyword">print</span>(s <span class="hljs-keyword">is</span> Speak);   <span class="hljs-comment">//true，子类实现了Speak接口</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>as</code>用于类型转换：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  String name;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Speak</span> &#123;<br>  speak();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> <span class="hljs-keyword">implements</span> Speak&#123;<br>  <span class="hljs-built_in">int</span> identifier;<br>  speak()&#123;<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;Hello~&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  <span class="hljs-built_in">var</span> p = Person();<br>  <span class="hljs-built_in">var</span> s = Student();<br>  Person  x = Student(); <span class="hljs-comment">//父类指针指向子类对象</span><br>  <br>  <span class="hljs-built_in">var</span> y = x <span class="hljs-keyword">as</span> Student;<br>  y.identifier = <span class="hljs-number">101</span>;<br>  <br>  <span class="hljs-keyword">print</span>(p <span class="hljs-keyword">as</span> Person);    <span class="hljs-comment">//Instance of &#x27;Person&#x27;</span><br>  <span class="hljs-keyword">print</span>(p <span class="hljs-keyword">as</span> Student);   <span class="hljs-comment">//报错，运行时异常</span><br>  <span class="hljs-keyword">print</span>(s <span class="hljs-keyword">as</span> Person);    <span class="hljs-comment">//Instance of &#x27;Student&#x27;</span><br>  <span class="hljs-keyword">print</span>(s <span class="hljs-keyword">as</span> Student);   <span class="hljs-comment">//Instance of &#x27;Student&#x27;</span><br>  <span class="hljs-keyword">print</span>(x <span class="hljs-keyword">as</span> Person);    <span class="hljs-comment">//Instance of &#x27;Student&#x27;</span><br>  <span class="hljs-keyword">print</span>(x <span class="hljs-keyword">as</span> Student);   <span class="hljs-comment">//Instance of &#x27;Student&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="19-库"><a href="#19-库" class="headerlink" title="19.库"></a>19.库</h4><ul><li>库不仅提供了 API ，而且对代码起到了封装的作用。 </li><li>import 和 library 指令可以用来创建一个模块化的，可共享的代码库。 </li><li>Dart中没有<code>public</code>、<code>protected</code>和<code>private</code>这些访问修饰符，约定以下划线<code>_</code>定义私有类型，表示仅在当前库中可见。</li><li>每个 Dart 应用程序都是一个库 ，虽然没有使用 library 指令。</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 导入核心库</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span>;<br><br><span class="hljs-comment">// 从外部包导入库</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:test/test.dart&#x27;</span>;<br><br><span class="hljs-comment">// 导入文件</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;path/to/my_other_file.dart&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果只使用库的一部分功能，则可以选择需要导入的内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// <span class="hljs-keyword">Import</span> <span class="hljs-keyword">only</span> foo.<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="hljs-keyword">show</span> foo;<br><br>// <span class="hljs-keyword">Import</span> <span class="hljs-keyword">all</span> names <span class="hljs-keyword">EXCEPT</span> foo.<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib2/lib2.dart&#x27;</span> hide foo;<br></code></pre></td></tr></table></figure><p>如果导入两个存在冲突标识符的库， 则可以为这两个库，或者其中一个指定前缀。 例如，如果 library1 和 library2 都有一个 Element 类， 那么可以通过下面的方式处理：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib1/lib1.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="hljs-keyword">as</span> lib2;<br><br><span class="hljs-comment">// 使用 lib1 中的 Element。</span><br><span class="hljs-built_in">Element</span> element1 = <span class="hljs-built_in">Element</span>();<br><br><span class="hljs-comment">// 使用 lib2 中的 Element。</span><br>lib2.<span class="hljs-built_in">Element</span> element2 = lib2.<span class="hljs-built_in">Element</span>();<br></code></pre></td></tr></table></figure><h4 id="20-异步"><a href="#20-异步" class="headerlink" title="20.异步"></a>20.异步</h4><p>Dart 默认是单线程的，耗时操作很容易造成线程阻塞：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">loadData()&#123;<br>  String dataURL <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://jsonplaceholder.typicode.com/posts&quot;</span><span class="hljs-comment">;</span><br>  http.Response response <span class="hljs-operator">=</span> http.get(dataURL)<span class="hljs-comment">;</span><br>  setState(() &#123;<br>    widgets <span class="hljs-operator">=</span> json.decode(response.body)<span class="hljs-comment">;</span><br>  &#125;)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>网络请求可能会很慢，这时主线程会被挂起，直到请求完成并更新状态。</p><p>好在 Dart 提供了异步工具<code>async</code>、<code>await</code>、<code>Future</code>，来实现异步操作。函数体被<code>async</code>标记的函数，即是一个异步函数。将<code>async</code>关键字添加到函数使其返回<code>Future</code>，以便检查结果。 </p><p>例如，下面的同步函数，它返回一个 String ：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">String</span> lookUpVersion() =&gt; &#x27;<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>&#x27;;<br></code></pre></td></tr></table></figure><p>假如将来的实现将非常耗时，将其更改为异步函数，返回值是<code>Future</code>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">Future&lt;String&gt; <span class="hljs-title">lookUpVersion</span>() <span class="hljs-keyword">async</span></span> =&gt; <span class="hljs-string">&#x27;1.0.0&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><code>await</code>与<code>async</code>借鉴自ES7，一般成对出现；</li><li>出现await操作的【方法】必须声明为async；</li><li>await修饰耗时操作，此耗时操作会阻塞当前线程；</li><li>async修饰的方法会立刻返回，不阻塞当前线程；</li></ul><p>示例1：调用时不带<code>await</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future refreshDate() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++3333: +<span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>  <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds:<span class="hljs-number">5</span>));<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++44444: <span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++111: <span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>  refreshDate(); <span class="hljs-comment">// 不标记为await 会直接执行下一行</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++222: <span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">+++<span class="hljs-string">+111</span>: 2020<span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:53:59.366<br>+++<span class="hljs-string">+3333</span>: <span class="hljs-string">+2020</span><span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:53:59.366<br>+++<span class="hljs-string">+222</span>: 2020<span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:53:59.366<br>+++<span class="hljs-string">+44444</span>: 2020<span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:54:04.367<br></code></pre></td></tr></table></figure><p>示例2：调用时带<code>await</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future refreshDate() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++3333: +<span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>  <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds:<span class="hljs-number">5</span>));<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++44444: <span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++111: <span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>  <span class="hljs-keyword">await</span> refreshDate(); <span class="hljs-comment">// 标记为await 则先执行完refreshDate操作才会执行下一行</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++222: <span class="hljs-subst">$&#123;DateTime.now()&#125;</span>&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">+++<span class="hljs-string">+111</span>: 2020<span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:51:24.701<br>+++<span class="hljs-string">+3333</span>: <span class="hljs-string">+2020</span><span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:51:24.701<br>+++<span class="hljs-string">+44444</span>: 2020<span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:51:29.702<br>+++<span class="hljs-string">+222</span>: 2020<span class="hljs-string">-05</span><span class="hljs-string">-08</span> 23:51:29.702<br></code></pre></td></tr></table></figure><p>Dart 还提供了<code>Isolate</code>来让代码运行在其他线程中，从而实现并发编程，后续有时间继续研究~</p><h3 id="三-后记"><a href="#三-后记" class="headerlink" title="三.后记"></a>三.后记</h3><p><code>Dart</code>包含了诸多现代编程语言的特性，特点鲜明：</p><ul><li><p>高效：语法清晰简洁、工具简单而强大、输入检测可尽早识别细微错误、库文件丰富；</p></li><li><p>快速：提供<code>AOT</code>提前编译优化，在移动设备和web上实现高性能和快速启动；支持<code>热加载</code>；</p></li><li><p>可移植：可编译成<code>ARM</code>和<code>x86</code>代码，支持移动、桌面及终端程序；web上会转换为<code>JavaScript</code>；</p></li><li><p>易学：面向对象，语法风格与<code>Swift</code>相似，上手相对容易些。</p></li><li><p>响应式：支持响应式编程。可通过 Future 和 Stream 的特性和API实现异步编程。</p></li></ul><p>学习<code>Flutter</code>之前有必要研究一下<code>Dart</code>，对比学习从而加深对各语言的理解~</p><hr><p>相关参考：</p><p>#<a href="https://www.dartcn.com/">©Dart中文网</a></p><p>#<a href="https://dartpad.cn/">©DartPad-在线编译调试工具</a></p><p>#<a href="https://flutterchina.club/">©Flutter中文网</a></p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAC-数据过滤与转换</title>
    <link href="/2021/06/06/RAC-filter.html"/>
    <url>/2021/06/06/RAC-filter.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>信号在订阅后就可以接收回调的数据了，有时候我们需要对收到的数据进行过滤或者转换。</p><p>例如发送按钮的<code>userInteractionEnabled</code>状态需要依请求的<code>isFnished</code>状态而定：</p><ul><li>请求未返回则按钮不可点击；</li><li>请求成功返回后按钮可点击；</li></ul><p>这种场景下我们只需创建一个信号监听请求的<code>isFnished</code>属性，并对信号返回的结果取反即可。</p><p>再比如修改昵称时一般不能前后输入一样的昵称，这时候我们可以通过信号监听文本框的内容，遇到前后一致的文本时自动过滤掉即可。</p><p>为了应对这些常见的使用场景，RAC同样也提供了对应的接口。本文将对这些接口进行调用展示和实现分析：</p><h3 id="1-bind"><a href="#1-bind" class="headerlink" title="1.bind"></a>1.bind</h3><p>信号的绑定，先讲这个方法是因为其他接口的底层都是通过它来实现的，理清它的实现有助于更好的理解接下来的其他接口。</p><p>这个方法定义在<code>RACStream.h</code>中，被多个子类重写，这里就看看<code>RACSignal.h</code>中的接口定义：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//1 bind方法的定义</span><br><span class="hljs-comment">/// Lazily binds a block to the values in the receiver.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This should only be used if you need to terminate the bind early, or close</span><br><span class="hljs-comment">/// over some state. -flattenMap: is more appropriate for all other cases.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// block - A block returning a RACSignalBindBlock. This block will be invoked</span><br><span class="hljs-comment">///         each time the bound signal is re-evaluated. This block must not be</span><br><span class="hljs-comment">///         nil or return nil.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a new signal which represents the combined result of all lazy</span><br><span class="hljs-comment">/// applications of `block`.</span><br>- (RACSignal *)bind:(<span class="hljs-built_in">RACSignalBindBlock</span> (^)(<span class="hljs-type">void</span>))block RAC_WARN_UNUSED_RESULT;<br><br><span class="hljs-comment">//2.block的返回值BindBlock的定义</span><br><span class="hljs-comment">/// A block which accepts a value from a RACSignal and returns a new signal.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Setting `stop` to `YES` will cause the bind to terminate after the returned</span><br><span class="hljs-comment">/// value. Returning `nil` will result in immediate termination.</span><br><span class="hljs-keyword">typedef</span> RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop);<br></code></pre></td></tr></table></figure><ul><li>方法的参数：一个“RACSignalBindBlock (^)(void)”类型的<code>block</code>；</li><li>方法的返回值：一个新的信号对象。</li></ul><p><strong>作用</strong>：将<code>block</code>绑定到方法接收者的值中，即把<code>block</code>参数保存在返回的信号中。</p><p>所以，<code>bind</code>的主要目的就是将任务以 block 的形式保存到返回的信号中，以期在将来进行处理。</p><p>#<strong>示例</strong>：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-variable">void</span>)<span class="hljs-title function_">callBind</span> &#123;<br>    <span class="hljs-comment">//bind的作用：将block绑定到信号2中，订阅信号1并创建新的信号2，收到信号1的数据后，修改数据并通过新创建的信号2发送新数据)</span><br>    <span class="hljs-comment">// 1.信号1</span><br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal1</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-comment">// 5.信号1发送数据1</span><br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;1&quot;</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">nil</span>;<br>    &#125;];<br>    <span class="hljs-comment">// 2.信号2</span><br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">bindSignal2</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">signal1</span> <span class="hljs-variable">bind</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACSignalBindBlock</span>&#123;<br>        <span class="hljs-comment">// 4.bind回调</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++This is BindBlock callback&quot;</span>);<br>        <span class="hljs-title class_">RACSignalBindBlock</span> <span class="hljs-variable">aBindBlock</span> <span class="hljs-operator">=</span> <span class="hljs-operator">^</span><span class="hljs-title class_">RACSignal</span><span class="hljs-title function_">*</span>(<span class="hljs-params">id</span> <span class="hljs-params">value</span>, <span class="hljs-params">BOOL</span> *<span class="hljs-params">stop</span>)&#123;<br>            <span class="hljs-comment">// 6.bindBlock内修改数据</span><br>            <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++ori value:%@&quot;</span>,<span class="hljs-variable">value</span>);<br>            <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> @<span class="hljs-string">&quot;2&quot;</span>;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-title class_">RACReturnSignal</span> <span class="hljs-keyword">return</span>:<span class="hljs-variable">value</span>];<span class="hljs-comment">// 信号3</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">aBindBlock</span>;<br>    &#125;];<br>    <span class="hljs-comment">// 3.订阅信号2</span><br>    [<span class="hljs-variable">bindSignal2</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-comment">// 7.接收数据</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;++++bindSignal return Value:%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">This is BindBlock callback</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">ori value:1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">bindSignal return Value:2</span><br></code></pre></td></tr></table></figure><p>示例中<code>信号1</code>调用了绑定方法，将一个修改数据的 block 绑定到返回值<code>信号2</code>中。</p><p>订阅<code>信号2</code>之后<code>信号1</code>发送了数据<code>1</code>，但最终<code>信号2</code>订阅者接收到的是修改后的数据<code>2</code>。</p><p>下面就来看看调用<code>bind</code>方法后都发生了什么：</p><p>#<strong>实现</strong>：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span>)<span class="hljs-variable">bind</span>:(<span class="hljs-title class_">RACSignalBindBlock</span> (<span class="hljs-operator">^</span>)(<span class="hljs-variable">void</span>))<span class="hljs-title function_">block</span> &#123;<br><span class="hljs-title class_">NSCParameterAssert</span>(<span class="hljs-variable">block</span> <span class="hljs-operator">!=</span> <span class="hljs-variable">NULL</span>);<span class="hljs-comment">//为空校验</span><br><br><span class="hljs-keyword">return</span> [[<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<span class="hljs-comment">//创建信号2 ^didSubscribe2</span><br><br><span class="hljs-comment">// 1.调用bind的block参数，返回BindBlock</span><br><span class="hljs-title class_">RACSignalBindBlock</span> <span class="hljs-variable">bindingBlock</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">block</span>();<br><br><span class="hljs-variable">__block</span> <span class="hljs-variable">volatile</span> int32_t <span class="hljs-variable">signalCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">// indicates self</span><br><br><span class="hljs-title class_">RACCompoundDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">compoundDisposable</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACCompoundDisposable</span> <span class="hljs-variable">compoundDisposable</span>];<br><br><span class="hljs-comment">// 创建完成block</span><br><span class="hljs-title function_">void</span> (<span class="hljs-operator">^</span><span class="hljs-variable">completeSignal</span>)(<span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span>) <span class="hljs-operator">=</span> <span class="hljs-title function_">^</span>(<span class="hljs-params">RACDisposable</span> *<span class="hljs-params">finishedDisposable</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">OSAtomicDecrement</span>32Barrier(<span class="hljs-operator">&amp;</span><span class="hljs-variable">signalCount</span>) <span class="hljs-operator">==</span> <span class="hljs-number">0</span>) &#123;<br>[<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">dispose</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">removeDisposable</span>:<span class="hljs-variable">finishedDisposable</span>];<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建信号处理block</span><br><span class="hljs-title function_">void</span> (<span class="hljs-operator">^</span><span class="hljs-variable">addSignal</span>)(<span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span>) <span class="hljs-operator">=</span> <span class="hljs-title function_">^</span>(<span class="hljs-params">RACSignal</span> *<span class="hljs-params">signal</span>) &#123;<br><span class="hljs-title class_">OSAtomicIncrement</span>32Barrier(<span class="hljs-operator">&amp;</span><span class="hljs-variable">signalCount</span>);<br><br><span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">selfDisposable</span> <span class="hljs-operator">=</span> [[<span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-variable">alloc</span>] init];<br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">addDisposable</span>:<span class="hljs-variable">selfDisposable</span>];<br><br><span class="hljs-comment">// 5.订阅传进来的信号</span><br><span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">disposable</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">signal</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<span class="hljs-comment">// ^sendNext3</span><br><span class="hljs-comment">// 6.向信号2发送数据</span><br>[<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:<span class="hljs-variable">x</span>];<br>&#125; <span class="hljs-variable">error</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSError</span> *<span class="hljs-params">error</span>) &#123;<br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">dispose</span>];<br>[<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendError</span>:<span class="hljs-variable">error</span>];<br>&#125; <span class="hljs-variable">completed</span>:<span class="hljs-operator">^</span>&#123;<br>@<span class="hljs-title function_">autoreleasepool</span> &#123;<br><span class="hljs-title function_">completeSignal</span>(<span class="hljs-variable">selfDisposable</span>);<br>&#125;<br>&#125;];<br><br><span class="hljs-variable">selfDisposable</span>.<span class="hljs-property">disposable</span> <span class="hljs-operator">=</span> <span class="hljs-variable">disposable</span>;<br>&#125;;<br><br>@<span class="hljs-title function_">autoreleasepool</span> &#123;<br><span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">selfDisposable</span> <span class="hljs-operator">=</span> [[<span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-variable">alloc</span>] init];<br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">addDisposable</span>:<span class="hljs-variable">selfDisposable</span>];<br><br><span class="hljs-comment">// 2.订阅信号1</span><br><span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">bindingDisposable</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">self</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<span class="hljs-comment">// ^sendNext1</span><br><span class="hljs-comment">// Manually check disposal to handle synchronous errors.</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">compoundDisposable</span>.<span class="hljs-property">disposed</span>) <span class="hljs-keyword">return</span>;<br><br><span class="hljs-variable">BOOL</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-variable">NO</span>;<br><span class="hljs-comment">// 3.调用 aBindBlock，返回一个信号3</span><br><span class="hljs-variable">id</span> <span class="hljs-variable">signal</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">bindingBlock</span>(<span class="hljs-variable">x</span>, <span class="hljs-operator">&amp;</span><span class="hljs-variable">stop</span>);<br><br>@<span class="hljs-title function_">autoreleasepool</span> &#123;<br><span class="hljs-comment">// 4.信号3作为参数 调用addSignal()</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">signal</span> <span class="hljs-operator">!=</span> <span class="hljs-variable">nil</span>) <span class="hljs-title function_">addSignal</span>(<span class="hljs-variable">signal</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">signal</span> <span class="hljs-operator">==</span> <span class="hljs-variable">nil</span> <span class="hljs-operator">||</span> <span class="hljs-variable">stop</span>) &#123;<br>[<span class="hljs-variable">selfDisposable</span> <span class="hljs-variable">dispose</span>];<br><span class="hljs-title function_">completeSignal</span>(<span class="hljs-variable">selfDisposable</span>);<br>&#125;<br>&#125;<br>&#125; <span class="hljs-variable">error</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSError</span> *<span class="hljs-params">error</span>) &#123;<br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">dispose</span>];<br>[<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendError</span>:<span class="hljs-variable">error</span>];<br>&#125; <span class="hljs-variable">completed</span>:<span class="hljs-operator">^</span>&#123;<br>@<span class="hljs-title function_">autoreleasepool</span> &#123;<br><span class="hljs-title function_">completeSignal</span>(<span class="hljs-variable">selfDisposable</span>);<br>&#125;<br>&#125;];<br><br><span class="hljs-variable">selfDisposable</span>.<span class="hljs-property">disposable</span> <span class="hljs-operator">=</span> <span class="hljs-variable">bindingDisposable</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-variable">compoundDisposable</span>;<br>&#125;] <span class="hljs-variable">setNameWithFormat</span>:@<span class="hljs-string">&quot;[%@] -bind:&quot;</span>, <span class="hljs-variable">self</span>.<span class="hljs-property">name</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>1.调用<code>bind</code>方法后方法体内只做了block为空的校验，之后返回了一个信号，即我们示例中的<code>信号2</code>。所以关键点在这个<code>信号2</code>的实现中。示例的最后我们订阅了<code>信号2</code>，所以就会触发其<code>^didSubscribe</code>回调，也就是<code>bind</code>方法中返回值的那个大的 block，在上面的代码注释中我将它命名为<code>^didSubscribe2</code>；</p><p>2.<code>^didSubscribe2</code>中先调用<code>bind</code>方法的<code>block</code>参数。这个<code>block</code>就是我们在示例中定义好的，其实什么都没做，只是返回了一个比较特殊的<code>aBindBlock</code>；</p><p>3.<code>^didSubscribe2</code>紧接着定义了两个block，然后订阅了<code>信号1</code>，触发<code>^didSubscribe1</code>，即示例1中<code>信号1</code>的 block；</p><p>4.<code>^didSubscribe1</code>中向订阅者发送了数据<code>1</code>；触发<code>bind</code>方法内的<code>^sendNext1</code>；</p><p>5.<code>^sendNext1</code>内调用<code>aBindBlock</code>，参数为数据<code>1</code>，返回一个新的信号，将其命名为<code>信号3</code>；<code>aBindBlock</code>本身也是一个 block，内部定义了处理数据的逻辑，返回值是一个特殊类型(RACReturnSignal)的<code>信号3</code>，这种信号的特点是被订阅之后会立刻将自己接收的参数作为数据发送出去，而这个参数就是我们修改之后的数据<code>2</code>；</p><p>6.<code>^sendNext1</code>内接着将<code>信号3</code>作为参数调用了<code>^addSignal</code>；<code>^addSignal</code>内订阅了<code>信号3</code>，上面说过<code>信号3</code>的特点，所以被订阅后立刻触发了<code>^sendNext3</code>；</p><p>7.<code>^sendNext3</code>内向<code>信号2</code>的订阅者发送数据<code>2</code>；</p><p>8.示例中<code>信号2</code>的订阅者接收到回来的数据<code>2</code>。</p><p>时序图整理如下：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_signal_bind2.jpg" alt="信号绑定时序图"></p><p><strong>小结</strong>：信号的绑定给了我们一个在其<code>BindBlock</code>中修改源信号返回值的机会，但这么直接使用<code>bind</code>显得有点麻烦，通常在使用RAC时我们都会选择下面这些基于<code>bind</code>的更便捷的语法。</p><h3 id="2-take"><a href="#2-take" class="headerlink" title="2.take"></a>2.take</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Returns a signal of the first `count` values in the receiver. If `count` is</span><br><span class="hljs-comment">/// greater than or equal to the number of values in the signal, a signal</span><br><span class="hljs-comment">/// equivalent to the receiver is returned.</span><br><span class="hljs-operator">-</span> (<span class="hljs-type">RACSignal</span>&lt;<span class="hljs-type">ValueType</span>&gt; <span class="hljs-operator">*</span>)take:(<span class="hljs-type">NSUInteger</span>)count <span class="hljs-type">RAC_WARN_UNUSED_RESULT</span>;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：返回一个新的信号，订阅后只接收指定的<code>前N次</code>源信号的数据。</p><p>#<strong>示例</strong>：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs prolog">- (void)take &#123;<br>    <span class="hljs-symbol">RACSignal</span> *signal1 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;1.1&quot;</span>]; // 第<span class="hljs-number">1</span>次发送数据<br>        <br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;1.2&quot;</span>];// 第<span class="hljs-number">2</span>次发送数据<br>            //[subscriber sendCompleted];<br>        &#125;];<br>        <br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">5</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;1.3&quot;</span>];// 第<span class="hljs-number">3</span>次发送数据<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <br>    [[signal1 take:<span class="hljs-number">2</span>] subscribeNext:^(id x) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++received Value:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">call signal1 block</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:1</span><span class="hljs-string">.</span><span class="hljs-comment">1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:1</span><span class="hljs-string">.</span><span class="hljs-comment">2</span><br></code></pre></td></tr></table></figure><p>可以看到，虽然示例中三次<code>sendNext:</code>，但最终新信号的订阅回调中只收到了前两次的数据~</p><p>#<strong>实现</strong>：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs fortran">- (__kindof RACStream *)take:(NSUInteger)<span class="hljs-built_in">count</span> &#123;<br><span class="hljs-keyword">Class</span> <span class="hljs-keyword">class</span> = self.<span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span>.empty;<br><br><span class="hljs-keyword">return</span> [[self <span class="hljs-keyword">bind</span>:^&#123;<br>__block NSUInteger taken = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> ^ id (id <span class="hljs-keyword">value</span>, BOOL *<span class="hljs-keyword">stop</span>) &#123;<br><span class="hljs-keyword">if</span> (taken &lt; <span class="hljs-built_in">count</span>) &#123;<br>++taken;<br><span class="hljs-keyword">if</span> (taken == <span class="hljs-built_in">count</span>) *<span class="hljs-keyword">stop</span> = YES;<br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:<span class="hljs-keyword">value</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> nil;<br>&#125;<br>&#125;;<br>&#125;] setNameWithFormat:@<span class="hljs-string">&quot;[%@] -take: %lu&quot;</span>, self.<span class="hljs-keyword">name</span>, (unsigned long)<span class="hljs-built_in">count</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>1.<code>take:</code>方法的内部是通过<code>bind</code>来实现的，所以其核心逻辑也是在<code>BindBlock</code>中；</p><p>2.<code>take:</code>方法的内部持有一个局部变量<code>taken</code>用于计算<code>BindBlock</code>被调用了几次;</p><p>3.上面<code>bind</code>方法的分析中提到过<code>BindBlock</code>的触发机制，所以<code>信号1</code>每发送一次数据，<code>taken</code>就自动加1;</p><p>4.当<code>taken</code>超过指定的次数时<code>BindBlock</code>返回一个空信号，不再继续接收新数据。</p><p><strong>ps</strong>：如果源信号在第N次之前被<code>sendCompleted</code>，那么后续也不会再产生新数据。</p><h3 id="3-skip"><a href="#3-skip" class="headerlink" title="3.skip"></a>3.skip</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Skips the first `skipCount` values in the receiver.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns the receiver after skipping the first `skipCount` values. If</span><br><span class="hljs-comment">/// `skipCount` is greater than the number of values in the signal, an empty</span><br><span class="hljs-comment">/// signal is returned.</span><br><span class="hljs-operator">-</span> (<span class="hljs-type">RACSignal</span>&lt;<span class="hljs-type">ValueType</span>&gt; <span class="hljs-operator">*</span>)skip:(<span class="hljs-type">NSUInteger</span>)skipCount <span class="hljs-type">RAC_WARN_UNUSED_RESULT</span>;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：跳过<code>前N次</code>的数据回调。</p><p>它跟<code>take</code>有点反着来的意思~所以可以想见，它的实现逻辑刚好与<code>take</code>相反。</p><p>#<strong>示例</strong>：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">- (void)skip &#123;<br>    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber) </span>&#123;<br>        NSLog(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [<span class="hljs-keyword">subscriber </span>sendNext:@<span class="hljs-string">&quot;1.1&quot;</span>]<span class="hljs-comment">; // 第1次发送数据</span><br>        <br>        [[RACScheduler mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> <span class="hljs-keyword">schedule:^&#123;</span><br><span class="hljs-keyword"></span>            [<span class="hljs-keyword">subscriber </span>sendNext:@<span class="hljs-string">&quot;1.2&quot;</span>]<span class="hljs-comment">; // 第2次发送数据</span><br>        &#125;];<br>        <br>        [[RACScheduler mainThreadScheduler] afterDelay:<span class="hljs-number">5</span> <span class="hljs-keyword">schedule:^&#123;</span><br><span class="hljs-keyword"></span>            [<span class="hljs-keyword">subscriber </span>sendNext:@<span class="hljs-string">&quot;1.3&quot;</span>]<span class="hljs-comment">; // 第3次发送数据</span><br>            [<span class="hljs-keyword">subscriber </span>sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <br>    [[signal1 skip:<span class="hljs-number">2</span>] <span class="hljs-keyword">subscribeNext:^(id </span>x) &#123;<br>        NSLog(@<span class="hljs-string">&quot;+++received Value:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">call signal1 block</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:1</span><span class="hljs-string">.</span><span class="hljs-comment">3</span><br></code></pre></td></tr></table></figure><p>日志显示，自动跳过前2次数据，只接收到了最后一次数据<code>1.3</code>。</p><p>#<strong>实现</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (__kindof RACStream *)skip:(<span class="hljs-built_in">NSUInteger</span>)skipCount &#123;<br>Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;<br><br><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> bind:^&#123;<br>__block <span class="hljs-built_in">NSUInteger</span> skipped = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> ^(<span class="hljs-type">id</span> value, <span class="hljs-type">BOOL</span> *stop) &#123;<br><span class="hljs-keyword">if</span> (skipped &gt;= skipCount) <span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:value];<br><br>skipped++;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span>.empty;<br>&#125;;<br>&#125;] setNameWithFormat:<span class="hljs-string">@&quot;[%@] -skip: %lu&quot;</span>, <span class="hljs-keyword">self</span>.name, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)skipCount];<br>&#125;<br></code></pre></td></tr></table></figure><p><code>skip</code>的实现与<code>take</code>相似，都是通过<code>BindBlock</code>中的数值型局部变量来控制接收信号的次数，只不过二者逻辑相反。</p><h3 id="4-distinctUntilChanged"><a href="#4-distinctUntilChanged" class="headerlink" title="4.distinctUntilChanged"></a>4.distinctUntilChanged</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">/// <span class="hljs-keyword">Returns</span> a signal <span class="hljs-keyword">of</span> <span class="hljs-keyword">values</span> <span class="hljs-keyword">for</span> which -isEqual: <span class="hljs-keyword">returns</span> <span class="hljs-keyword">NO</span> <span class="hljs-keyword">when</span> compared <span class="hljs-keyword">to</span> the<br>/// previous <span class="hljs-keyword">value</span>.<br>- (RACSignal&lt;ValueType&gt; *)distinctUntilChanged RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：过滤源信号的数据，相同的数据出现时订阅者不会收到回调，直到不同的数据出现。</p><p>#<strong>示例</strong>：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">- (void)<span class="hljs-keyword">distinct </span>&#123;<br>    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber) </span>&#123;<br>        NSLog(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [<span class="hljs-keyword">subscriber </span>sendNext:@<span class="hljs-string">&quot;1&quot;</span>];<br>        [<span class="hljs-keyword">subscriber </span>sendNext:@<span class="hljs-string">&quot;1&quot;</span>];<br>        [<span class="hljs-keyword">subscriber </span>sendNext:@<span class="hljs-string">&quot;3&quot;</span>];<br>        [<span class="hljs-keyword">subscriber </span>sendCompleted];<br>        return nil;<br>    &#125;];<br>    [[signal1 <span class="hljs-keyword">distinctUntilChanged] </span><span class="hljs-keyword">subscribeNext:^(id </span>x) &#123;<br>        NSLog(@<span class="hljs-string">&quot;+++received Value:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">call signal1 block</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:3</span><br></code></pre></td></tr></table></figure><p>前两次的数据相同，所以只接收了第1次的数据，第2次数据自动过滤掉了~</p><p>#<strong>实现</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (__kindof RACStream *)distinctUntilChanged &#123;<br>Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;<br><br><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> bind:^&#123;<br>__block <span class="hljs-type">id</span> lastValue = <span class="hljs-literal">nil</span>;<br>__block <span class="hljs-type">BOOL</span> initial = <span class="hljs-literal">YES</span>;<br><br><span class="hljs-keyword">return</span> ^(<span class="hljs-type">id</span> x, <span class="hljs-type">BOOL</span> *stop) &#123;<br><span class="hljs-keyword">if</span> (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) <span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> empty];<br><br>initial = <span class="hljs-literal">NO</span>;<br>lastValue = x;<br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:x];<br>&#125;;<br>&#125;] setNameWithFormat:<span class="hljs-string">@&quot;[%@] -distinctUntilChanged&quot;</span>, <span class="hljs-keyword">self</span>.name];<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>BindBlock</code>中将当前数据与上次返回的数据对比，数据的地址相同或者<code>isEqual</code>返回<code>YES</code>时，则返回空信号；否则正常接收。</p><p><strong>ps</strong>：当使用自定义的对象类型时你可能需要重写其<code>isEqual</code>方法。</p><h3 id="5-flattenMap"><a href="#5-flattenMap" class="headerlink" title="5.flattenMap"></a>5.flattenMap</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">/// Maps `block` across the values in the receiver and flattens the result.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Note that operators applied _after_ -flattenMap: behave differently from</span><br><span class="hljs-comment">/// operators _within_ -flattenMap:. See the Examples section below.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This corresponds to the `SelectMany` method in Rx.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// block - A block which accepts the values in the receiver and returns a new</span><br><span class="hljs-comment">///         instance of the receiver&#x27;s class. Returning `nil` from this block is</span><br><span class="hljs-comment">///         equivalent to returning an empty signal.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Examples</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">///   [signal flattenMap:^(id x) &#123;</span><br><span class="hljs-comment">///       // Logs each time a returned signal completes.</span><br><span class="hljs-comment">///       return [[RACSignal return:x] logCompleted];</span><br><span class="hljs-comment">///   &#125;];</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">///   [[signal</span><br><span class="hljs-comment">///       flattenMap:^(id x) &#123;</span><br><span class="hljs-comment">///           return [RACSignal return:x];</span><br><span class="hljs-comment">///       &#125;]</span><br><span class="hljs-comment">///       // Logs only once, when all of the signals complete.</span><br><span class="hljs-comment">///       logCompleted];</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a new signal which represents the combined signals resulting from</span><br><span class="hljs-comment">/// mapping `block`.</span><br>- (RACSignal *)flattenMap:(<span class="hljs-variable">__kindof</span> RACSignal * <span class="hljs-variable">_Nullable</span> (^)(ValueType <span class="hljs-variable">_Nullable</span> value))block RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：将源信号的数据映射成新的<code>信号</code>，即根据源信号的数据生成新的<code>信号</code>。</p><p>#<strong>示例</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)RACBinder&#123;<br>    @weakify(<span class="hljs-keyword">self</span>);<br>    <br>    <span class="hljs-comment">//设置返回按钮</span><br>    <span class="hljs-built_in">UIButton</span> *btn1 = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>    [btn1 setTitleColor:[<span class="hljs-built_in">UIColor</span> whiteColor] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn1 setTitle:<span class="hljs-string">@&quot;返回&quot;</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn1 sizeToFit];<br>    <span class="hljs-keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="hljs-built_in">UIBarButtonItem</span> alloc] initWithCustomView:btn1];<br>    <br>    <span class="hljs-comment">//添加点击事件逻辑</span><br>    [[[btn1 rac_signalForControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>] <span class="hljs-comment">// btnSignal</span><br>      flattenMap:^RACSignal *(<span class="hljs-built_in">UIControl</span> *value) &#123; <span class="hljs-comment">// flattenMapBlock</span><br>          <br>          RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="hljs-type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;<br>              @strongify(<span class="hljs-keyword">self</span>);<span class="hljs-comment">//一定要强引用一下，否则VC不会销毁</span><br>              [<span class="hljs-keyword">self</span>.navigationController popViewControllerAnimated:<span class="hljs-literal">YES</span>];<br>              [subscriber sendNext:<span class="hljs-string">@&quot;++Poped~&quot;</span>];<br>              [subscriber sendCompleted];<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>          &#125;];<br>        <span class="hljs-keyword">return</span> signal2;<br>    &#125;] <br>    subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Mess:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>点击按钮后，订阅新的<code>信号2</code>以处理导航器的<code>pop</code>操作，之后发出一条已完成的消息。</p><p>#<strong>实现</strong>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ruby">- (__kindof RACStream *)<span class="hljs-symbol">flattenMap:</span>(__kindof RACStream * (^)(id value))block &#123;<br>Class <span class="hljs-keyword">class</span> = <span class="hljs-variable language_">self</span>.<span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">return</span> [[<span class="hljs-variable language_">self</span> <span class="hljs-symbol">bind:</span>^&#123;<br><span class="hljs-keyword">return</span> ^(id value, <span class="hljs-variable constant_">BOOL</span> *stop) &#123;<br>id stream = block(value) <span class="hljs-string">?:</span> [<span class="hljs-keyword">class</span> empty];<br>NSCAssert([stream <span class="hljs-symbol">isKindOfClass:</span>RACStream.<span class="hljs-keyword">class</span>], @<span class="hljs-string">&quot;Value returned from -flattenMap: is not a stream: %@&quot;</span>, stream);<br><br><span class="hljs-keyword">return</span> stream;<br>&#125;;<br>&#125;] <span class="hljs-symbol">setNameWithFormat:</span>@<span class="hljs-string">&quot;[%@] -flattenMap:&quot;</span>, <span class="hljs-variable language_">self</span>.name];<br>&#125;<br></code></pre></td></tr></table></figure><p>1.<code>flattenMap</code>也是由<code>bind</code>实现的，<code>btnSignal</code>调用了<code>flattenMap</code>也就是调用了<code>bind</code>，之后就交给<code>bind</code>来处理；</p><p>2.<code>bind</code>先在<code>BindBlock</code>中调用了<code>block(value)</code>，这里的<code>block</code>就是<code>flattenMapBlock</code>；<code>value</code>就是源信号发送的数据，即<code>btn1</code>；返回值是我们定义好的处理 pop 业务的<code>信号2</code></p><p>3.根据之前介绍的<code>bind</code>时序图可知，<code>信号2</code>被<code>BindBlock</code>返回之后即被订阅，继而开始执行其<code>^didSubscribe</code>中的 pop 任务；</p><p>4.pop之后<code>^didSubscribe</code>发送已完成的消息，订阅者收到数据回调，整个任务执行完成。</p><p><strong>小结</strong>：<code>flattenMap</code>的主要作用就是接收源信号的数据，并返回一个处理业务的新<code>信号</code>。</p><h3 id="6-map"><a href="#6-map" class="headerlink" title="6.map"></a>6.map</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">/// Maps `block` across the values in the receiver.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This corresponds to the `Select` method in Rx.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a new signal with the mapped values.</span><br>- (RACSignal *)map:(id <span class="hljs-variable">_Nullable</span> (^)(ValueType <span class="hljs-variable">_Nullable</span> value))block RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：将源信号的数据映射成新的<code>数据</code>，即根据源信号的数据生成新的<code>数据</code>。</p><p><strong>#示例</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)map &#123;<br><br>    <span class="hljs-comment">//设置刷新按钮</span><br>    <span class="hljs-built_in">UIButton</span> *btn2 = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>    [btn2 setTitleColor:[<span class="hljs-built_in">UIColor</span> whiteColor] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn2 setTitle:<span class="hljs-string">@&quot;刷新&quot;</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn2 sizeToFit];<br>    <br>    <span class="hljs-keyword">self</span>.navigationItem.rightBarButtonItem = [[<span class="hljs-built_in">UIBarButtonItem</span> alloc] initWithCustomView:btn2];<br>    <br>    <span class="hljs-comment">//创建信号 监听刷新状态</span><br>    RACSignal *mEnableSignal = [RACObserve(<span class="hljs-keyword">self</span>.mViewModel, isRefresh)<br>                                map:^<span class="hljs-type">id</span> (<span class="hljs-type">id</span> value) &#123; <span class="hljs-comment">// mapBlock</span><br>                                    <span class="hljs-keyword">return</span> @(![value boolValue]); <span class="hljs-comment">// 对刷新状态取反</span><br>    &#125;];<br>    <br>    btn2.rac_command = [[RACCommand alloc] initWithEnabled:mEnableSignal<br>                                               signalBlock:^RACSignal *(<span class="hljs-type">id</span> input) &#123;<br>                                                   @strongify(<span class="hljs-keyword">self</span>);<br>                                                   <span class="hljs-comment">//business</span><br>                                                   [<span class="hljs-keyword">self</span>.mRrefreshControl endRefreshing];<br>                                                   RACSignal *signalFetch = [RACSignal createSignal:^RACDisposable *(<span class="hljs-type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;<br>                                                       <span class="hljs-comment">//声明请求参数</span><br>                                                       RACTuple *paramsTuple = [RACTuple tupleWithObjects:@(<span class="hljs-number">1</span>),@(<span class="hljs-number">20</span>), <span class="hljs-literal">nil</span>];<span class="hljs-comment">//元组第一个对象表示页码，第二个表示每页数量</span><br>                                                       <span class="hljs-comment">//发起请求</span><br>                                                       [<span class="hljs-keyword">self</span>.mRrefreshControl beginRefreshing];<br>                                                       [<span class="hljs-keyword">self</span>.mViewModel.fetchCommand execute:paramsTuple];<br>                                                       [subscriber sendCompleted];<br>                                                       <br>                                                       <span class="hljs-keyword">return</span> [RACDisposable disposableWithBlock:^&#123;<br>                                                       &#125;];<br>                                                   &#125;];<br>                                                   <span class="hljs-keyword">return</span> signalFetch;<br>                                               &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>1.示例中创建<code>RACCommand</code>时需要一个控制其是否执行的信号<code>EnableSignal</code>；</p><p>2.<code>RACObserve()</code>监听<code>VM</code>中表示是否在刷新的属性<code>isRefresh</code>，返回一个信号，取名<code>信号1</code>；</p><p>3.当<code>VM</code>中<code>isRefresh</code>属性值变化后，<code>信号1</code>会收到回调并在<code>map</code>回调内对其值取反。</p><p>#<strong>实现</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (__kindof RACStream *)map:(<span class="hljs-type">id</span> (^)(<span class="hljs-type">id</span> value))block &#123;<br><span class="hljs-built_in">NSCParameterAssert</span>(block != <span class="hljs-literal">nil</span>);<br><br>Class <span class="hljs-keyword">class</span> = <span class="hljs-keyword">self</span>.class;<br><br><span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> flattenMap:^(<span class="hljs-type">id</span> value) &#123; <span class="hljs-comment">// flattenMapBlock</span><br><span class="hljs-comment">//block(value)返回修改之后的新值，然后作为参数传入返回的RACReturnSignal中</span><br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-keyword">return</span>:block(value)]; <br>&#125;] setNameWithFormat:<span class="hljs-string">@&quot;[%@] -map:&quot;</span>, <span class="hljs-keyword">self</span>.name];<br>&#125;<br></code></pre></td></tr></table></figure><p>1.首先，源信号调用<code>map</code>后，其底层调用了<code>flattenMap</code>并返回一个新的信号，即<code>mEnableSignal</code>；</p><p>2.<code>flattenMap</code>的<code>flattenMapBlock</code>返回值为一个<code>RACReturnSignal</code>类型的信号；</p><p>3.此信号的参数通过<code>block(value)</code>获取，即我们在示例的<code>map</code>方法中定义的取反的那个<code>mapBlock</code>，返回修改后的数据。</p><p>4.<code>bind</code>方法的<code>BindBlock</code>获取到<code>RACReturnSignal</code>信号后随即订阅它；</p><p>5.<code>RACReturnSignal</code>被订阅后立刻向<code>mEnableSignal</code>的订阅者发送了修改后的数据。</p><p><strong>小结</strong>：<code>map</code>的主要作用就是对源信号发送的数据进行转换，从而返回一个新的<code>数据</code>。</p><hr><p>区分 map 与 flattenMap：</p><ul><li>map 的 block 中返回的是修改后的新数据；</li><li>flattenMap 的 block 中返回的是处理后续业务的新信号；</li><li>map 的底层调用了 flattenMap。</li></ul><p>理解了这些区别，就能更好的区分二者的使用场景了~</p><h3 id="7-filter"><a href="#7-filter" class="headerlink" title="7.filter"></a>7.filter</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/// Filters out values in the receiver that don&#x27;t pass the given test.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This corresponds to the `Where` method in Rx.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a new signal with only those values that passed.</span><br>- (RACSignal&lt;ValueType&gt; *)<span class="hljs-attribute">filter</span>:(BOOL (^)(ValueType _Nullable value))block RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：过滤信号的数据，只有条件为<code>YES</code>时订阅者才会收到数据。</p><p>#<strong>示例</strong>：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-variable">void</span>)<span class="hljs-title function_">filter</span> &#123;<br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal1</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@(<span class="hljs-number">1</span>)];<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@(<span class="hljs-number">2</span>)];<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@(<span class="hljs-number">3</span>)];<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">nil</span>;<br>    &#125;];<br>    [[<span class="hljs-variable">signal1</span> <span class="hljs-variable">filter</span>:<span class="hljs-operator">^</span><span class="hljs-title function_">BOOL</span>(<span class="hljs-params">NSNumber</span> *<span class="hljs-params">value</span>) &#123; <span class="hljs-comment">// filterBlock</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-variable">value</span> intValue] <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 条件表达式</span><br>    &#125;] <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++received Value:%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">call signal1 block</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:3</span><br></code></pre></td></tr></table></figure><p>自动过滤了小于1的数据。</p><p>#<strong>实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">- (__kindof RACStream *)<span class="hljs-built_in">filter</span>:(BOOL (^)(<span class="hljs-built_in">id</span> value))block &#123;<br>NSCParameterAssert(block != nil);<br><br>Class <span class="hljs-keyword">class</span> = self.<span class="hljs-keyword">class</span>;<br><br><span class="hljs-keyword">return</span> [[self flattenMap:^ <span class="hljs-built_in">id</span> (<span class="hljs-built_in">id</span> value) &#123;<br><span class="hljs-keyword">if</span> (block(value)) &#123;<br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">class</span> <span class="hljs-title class_">return</span>:value];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span>.empty;<br>&#125;<br>&#125;] setNameWithFormat:@<span class="hljs-string">&quot;[%@] -filter:&quot;</span>, self.name];<br>&#125;<br></code></pre></td></tr></table></figure><p>收到源信号发送的数据时，<code>BindBlock</code>中调用<code>block(value)</code>，即<code>filterBlock</code>中的逻辑，去判断数据是否满足指定的条件。</p><p><code>filterBlock</code>的返回值为<code>BOOl</code>型，所以我们只需要在其<code>return</code>后定义一个返回<code>BOOL</code>类型的表达式即可~</p><h3 id="8-ignore"><a href="#8-ignore" class="headerlink" title="8.ignore"></a>8.ignore</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/// Filters out values in the receiver that equal (via -isEqual:) the provided</span><br><span class="hljs-comment">/// value.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// value - The value can be `nil`, in which case it ignores `nil` values.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a new signal containing only the values which did not compare equal</span><br><span class="hljs-comment">/// to `value`.</span><br>- (RACSignal&lt;ValueType&gt; *)ignore:(<span class="hljs-literal">null</span>able ValueType)value RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：过滤掉源信号发送的特定数据。</p><p>#<strong>示例</strong>：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>ignore &#123;<br>    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *<span class="hljs-params">(id&lt;RACSubscriber&gt; subscriber)</span> &#123;<br>        NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>)</span>;<br>        [subscriber sendNext:@<span class="hljs-params">(<span class="hljs-number">1</span>)</span>];<br>        [subscriber sendNext:@<span class="hljs-params">(<span class="hljs-number">2</span>)</span>];<br>        [subscriber sendNext:@<span class="hljs-params">(<span class="hljs-number">3</span>)</span>];<br>        [subscriber sendCompleted];<br>        return nil;<br>    &#125;];<br>    [[signal1 ignore:@<span class="hljs-params">(<span class="hljs-number">2</span>)</span>] subscribeNext:^<span class="hljs-params">(id x)</span> &#123;<br>        NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++received Value:%@&quot;</span>,x)</span>;<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">call signal1 block</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">received Value:3</span><br></code></pre></td></tr></table></figure><p>只接收不为2的数据。</p><p>#<strong>实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">- (__kindof RACStream *)ignore:(<span class="hljs-built_in">id</span>)value &#123;<br><span class="hljs-keyword">return</span> [[self <span class="hljs-built_in">filter</span>:^ BOOL (<span class="hljs-built_in">id</span> innerValue) &#123;<br><span class="hljs-keyword">return</span> innerValue != value &amp;&amp; ![innerValue isEqual:value];<br>&#125;] setNameWithFormat:@<span class="hljs-string">&quot;[%@] -ignore: %@&quot;</span>, self.name, RACDescription(value)];<br>&#125;<br></code></pre></td></tr></table></figure><p>其内部是通过<code>filter</code>实现的，在<code>filter</code>的条件表达式中将信号返回的数据与我们指定的值进行了对比，相同时自动过滤掉~</p><h3 id="9-reduce"><a href="#9-reduce" class="headerlink" title="9.reduce"></a>9.reduce</h3><p><strong>作用</strong>：聚合，把多个信号返回的数据聚合到一处，以便对这些值进行相关处理。</p><p>此方法叫聚合，所以可以想象先要有数据需要它去整合，这些数据是独立的信号们发出的。</p><p>信号中并没有单独的<code>reduce</code>方法，它通常是与其他组合信号的方法结合使用的。以<code>combineLatest</code>为例：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/// Combines signals using +combineLatest:, then reduces the resulting tuples</span><br><span class="hljs-comment">/// into a single value using -reduceEach:.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// signals     - The signals to combine. If this collection is empty, the</span><br><span class="hljs-comment">///               returned signal will immediately complete upon subscription.</span><br><span class="hljs-comment">/// reduceBlock - The block which reduces the latest values from all the</span><br><span class="hljs-comment">///               signals into one value. It must take as many arguments as the</span><br><span class="hljs-comment">///               number of signals given. Each argument will be an object</span><br><span class="hljs-comment">///               argument. The return value must be an object. This argument</span><br><span class="hljs-comment">///               must not be nil.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Example:</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">///   [RACSignal combineLatest:@[ stringSignal, intSignal ] reduce:^(NSString *string, NSNumber *number) &#123;</span><br><span class="hljs-comment">///       return [NSString stringWithFormat:@&quot;%@: %@&quot;, string, number];</span><br><span class="hljs-comment">///   &#125;];</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a signal which sends the results from each invocation of</span><br><span class="hljs-comment">/// `reduceBlock`.</span><br>+ (RACSignal&lt;ValueType&gt; *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals <span class="hljs-built_in">reduce</span>:(RACGenericReduceBlock)reduceBlock RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><code>combineLatest</code>将两个信号组合成了一个新的信号，新信号返回的数据是一个元组。</p><p><code>reduce</code>是对元组中的数据进行了聚合，返回值为一个新的字符串数据对象。</p><p><code>reduce</code>中聚合的数据的数量和类型与源信号的数量和数据类型保持一致。</p><p><strong>示例</strong>：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-variable">void</span>)<span class="hljs-title function_">reduce</span> &#123;<br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal1</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;1&quot;</span>];<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">nil</span>;<br>    &#125;];<br>    <br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal2</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++call signal2 block&quot;</span>);<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;2.1&quot;</span>];<br>        [[<span class="hljs-title class_">RACScheduler</span> <span class="hljs-variable">mainThreadScheduler</span>] <span class="hljs-variable">afterDelay</span>:<span class="hljs-number">2</span> <span class="hljs-variable">schedule</span>:<span class="hljs-operator">^</span>&#123;<br>            [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;2.2&quot;</span>];<br>            [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>        &#125;];<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">nil</span>;<br>    &#125;];<br>    <br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal3</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">combineLatest</span>:@[<span class="hljs-variable">signal1</span>,<span class="hljs-variable">signal2</span>]<br>                                           <span class="hljs-variable">reduce</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSString</span> *<span class="hljs-params">str1</span>, <span class="hljs-params">NSString</span> *<span class="hljs-params">str2</span>)&#123; <span class="hljs-comment">// reduceBlock</span><br>                                               <span class="hljs-keyword">return</span> [@[<span class="hljs-variable">str1</span>,<span class="hljs-variable">str2</span>] <span class="hljs-variable">componentsJoinedByString</span>:@<span class="hljs-string">&quot;+&quot;</span>];<br>                                           &#125;];<br>    <br>    [<span class="hljs-variable">signal3</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++++received data:%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">+++<span class="hljs-keyword">call</span> signal1 <span class="hljs-keyword">block</span><br>+++<span class="hljs-keyword">call</span> signal2 <span class="hljs-keyword">block</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">1</span>+<span class="hljs-number">2.1</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">1</span>+<span class="hljs-number">2.2</span><br></code></pre></td></tr></table></figure><p>1.<code>combineLatest</code>整合了<code>信号1</code>和<code>信号2</code>，当二者都发送数据后，这俩数据被整合进一个元组中；</p><p>2.<code>reduce</code>将元组中的数据聚合到它的<code>reduceBlock</code>中，这样我们便有机会对这些数据做进一步的过滤和转换。</p><p>3.处理完的新数据会回调给<code>信号3</code>的订阅者。</p><p><strong>小结</strong>：信号虽无独立的<code>reduce</code>方法，但它与信号的组合结合时，便给了我们修改数据的机会，这就是我把它列入本章节的原因。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对使用者来说，RAC的这些方法可说是很简单了，而这全仰仗<code>bind</code>方法，所以理解<code>bind</code>很关键。</p><p>最底层的<code>bidn</code>方法定义在<code>RACStream</code>中，这是一个基类，其内部对<code>bind</code>方法的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(<span class="hljs-type">void</span>))block &#123;<br><span class="hljs-built_in">NSString</span> *reason = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@ must be overridden by subclasses&quot;</span>, <span class="hljs-built_in">NSStringFromSelector</span>(_cmd)];<br><span class="hljs-keyword">@throw</span> [<span class="hljs-built_in">NSException</span> exceptionWithName:<span class="hljs-built_in">NSInternalInconsistencyException</span> reason:reason userInfo:<span class="hljs-literal">nil</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>这只是一个抽象的实现，具体的实现方式交给了它的各个子类：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_rac_cluster.png" alt="RAC类簇"></p><p>这很好的体现了<code>类簇</code>的思想，值得学习借鉴~</p><p>另外<code>map</code>、<code>filter</code>、<code>reduce</code>这几个方法在 Swift 中都有同名方法，似乎RAC也借鉴了<code>Swift</code>或者<code>RX</code>的一些理念。</p><hr><p>相关参考：</p><p>#<a href="https://github.com/ReactiveCocoa/ReactiveObjC">©RAC-Github</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAC-信号的组合</title>
    <link href="/2021/06/01/RAC-order.html"/>
    <url>/2021/06/01/RAC-order.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目中往往有多个<code>信号</code>在执行任务，而信号之间通常要按一定的方式或顺序进行<code>组合</code>。比如：</p><ul><li>先要用户登录成功才能加载通讯录；</li><li>请求头像和用户信息都完成后才刷新详情页。</li></ul><p>RAC 针对诸如这些场景，设计了一套实用的API供我们组合信号：</p><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">/// Subscribes <span class="hljs-keyword">to</span> `<span class="hljs-keyword">signal</span>` <span class="hljs-keyword">when</span> the source <span class="hljs-keyword">signal</span> completes.<br>- (RACSignal *)concat:(RACSignal *)<span class="hljs-keyword">signal</span> RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><strong>作用:</strong> 拼接信号流，将<code>信号1</code>与<code>信号2</code>拼接成新的信号，<code>信号1</code>状态为<code>Completed</code>时才开始执行<code>信号2</code>中的任务。无论<code>信号1</code>和<code>信号2</code>谁先发送数据，新信号的订阅者最终都只会按<code>信号1</code>先<code>信号2</code>后的顺序收到回调。</p><p>#示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs prolog">- (void)concat &#123;<br>// concat: concat左边的在前，右边的在后，二者发送数据后按照前后顺序分别触发一次新信号订阅者回调<br>    <span class="hljs-symbol">RACSignal</span> *signal1 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;1.1&quot;</span>];<br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;1.2&quot;</span>];<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <span class="hljs-symbol">RACSignal</span> *signal2 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal2 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;2.1&quot;</span>];<br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;2.2&quot;</span>];<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <span class="hljs-symbol">RACSignal</span> *signal3 = [signal1 concat:signal2];<br>    [signal3 subscribeNext:^(id x) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++++received data:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">+++<span class="hljs-keyword">call</span> signal1 <span class="hljs-keyword">block</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">1.1</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">1.2</span><br>+++<span class="hljs-keyword">call</span> signal2 <span class="hljs-keyword">block</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">2.1</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">2.2</span><br></code></pre></td></tr></table></figure><p>说明:</p><p>1.<code>信号1</code>和<code>信号2</code>发送几次数据，<code>信号3</code>订阅者就收到几次数据；</p><p>2.<code>信号3</code>订阅者收到数据的顺序是确定的，按照拼接时的顺序来：<code>信号1</code>先，<code>信号2</code>后；</p><p>3.<code>concat</code>类似于<code>NSOperation</code>的依赖关系，<code>信号2</code>依赖<code>信号1</code>，所以<code>信号2</code>要知道<code>信号1</code>的状态；</p><p>4.<code>信号1</code>在发送完数据之后记得<code>sendCompleted</code>，否则<code>信号2</code>的<code>^didSubscribe</code>不会触发，也就不会执行任务；</p><p>#实现原理：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span>)<span class="hljs-variable">concat</span>:(<span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span>)<span class="hljs-title function_">signal</span> &#123;<br><span class="hljs-comment">// 1.拼接时返回新的信号3</span><br>    <span class="hljs-keyword">return</span> [[<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br><span class="hljs-title class_">RACCompoundDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">compoundDisposable</span> <span class="hljs-operator">=</span> [[<span class="hljs-title class_">RACCompoundDisposable</span> <span class="hljs-variable">alloc</span>] init];<br><span class="hljs-comment">// 2.订阅信号3时立刻订阅信号1</span><br>        <span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">sourceDisposable</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">self</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br><span class="hljs-comment">// 3.信号1 sendNext 后向信号3 的订阅者发送数据</span><br>            [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:<span class="hljs-variable">x</span>];<br>&#125; <span class="hljs-variable">error</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSError</span> *<span class="hljs-params">error</span>) &#123;<br>[<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendError</span>:<span class="hljs-variable">error</span>];<br>&#125; <span class="hljs-variable">completed</span>:<span class="hljs-operator">^</span>&#123;<br><span class="hljs-comment">// 4.信号1 sendConpleted 后调用信号2的 didSubscribe()</span><br>            <span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">concattedDisposable</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">signal</span> <span class="hljs-variable">subscribe</span>:<span class="hljs-variable">subscriber</span>];<br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">addDisposable</span>:<span class="hljs-variable">concattedDisposable</span>];<br>&#125;];<br><br>[<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">addDisposable</span>:<span class="hljs-variable">sourceDisposable</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-variable">compoundDisposable</span>;<br>&#125;] <span class="hljs-variable">setNameWithFormat</span>:@<span class="hljs-string">&quot;[%@] -concat: %@&quot;</span>, <span class="hljs-variable">self</span>.<span class="hljs-property">name</span>, <span class="hljs-variable">signal</span>];<br>&#125;<br><br><span class="hljs-operator">-</span> (<span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span>)<span class="hljs-variable">subscribe</span>:(<span class="hljs-variable">id</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">RACSubscriber</span><span class="hljs-operator">&gt;</span>)<span class="hljs-title function_">subscriber</span> &#123;<br><span class="hljs-title class_">NSCParameterAssert</span>(<span class="hljs-variable">subscriber</span> <span class="hljs-operator">!=</span> <span class="hljs-variable">nil</span>);<br>    <span class="hljs-operator">...</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">self</span>.<span class="hljs-property">didSubscribe</span> <span class="hljs-operator">!=</span> <span class="hljs-variable">NULL</span>) &#123;<br><span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">schedulingDisposable</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACScheduler</span>.<span class="hljs-property">subscriptionScheduler</span> <span class="hljs-variable">schedule</span>:<span class="hljs-operator">^</span>&#123;<br>    <span class="hljs-comment">// 调用信号2的 didSubscribe()</span><br><span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span>innerDisposable <span class="hljs-operator">=</span> <span class="hljs-variable">self</span>.<span class="hljs-property">didSubscribe</span>(<span class="hljs-variable">subscriber</span>);<br>[<span class="hljs-variable">disposable</span> <span class="hljs-variable">addDisposable</span>:innerDisposable];<br>&#125;];<br>[<span class="hljs-variable">disposable</span> <span class="hljs-variable">addDisposable</span>:<span class="hljs-variable">schedulingDisposable</span>];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">disposable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中有注释，具体整理如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_RAC_concat.png" alt="RAC_CONCAT"></p><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">/// Ignores all `next`s from the receiver, waits for the receiver to complete,</span><br><span class="hljs-comment">/// then subscribes to a new signal.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// block - A block which will create or obtain a new signal to subscribe to,</span><br><span class="hljs-comment">///         executed only after the receiver completes. This block must not be</span><br><span class="hljs-comment">///         nil, and it must not return a nil signal.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a signal which will pass through the events of the signal created in</span><br><span class="hljs-comment">/// `block`. If the receiver errors out, the returned signal will error as well.</span><br>- (RACSignal *)then:(RACSignal * (^)(<span class="hljs-type">void</span>))<span class="hljs-built_in">block</span> RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p><strong>作用:</strong> 先执行<code>信号1</code>但过滤掉<code>信号1</code>的数据，再执行<code>信号2</code>的任务并获取其发送的数据。</p><p>#示例2:</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-variable">void</span>)<span class="hljs-title function_">then</span> &#123;<br>    <span class="hljs-comment">// then：信号1先执行，信号2后执行,最后只获取信号2的数据</span><br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal1</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;1.1&quot;</span>];<br>        [[<span class="hljs-title class_">RACScheduler</span> <span class="hljs-variable">mainThreadScheduler</span>] <span class="hljs-variable">afterDelay</span>:<span class="hljs-number">2</span> <span class="hljs-variable">schedule</span>:<span class="hljs-operator">^</span>&#123;<br>            [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;1.2&quot;</span>];<br>            [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>        &#125;];<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">nil</span>;<br>    &#125;];<br>    <br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal2</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span> (<span class="hljs-variable">id</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">RACSubscriber</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">subscriber</span>) &#123;<br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++call signal2 block&quot;</span>);<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;2.1&quot;</span>];<br>        [[<span class="hljs-title class_">RACScheduler</span> <span class="hljs-variable">mainThreadScheduler</span>] <span class="hljs-variable">afterDelay</span>:<span class="hljs-number">2</span> <span class="hljs-variable">schedule</span>:<span class="hljs-operator">^</span>&#123;<br>            [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;2.2&quot;</span>];<br>            [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>        &#125;];<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">nil</span>;<br>    &#125;];<br>    <br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">signal3</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">signal1</span> <span class="hljs-variable">then</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span> &#123;<br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;++++call signal3 then&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">signal2</span>;<br>    &#125;];<br>    <br>    [<span class="hljs-variable">signal3</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-comment">// 4</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;++++received data:%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">+++<span class="hljs-keyword">call</span> signal1 <span class="hljs-keyword">block</span><br>++++<span class="hljs-keyword">call</span> signal3 <span class="hljs-keyword">then</span><br>+++<span class="hljs-keyword">call</span> signal2 <span class="hljs-keyword">block</span><br>++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">2.1</span><br>++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">2.2</span><br></code></pre></td></tr></table></figure><p>说明：</p><p>1.<code>信号1</code>发送的数据自动被过滤掉，<code>信号3</code>订阅者不会收到数据<code>信号1</code>的数据回调；</p><p>2.<code>信号2</code>发送几次数据，<code>信号3</code>的订阅者就收到几次数据；</p><p>3.<code>信号2</code>总是在<code>信号1</code>完成之后，才会开始执行自己的任务；</p><p>#实现原理：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">- (RACSignal *)<span class="hljs-keyword">then</span>:(RACSignal * (^)(void))block &#123;<br>NSCParameterAssert(block != <span class="hljs-literal">nil</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">[[[self</span><br><span class="hljs-string">ignoreValues]</span><br><span class="hljs-string">concat:[RACSignal defer:block]]</span><br>setNameWithFormat:@<span class="hljs-string">&quot;[%@] -then:&quot;</span>, <span class="hljs-built_in">self</span>.name];<br>&#125;<br></code></pre></td></tr></table></figure><p>1.先通过<code>ignoreValues</code>对<code>信号1</code>进行了过滤，忽略掉了它的<code>sendNext:</code>事件，只关注其<code>error</code>和<code>completed</code>事件：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> Ignores all <span class="hljs-string">`next`</span>s from the receiver.<br>/<span class="hljs-regexp">//</span><br>/<span class="hljs-regexp">//</span> Returns a signal which only passes through <span class="hljs-string">`error`</span> <span class="hljs-keyword">or</span> <span class="hljs-string">`completed`</span> events from<br>/<span class="hljs-regexp">//</span> the receiver.<br>- (RACSignal *)ignoreValues <span class="hljs-variable constant_">RAC_WARN_UNUSED_RESULT</span>;<br><br>- (RACSignal *)ignoreValues &#123;<br><span class="hljs-keyword">return</span> [[<span class="hljs-variable language_">self</span> <span class="hljs-symbol">filter:</span>^(id _) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable constant_">NO</span>;<br>&#125;] <span class="hljs-symbol">setNameWithFormat:</span>@<span class="hljs-string">&quot;[%@] -ignoreValues&quot;</span>, <span class="hljs-variable language_">self</span>.name];<br>&#125;<br></code></pre></td></tr></table></figure><p>2.再通过<code>[RACSignal defer:block]]</code>，将<code>信号2</code>封装到一个新信号中：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">/// Defers creation of a signal until the signal&#x27;s actually subscribed to.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This can be used to effectively turn a hot signal into a cold signal.</span><br>+ (RACSignal&lt;ValueType&gt; *)defer:(RACSignal&lt;ValueType&gt; * (^)(<span class="hljs-type">void</span>))<span class="hljs-built_in">block</span> RAC_WARN_UNUSED_RESULT;<br><br>+ (RACSignal *)defer:(RACSignal&lt;id&gt; * (^)(<span class="hljs-type">void</span>))<span class="hljs-built_in">block</span> &#123;<br>NSCParameterAssert(<span class="hljs-built_in">block</span> != NULL);<br><br><span class="hljs-keyword">return</span> [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;<br><span class="hljs-keyword">return</span> [<span class="hljs-built_in">block</span>() subscribe:subscriber];<br>&#125;] setNameWithFormat:@<span class="hljs-string">&quot;+defer:&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>3.最后用<code>concat</code>方法将两个新信号进行拼接，先执行<code>信号1</code>的任务，再开始<code>信号2</code>的任务。</p><p>所以，从本质上来说，<code>then</code>最终调用的还是<code>concat</code>~</p><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Sends the latest `next` from any of the signals.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a signal that passes through values from each of the given signals,</span><br><span class="hljs-comment">/// and sends `completed` when all of them complete. If any signal sends an error,</span><br><span class="hljs-comment">/// the returned signal sends `error` immediately.</span><br><span class="hljs-operator">+</span> (<span class="hljs-type">RACSignal</span>&lt;<span class="hljs-type">ValueType</span>&gt; <span class="hljs-operator">*</span>)merge:(id<span class="hljs-operator">&lt;</span><span class="hljs-type">NSFastEnumeration</span><span class="hljs-operator">&gt;</span>)signals <span class="hljs-type">RAC_WARN_UNUSED_RESULT</span>;<br></code></pre></td></tr></table></figure><p><strong>作用:</strong> 将n个信号整合为新<code>信号x</code>，信号之间不存在依赖关系，任何一个信号发送数据，信号x的订阅者都会收到回调，且遵循FIFO原则，谁先发送数据则订阅者就先收到谁的数据。</p><p>#示例3:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs prolog">- (void)merge &#123;<br>    // merge 谁先sendNext就先收到谁的数据<br>    <span class="hljs-symbol">RACSignal</span> *signal1 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;1.1&quot;</span>];<br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;1.2&quot;</span>];<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <br>    <span class="hljs-symbol">RACSignal</span> *signal2 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal2 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;2.1&quot;</span>];<br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;2.2&quot;</span>];<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <br>    <span class="hljs-symbol">RACSignal</span> *signal3 = [<span class="hljs-symbol">RACSignal</span> merge:@[signal1,signal2]];<br>    <br>    [signal3 subscribeNext:^(id x) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++++received data:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">+++<span class="hljs-keyword">call</span> signal1 <span class="hljs-keyword">block</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">1.1</span><br>+++<span class="hljs-keyword">call</span> signal2 <span class="hljs-keyword">block</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">2.1</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">1.2</span><br>+++++received <span class="hljs-keyword">data</span>:<span class="hljs-number">2.2</span><br></code></pre></td></tr></table></figure><p>说明：</p><p>1.<code>merge</code>将<code>信号1</code>和<code>信号2</code>整合到<code>信号3</code>中，1、2之间不会相互影响；</p><p>2.<code>信号1</code>和<code>信号2</code>发送新数据时，<code>信号3</code>都能收到新数据；</p><p>#实现原理</p><p>从最底层的实现上来讲，merge使用了RAC的<code>-bind:</code>方法，接下来一步步来看：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">RACSignal *signal3 = <span class="hljs-comment">[RACSignal merge:@<span class="hljs-comment">[signal1,signal2]</span>]</span>;<br></code></pre></td></tr></table></figure><p>这里我们调用了<code>merge</code>，将<code>信号1</code>和<code>信号2</code>合并，来看看方法内部具体做了啥：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">+</span> (<span class="hljs-type">RACSignal</span> <span class="hljs-operator">*</span>)merge:(id<span class="hljs-operator">&lt;</span><span class="hljs-type">NSFastEnumeration</span><span class="hljs-operator">&gt;</span>)signals &#123;<br>    <span class="hljs-type">NSMutableArray</span> <span class="hljs-operator">*</span>copiedSignals <span class="hljs-operator">=</span> [[<span class="hljs-type">NSMutableArray</span> alloc] <span class="hljs-keyword">init</span>];<br>    <span class="hljs-comment">// 1.将信号1和信号2保存到一个数组中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">RACSignal</span> <span class="hljs-operator">*</span>signal <span class="hljs-keyword">in</span> signals) &#123;<br>        [copiedSignals addObject:signal];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> [[[<span class="hljs-type">RACSignal</span> <span class="hljs-comment">// 2.创建信号4</span><br>        createSignal:<span class="hljs-operator">^</span> <span class="hljs-type">RACDisposable</span> <span class="hljs-operator">*</span> (id<span class="hljs-operator">&lt;</span><span class="hljs-type">RACSubscriber</span><span class="hljs-operator">&gt;</span> subscriber) &#123; <span class="hljs-comment">//将此block命名为^didSubscribe4</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">RACSignal</span> <span class="hljs-operator">*</span>signal <span class="hljs-keyword">in</span> copiedSignals) &#123;<br>                <span class="hljs-comment">// 发送信号1和信号2（注意这与我们自己使用时发送的字符串之类的不同，它发送的是信号类型）</span><br>                [subscriber sendNext:signal];<br>            &#125;<br><br>            [subscriber sendCompleted];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;]<br>        flatten]<span class="hljs-comment">// 3.信号4调用了 flatten 方法</span><br>        setNameWithFormat:@<span class="hljs-string">&quot;+merge: %@&quot;</span>, copiedSignals];<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>信号4</code>看上去是一个挺简单的信号，主要作用就是向订阅者发送<code>信号1</code>和<code>信号2</code>。<code>信号4</code>调用了<code>flatten</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ruby">- (__kindof RACStream *)flatten &#123;<br>    <span class="hljs-regexp">//</span>我将此方法的参数命名为 mapBlock 方便后续解释此处代码<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-variable language_">self</span> <span class="hljs-symbol">flattenMap:</span>^(id value) &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;] <span class="hljs-symbol">setNameWithFormat:</span>@<span class="hljs-string">&quot;[%@] -flatten&quot;</span>, <span class="hljs-variable language_">self</span>.name];<br>&#125;<br><br>- (__kindof RACStream *)<span class="hljs-symbol">flattenMap:</span>(__kindof RACStream * (^)(id value))block &#123;<br>    Class <span class="hljs-keyword">class</span> = <span class="hljs-variable language_">self</span>.<span class="hljs-keyword">class</span>;<br><br>    <span class="hljs-keyword">return</span> [[<span class="hljs-variable language_">self</span> <span class="hljs-symbol">bind:</span>^&#123;<br>    <span class="hljs-regexp">//bind</span>的参数为一个block 此block类型为：RACSignalBindBlock (^)(void)，即无参数，返回一个RACSignalBindBlock类型的bindingBlock<br>        <span class="hljs-keyword">return</span> ^(id value, <span class="hljs-variable constant_">BOOL</span> *stop) &#123;<br>            id stream = block(value) <span class="hljs-string">?:</span> [<span class="hljs-keyword">class</span> empty];<br>            NSCAssert([stream <span class="hljs-symbol">isKindOfClass:</span>RACStream.<span class="hljs-keyword">class</span>], @<span class="hljs-string">&quot;Value returned from -flattenMap: is not a stream: %@&quot;</span>, stream);<br><br>            <span class="hljs-keyword">return</span> stream;<br>        &#125;;<br>    &#125;] <span class="hljs-symbol">setNameWithFormat:</span>@<span class="hljs-string">&quot;[%@] -flattenMap:&quot;</span>, <span class="hljs-variable language_">self</span>.name];<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>flatten</code>方法内部最终是调用了<code>bind</code>方法，即<code>信号4</code>调用了<code>bind</code>方法。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span>)<span class="hljs-variable">bind</span>:(<span class="hljs-title class_">RACSignalBindBlock</span> (<span class="hljs-operator">^</span>)(<span class="hljs-variable">void</span>))<span class="hljs-title function_">block</span> &#123;<br>    <span class="hljs-title class_">NSCParameterAssert</span>(<span class="hljs-variable">block</span> <span class="hljs-operator">!=</span> <span class="hljs-variable">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> [[<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<span class="hljs-comment">//将此block命名为^didSubscribe3</span><br>        <span class="hljs-comment">// 1.创建并返回新信号（即示例中的信号3）</span><br>        <span class="hljs-title class_">RACSignalBindBlock</span> <span class="hljs-variable">bindingBlock</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">block</span>();<br>        <span class="hljs-comment">// 2.获取bind方法的参数 block 的返回值“bindingBlock”</span><br><br>        <span class="hljs-variable">__block</span> <span class="hljs-variable">volatile</span> int32_t <span class="hljs-variable">signalCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;   <span class="hljs-comment">// indicates self</span><br><br>        <span class="hljs-title class_">RACCompoundDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">compoundDisposable</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACCompoundDisposable</span> <span class="hljs-variable">compoundDisposable</span>];<br><br>        <span class="hljs-comment">// 定义completeSignal block，处理信号完成事件</span><br>        <span class="hljs-title function_">void</span> (<span class="hljs-operator">^</span><span class="hljs-variable">completeSignal</span>)(<span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span>) <span class="hljs-operator">=</span> <span class="hljs-title function_">^</span>(<span class="hljs-params">RACDisposable</span> *<span class="hljs-params">finishedDisposable</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">OSAtomicDecrement</span>32Barrier(<span class="hljs-operator">&amp;</span><span class="hljs-variable">signalCount</span>) <span class="hljs-operator">==</span> <span class="hljs-number">0</span>) &#123;<br>                [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>                [<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">dispose</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                [<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">removeDisposable</span>:<span class="hljs-variable">finishedDisposable</span>];<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 定义addSignal block，处理传进来的信号参数</span><br>        <span class="hljs-title function_">void</span> (<span class="hljs-operator">^</span><span class="hljs-variable">addSignal</span>)(<span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span>) <span class="hljs-operator">=</span> <span class="hljs-title function_">^</span>(<span class="hljs-params">RACSignal</span> *<span class="hljs-params">signal</span>) &#123;<br>            <span class="hljs-title class_">OSAtomicIncrement</span>32Barrier(<span class="hljs-operator">&amp;</span><span class="hljs-variable">signalCount</span>);<br><br>            <span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">selfDisposable</span> <span class="hljs-operator">=</span> [[<span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-variable">alloc</span>] init];<br>            [<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">addDisposable</span>:<span class="hljs-variable">selfDisposable</span>];<br><br>            <span class="hljs-comment">// 8.订阅传进来的信号（信号1和信号2）</span><br>            <span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">disposable</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">signal</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123; <span class="hljs-comment">//将此block命名为^sendNext1/^sendNext2</span><br>                <span class="hljs-comment">// 9.信号1和信号2发送数据时，向信号3的订阅者subscriber发送数据</span><br>                [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:<span class="hljs-variable">x</span>];<br>            &#125; <span class="hljs-variable">error</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSError</span> *<span class="hljs-params">error</span>) &#123;<br>                [<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">dispose</span>];<br>                [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendError</span>:<span class="hljs-variable">error</span>];<br>            &#125; <span class="hljs-variable">completed</span>:<span class="hljs-operator">^</span>&#123;<br>                @<span class="hljs-title function_">autoreleasepool</span> &#123;<br>                    <span class="hljs-title function_">completeSignal</span>(<span class="hljs-variable">selfDisposable</span>);<br>                &#125;<br>            &#125;];<br><br>            <span class="hljs-variable">selfDisposable</span>.<span class="hljs-property">disposable</span> <span class="hljs-operator">=</span> <span class="hljs-variable">disposable</span>;<br>        &#125;;<br><br>        @<span class="hljs-title function_">autoreleasepool</span> &#123;<br>            <span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">selfDisposable</span> <span class="hljs-operator">=</span> [[<span class="hljs-title class_">RACSerialDisposable</span> <span class="hljs-variable">alloc</span>] init];<br>            [<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">addDisposable</span>:<span class="hljs-variable">selfDisposable</span>];<br><br>            <span class="hljs-comment">// 3.订阅信号4 这里的 self 是信号4</span><br>            <span class="hljs-title class_">RACDisposable</span> <span class="hljs-operator">*</span><span class="hljs-variable">bindingDisposable</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">self</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<span class="hljs-comment">// 将此block命名为^sendNext4</span><br><br>                <span class="hljs-comment">// 4.信号4 ^didSubscribe4 中[sendNext(信号1/信号2))]触发此处回调</span><br>                <span class="hljs-comment">// Manually check disposal to handle synchronous errors.</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">compoundDisposable</span>.<span class="hljs-property">disposed</span>) <span class="hljs-keyword">return</span>;<br><br>                <br>                <span class="hljs-variable">BOOL</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-variable">NO</span>;<br>                <span class="hljs-comment">// 5.调用bindingBlock，参数x为信号4发送的数据（信号1和信号2）</span><br>                <span class="hljs-variable">id</span> <span class="hljs-variable">signal</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">bindingBlock</span>(<span class="hljs-variable">x</span>, <span class="hljs-operator">&amp;</span><span class="hljs-variable">stop</span>);<br><br>                <span class="hljs-comment">// 6.bindingBlock中调用了 mapBlock(value)，最终返回了value，即信号1和信号2</span><br><br>                @<span class="hljs-title function_">autoreleasepool</span> &#123;<br>                    <span class="hljs-comment">// 7.执行addSignal()</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable">signal</span> <span class="hljs-operator">!=</span> <span class="hljs-variable">nil</span>) <span class="hljs-title function_">addSignal</span>(<span class="hljs-variable">signal</span>);<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-variable">signal</span> <span class="hljs-operator">==</span> <span class="hljs-variable">nil</span> <span class="hljs-operator">||</span> <span class="hljs-variable">stop</span>) &#123;<br>                        [<span class="hljs-variable">selfDisposable</span> <span class="hljs-variable">dispose</span>];<br>                        <span class="hljs-title function_">completeSignal</span>(<span class="hljs-variable">selfDisposable</span>);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-variable">error</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSError</span> *<span class="hljs-params">error</span>) &#123;<br>                [<span class="hljs-variable">compoundDisposable</span> <span class="hljs-variable">dispose</span>];<br>                [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendError</span>:<span class="hljs-variable">error</span>];<br>            &#125; <span class="hljs-variable">completed</span>:<span class="hljs-operator">^</span>&#123;<br>                @<span class="hljs-title function_">autoreleasepool</span> &#123;<br>                    <span class="hljs-title function_">completeSignal</span>(<span class="hljs-variable">selfDisposable</span>);<br>                &#125;<br>            &#125;];<br><br>            <span class="hljs-variable">selfDisposable</span>.<span class="hljs-property">disposable</span> <span class="hljs-operator">=</span> <span class="hljs-variable">bindingDisposable</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">compoundDisposable</span>;<br>    &#125;] <span class="hljs-variable">setNameWithFormat</span>:@<span class="hljs-string">&quot;[%@] -bind:&quot;</span>, <span class="hljs-variable">self</span>.<span class="hljs-property">name</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>bind方法里的代码逻辑，结合我在上面的标注来看：</p><p>1.<code>信号4</code>调用<code>bind</code>方法后，<code>bind</code>内部先创建了一个新的信号并沿着调用路径层层往上返回给调用者，最终这个新信号的接收者正是我们在最开始执行”[RACSignal merge:@[signal1,signal2]]”时的<code>signal3</code>，即<code>信号3</code>。在示例3中订阅<code>信号3</code>之后，触发其<code>^didSubscribe3</code>，也就是<code>bind</code>方法内新建信号后面的那个大 block。</p><p>2.<code>^didSubscribe3</code>先调用了<code>bind</code>的 block参数，返回了一个<code>bindingBlock</code>备用；</p><p>3.紧接着订阅了<code>信号4</code>，从而触发<code>^didSubscribe4</code>；</p><p>4.<code>^didSubscribe4</code>通过 for循环将<code>信号1</code>和<code>信号2</code>作为数据发送给订阅者<code>^sendNext4</code>；</p><p>5.<code>^sendNext4</code>中调用<code>bindingBlock</code>，其参数为<code>信号4</code>传来的<code>信号1</code>和<code>信号2</code>；</p><p>6.<code>bindingBlock</code>内调用了<code>block(value)</code>，即回调了<code>flattenMap</code>方法的 mapBlock，最终返回了<code>value</code>（信号1和信号2）；</p><p>7.<code>^sendNext4</code>继续调用<code>addSignal(信号1/信号2)</code>；</p><p>8.<code>addSignal()</code>内部实现是订阅传进来的信号，即订阅了<code>信号1</code>和<code>信号2</code>；</p><p>9.到这一步<code>bind</code>已经万事俱备，只等接收数据了。当<code>信号1</code>和<code>信号2</code>产生新数据时，<code>^sendNext1/^sendNext2</code>会自动触发；</p><p>10.<code>^sendNext1/^sendNext2</code>内通过<code>^didSubscribe3</code>将数据回调给订阅者，因为<code>^didSubscribe3</code>本身代表的是信号3的订阅，所以<code>信号1</code>和<code>信号2</code>的数据最终传递给了<code>信号3</code>的订阅者，即我们在示例3中定义好的 block 中；</p><p><strong>小结：</strong> 以上就是<code>merge</code>方法的具体实现，简单来说就是<code>merge</code>操作得到的新信号，通过<code>bind</code>方法在内部订阅了被<code>merge</code>的子信号；子信号产生一份数据时新信号就会收到一份新数据。所以想要更好的理解<code>merge</code>方法，就要先理解<code>bind</code>方法。</p><p>附赠我用思维导图整理的<code>merge</code>实现：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_signal_merge.png" alt="信号绑定"></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Zips the values in the given signals to create RACTuples.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// The first value of each signals will be combined, then the second value, and</span><br><span class="hljs-comment">/// so forth, until at least one of the signals is exhausted.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// signals - The signals to combine. If this collection is empty, the returned</span><br><span class="hljs-comment">///           signal will be empty.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a new signal containing RACTuples of the zipped values from the</span><br><span class="hljs-comment">/// signals.</span><br><span class="hljs-operator">+</span> (<span class="hljs-type">RACSignal</span>&lt;<span class="hljs-type">RACTuple</span> *&gt; <span class="hljs-operator">*</span>)zip:(id<span class="hljs-operator">&lt;</span><span class="hljs-type">NSFastEnumeration</span><span class="hljs-operator">&gt;</span>)signals <span class="hljs-type">RAC_WARN_UNUSED_RESULT</span>;<br></code></pre></td></tr></table></figure><p><strong>作用:</strong> 将n个信号打包进一个新信号中，当所有子信号都<code>sendNext</code>之后，新信号将接收到的数据组合在一个<code>元组</code>中，值在元组中的排序按照打包信号时的顺序来。</p><p>#示例4:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs prolog">- (void)zip &#123;<br>    // zip: 合并n个信号的值到一个元组中，哪个信号在前哪个信号的值就在元组中靠前<br>    <span class="hljs-symbol">RACSignal</span> *signal1 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;1&quot;</span>];<br>        [subscriber sendCompleted];<br>        return nil;<br>    &#125;];<br>    <br>    <span class="hljs-symbol">RACSignal</span> *signal2 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal2 block&quot;</span>);<br>        <br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">1</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;2.1&quot;</span>];<br>        &#125;];<br>        <br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;2.2&quot;</span>];<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <br>    <span class="hljs-symbol">RACSignal</span> *signal3 = [<span class="hljs-symbol">RACSignal</span> zip:@[signal1,signal2]];<br>    <br>    [signal3 subscribeNext:^(id x) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++++received data:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs wasm">+++<span class="hljs-keyword">call</span> signal1 <span class="hljs-keyword">block</span><br>+++<span class="hljs-keyword">call</span> signal2 <span class="hljs-keyword">block</span><br>+++++received <span class="hljs-keyword">data</span>:&lt;RACTuple: <span class="hljs-number">0x7ff33e4bbab0</span>&gt; <span class="hljs-punctuation">(</span><br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;2.1&quot;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>说明：</p><p>1.<code>信号3</code>的订阅者要在组合中的信号都<code>sendNext:</code>之后才会收到回调的元组；</p><p>2.<code>信号3</code>元组中数据的顺序与组合时信号的顺序排列一致；</p><p>3.<code>信号3</code>的订阅者是一次性的，收到一次数据后，不论源信号再发送几次数据，它都不再接收。</p><p><code>zip</code>可用来整合网络请求，例如当需要同时发送N个请求，只有这N个请求都成功后，才将这N个的结果整合起来继续往下处理。</p><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// Combines the latest values from the given signals into RACTuples, once all</span><br><span class="hljs-comment">/// the signals have sent at least one `next`.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Any additional `next`s will result in a new RACTuple with the latest values</span><br><span class="hljs-comment">/// from all signals.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// signals - The signals to combine. If this collection is empty, the returned</span><br><span class="hljs-comment">///           signal will immediately complete upon subscription.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Returns a signal which sends RACTuples of the combined values, forwards any</span><br><span class="hljs-comment">/// `error` events, and completes when all input signals complete.</span><br><span class="hljs-operator">+</span> (<span class="hljs-type">RACSignal</span>&lt;<span class="hljs-type">RACTuple</span> *&gt; <span class="hljs-operator">*</span>)combineLatest:(id<span class="hljs-operator">&lt;</span><span class="hljs-type">NSFastEnumeration</span><span class="hljs-operator">&gt;</span>)signals <span class="hljs-type">RAC_WARN_UNUSED_RESULT</span>;<br></code></pre></td></tr></table></figure><p><strong>作用:</strong> 将多个信号的<code>最新值</code>组合到新信号的一个<code>元组</code>中，直到所有的信号都<code>sendNext</code>之后，新信号的订阅者才能收到此元组。</p><p>#示例5:</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs prolog">- (void)combineLatest &#123;<br>    <span class="hljs-symbol">RACSignal</span> *signal1 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal1 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;1&quot;</span>];<br>        [subscriber sendCompleted];<br>        return nil;<br>    &#125;];<br>    <br>    <span class="hljs-symbol">RACSignal</span> *signal2 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal2 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;2.1&quot;</span>];<br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;2.2&quot;</span>];<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <br>    <span class="hljs-symbol">RACSignal</span> *signal3 = [<span class="hljs-symbol">RACSignal</span> createSignal:^<span class="hljs-symbol">RACDisposable</span> *(id&lt;<span class="hljs-symbol">RACSubscriber</span>&gt; subscriber) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++call signal3 block&quot;</span>);<br>        [subscriber sendNext:@<span class="hljs-string">&quot;3.1&quot;</span>];<br>        [[<span class="hljs-symbol">RACScheduler</span> mainThreadScheduler] afterDelay:<span class="hljs-number">2</span> schedule:^&#123;<br>            [subscriber sendNext:@<span class="hljs-string">&quot;3.2&quot;</span>];<br>            [subscriber sendCompleted];<br>        &#125;];<br>        return nil;<br>    &#125;];<br>    <br>    <span class="hljs-symbol">RACSignal</span> *signal4 = [<span class="hljs-symbol">RACSignal</span> combineLatest:@[signal1,signal2,signal3]];<br>    <br>    [signal4 subscribeNext:^(id x) &#123;<br>        <span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;+++++received data:%@&quot;</span>,x);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志:</p><figure class="highlight wasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs wasm"><span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">08.894</span> +++<span class="hljs-keyword">call</span> signal1 <span class="hljs-keyword">block</span><br><span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">08.895</span> +++<span class="hljs-keyword">call</span> signal2 <span class="hljs-keyword">block</span><br><span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">08.895</span> +++<span class="hljs-keyword">call</span> signal3 <span class="hljs-keyword">block</span><br><span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">08.896</span> +++++received <span class="hljs-keyword">data</span>:&lt;RACTuple: <span class="hljs-number">0x7ff33e49e300</span>&gt; <span class="hljs-punctuation">(</span><br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;2.1&quot;</span>,<br>    <span class="hljs-string">&quot;3.1&quot;</span><br><span class="hljs-punctuation">)</span><br><span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10.895</span> +++++received <span class="hljs-keyword">data</span>:&lt;RACTuple: <span class="hljs-number">0x7ff33e4db8d0</span>&gt; <span class="hljs-punctuation">(</span><br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;2.2&quot;</span>,<br>    <span class="hljs-string">&quot;3.1&quot;</span><br><span class="hljs-punctuation">)</span><br><span class="hljs-number">02</span>:<span class="hljs-number">30</span>:<span class="hljs-number">11.094</span> +++++received <span class="hljs-keyword">data</span>:&lt;RACTuple: <span class="hljs-number">0x7ff33e6e79f0</span>&gt; <span class="hljs-punctuation">(</span><br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;2.2&quot;</span>,<br>    <span class="hljs-string">&quot;3.2&quot;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>这里需要说明的是：</p><p>1.<code>信号4</code>订阅者的元组中数据的顺序，是按照组合时的顺序来的；</p><p>2.<code>信号4</code>的订阅者第一次触发是在所有信号都发送了一遍<code>sendNext:</code>之后；</p><p>3.之后如果再有某个信号<code>sendNext:</code>，<code>信号4</code>都会再次触发并返回最新值组成的元组，这是它与<code>zip</code>的最大不同；</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>以上就是RAC中几种常用组合信号的方法，可以根据业务需求任意组合操作，很强大、方便。</p><hr><p>相关参考：</p><p>#<a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/BasicOperators.md">©RAC-Github</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAC-异步行为</title>
    <link href="/2021/05/25/RAC-async.html"/>
    <url>/2021/05/25/RAC-async.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>OC中的异步行为：</p><ul><li>block</li><li>delegate</li><li>KVO</li><li>通知</li><li>target-action机制</li></ul><p>异步行为的共同点：</p><ul><li>何时触发并不确定，观察者需要等待其触发时的回调；</li><li>异步行为的创建和触发并不在同一块区域，往往是分开的。</li></ul><p>异步行为的缺点：</p><ul><li>异步行为的创建和回调相对分散，这不符合代码规范中”高内聚”的要求；</li><li>使用不当时，这些行为往往会造成循环引用等问题。</li></ul><p><a href="https://github.com/ReactiveCocoa/ReactiveObjC">RAC文档</a> 摘要：</p><blockquote><p>One of the major advantages of RAC is that it provides a single, unified approach to dealing with asynchronous behaviors, including delegate methods, callback blocks, target-action mechanisms, notifications, and KVO.</p></blockquote><p>RAC 借鉴了<a href="https://github.com/ReactiveX">RX</a>的思想，它处理这些问题的核心在于<code>信号</code>：</p><p>针对内聚问题，RAC将异步行为的实现封装在信号的<code>didSubscribe</code>block 中，从而能对外提供统一的接口。我们只需要在创建完信号后订阅信号，即可在异步行为触发时收到回调，这样创建、监听、业务逻辑聚合到了一起；</p><p>针对第二点，信号的 block 内向订阅者发送了<code>sendNext:</code>事件后，会自动清理资源和引用，从而解决了循环引用问题。</p><p>下面将分别介绍它们的使用和实现原理。</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>block 创建完成后在随后的某个时间点被调用，执行其内部定义的业务。RAC中block的使用如下：</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span>&lt;RACSubscriber&gt; subscriber;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <br>    <span class="hljs-comment">//1.信号的使用</span><br>    RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(<span class="hljs-type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;<br>        _subscriber = subscriber;<br>        <span class="hljs-keyword">return</span> [RACDisposable disposableWithBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++s1 Disposed~&quot;</span>);<br>        &#125;];<br>    &#125;];<br>    <br>    <span class="hljs-comment">//订阅消息，创建block</span><br>    [s1 subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++订阅触发:%@&quot;</span>,x);<br>    &#125;];<br>    <span class="hljs-comment">//调用block</span><br>    [_subscriber sendNext:<span class="hljs-string">@&quot;Hello world~&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>执行[s1 subscribeNext:]订阅信号时，我们传入了一个 nextBlock，它会被保存起来以在后续被调用。subscribeNext:的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//RACSignal.m</span><br>- (RACDisposable *)subscribeNext:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> x))nextBlock &#123;<br><span class="hljs-built_in">NSCParameterAssert</span>(nextBlock != <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//1.创建订阅者</span><br>RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="hljs-literal">NULL</span> completed:<span class="hljs-literal">NULL</span>];<br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> subscribe:o];<br>&#125;<br><br><span class="hljs-comment">//RACSubscriber.m</span><br>+ (<span class="hljs-keyword">instancetype</span>)subscriberWithNext:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> x))next error:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSError</span> *error))error completed:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">void</span>))completed &#123;<br>RACSubscriber *subscriber = [[<span class="hljs-keyword">self</span> alloc] init];<br><br><span class="hljs-comment">//2.保存 block</span><br>subscriber-&gt;_next = [next <span class="hljs-keyword">copy</span>]; <br>subscriber-&gt;_error = [error <span class="hljs-keyword">copy</span>];<br>subscriber-&gt;_completed = [completed <span class="hljs-keyword">copy</span>];<br><br><span class="hljs-keyword">return</span> subscriber;<br>&#125;<br></code></pre></td></tr></table></figure><p>信号内部自动创建了一个<code>订阅者</code>对象，并将我们传入的 nextBlock 保存了起来。</p><p>随后在示例中我们调用了[_subscriber sendNext:]，其实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)sendNext:(<span class="hljs-type">id</span>)value &#123;<br><span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br><span class="hljs-type">void</span> (^nextBlock)(<span class="hljs-type">id</span>) = [<span class="hljs-keyword">self</span>.next <span class="hljs-keyword">copy</span>];<br><span class="hljs-keyword">if</span> (nextBlock == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span>;<br>nextBlock(value);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>即调用 sendNext: 相当于调用了之前保存在订阅者内部的<code>nextBlock</code>并向其输入了一个新值。</p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *text;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    [[<span class="hljs-keyword">self</span> rac_valuesAndChangesForKeyPath:<span class="hljs-string">@&quot;text&quot;</span><br>                                  options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span><br>                                 observer:<span class="hljs-keyword">self</span>]<br>     subscribeNext:^(RACTwoTuple&lt;<span class="hljs-type">id</span>,<span class="hljs-built_in">NSDictionary</span> *&gt; *x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++self.text update:%@&quot;</span>,x.first);<br>    &#125;];<br>    <br>    <span class="hljs-keyword">self</span>.text = <span class="hljs-string">@&quot;Text1&quot;</span>;<br>    _text = <span class="hljs-string">@&quot;Text2&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">++self.text <span class="hljs-keyword">update</span>:Text1<br></code></pre></td></tr></table></figure><p>注意：要使用<code>self.xxx</code>来赋值，下划线的方式是给成员变量直接赋值，并不会触发KVO回调~~</p><ul><li><strong>RAC的KVO实现原理：</strong></li></ul><p>RAC 版的 KVO 与 OC 版的差别并不大，rac_valuesAndChangesForKeyPath:options:observer:方法是RAC在 NSObject 分类中定义的一个方法。它的返回值是一个信号，供我们订阅并自定义回调block。其内部最终是通过<code>RACKVOTrampoline</code>来管理和实现KVO的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//RACKVOTrampoline.m</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithTarget:(__<span class="hljs-keyword">weak</span> <span class="hljs-built_in">NSObject</span> *)target <br>observer:(__<span class="hljs-keyword">weak</span> <span class="hljs-built_in">NSObject</span> *)observer <br>keyPath:(<span class="hljs-built_in">NSString</span> *)keyPath <br>options:(<span class="hljs-built_in">NSKeyValueObservingOptions</span>)options <br>block:(RACKVOBlock)block &#123;<br><br><span class="hljs-built_in">NSCParameterAssert</span>(keyPath != <span class="hljs-literal">nil</span>);<br><span class="hljs-built_in">NSCParameterAssert</span>(block != <span class="hljs-literal">nil</span>);<br><br><span class="hljs-built_in">NSObject</span> *strongTarget = target;<br><span class="hljs-keyword">if</span> (strongTarget == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br><span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br><br>_keyPath = [keyPath <span class="hljs-keyword">copy</span>];<br><br>_block = [block <span class="hljs-keyword">copy</span>];<br>_weakTarget = target;<br>_unsafeTarget = strongTarget;<br>_observer = observer;<br><br>[RACKVOProxy.sharedProxy addObserver:<span class="hljs-keyword">self</span> forContext:(__bridge <span class="hljs-type">void</span> *)<span class="hljs-keyword">self</span>];<br>[strongTarget addObserver:RACKVOProxy.sharedProxy forKeyPath:<span class="hljs-keyword">self</span>.keyPath options:options context:(__bridge <span class="hljs-type">void</span> *)<span class="hljs-keyword">self</span>];<br><br>[strongTarget.rac_deallocDisposable addDisposable:<span class="hljs-keyword">self</span>];<br>[<span class="hljs-keyword">self</span>.observer.rac_deallocDisposable addDisposable:<span class="hljs-keyword">self</span>];<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span> *)change context:(<span class="hljs-type">void</span> *)context &#123;<br><span class="hljs-keyword">if</span> (context != (__bridge <span class="hljs-type">void</span> *)<span class="hljs-keyword">self</span>) &#123;<br>[<span class="hljs-variable language_">super</span> observeValueForKeyPath:keyPath ofObject:object change:change context:context];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>RACKVOBlock block;<br><span class="hljs-type">id</span> observer;<br><span class="hljs-type">id</span> target;<br><br><span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>block = <span class="hljs-keyword">self</span>.block;<br>observer = <span class="hljs-keyword">self</span>.observer;<br>target = <span class="hljs-keyword">self</span>.weakTarget;<br>&#125;<br><br><span class="hljs-keyword">if</span> (block == <span class="hljs-literal">nil</span> || target == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span>;<br><br>block(target, observer, change);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RACKVOTrampoline</code>将我们传入的<code>observer</code>和<code>target</code>及回调<code>block</code>保存了起来。属性变化后KVO代理中回调了 block 并传回变化的信息。</p><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><p>KVC本身不算异步行为，因为OC中调用[self valueForKey:@”text”]后，能立刻得到<code>text</code>属性的值。但是 RAC 还是对其进行了封装和扩展，使得 KVC 既能立刻获取属性的值，又能和 KVO 一样持续收到属性变化的回调。</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *text;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    [[<span class="hljs-keyword">self</span> rac_valuesForKeyPath:<span class="hljs-string">@&quot;text&quot;</span> observer:<span class="hljs-keyword">self</span>] subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++self.text By KVC:%@&quot;</span>,x);<br>    &#125;];<br>    <br>    <span class="hljs-keyword">self</span>.text = <span class="hljs-string">@&quot;Text1&quot;</span>;<br>    _text = <span class="hljs-string">@&quot;Text2&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">++++<span class="hljs-built_in">self</span>.text <span class="hljs-keyword">By</span> KVC:(<span class="hljs-built_in">null</span>)<br>++++<span class="hljs-built_in">self</span>.text <span class="hljs-keyword">By</span> KVC:Text1<br></code></pre></td></tr></table></figure><p>调用 rac_valuesForKeyPath: 并订阅信号后，立刻收到了一次回调，返回属性的当前值<code>null</code>；</p><p>调用 self.text &#x3D; @”Text1” 给属性赋值后，订阅者的回调再次触发并传回当前的新值。</p><p>调用 _text &#x3D; @”Text2” 给属性的成员变量赋值时，并未触发订阅者回调，这与 RAC 的 KVO 一样。</p><p>结合这些情况来看，RAC 的 KVC 似乎与其 KVO 有密切关系，那么我们来看看其方法的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (RACSignal *)rac_valuesForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath observer:(__<span class="hljs-keyword">weak</span> <span class="hljs-built_in">NSObject</span> *)observer &#123;<br><span class="hljs-keyword">return</span> [[[<span class="hljs-keyword">self</span><br>rac_valuesAndChangesForKeyPath:keyPath options:<span class="hljs-built_in">NSKeyValueObservingOptionInitial</span> observer:observer]<br>map:^(RACTuple *value) &#123;<br><span class="hljs-comment">// -map: because it doesn&#x27;t require the block trampoline that -reduceEach: uses</span><br><span class="hljs-keyword">return</span> value[<span class="hljs-number">0</span>];<br>&#125;]<br>setNameWithFormat:<span class="hljs-string">@&quot;RACObserve(%@, %@)&quot;</span>, RACDescription(<span class="hljs-keyword">self</span>), keyPath];<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，RAC 的 KVC 内部只是调用了其 KVO 方法并返回元组的第一个值。这就不难理解上面的猜测了~</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[[[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] rac_addObserverForName:<span class="hljs-built_in">UIKeyboardWillShowNotification</span><br>                                                       object:<span class="hljs-literal">nil</span>]<br>subscribeNext:^(<span class="hljs-built_in">NSNotification</span> *x) &#123;<br>     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++通知:%@&quot;</span>,x);<br>&#125;];<br></code></pre></td></tr></table></figure><p>监听键盘通知并订阅其返回的信号，待键盘弹出或收回时即可触发订阅者的回调。其实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@implementation NSNotificationCenter (<span class="hljs-params">RACSupport</span>)</span><br><br>- (RACSignal *)rac_addObserverForName:(NSString *)notificationName <span class="hljs-built_in">object</span>:(<span class="hljs-built_in">id</span>)<span class="hljs-built_in">object</span> &#123;<br><span class="hljs-meta">@unsafeify(<span class="hljs-params"><span class="hljs-built_in">object</span></span>);</span><br><span class="hljs-keyword">return</span> [[RACSignal createSignal:^(<span class="hljs-built_in">id</span>&lt;RACSubscriber&gt; subscriber) &#123;<br><span class="hljs-meta">@strongify(<span class="hljs-params"><span class="hljs-built_in">object</span></span>);</span><br><span class="hljs-built_in">id</span> observer = [self addObserverForName:notificationName <span class="hljs-built_in">object</span>:<span class="hljs-built_in">object</span> queue:nil usingBlock:^(NSNotification *note) &#123;<br>[subscriber sendNext:note];<br>&#125;];<br><br><span class="hljs-keyword">return</span> [RACDisposable disposableWithBlock:^&#123;<br>[self removeObserver:observer];<br>&#125;];<br>&#125;] setNameWithFormat:@<span class="hljs-string">&quot;-rac_addObserverForName: %@ object: &lt;%@: %p&gt;&quot;</span>, notificationName, [<span class="hljs-built_in">object</span> <span class="hljs-keyword">class</span>], <span class="hljs-built_in">object</span>];<br>&#125;<br><span class="hljs-meta">@end</span><br></code></pre></td></tr></table></figure><p>在RAC对 NSNotificationCenter 的扩展中，监听通知后实际上只是调用了OC原生的通知监听方法，在原生回调中向订阅者发送消息~</p><h3 id="target-action"><a href="#target-action" class="headerlink" title="target-action"></a>target-action</h3><p>#示例:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[[<span class="hljs-name">_mBtn1</span> rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(<span class="hljs-name">UIControl</span> *x) &#123;<br>    NSLog(<span class="hljs-name">@</span><span class="hljs-string">&quot;++clicked Btn1~&quot;</span>)<span class="hljs-comment">;</span><br>&#125;]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其内部实现为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@implementation</span> <span class="hljs-type">UIControl</span> (<span class="hljs-type">RACSignalSupport</span>)<br><br><span class="hljs-operator">-</span> (<span class="hljs-type">RACSignal</span> <span class="hljs-operator">*</span>)rac_signalForControlEvents:(<span class="hljs-type">UIControlEvents</span>)controlEvents &#123;<br><span class="hljs-meta">@weakify</span>(<span class="hljs-keyword">self</span>);<br><br><span class="hljs-keyword">return</span> [[<span class="hljs-type">RACSignal</span><br>createSignal:<span class="hljs-operator">^</span>(id<span class="hljs-operator">&lt;</span><span class="hljs-type">RACSubscriber</span><span class="hljs-operator">&gt;</span> subscriber) &#123;<br><span class="hljs-meta">@strongify</span>(<span class="hljs-keyword">self</span>);<br><span class="hljs-comment">//OC原生方法</span><br>[<span class="hljs-keyword">self</span> addTarget:subscriber action:<span class="hljs-meta">@selector</span>(sendNext:) forControlEvents:controlEvents];<br><br><span class="hljs-type">RACDisposable</span> <span class="hljs-operator">*</span>disposable <span class="hljs-operator">=</span> [<span class="hljs-type">RACDisposable</span> disposableWithBlock:<span class="hljs-operator">^</span>&#123;<br>[subscriber sendCompleted];<br>&#125;];<br>[<span class="hljs-keyword">self</span>.rac_deallocDisposable addDisposable:disposable];<br><br><span class="hljs-keyword">return</span> [<span class="hljs-type">RACDisposable</span> disposableWithBlock:<span class="hljs-operator">^</span>&#123;<br><span class="hljs-meta">@strongify</span>(<span class="hljs-keyword">self</span>);<br>[<span class="hljs-keyword">self</span>.rac_deallocDisposable removeDisposable:disposable];<br>[<span class="hljs-keyword">self</span> removeTarget:subscriber action:<span class="hljs-meta">@selector</span>(sendNext:) forControlEvents:controlEvents];<br>&#125;];<br>&#125;]<br>setNameWithFormat:@<span class="hljs-string">&quot;%@ -rac_signalForControlEvents: %lx&quot;</span>, <span class="hljs-type">RACDescription</span>(<span class="hljs-keyword">self</span>), (unsigned long)controlEvents];<br>&#125;<br><span class="hljs-meta">@end</span><br></code></pre></td></tr></table></figure><p>RAC在<code>UIControl</code>的分类中返回一个信号，通过OC原生的”addTarget:action:forControlEvents:”添加了<code>subscriber</code>为<code>target</code>，而其响应方法为<code>sendNext:</code>。所以当按钮被点击后会触发<code>subscriber</code>的<code>sendNext:</code>方法，随即回调订阅者的 block。</p><h3 id="delegate"><a href="#delegate" class="headerlink" title="delegate"></a>delegate</h3><p>RAC中的<code>delegate</code>可以通过<code>RACSubject</code>来实现。官方文档中关于此类的描述如下：</p><blockquote><p>A subject, represented by the RACSubject class, is a signal that can be manually controlled.<br>Subjects can be thought of as the “mutable” variant of a signal, much like NSMutableArray is for NSArray. They are extremely useful for bridging non-RAC code into the world of signals.<br>For example, instead of handling application logic in block callbacks, the blocks can simply send events to a shared subject instead. The subject can then be returned as a RACSignal, hiding the implementation detail of the callbacks.</p></blockquote><p><code>RACSubject</code>继承自<code>RACSignal</code>，是一种可以由我们控制的信号。</p><p>相比于在某个 block 回调中自己处理业务逻辑，RAC 可以让 block 向某个共享的 subject 发送事件并让其处理该业务逻辑。</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//HelloRACController.m</span><br>- (<span class="hljs-keyword">IBAction</span>)onAction2:(<span class="hljs-type">id</span>)sender &#123;<br>    <span class="hljs-comment">//push到新界面</span><br>    ViewControllerII *controller = [[<span class="hljs-built_in">UIStoryboard</span> storyboardWithName:<span class="hljs-string">@&quot;Main&quot;</span> bundle:<span class="hljs-literal">nil</span>]<br>                                    instantiateViewControllerWithIdentifier:<span class="hljs-string">@&quot;ViewControllerII&quot;</span>];<br>    <span class="hljs-comment">//设置代理信号</span><br>    controller.delegate = [RACSubject subject];<br>    <br>    <span class="hljs-comment">//订阅代理</span><br>    [controller.delegate subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,x);<br>    &#125;];<br>    [<span class="hljs-keyword">self</span>.navigationController pushViewController:controller animated:<span class="hljs-literal">YES</span>];<br>&#125;<br><br><span class="hljs-comment">//ViewControllerII.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewControllerII</span> : <span class="hljs-title">UIViewController</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) RACSubject *delegate;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewControllerII</span></span><br><br>- (<span class="hljs-keyword">IBAction</span>)onDismiss:(<span class="hljs-type">id</span>)sender<br>&#123;<br>    <span class="hljs-comment">//RAC回调</span><br>    [<span class="hljs-keyword">self</span>.delegate sendNext:<span class="hljs-string">@&quot;++ViewControllerII Closed~&quot;</span>];<br>    [<span class="hljs-keyword">self</span>.navigationController popViewControllerAnimated:<span class="hljs-literal">YES</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><code>RACSubject</code>是信号的子类，我们在 A 中订阅 B 中的信号，并在 B 中向 A 中订阅者发送消息，以此实现代理的功能。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>综上，RAC在对异步行为进行封装时所做的工作主要为：</p><ul><li>将这些行为封装到信号的 block 中（有些只是调用原生接口）；</li><li>我们只须订阅此信号就能以一种统一的方式实现业务代码的内聚；</li><li>信号向订阅者发送完事件之后随即清理资源和引用；</li></ul><p>RAC将这些异步行为的创建、监听、业务回调集中在一片代码区域或交由RAC内部实现，这符合高内聚的设计思想，值得学习和借鉴~</p><hr><p>相关参考：</p><p>#<a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/FrameworkOverview.md">©RAC-Github</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAC-信号与订阅者</title>
    <link href="/2021/05/25/RAC-signal.html"/>
    <url>/2021/05/25/RAC-signal.html</url>
    
    <content type="html"><![CDATA[<h3 id="一-信号"><a href="#一-信号" class="headerlink" title="一.信号"></a>一.信号</h3><h4 id="1-信号是啥"><a href="#1-信号是啥" class="headerlink" title="1.信号是啥"></a>1.信号是啥</h4><p><a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/FrameworkOverview.md">RAC文档</a> 中关于<code>RACSignal</code>的描述:</p><blockquote><p>A signal, represented by the RACSignal class, is a push-driven stream.<br>Signals generally represent data that will be delivered in the future. As work is performed or data is received, values are sent on the signal, which pushes them out to any subscribers. Users must subscribe to a signal in order to access its values.</p></blockquote><ul><li>信号是一种 “推送” 类型的流。</li><li>信号代表着将来要传输的数据，值通过信号传递给订阅者；</li><li>用户须订阅信号才能接收到这些值。</li></ul><h4 id="2-冷热信号"><a href="#2-冷热信号" class="headerlink" title="2.冷热信号"></a>2.冷热信号</h4><p>信号分为<code>冷信号</code>和<code>热信号</code>两种：</p><ul><li>冷信号是被动的，被订阅之后才能发送消息；</li><li>热信号是主动的，即使未被订阅也能不断推送新消息；</li><li>冷信号只能1-1，对应一个订阅者，当有新订阅者时消息会重新发送一遍；</li><li>热信号可以1-N，可以有多个订阅者，信号可与多个订阅者共享信息；</li></ul><h5 id="2-1-冷信号"><a href="#2-1-冷信号" class="headerlink" title="#2.1.冷信号"></a>#2.1.冷信号</h5><ul><li>RACDynamicSignal</li><li>RACEmptySignal</li><li>RACErrorSignal</li><li>RACReturnSignal</li><li>RACChannelTerminal</li></ul><h5 id="2-2-热信号"><a href="#2-2-热信号" class="headerlink" title="#2.2.热信号"></a>#2.2.热信号</h5><ul><li>RACSubject</li><li>RACBehaviorSubject</li><li>RACGroupedSignal</li><li>RACReplaySubject</li></ul><h3 id="二-订阅者"><a href="#二-订阅者" class="headerlink" title="二.订阅者"></a>二.订阅者</h3><p>关于<code>RACSubscriber</code>的描述:</p><blockquote><p>A subscriber is anything that is waiting or capable of waiting for events from a signal. Within RAC, a subscriber is represented as any object that conforms to the RACSubscriber protocol.</p></blockquote><blockquote><p>Subscriptions retain their signals, and are automatically disposed of when the signal completes or errors. Subscriptions can also be disposed of manually.</p></blockquote><ul><li>订阅者表示正在等待信号发送事件的对象。</li><li>当信号有新数据时，通过这个订阅者发送新值。</li><li>订阅者在信号发送完成或者错误事件时会自动销毁。</li></ul><hr><p>这些关于<code>信号</code>与<code>订阅者</code>的描述很容易让人联想到<code>APNs</code>，两者机制很相似：</p><ul><li>iOS设备提前注册推送服务（订阅）；</li><li>苹果的推送服务器推送消息（事件）；</li><li>iOS设备接收到消息并处理自己的业务（响应）。</li></ul><p>iOS设备就是订阅者，苹果的 APNs 服务作为一个整体而被视为信号流。二者是 N 对 1 的关系。</p><h3 id="三-冷信号"><a href="#三-冷信号" class="headerlink" title="三.冷信号"></a>三.冷信号</h3><p>#示例1：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs wren">@<span class="hljs-title function_">property</span> (<span class="hljs-variable">nonatomic</span>, <span class="hljs-variable">strong</span>) <span class="hljs-variable">id</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">RACSubscriber</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">subscriber</span>;<br><br><span class="hljs-operator">-</span> (<span class="hljs-variable">void</span>)<span class="hljs-title function_">coldSignal</span> &#123;<br>    <span class="hljs-comment">//1.创建信号</span><br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-comment">// ^didSubscribe</span><br>        <span class="hljs-comment">// 这里封装业务代码</span><br>        <span class="hljs-variable">_subscriber</span> <span class="hljs-operator">=</span> <span class="hljs-variable">subscriber</span>;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-title class_">RACDisposable</span> <span class="hljs-variable">disposableWithBlock</span>:<span class="hljs-operator">^</span>&#123;<br>            <span class="hljs-comment">//清理资源</span><br>        &#125;];<br>    &#125;];<br>    <span class="hljs-comment">//2.订阅信号</span><br>    [<span class="hljs-variable">s1</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-comment">//4.接收数据</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++received value1:%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br>    <span class="hljs-comment">//3.订阅信号</span><br>    [<span class="hljs-variable">s1</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-comment">//5.接收数据</span><br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++received value2:%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br>    [<span class="hljs-variable">_subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;x&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">received value2:x</span><br></code></pre></td></tr></table></figure><h4 id="1-创建信号"><a href="#1-创建信号" class="headerlink" title="1.创建信号"></a>1.创建信号</h4><p>#1.1.类方法:</p><p>调用<code>RACSignal</code>的类方法创建一个信号：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-comment">//^didSubscribe中执行任务</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-title class_">RACDisposable</span> <span class="hljs-variable">disposableWithBlock</span>:<span class="hljs-operator">^</span>&#123;<br>            <span class="hljs-comment">//清理资源</span><br>        &#125;];<br>    &#125;];<br></code></pre></td></tr></table></figure><p>此方法的定义如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/// Creates a new signal. This is the preferred way to create a new signal</span><br><span class="hljs-comment">/// operation or behavior.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// Events can be sent to new subscribers immediately in the `didSubscribe`</span><br><span class="hljs-comment">/// block, but the subscriber will not be able to dispose of the signal until</span><br><span class="hljs-comment">/// a RACDisposable is returned from `didSubscribe`. In the case of infinite</span><br><span class="hljs-comment">/// signals, this won&#x27;t _ever_ happen if events are sent immediately.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// To ensure that the signal is disposable, events can be scheduled on the</span><br><span class="hljs-comment">/// +[RACScheduler currentScheduler] (so that they&#x27;re deferred, not sent</span><br><span class="hljs-comment">/// immediately), or they can be sent in the background. The RACDisposable</span><br><span class="hljs-comment">/// returned by the `didSubscribe` block should cancel any such scheduling or</span><br><span class="hljs-comment">/// asynchronous work.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// didSubscribe - Called when the signal is subscribed to. The new subscriber is</span><br><span class="hljs-comment">///                passed in. You can then manually control the &lt;RACSubscriber&gt; by</span><br><span class="hljs-comment">///                sending it -sendNext:, -sendError:, and -sendCompleted,</span><br><span class="hljs-comment">///                as defined by the operation you&#x27;re implementing. This block</span><br><span class="hljs-comment">///                should return a RACDisposable which cancels any ongoing work</span><br><span class="hljs-comment">///                triggered by the subscription, and cleans up any resources or</span><br><span class="hljs-comment">///                disposables created as part of it. When the disposable is</span><br><span class="hljs-comment">///                disposed of, the signal must not send any more events to the</span><br><span class="hljs-comment">///                `subscriber`. If no cleanup is necessary, return nil.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// **<span class="hljs-doctag">Note:</span>** The `didSubscribe` block is called every time a new subscriber</span><br><span class="hljs-comment">/// subscribes. Any side effects within the block will thus execute once for each</span><br><span class="hljs-comment">/// subscription, not necessarily on one thread, and possibly even</span><br><span class="hljs-comment">/// simultaneously!</span><br>+ (RACSignal&lt;ValueType&gt; *)createSignal:(RACDisposable * _Nullable (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe RAC_WARN_UNUSED_RESULT;<br></code></pre></td></tr></table></figure><p>方法的参数为<code>didSubscribe</code>，返回值为新的信号。</p><p>#1.2.didSubscribe:</p><p><code>didSubscribe</code>是我们定义的处理业务的Block，在创建信号时作为参数，被传入并保存在信号内；</p><p><code>didSubscribe</code>的参数为实现了<code>RACSubscriber</code>协议的<code>订阅者</code>，在信号被订阅后可用于接收数据；</p><p><code>didSubscribe</code>的返回值是一个用于清理资源的<code>RACDisposable</code>对象，无需清理资源时可返回 nil；</p><p><code>didSubscribe</code>在创建信号时被作为参数传入并保存在<code>RACSignal</code>实例的<code>_didSubscribe</code>属性内：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">// The block to invoke for each subscriber.</span><br>@<span class="hljs-keyword">property</span><span class="hljs-string"> (nonatomic</span>, copy, readonly) RACDisposable * (^didSubscribe)(id&lt;RACSubscriber&gt; subscriber);<br><br>+ (RACSignal *)<span class="hljs-attribute">createSignal</span>:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))<span class="hljs-title">didSubscribe</span> &#123;<br><br>    RACDynamicSignal *<span class="hljs-keyword">signal</span><span class="hljs-string"> </span>= [[self alloc] init];<br>    <span class="hljs-comment">// 保存block为属性</span><br>    <span class="hljs-keyword">signal</span><span class="hljs-string">-&gt;_didSubscribe </span>= [didSubscribe copy];<br><br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">signal</span><span class="hljs-string"> setNameWithFormat</span>:@<span class="hljs-string">&quot;+createSignal:&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>#1.3.冷信号</p><p>执行完上面的类方法之后，我们已经成功创建了一个<code>信号</code>。但新创建的信号默认是<code>冷</code>信号，还不能立刻用它发送数据，因为：</p><p>发送数据需要用到<code>sendNext</code>方法；</p><p><code>sendNext</code>方法的调用者为<code>subscriber</code>，即订阅者；</p><p>所以，我们还缺少一个订阅者，这就是所谓的<strong>冷信号需要被订阅之后才能发送数据</strong>。</p><h4 id="2-订阅信号"><a href="#2-订阅信号" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h4><p>订阅信号的语句为：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">//2.订阅信号</span><br>[<span class="hljs-variable">s1</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;+++received value:%@&quot;</span>,<span class="hljs-variable">x</span>);<br>&#125;];<br></code></pre></td></tr></table></figure><p>其中<code>subscribeNext:</code>方法的实现为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (RACDisposable *)subscribeNext:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> x))nextBlock &#123;<br><span class="hljs-built_in">NSCParameterAssert</span>(nextBlock != <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">// 1.创建订阅者</span><br>RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="hljs-literal">NULL</span> completed:<span class="hljs-literal">NULL</span>];<br><span class="hljs-comment">// 2.调用 ^didSubscribe</span><br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> subscribe:o];<br>&#125;<br></code></pre></td></tr></table></figure><p>#2.1.保存事件的block</p><p>首先，<code>subscribeNext:</code>内会创建一个订阅者，且冷信号每次被订阅都会创建新的订阅者，<strong>多次订阅只会保留最后一次订阅关系</strong>，即信号被多次订阅后，<code>sendNext:</code>通过订阅者发送数据时，只有最后一个订阅者会收到数据回调；</p><p>其次，方法将传进来的<code>next</code>、<code>error</code>、<code>completed</code> 三个 block 保存到此订阅者对象中（属性）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RACSubscriber</span> ()</span><br><br><span class="hljs-comment">// These callbacks should only be accessed while synchronized on self.</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^next)(<span class="hljs-type">id</span> value);<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^error)(<span class="hljs-built_in">NSError</span> *error);<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^completed)(<span class="hljs-type">void</span>);<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) RACCompoundDisposable *disposable;<br><br><span class="hljs-keyword">@end</span><br><br>+ (<span class="hljs-keyword">instancetype</span>)subscriberWithNext:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> x))next<br>                             error:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSError</span> *error))error<br>                         completed:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">void</span>))completed <br>&#123;<br>RACSubscriber *subscriber = [[<span class="hljs-keyword">self</span> alloc] init];<br><br>subscriber-&gt;_next = [next <span class="hljs-keyword">copy</span>];<br>subscriber-&gt;_error = [error <span class="hljs-keyword">copy</span>];<br>subscriber-&gt;_completed = [completed <span class="hljs-keyword">copy</span>];<br><br><span class="hljs-keyword">return</span> subscriber;<br>&#125;<br></code></pre></td></tr></table></figure><p>这三个 block 分别代表了信号的三种事件：</p><ul><li>next 表示将要发送数据；</li><li>error 表示出现错误；</li><li>completed 表示信号已完成。</li></ul><p>调用完<code>subscribeNext:</code>方法后，就成功创建了订阅者对象，也就是之前的<code>didSubscribe</code> block 所缺少的那个参数。</p><p>至此，信号具备了发送数据的完整前提条件!</p><p>#2.2.调用didSubscribe block</p><p>创建订阅者后，继续调用self.didSubscribe(subscriber)，<code>subscriber</code>参数就是刚新建的订阅者。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;<br><span class="hljs-params">...</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.didSubscribe != <span class="hljs-built_in">NULL</span>) &#123;<br>            RACDisposable *schedulingDisposable = <span class="hljs-meta">[</span>RACScheduler.subscriptionScheduler schedule:^&#123;<br>                <span class="hljs-comment">//调用之前创建和保存起来的*didSubscribe* block，传入订阅者参数</span><br>                RACDisposable *innerDisposable = <span class="hljs-built_in">self</span>.didSubscribe(subscriber);<br>                <span class="hljs-meta">[</span>disposable addDisposable:innerDisposable<span class="hljs-meta">]</span>;<br>            &#125;];<br><span class="hljs-meta">[</span>disposable addDisposable:schedulingDisposable<span class="hljs-meta">]</span>;<br>&#125;<br>return disposable;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 self.didSubscribe 属性指向的正是之前在创建信号时我们自定义的<code>didSubscribe</code>，所以 self.didSubscribe(subscriber) 就是调用我们自己的<code>didSubscribe</code> block。</p><p>即：<strong>订阅信号后，信号的<code>didSubscribe</code>会自动调用一次</strong>。</p><h4 id="3-发送消息"><a href="#3-发送消息" class="headerlink" title="3.发送消息"></a>3.发送消息</h4><p>订阅完成后自动创建了订阅者，接下来就可以向订阅者发送<code>事件</code>和<code>数据</code>了。信号内有三种消息：</p><ul><li>next</li><li>error</li><li>completed</li></ul><p>三种消息对应的接口分别为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/// Sends the next value to subscribers.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// value - The value to send. This can be `nil`.</span><br>- (<span class="hljs-type">void</span>)sendNext:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)value;<br><br><span class="hljs-comment">/// Sends the error to subscribers.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// error - The error to send. This can be `nil`.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This terminates the subscription, and invalidates the subscriber (such that</span><br><span class="hljs-comment">/// it cannot subscribe to anything else in the future).</span><br>- (<span class="hljs-type">void</span>)sendError:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSError</span> *)error;<br><br><span class="hljs-comment">/// Sends completed to subscribers.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This terminates the subscription, and invalidates the subscriber (such that</span><br><span class="hljs-comment">/// it cannot subscribe to anything else in the future).</span><br>- (<span class="hljs-type">void</span>)sendCompleted;<br></code></pre></td></tr></table></figure><p>其实现为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)sendNext:(<span class="hljs-type">id</span>)value &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-type">void</span> (^nextBlock)(<span class="hljs-type">id</span>) = [<span class="hljs-keyword">self</span>.next <span class="hljs-keyword">copy</span>];<br>        <span class="hljs-keyword">if</span> (nextBlock == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span>;<br><br>        nextBlock(value);<br>    &#125;<br>&#125;<br>- (<span class="hljs-type">void</span>)sendError:(<span class="hljs-built_in">NSError</span> *)e &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-type">void</span> (^errorBlock)(<span class="hljs-built_in">NSError</span> *) = [<span class="hljs-keyword">self</span>.error <span class="hljs-keyword">copy</span>];<br>        [<span class="hljs-keyword">self</span>.disposable dispose];<br><br>        <span class="hljs-keyword">if</span> (errorBlock == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span>;<br>        errorBlock(e);<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)sendCompleted &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-type">void</span> (^completedBlock)(<span class="hljs-type">void</span>) = [<span class="hljs-keyword">self</span>.completed <span class="hljs-keyword">copy</span>];<br>        [<span class="hljs-keyword">self</span>.disposable dispose];<br><br>        <span class="hljs-keyword">if</span> (completedBlock == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span>;<br>        completedBlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>向订阅者发送<code>next</code>、<code>error</code>、<code>completed</code>事件，实际上是调用之前保存在订阅者对象中的三种 block 属性。</p><p><strong>注意</strong>：信号向订阅者发送了<code>error</code>或者<code>completed</code>后，订阅关系随即结束，订阅者后续不会再收到任何事件和数据。</p><p>#冷信号使用示例:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HelloRACController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span>&lt;RACSubscriber&gt; subscriber;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HelloRACController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">//1.信号的使用</span><br>    <span class="hljs-comment">//1.1.创建信号，此时信号为冷信号，被订阅之后才能发送消息</span><br>    RACSignal *s1 = [RACSignal createSignal:^RACDisposable *(<span class="hljs-type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;<br>        <br>        <span class="hljs-comment">//当有订阅者订阅信号，就会调用此block</span><br>        _subscriber = subscriber;<br>        <br>        <span class="hljs-comment">//1.3.发送信号</span><br>        [subscriber sendNext:<span class="hljs-string">@&quot;Hello from s1~&quot;</span>];<br>        <br>        <span class="hljs-comment">//回抛错误</span><br>        [subscriber sendError:[<span class="hljs-built_in">NSError</span> errorWithDomain:<span class="hljs-string">@&quot;NetError&quot;</span> code:<span class="hljs-number">1022</span> userInfo:@&#123;<span class="hljs-string">@&quot;code&quot;</span>:@(<span class="hljs-number">1022</span>)&#125;]];<br>        <br>        <span class="hljs-comment">//如果不再发送数据，发送信号完成</span><br>        [subscriber sendCompleted];<br>        <br>        <span class="hljs-comment">//返回一个信号，内部会自动调用[RACDisposable disposable]取消订阅。</span><br>        <span class="hljs-keyword">return</span> [RACDisposable disposableWithBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++s1 Disposed~&quot;</span>);<br>        &#125;];<br>    &#125;];<br>    <br>    <span class="hljs-comment">//1.2.订阅信号(被订阅后，如果向订阅者发送了信号，则此时subscribeNext的block被调用)</span><br>    [s1 subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~第1个订阅消息：%@&quot;</span>,x);<br>    &#125;];<br>    <br>    [s1 subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~第2个订阅消息：%@&quot;</span>,x);<br>    &#125; error:^(<span class="hljs-built_in">NSError</span> * error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++error:%@&quot;</span>,error.description);<br>    &#125; completed:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++s1 completed&quot;</span>);<br>    &#125;];<br>    <br>    [_subscriber sendNext:<span class="hljs-string">@&quot;Hello2 from s1~&quot;</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">~~第1个订阅消息：Hello <span class="hljs-keyword">from</span> s1~<br>++s1 Disposed~<br>~~第2个订阅消息：Hello <span class="hljs-keyword">from</span> s1~<br>+++error:<span class="hljs-built_in">Error</span> <span class="hljs-attribute">Domain</span>=NetError <span class="hljs-attribute">Code</span>=1022 <span class="hljs-string">&quot;(null)&quot;</span> UserInfo=&#123;<span class="hljs-attribute">code</span>=1022&#125;<br>++s1 Disposed~<br></code></pre></td></tr></table></figure><p>结合日志来分析，有几点可以得到印证：</p><p>1.调用完 [s1 subscribeNext:] 订阅信号之后，<code>s1</code>的 block 会立刻执行。</p><p>2.订阅者调用 [subscriber sendNext:] 后订阅者的<code>subscribeNext</code> block 会立刻执行。同理调用 [subscriber sendError:] 或者 [subscriber sendCompleted] 后，对应的<code>error</code>和<code>completed</code>回调也会立刻执行。 </p><p>3.block 内调用 [subscriber sendError:] 或者 [subscriber sendCompleted] 之后，信号<code>s1</code>会立刻调用其<code>RACDisposable</code>的 block 清理资源。</p><p>4.一旦信号调用<code>RACDisposable</code>之后，它后续将不能再接收任何事件。比如示例中第二个订阅者调用了 <code>sendError</code> 之后，s1 自动调用了<code>RACDisposable</code>，后续调用 <code>setCompleted</code> 时<code>completed</code>回调不再执行，并且后面的 [_subscriber sendNext:] 也不会有任何响应或日志输出。</p><h3 id="四-热信号"><a href="#四-热信号" class="headerlink" title="四.热信号"></a>四.热信号</h3><p>热信号本身不需要订阅也能发送消息，因为它们一般都直接或间接地实现了<code>&lt;RACSubscriber&gt;</code>协议，此协议定义了以下方法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@protocol</span> RACSubscriber &lt;NSObject&gt;<br><span class="hljs-variable">@required</span><br><br><span class="hljs-comment">/// Sends the next value to subscribers.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// value - The value to send. This can be `nil`.</span><br>- (void)<span class="hljs-attribute">sendNext</span>:(nullable id)value;<br><br><span class="hljs-comment">/// Sends the error to subscribers.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// error - The error to send. This can be `nil`.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This terminates the subscription, and invalidates the subscriber (such that</span><br><span class="hljs-comment">/// it cannot subscribe to anything else in the future).</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">sendError</span>:(nullable NSError *)<span class="hljs-selector-tag">error</span>;<br><br><span class="hljs-comment">/// Sends completed to subscribers.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// This terminates the subscription, and invalidates the subscriber (such that</span><br><span class="hljs-comment">/// it cannot subscribe to anything else in the future).</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">sendCompleted</span>;<br><br><span class="hljs-comment">/// Sends the subscriber a disposable that represents one of its subscriptions.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// A subscriber may receive multiple disposables if it gets subscribed to</span><br><span class="hljs-comment">/// multiple signals; however, any error or completed events must terminate _all_</span><br><span class="hljs-comment">/// subscriptions.</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">didSubscribeWithDisposable</span>:(RACCompoundDisposable *)<span class="hljs-selector-tag">disposable</span>;<br></code></pre></td></tr></table></figure><p>以上几个方法主要用来向订阅者发送数据或更新状态。</p><p>热信号正是实现了此协议，才能在没有订阅者的情况下也能主动发送数据。以<code>RACSubject</code>为例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/// A subject can be thought of as a signal that you can manually control by</span><br><span class="hljs-comment">/// sending next, completed, and error.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// They&#x27;re most helpful in bridging the non-RAC world to RAC, since they let you</span><br><span class="hljs-comment">/// manually control the sending of events.</span><br>@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">RACSubject</span>&lt;<span class="hljs-symbol">ValueType</span>&gt; : <span class="hljs-symbol">RACSignal</span>&lt;<span class="hljs-symbol">ValueType</span>&gt; &lt;<span class="hljs-symbol">RACSubscriber</span>&gt;<br></code></pre></td></tr></table></figure><p>继承自<code>RACSignal</code>，说明它是一种信号；实现了<code>&lt;RACSubscriber&gt;</code>协议，说明它能在不被订阅的情况下主动发送数据。</p><p>#示例：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl">- (void)hotSignal &#123;<br>    RACSubject *<span class="hljs-function"><span class="hljs-keyword">sub</span> = [<span class="hljs-title">RACSubject</span> <span class="hljs-title">subject</span>]</span>;<br>    [<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sendNext</span>:@&quot;1&quot;]</span>;<br>    <br>    [<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">subscribeNext</span>:^(<span class="hljs-title">id</span> <span class="hljs-title">x</span>) </span>&#123;<br>        NSLog(@&quot;+++sub1:%@<span class="hljs-string">&quot;,x);</span><br><span class="hljs-string">    &#125;];</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    [sub sendNext:@&quot;2&quot;</span>];<br>    <br>    [<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">subscribeNext</span>:^(<span class="hljs-title">id</span> <span class="hljs-title">x</span>) </span>&#123;<br>        NSLog(@&quot;+++sub2:%@<span class="hljs-string">&quot;,x);</span><br><span class="hljs-string">    &#125;];</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    [sub sendNext:@&quot;3&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">sub1:2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">sub1:3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">sub2:3</span><br></code></pre></td></tr></table></figure><p>1.从<code>[sub sendNext:@&quot;1&quot;]</code>可以看到，<code>sub</code>对象不需要被订阅也能发送消息，只是此时没订阅者接收消息而已；</p><p>2.当订阅了两次之后，发送数据3时收到两次回调，也说明了热信号是1~N的关系，信号与N个订阅者共享信息。</p><p>下面将介绍<code>RACSubject</code>的实现：</p><h4 id="1-创建信号-1"><a href="#1-创建信号-1" class="headerlink" title="1.创建信号"></a>1.创建信号</h4><p>创建方法如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">RACSubject *<span class="hljs-function"><span class="hljs-keyword">sub</span> = [<span class="hljs-title">RACSubject</span> <span class="hljs-title">subject</span>]</span>;<br></code></pre></td></tr></table></figure><p>其实现为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">+</span> (instancetype)subject &#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> alloc] <span class="hljs-keyword">init</span>];<br>&#125;<br><br><span class="hljs-operator">-</span> (instancetype)<span class="hljs-keyword">init</span> &#123;<br>    <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> [<span class="hljs-keyword">super</span> <span class="hljs-keyword">init</span>];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><br>    _disposable <span class="hljs-operator">=</span> [<span class="hljs-type">RACCompoundDisposable</span> compoundDisposable];<br>    _subscribers <span class="hljs-operator">=</span> [[<span class="hljs-type">NSMutableArray</span> alloc] initWithCapacity:<span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个<code>_subscribers</code>数组，后面会有重要作用。</p><h4 id="2-订阅信号-1"><a href="#2-订阅信号-1" class="headerlink" title="2.订阅信号"></a>2.订阅信号</h4><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs hy">[sub subscribeNext:^(<span class="hljs-name"><span class="hljs-built_in">id</span></span> x) &#123;<br>    NSLog(@<span class="hljs-string">&quot;+++sub1:%@&quot;</span>,x)<span class="hljs-comment">;</span><br>&#125;]<span class="hljs-comment">;</span><br>[sub subscribeNext:^(<span class="hljs-name"><span class="hljs-built_in">id</span></span> x) &#123;<br>    NSLog(@<span class="hljs-string">&quot;+++sub2:%@&quot;</span>,x)<span class="hljs-comment">;</span><br>&#125;]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>subscribeNext:</code>的实现为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (RACDisposable *)subscribeNext:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> x))nextBlock &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(nextBlock != <span class="hljs-literal">NULL</span>);<br>    <br>    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="hljs-literal">NULL</span> completed:<span class="hljs-literal">NULL</span>];<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> subscribe:o];<br>&#125;<br></code></pre></td></tr></table></figure><p>和冷信号一样，这里会先创建一个订阅者对象，随后调用<code>subscribe:</code>方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (RACDisposable *)subscribe:(<span class="hljs-type">id</span>&lt;RACSubscriber&gt;)subscriber &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(subscriber != <span class="hljs-literal">nil</span>);<br><br>    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];<br>    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="hljs-keyword">self</span> disposable:disposable];<br><br>    <span class="hljs-built_in">NSMutableArray</span> *subscribers = <span class="hljs-keyword">self</span>.subscribers;<br>    <span class="hljs-keyword">@synchronized</span> (subscribers) &#123;<br>        <span class="hljs-comment">// 将订阅者添加进数组</span><br>        [subscribers addObject:subscriber];<br>    &#125;<br>    <span class="hljs-comment">// 略。。</span><br>    <span class="hljs-keyword">return</span> disposable;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法将传进来的订阅者添加进之前提到的<code>subscribers</code>数组中，等待随后的调用。</p><h4 id="3-发送消息-1"><a href="#3-发送消息-1" class="headerlink" title="3.发送消息"></a>3.发送消息</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">[<span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">sendNext</span>:@&quot;1&quot;]</span>;<br></code></pre></td></tr></table></figure><p><code>sendNext:</code>的实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">- (void)sendNext:(id)value &#123;<br>    [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber) </span>&#123;<br>        [<span class="hljs-keyword">subscriber </span>sendNext:value];<br>    &#125;];<br>&#125;<br><br>- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber))block </span>&#123;<br>    NSArray *<span class="hljs-keyword">subscribers;</span><br><span class="hljs-keyword"></span>    @<span class="hljs-keyword">synchronized </span>(self.<span class="hljs-keyword">subscribers) </span>&#123;<br>        <span class="hljs-keyword">subscribers </span>= [self.<span class="hljs-keyword">subscribers </span>copy];<br>    &#125;<br><br>    for (id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber </span>in <span class="hljs-keyword">subscribers) </span>&#123;<br>        <span class="hljs-keyword">block(subscriber);</span><br><span class="hljs-keyword"></span>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sub</code>对象从<code>subscribers</code>数组中取出所有的订阅者，依次向其发送数据~</p><h4 id="4-用作代理"><a href="#4-用作代理" class="headerlink" title="4.用作代理"></a>4.用作代理</h4><p><code>RACSubject</code>的实现并不难理解，它与订阅者之间是<code>1~N</code>的关系并可主动发送消息，常用来代替OC中的<code>delegate</code>。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">ViewControllerII </span>: UIViewController<br><br><span class="hljs-variable">@property</span> (nonatomic, strong) RACSubject *delegate;<br><br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@implementation</span> ViewControllerII<br><br>- (void)viewDidLoad &#123;<br>    <span class="hljs-selector-attr">[super viewDidLoad]</span>;<br>&#125;<br><br>- (IBAction)<span class="hljs-attribute">onDismiss</span>:(id)sender<br>&#123;<br>    <span class="hljs-comment">//RAC回调</span><br>    <span class="hljs-selector-tag">if</span> (self.delegate) &#123;<br>        <span class="hljs-selector-attr">[self.delegate sendNext:@<span class="hljs-string">&quot;++ViewControllerII Closed~&quot;</span>]</span>;<br>    &#125;<br>    <span class="hljs-comment">//关闭</span><br>    [self.navigationController <span class="hljs-attribute">popViewControllerAnimated</span>:YES];<br>&#125;<br></code></pre></td></tr></table></figure><p>在某个页面设置代理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">IBAction</span>)onAction2:(<span class="hljs-type">id</span>)sender &#123;<br>    ViewControllerII *controller = [[<span class="hljs-built_in">UIStoryboard</span> storyboardWithName:<span class="hljs-string">@&quot;Main&quot;</span> bundle:<span class="hljs-literal">nil</span>]<br>                                    instantiateViewControllerWithIdentifier:<span class="hljs-string">@&quot;ViewControllerII&quot;</span>];<br>    <span class="hljs-comment">//设置代理信号</span><br>    controller.delegate = [RACSubject subject];<br>    <br>    <span class="hljs-comment">//订阅代理</span><br>    [controller.delegate subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,x);<br>    &#125;];<br>    [<span class="hljs-keyword">self</span>.navigationController pushViewController:controller animated:<span class="hljs-literal">YES</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五-组播"><a href="#五-组播" class="headerlink" title="五.组播"></a>五.组播</h3><blockquote><p>Signals are cold by default, meaning that they start doing work each time a new subscription is added. This behavior is usually desirable, because it means that data will be freshly recalculated for each subscriber, but it can be problematic if the signal has side effects or the work is expensive (for example, sending a network request).</p></blockquote><p>信号有多个订阅者时，每被订阅一次其<code>block</code>都自动触发一次，这种情况有时会有<code>副作用</code>。比如<code>block</code>内封装了耗时操作，每次订阅都单独触发一遍显然浪费性能。理想的情况是多个订阅者都订阅完成后，<code>block</code>只触发一次而所有订阅者都收到回调。这种场景RAC考虑到了，此时<code>RACMulticastConnection</code>就派上用场了。</p><blockquote><p>A multicast connection encapsulates the idea of sharing one subscription to a signal to many subscribers. This is most often needed if the subscription to the underlying signal involves side-effects or shouldn’t be called more than once.</p></blockquote><p>组播，用于在多个订阅者之间共享对某个信号的订阅，在发送者和每一订阅者之间实现<code>1~N</code>的连接。</p><h4 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h4><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-operator">-</span> (<span class="hljs-variable">void</span>)<span class="hljs-title function_">viewDidLoad</span> &#123;<br>    [<span class="hljs-variable language_">super</span> <span class="hljs-variable">viewDidLoad</span>];<br>    <br>    <span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;Hello from s2~&quot;</span>];<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>        <span class="hljs-keyword">return</span> [<span class="hljs-title class_">RACDisposable</span> <span class="hljs-variable">disposableWithBlock</span>:<span class="hljs-operator">^</span>&#123;<br>            <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;++s2 Disposed~&quot;</span>);<br>        &#125;];<br>    &#125;];<br>    <br>    <span class="hljs-comment">//连接类(单次订阅之后不会立刻收到回调，所有订阅完成后调用 connect 时才会先后触发)</span><br>    <span class="hljs-title class_">RACMulticastConnection</span> <span class="hljs-operator">*</span><span class="hljs-variable">cnn</span> <span class="hljs-operator">=</span> [<span class="hljs-variable">s2</span> <span class="hljs-variable">publish</span>];<br>    <br>    <span class="hljs-comment">//订阅连接类信号</span><br>    [<span class="hljs-variable">cnn</span>.<span class="hljs-property">signal</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;~~第1个订阅消息：%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br><br>    [<span class="hljs-variable">cnn</span>.<span class="hljs-property">signal</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;~~第2个订阅消息：%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br><br>    [<span class="hljs-variable">cnn</span>.<span class="hljs-property">signal</span> <span class="hljs-variable">subscribeNext</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">id</span> <span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;~~第3个订阅消息：%@&quot;</span>,<span class="hljs-variable">x</span>);<br>    &#125;];<br><br>    [<span class="hljs-variable">cnn</span> <span class="hljs-variable">connect</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm">~~第<span class="hljs-number">1</span>个订阅消息：Hello from <span class="hljs-built_in">s2</span>~<br>~~第<span class="hljs-number">2</span>个订阅消息：Hello from <span class="hljs-built_in">s2</span>~<br>~~第<span class="hljs-number">3</span>个订阅消息：Hello from <span class="hljs-built_in">s2</span>~<br>++<span class="hljs-built_in">s2</span> Disposed~<br></code></pre></td></tr></table></figure><p>调用<code>[cnn connect]</code>后三个 block 都触发了且依次触发。</p><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><ul><li>创建多播实例</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">RACMulticastConnection *cnn <span class="hljs-operator">=</span> [s2 publish]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>来看看<code>publish</code>都做了什么：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (RACMulticastConnection *)publish &#123;<br>    RACSubject *subject = [[RACSubject subject] setNameWithFormat:@&quot;[%@] -publish&quot;, self.name];<br>    RACMulticastConnection *<span class="hljs-keyword">connection</span> = [self multicast:subject];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">connection</span>;<br>&#125;<br><br>- (RACMulticastConnection *)multicast:(RACSubject *)subject &#123;<br>    [subject setNameWithFormat:@&quot;[%@] -multicast: %@&quot;, self.name, subject.name];<br>    RACMulticastConnection *<span class="hljs-keyword">connection</span> = [[RACMulticastConnection alloc] initWithSourceSignal:self subject:subject];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">connection</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>publish</code>内创建了一个<code>RACSubject</code>对象，随后将其作为参数传入<code>RACMulticastConnection</code>的构造函数中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RACMulticastConnection</span> () </span>&#123;<br>    RACSubject *_signal;<br>    int32_t <span class="hljs-keyword">volatile</span> _hasConnected;<br>&#125;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">strong</span>) RACSignal *sourceSignal;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>) RACSerialDisposable *serialDisposable;<br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(source != <span class="hljs-literal">nil</span>);<br>    <span class="hljs-built_in">NSCParameterAssert</span>(subject != <span class="hljs-literal">nil</span>);<br><br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br><br>    _sourceSignal = source;<br>    _serialDisposable = [[RACSerialDisposable alloc] init];<br>    _signal = subject;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数将源信号<code>s2</code>保存为<code>sourceSignal</code>，将刚才创建的<code>subject</code>保存为<code>signal</code>，之后返回一个多播实例。</p><ul><li>订阅信号</li></ul><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hy">[cnn.signal subscribeNext:^(<span class="hljs-name"><span class="hljs-built_in">id</span></span> x) &#123;<br>    NSLog(@<span class="hljs-string">&quot;~~第1个订阅消息：%@&quot;</span>,x)<span class="hljs-comment">;</span><br>&#125;]<span class="hljs-comment">;</span><br>    <br>[cnn.signal subscribeNext:^(<span class="hljs-name"><span class="hljs-built_in">id</span></span> x) &#123;<br>    NSLog(@<span class="hljs-string">&quot;~~第2个订阅消息：%@&quot;</span>,x)<span class="hljs-comment">;</span><br>&#125;]<span class="hljs-comment">;</span><br>    <br>[cnn.signal subscribeNext:^(<span class="hljs-name"><span class="hljs-built_in">id</span></span> x) &#123;<br>    NSLog(@<span class="hljs-string">&quot;~~第3个订阅消息：%@&quot;</span>,x)<span class="hljs-comment">;</span><br>&#125;]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这里订阅的不再是<code>s2</code>，而是刚才的<code>RACSubject</code>类型属性<code>signal</code>，此订阅的内部实现为：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// RACSignal.m</span><br>- (RACDisposable *)subscribeNext:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> x))nextBlock &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(nextBlock != <span class="hljs-literal">NULL</span>);<br>    <br>    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="hljs-literal">NULL</span> completed:<span class="hljs-literal">NULL</span>];<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> subscribe:o];<br>&#125;<br><br><span class="hljs-comment">// RACSubject.m</span><br>- (RACDisposable *)subscribe:(<span class="hljs-type">id</span>&lt;RACSubscriber&gt;)subscriber &#123;<br>    <span class="hljs-built_in">NSCParameterAssert</span>(subscriber != <span class="hljs-literal">nil</span>);<br><br>    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];<br>    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="hljs-keyword">self</span> disposable:disposable];<br><br>    <span class="hljs-built_in">NSMutableArray</span> *subscribers = <span class="hljs-keyword">self</span>.subscribers;<br>    <span class="hljs-keyword">@synchronized</span> (subscribers) &#123;<br>        <span class="hljs-comment">// 将订阅者保存到数组中</span><br>        [subscribers addObject:subscriber];<br>    &#125;<br>    <span class="hljs-comment">// 略。。。</span><br><br>    <span class="hljs-keyword">return</span> disposable;<br>&#125;<br></code></pre></td></tr></table></figure><p>即订阅<code>signal</code>时，先创建新的订阅者，随后将订阅者添加到多播实例的数组<code>subscribers</code>中。此时还没有调用<code>s2</code>的<code>didSubscribe</code>!</p><ul><li>连接 connect</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[cnn connect]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>connect</code>的内部实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (RACDisposable *)connect &#123;<br>    <span class="hljs-type">BOOL</span> shouldConnect = OSAtomicCompareAndSwap32Barrier(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &amp;_hasConnected);<br><br>    <span class="hljs-keyword">if</span> (shouldConnect) &#123;<br>        <span class="hljs-comment">// 这里的</span><br>        <span class="hljs-keyword">self</span>.serialDisposable.disposable = [<span class="hljs-keyword">self</span>.sourceSignal subscribe:_signal];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.serialDisposable;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了<code>self.sourceSignal</code>的<code>subscribe</code>，参数为之前 RACSubject 类型的属性<code>_signal</code>（信号订阅了信号）：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lisp">- (<span class="hljs-name">RACDisposable</span> *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;<br>    NSCParameterAssert(subscriber != nil);<br><br>    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]<span class="hljs-comment">;</span><br>    // 对subscriber做了变换<br>    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber<span class="hljs-symbol">:subscriber</span> signal<span class="hljs-symbol">:self</span> disposable<span class="hljs-symbol">:disposable</span>]<span class="hljs-comment">;</span><br><br>    if (<span class="hljs-name">self</span>.didSubscribe != NULL) &#123;<br>        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;<br>            // 回调s2的^didSubscribe<br>            RACDisposable *innerDisposable = self.didSubscribe(<span class="hljs-name">subscriber</span>)<span class="hljs-comment">;</span><br>            [disposable addDisposable<span class="hljs-symbol">:innerDisposable</span>]<span class="hljs-comment">;</span><br>        &#125;]<span class="hljs-comment">;</span><br><br>        [disposable addDisposable<span class="hljs-symbol">:schedulingDisposable</span>]<span class="hljs-comment">;</span><br>    &#125;<br>    <br>    return disposable<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>subscribe:</code>内对<code>_signal</code>做了变换，调了<code>self.didSubscribe(subscriber)</code>回调了<code>s2</code>的<code>didSubscribe</code>：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-title class_">RACSignal</span> <span class="hljs-operator">*</span><span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> [<span class="hljs-title class_">RACSignal</span> <span class="hljs-variable">createSignal</span>:<span class="hljs-operator">^</span><span class="hljs-title class_">RACDisposable</span> <span class="hljs-title function_">*</span>(<span class="hljs-params">id</span>&lt;<span class="hljs-params">RACSubscriber</span>&gt; <span class="hljs-params">subscriber</span>) &#123;<br>        <span class="hljs-comment">// 此 subscriber 为 RACSubject 类型</span><br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendNext</span>:@<span class="hljs-string">&quot;Hello from s2~&quot;</span>];<br>        [<span class="hljs-variable">subscriber</span> <span class="hljs-variable">sendCompleted</span>];<br>        <br>        <span class="hljs-keyword">return</span> [<span class="hljs-title class_">RACDisposable</span> <span class="hljs-variable">disposableWithBlock</span>:<span class="hljs-operator">^</span>&#123;<br>            <span class="hljs-title class_">NSLog</span>(@<span class="hljs-string">&quot;++s2 Disposed~&quot;</span>);<br>        &#125;];<br>    &#125;];<br></code></pre></td></tr></table></figure><p><code>didSubscribe</code>内随即通过<code>sendNext:</code>向订阅者（即<code>_signal</code>）发送数据:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">- (void)sendNext:(id)value &#123;<br>    [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber) </span>&#123;<br>        [<span class="hljs-keyword">subscriber </span>sendNext:value];<br>    &#125;];<br>&#125;<br><br>- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber))block </span>&#123;<br>    NSArray *<span class="hljs-keyword">subscribers;</span><br><span class="hljs-keyword"></span>    @<span class="hljs-keyword">synchronized </span>(self.<span class="hljs-keyword">subscribers) </span>&#123;<br>        <span class="hljs-keyword">subscribers </span>= [self.<span class="hljs-keyword">subscribers </span>copy];<br>    &#125;<br><br>    for (id&lt;RACSubscriber&gt; <span class="hljs-keyword">subscriber </span>in <span class="hljs-keyword">subscribers) </span>&#123;<br>        <span class="hljs-keyword">block(subscriber);</span><br><span class="hljs-keyword"></span>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>_signal</code> 的<code>sendNext:</code>方法遍历之前保存在<code>subscribers</code>数组中的订阅者，向其一一发送数据，三个订阅者依次收到回调~</p><p><strong>小结</strong>：多播主要是在内部产生<code>RACSubject</code>类型的热信号<code>_signal</code>，进而将多个订阅者保存在其数组中并最终一一向其发送数据。</p><h3 id="六-结束语"><a href="#六-结束语" class="headerlink" title="六.结束语"></a>六.结束语</h3><p>以上就是关于RAC中<code>信号</code>和<code>订阅者</code>的分析和简单使用。实践中可以结合RAC其他功能一起使用，后续文章中会继续研究~</p><hr><p>相关参考：</p><p>#<a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/FrameworkOverview.md">©RAC-Github</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件化-面向协议方案</title>
    <link href="/2020/12/21/modules-protocol.html"/>
    <url>/2020/12/21/modules-protocol.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p><code>URL</code>和<code>反射</code>方案各有自己的局限性：</p><ul><li><code>URL路由</code>方案支持的参数类型不够灵活；</li><li><code>反射方案</code>的中间通信层使用明文类名和接口名，硬编码极容易出错；</li><li>两种方案中组件之间传值时需要引用对方的实体文件，这样就依然存在耦合问题；</li></ul><p>本篇将要探讨的<code>协议+服务注册+URL+反射</code>方案，其中的协议就很好的解决了这些问题~</p><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h3><p><img src="https://davidlii.nos-eastchina1.126.net/pic_module_protocols.jpg" alt="组件化-面向协议"></p><h4 id="2-1-本地调用"><a href="#2-1-本地调用" class="headerlink" title="2.1.本地调用"></a>2.1.本地调用</h4><p>组件将自己对外提供的服务以<code>协议</code>的形式进行声明，对其他所有组件可见；</p><p>组件内提供一个<code>对外服务类</code>，遵守此协议并实现协议方法，处理组件对外服务的具体内容；</p><p>独立出一个单例的<code>中间层</code>，以协议的类名为键，以协议的实现类为值，将此键值对注册到<code>中间层</code>；</p><p>A组件调用B组件的服务时，A方从中间层以B组件对外暴露的服务协议为key，将实现了此协议的B服务类取出，实例化后调用对应的协议方法，运行时自动查找并调用B服务类中的具体实现，即可完成服务的调用。</p><h4 id="2-2-远程调用"><a href="#2-2-远程调用" class="headerlink" title="2.2.远程调用"></a>2.2.远程调用</h4><p>按约定格式传入URL，本应用的回调函数中，解析出URL中的协议名、协议方法和参数的字符串；</p><p>通过前篇中讲到的反射原理，从上一步的解析结果中得到真正的协议类名和协议方法SEL；</p><p>根据协议类名从服务注册中心查询其实现类，并创建其实例；</p><p>通过实例调用协议方法，由运行时调用具体的实现，从而完成本次服务调用；</p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h3><p>需求：从<code>主页</code>组件跳转到<code>详情</code>组件；返回时更新主页组件的标题。</p><h5 id="3-1-目标组件"><a href="#3-1-目标组件" class="headerlink" title="3.1.目标组件"></a>3.1.目标组件</h5><p>详情组件视图控制器：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 头文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailModuleProtocol.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailViewController</span> : <span class="hljs-title">UIViewController</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIImage</span> *image;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^detailCallback) (<span class="hljs-type">id</span>&lt;DetailModelProtocol&gt;); <span class="hljs-comment">//回调中回传详情实体</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// 实现文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailModel.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIImageView</span> *mIconImv;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DetailViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <br>    <span class="hljs-keyword">self</span>.mIconImv.image = <span class="hljs-keyword">self</span>.image;<br>    <br>    <span class="hljs-built_in">UIButton</span> *btn = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>    [btn setTitle:<span class="hljs-string">@&quot;返回&quot;</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(onBackWithBlock) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];<br>    <span class="hljs-keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="hljs-built_in">UIBarButtonItem</span> alloc] initWithCustomView:btn];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)onBackWithBlock&#123;<br>    <span class="hljs-comment">// block中回传详情实体</span><br>    DetailModel *model = [[DetailModel alloc] init];<br>    model.name = <span class="hljs-string">@&quot;David&quot;</span>;<br>    model.version = <span class="hljs-string">@&quot;1.0&quot;</span>;<br>    <span class="hljs-keyword">self</span>.detailCallback(model); <span class="hljs-comment">//回调信息</span><br>    <br>    [<span class="hljs-keyword">self</span>.navigationController popViewControllerAnimated:<span class="hljs-literal">YES</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>详情实体文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailModuleProtocol.h&quot;</span></span><br><br><span class="hljs-comment">// 实现DetailModelProtocol协议</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailModel</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">DetailModelProtocol</span>&gt;</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *version;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h5 id="3-2-服务协议"><a href="#3-2-服务协议" class="headerlink" title="3.2.服务协议"></a>3.2.服务协议</h5><p>详情组件对外提供服务的协议：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// DetailModuleProtocol.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DetailModuleProtocol_h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DetailModuleProtocol_h</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - Model Protocols</span><br><br><span class="hljs-comment">/// 对应的是详情组件中的DetailModel实体，只不过是将实体的字段以协议方法的形式进行声明</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">DetailModelProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br>- (<span class="hljs-built_in">NSString</span>*)name;<br>- (<span class="hljs-built_in">NSString</span>*)version;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *详情组件对外提供的所有服务，都在这里以协议方法的形式对外曝光；</span><br><span class="hljs-comment"> *此协议对所有其他组件可见，所以其他组件导入此头文件即可知道详情组件有哪些服务可用；</span><br><span class="hljs-comment"> *面向协议编程；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">DetailModuleProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br><span class="hljs-keyword">@required</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 进入详情页</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> @param pic 图片</span><br><span class="hljs-comment"> @param callback 从详情页返回时的回调</span><br><span class="hljs-comment"> @return 返回详情页，以便主页调用push进入此页面</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-built_in">UIViewController</span>*)detailControllerWithPic:(<span class="hljs-built_in">UIImage</span>*)pic callback:(<span class="hljs-type">void</span>(^)(<span class="hljs-type">id</span>&lt;DetailModelProtocol&gt;))callback;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* DetailModuleProtocol_h */</span></span><br></code></pre></td></tr></table></figure><p>其他组件调用详情组件的服务时，只需查看此协议并调用其协议方法即可。为了便于查询，可将此协议导入到公共的协议头文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CommonProtocol.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CommonProtocol_h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CommonProtocol_h</span><br><br><span class="hljs-comment">// 导入每个组件中声明对外服务接口的协议头文件</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailModuleProtocol.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CommonProtocol_h */</span></span><br></code></pre></td></tr></table></figure><p>这样，别的组件调用详情组件的服务时，只需要导入此公共协议头文件即可。</p><h5 id="3-3-服务类"><a href="#3-3-服务类" class="headerlink" title="3.3.服务类"></a>3.3.服务类</h5><p>详情组件中实现了服务协议的类，其中提供了协议方法的具体实现，即组件对外服务的具体内容：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailProtocolImplementor.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ModuleProtocolMediator.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailModuleProtocol.h&quot;</span></span><br><br><span class="hljs-comment">// 封装了详情组件对外提供服务的具体实现</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailProtocolImplementor</span> ()&lt;<span class="hljs-title">DetailModuleProtocol</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DetailProtocolImplementor</span></span><br><br><span class="hljs-comment">// 实现协议 提供具体服务</span><br>- (<span class="hljs-built_in">UIViewController</span> *)detailControllerWithPic:(<span class="hljs-built_in">UIImage</span> *)pic<br>                                     callback:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span>&lt;DetailModelProtocol&gt;))callback<br>&#123;<br>    <span class="hljs-comment">// 具体实现</span><br>    DetailViewController *vc = [[<span class="hljs-built_in">UIStoryboard</span> storyboardWithName:<span class="hljs-string">@&quot;Main&quot;</span> bundle:<span class="hljs-literal">nil</span>]<br>                                  instantiateViewControllerWithIdentifier:<span class="hljs-string">@&quot;DetailViewController&quot;</span>];<br>    vc.image = pic;<br>    vc.detailCallback = callback;<br>    <br>    <span class="hljs-keyword">return</span> vc;<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)load&#123;<br>    <span class="hljs-comment">// 注册协议 将协议与实现了此协议的业务类进行绑定</span><br>    [ModuleProtocolMediator registerModuleProtocolImplementor:[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]<br>                                                   forProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">DetailModuleProtocol</span>)];</span><br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>注意这里的<code>+load</code>方法，它调用了中间层注册协议，注册操作的具体实现且往下看~</p><h5 id="3-4-注册协议"><a href="#3-4-注册协议" class="headerlink" title="3.4.注册协议"></a>3.4.注册协议</h5><p>这是本方案的核心类，属于中间层，负责本地服务注册、查询、远程调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 头文件</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ModuleProtocolMediator</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">// 单例类</span><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance;<br><br><span class="hljs-comment">// 将实现了协议的服务类注册到全局字典中</span><br>+ (<span class="hljs-type">void</span>)registerModuleProtocolImplementor:(Class)implementor<br>                      forProtocol:(Protocol*)protocol;<br><br><span class="hljs-comment">// 根据协议查询实现了此协议的服务类，并返回它的一个实例</span><br>+ (<span class="hljs-type">id</span>)protocolImplementorWithProtocol:(Protocol*)protocol;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 远程调用接口</span><br><span class="hljs-comment"> @param url 按照约定好的格式传值</span><br><span class="hljs-comment"> @param completion 回调</span><br><span class="hljs-comment"> @return 返回值 是否响应此URL</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">BOOL</span>)performActionWithUrl:(<span class="hljs-built_in">NSURL</span> *)url<br>                completion:(<span class="hljs-type">void</span>(^)(<span class="hljs-type">id</span> info))completion;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// 实现文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ModuleProtocolMediator.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> CallResult &#123;<br>    <span class="hljs-type">BOOL</span> raiseError; <span class="hljs-comment">// 是否产生异常错误（如target或SEL为nil）</span><br>    <span class="hljs-type">id</span> result;       <span class="hljs-comment">// perform 或 invocation 的返回值</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ModuleProtocolMediator</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *mProtocolsDic; <span class="hljs-comment">// 保存协议与实现类的全局容器</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ModuleProtocolMediator</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance&#123;<br>    <br>    <span class="hljs-keyword">static</span> ModuleProtocolMediator *mProtocolManager;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> token;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;token, ^&#123;<br>        mProtocolManager = [[ModuleProtocolMediator alloc] init];<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> mProtocolManager;<br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)init&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        _mProtocolsDic = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// 注册 将协议与实现类进行绑定 以便后续查找此类</span><br>+ (<span class="hljs-type">void</span>)registerModuleProtocolImplementor:(Class)implementor<br>                      forProtocol:(Protocol*)protocol&#123;<br>    <br>    <span class="hljs-built_in">NSString</span> *key = <span class="hljs-built_in">NSStringFromProtocol</span>(protocol);<br>    [ModuleProtocolMediator shareInstance].mProtocolsDic[key] = implementor;<br>&#125;<br><br><span class="hljs-comment">// 查找实现了此协议的类 生成其实例</span><br>+ (<span class="hljs-type">id</span>)protocolImplementorWithProtocol:(Protocol*)protocol&#123;<br>    <br>    <span class="hljs-built_in">NSString</span> *key = <span class="hljs-built_in">NSStringFromProtocol</span>(protocol);<br>    Class className = [ModuleProtocolMediator shareInstance].mProtocolsDic[key];<br>    <span class="hljs-type">id</span> obj = [[className alloc] init];<br>    <br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-comment">/* url示例：@&quot;DaModuleProtocolScheme://DetailModuleProtocol:detailControllerWithPic:callback:&quot;</span><br><span class="hljs-comment"> * scheme://[protocolName]:[protocolMethod]?key1=value1&amp;key2=value2</span><br><span class="hljs-comment"> * [scheme]  [host]         [path]           [query]</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">BOOL</span>)performActionWithUrl:(<span class="hljs-built_in">NSURL</span> *)url<br>                completion:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">id</span> info))completion<br>&#123;<br>    <span class="hljs-built_in">NSMutableArray</span> *params = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];<br>    <span class="hljs-built_in">NSString</span> *urlString = [url query];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *param <span class="hljs-keyword">in</span> [urlString componentsSeparatedByString:<span class="hljs-string">@&quot;&amp;&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSArray</span> *elts = [param componentsSeparatedByString:<span class="hljs-string">@&quot;=&quot;</span>];<br>        <span class="hljs-keyword">if</span>([elts count] &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>        [params addObject:[elts lastObject]];<br>    &#125;<br>    <span class="hljs-comment">// 反射协议对象</span><br>    Protocol *protocol = <span class="hljs-built_in">NSProtocolFromString</span>(url.host);<br>    <span class="hljs-comment">// 调用本类查询协议的实现类</span><br>    <span class="hljs-built_in">NSObject</span> *target = [<span class="hljs-keyword">self</span> protocolImplementorWithProtocol:protocol];<br>    <span class="hljs-comment">// 取出想调用的协议方法(URL Decode)</span><br>    <span class="hljs-built_in">NSString</span> *protocolMethod = [[url.path stringByRemovingPercentEncoding]<br>                                stringByReplacingOccurrencesOfString:<span class="hljs-string">@&quot;/&quot;</span> withString:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-comment">// 反射SEL，即协议中定义的方法</span><br>    SEL selector = <span class="hljs-built_in">NSSelectorFromString</span>(protocolMethod);<br>    <br>    <span class="hljs-comment">// 调用 perform 方法或者 NSInvocation 实现通信</span><br>    <span class="hljs-keyword">struct</span> CallResult retStruct = [<span class="hljs-keyword">self</span> safePerformAction:selector target:target params:params];<br><br>    <span class="hljs-keyword">if</span> (retStruct.raiseError) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">id</span> value = retStruct.result;<br>        <span class="hljs-keyword">if</span> (completion) &#123;<br>            completion(value);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>&#125;<br><br><br>+ (<span class="hljs-keyword">struct</span> CallResult)safePerformAction:(SEL)action<br>                 target:(<span class="hljs-built_in">NSObject</span> *)target<br>                 params:(<span class="hljs-built_in">NSArray</span> *)params<br>&#123;<br>    <span class="hljs-built_in">NSMethodSignature</span>* methodSig = [target methodSignatureForSelector:action];<br>    <span class="hljs-keyword">if</span>(methodSig == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">struct</span> CallResult retStruct = &#123;<span class="hljs-literal">YES</span>,<span class="hljs-literal">nil</span>&#125;;<br>        <span class="hljs-keyword">return</span> retStruct;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* retType = [methodSig methodReturnType];<br>    <br>    <span class="hljs-keyword">if</span> (strcmp(retType, <span class="hljs-keyword">@encode</span>(<span class="hljs-type">void</span>)) == <span class="hljs-number">0</span> ||<br>        strcmp(retType, <span class="hljs-keyword">@encode</span>(<span class="hljs-type">BOOL</span>)) == <span class="hljs-number">0</span> ||<br>        strcmp(retType, <span class="hljs-keyword">@encode</span>(<span class="hljs-built_in">CGFloat</span>)) == <span class="hljs-number">0</span> ||<br>        strcmp(retType, <span class="hljs-keyword">@encode</span>(<span class="hljs-built_in">NSInteger</span>)) == <span class="hljs-number">0</span> ||<br>        strcmp(retType, <span class="hljs-keyword">@encode</span>(<span class="hljs-built_in">NSUInteger</span>)) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:methodSig];<br>        [invocation setSelector:action];<br>        [invocation setTarget:target];<br>        <br>        <span class="hljs-built_in">NSInteger</span> count = params.count;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-built_in">NSObject</span> *value = params[i];<br>            [invocation setArgument:&amp;value atIndex:i + <span class="hljs-number">2</span>]; <span class="hljs-comment">// 参数从第二位开始算起</span><br>        &#125;<br>        [invocation invoke];<br>        <br>        <span class="hljs-comment">// 无返回值时，结构体中result字段为nil</span><br>        <span class="hljs-keyword">if</span> (strcmp(retType, <span class="hljs-keyword">@encode</span>(<span class="hljs-type">void</span>)) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">struct</span> CallResult retStruct = &#123;<span class="hljs-literal">NO</span>,<span class="hljs-literal">nil</span>&#125;;<br>            <span class="hljs-keyword">return</span> retStruct;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 返回值为数值类型时，包装成对象</span><br>            <span class="hljs-built_in">NSInteger</span> result = <span class="hljs-number">0</span>;<br>            [invocation getReturnValue:&amp;result];<br>            <span class="hljs-keyword">struct</span> CallResult retStruct = &#123;<span class="hljs-literal">NO</span>,@(result)&#125;;<br>            <span class="hljs-keyword">return</span> retStruct;<br>        &#125;<br>    &#125;<br>    <br>    <br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic push</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic ignored <span class="hljs-string">&quot;-Warc-performSelector-leaks&quot;</span></span><br>    <span class="hljs-comment">// 返回值为对象类型，直接调用即可</span><br>    <span class="hljs-type">id</span> result = [target performSelector:action withObject:params];<br>    <span class="hljs-keyword">struct</span> CallResult retStruct = &#123;<span class="hljs-literal">NO</span>,result&#125;;<br>    <span class="hljs-keyword">return</span> retStruct;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> clang diagnostic pop</span><br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>此工具类也提供了<code>本地调用</code>与<code>远程调用</code>两种调用组件的方式。</p><ul><li>本地调用</li></ul><p>本地调用组件时，<code>ModuleProtocolMediator</code>作为中间层通过下面的接口将协议与实现了此协议的服务类进行绑定，并保存到内部的字典中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">+ (<span class="hljs-keyword">void</span>)registerModuleProtocolImplementor:(<span class="hljs-keyword">Class</span>)implementor<br>                      forProtocol:(Protocol*)protocol;<br></code></pre></td></tr></table></figure><p>在A组件调用B组件的服务时，只需要通过下面的接口，根据B组件提供的协议取出协议实现类，实例化之后调用对应的协议方法即可。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">+ (<span class="hljs-built_in">id</span>)protocolImplementorWithProtocol:(Protocol*)protocol;<br></code></pre></td></tr></table></figure><ul><li>远程调用</li></ul><p>此处的远程调用与反射方案中远程调用的方式相同，A应用按照约定的格式组合一个URL并传递给B应用，随后B应用的<code>application:openURL:options:</code>回调中调用以下方法对URL进行解析：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-type">BOOL</span>)performActionWithUrl:(<span class="hljs-built_in">NSURL</span> *)url<br>                completion:(<span class="hljs-type">void</span>(^)(<span class="hljs-type">id</span> info))completion;<br></code></pre></td></tr></table></figure><p>在此方法的实现中解析出协议名和协议方法SEL；以解析出来的协议名作为key，从本工具类中取出实现了此协议的组件服务类；随后创建其实例并通过 perform 或 NSInvocation 调用反射出来的协议方法，完成本次远程调用。可参考我在上面代码中的注释。</p><h5 id="3-5-调用服务"><a href="#3-5-调用服务" class="headerlink" title="3.5.调用服务"></a>3.5.调用服务</h5><ul><li>本地调用</li></ul><p>主页组件中调用详情组件，跳转到返回的详情组件实例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;HomeViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ModuleProtocolMediator.h&quot;</span> <span class="hljs-comment">// 导入中间层</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;CommonProtocol.h&quot;</span>  <span class="hljs-comment">// 导入公共协议头文件</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HomeViewController</span></span><br><br>- (<span class="hljs-keyword">IBAction</span>)onShowDetail:(<span class="hljs-type">id</span>)sender &#123;<br>    <br>    <span class="hljs-built_in">UIButton</span> *btn = sender;<br>    <br>    <span class="hljs-comment">/* 调用详情组件 因为导入了 ModuleProtocolMediator 和 DetailModuleProtocol，</span><br><span class="hljs-comment">     *所以当前类中直到详情组件提供了哪些服务接口，调用这些接口即可~</span><br><span class="hljs-comment">     *当前类只跟ModuleProtocolMediator交互，不与DetailViewController耦合~</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">id</span>&lt;DetailModuleProtocol&gt; implementor = [ModuleProtocolMediator protocolImplementorWithProtocol:<br>                                            <span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">DetailModuleProtocol</span>)];</span><br>    <br>    <span class="hljs-comment">// 调用协议接口 传递参数 获取返回值</span><br>    <span class="hljs-built_in">UIViewController</span> *vc = [implementor detailControllerWithPic:btn.currentBackgroundImage<br>                                                       callback:^(<span class="hljs-type">id</span>&lt;DetailModelProtocol&gt; model) &#123;<br>        <span class="hljs-keyword">self</span>.title = model.name; <span class="hljs-comment">// 从详情中返回时更新标题(注意，这里并未导入详情实体，而是实体的协议类)</span><br>    &#125;];<br>    [<span class="hljs-keyword">self</span>.navigationController pushViewController:vc animated:<span class="hljs-literal">YES</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>主页组件调用了详情组件但并未引用详情组件的头文件；详情组件的回调中返回了详情实体，但也只是用了协议的形式，并未真的导入<code>DetailModel.h</code>实体。所以从整体上来说，<code>Home</code>组件只导入了中间层和公共协议头文件。</p><ul><li>远程调用</li></ul><p>A应用中按照约定的格式组装URL并跳转：（注意SEL部分要进行编码）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSCharacterSet</span> *allowedCharacters = [[<span class="hljs-built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="hljs-string">@&quot;:&quot;</span>] invertedSet];<br><span class="hljs-built_in">NSString</span> *scheme = <span class="hljs-string">@&quot;DaModuleProtocolScheme&quot;</span>;<br><span class="hljs-built_in">NSString</span> *protocol = <span class="hljs-string">@&quot;DetailModuleProtocol&quot;</span>;<br><span class="hljs-built_in">NSString</span> *SELStr = [<span class="hljs-string">@&quot;detailControllerWithPic:callback:&quot;</span> <br>   stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters];<br><br><span class="hljs-built_in">NSString</span> *params = [<span class="hljs-string">@&quot;k1=1&amp;k2=2&quot;</span> stringByAddingPercentEncodingWithAllowedCharacters:allowedCharacters];<br><span class="hljs-built_in">NSString</span> *urlStr = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@://%@:/%@?%@&quot;</span>,scheme,protocol,SELStr,params];<br><span class="hljs-comment">// URL示例：@&quot;DaModuleProtocolScheme://DetailModuleProtocol:/detailControllerWithPic:callback:?k1=1&amp;k2=2&quot;;</span><br>    <br><span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:urlStr];<br>[[<span class="hljs-built_in">UIApplication</span> sharedApplication] openURL:url];<br></code></pre></td></tr></table></figure><p>当前应用的<code>AppDelegate</code>回调中调用注册中心提供的远程调用接口:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)app<br>            openURL:(<span class="hljs-built_in">NSURL</span> *)url<br>            options:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">UIApplicationOpenURLOptionsKey</span>,<span class="hljs-type">id</span>&gt; *)options<br>&#123;<br>    <span class="hljs-keyword">return</span> [ModuleProtocolMediator performActionWithUrl:url completion:^(<span class="hljs-type">id</span> info) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++%@&quot;</span>,info);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p><code>performActionWithUrl</code>接口的具体实现可参考<code>3.4.注册协议</code>章节中的<code>ModuleProtocolMediator</code>类。此方法借鉴了前两篇文章中分析过的<code>URL</code>和<code>反射</code>原理，反射出协议类名和方法名，再通过注册中心查找并创建实现了此协议的类的实例，最后利用运行时接口调用协议方法，我已在上面的代码中已经做了详细注释。</p><h5 id="3-6-方案总结"><a href="#3-6-方案总结" class="headerlink" title="3.6.方案总结"></a>3.6.方案总结</h5><ol><li>定义协议：包括实体协议、组件对外提供服务的接口协议；</li><li>实现协议：提供协议实现类，处理来自组件外的服务调用，在<code>load</code>中注册本<code>协议名</code>+<code>实现类</code>；</li><li>路由服务：提供全局服务类，处理<code>协议名</code>+<code>实现类</code>的映射存取，定义远程调用反射实现方案；</li><li>本地调用：以对方协议名为键，从服务类中取出协议实现者对象，调用组件的协议方法；</li><li>远程调用：从URL中反射协议实现者Target、SEL，通过<code>invocation</code>或<code>perform</code>调用服务；</li></ol><p>优点：</p><ul><li>体现了面向协议的编程思想，组件间通过协议进行通信；</li><li>调用协议方法时有代码提示辅助，避免了明文硬编码的不便；</li><li>协议方法中可以定义任意个数和任意类型的参数；</li><li>组件间需要用到对方的实体时，只需替换为实体所继承的协议即可；</li><li>各组件单向依赖于服务中心，实现了以服务类为中心的解耦；</li></ul><p>缺点：</p><ul><li>组件A向B传递N个参数，就需要在B组件的服务协议方法中定义N个参数，不如传实体方便，但A一旦引入B的实体文件就产生了依赖；</li><li>过多的在组件对外服务类的<code>+load</code>方法中注册服务协议，会影响应用的启动速度。</li></ul><h3 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4.目录结构"></a>4.目录结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── DaModule+Protocol<br>│   ├── AppDelegate<span class="hljs-selector-class">.h</span><br>│   ├── AppDelegate<span class="hljs-selector-class">.m</span><br>│   ├── Assets<span class="hljs-selector-class">.xcassets</span><br>│   │   ├── AppIcon<span class="hljs-selector-class">.appiconset</span><br>│   │   │   └── Contents<span class="hljs-selector-class">.json</span><br>│   │   └── Contents<span class="hljs-selector-class">.json</span><br>│   ├── Base<span class="hljs-selector-class">.lproj</span><br>│   │   ├── LaunchScreen<span class="hljs-selector-class">.storyboard</span><br>│   │   └── Main<span class="hljs-selector-class">.storyboard</span><br>│   ├── Detail<br>│   │   ├── Controllers<br>│   │   │   ├── DetailViewController<span class="hljs-selector-class">.h</span><br>│   │   │   └── DetailViewController<span class="hljs-selector-class">.m</span><br>│   │   ├── Model<br>│   │   │   ├── DetailModel<span class="hljs-selector-class">.h</span><br>│   │   │   └── DetailModel<span class="hljs-selector-class">.m</span><br>│   │   ├── Protocol+IMPer<br>│   │   │   ├── DetailProtocolImplementor<span class="hljs-selector-class">.h</span><br>│   │   │   └── DetailProtocolImplementor<span class="hljs-selector-class">.m</span><br>│   │   └── Protocols<br>│   │       └── DetailModuleProtocol<span class="hljs-selector-class">.h</span><br>│   ├── Home<br>│   │   ├── HomeViewController<span class="hljs-selector-class">.h</span><br>│   │   └── HomeViewController<span class="hljs-selector-class">.m</span><br>│   ├── Icons<br>│   │   ├── <span class="hljs-number">1</span>@<span class="hljs-number">2</span>x<span class="hljs-selector-class">.png</span><br>│   │   └── <span class="hljs-number">1</span>@<span class="hljs-number">3</span>x<span class="hljs-selector-class">.png</span><br>│   ├── Info<span class="hljs-selector-class">.plist</span><br>│   ├── ProtocolMediator<br>│   │   ├── CommonProtocol<span class="hljs-selector-class">.h</span><br>│   │   ├── ModuleProtocolMediator<span class="hljs-selector-class">.h</span><br>│   │   └── ModuleProtocolMediator<span class="hljs-selector-class">.m</span><br>│   └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.m</span><br>└── DaModule+Protocol.xcodeproj<br></code></pre></td></tr></table></figure><h3 id="5-结尾"><a href="#5-结尾" class="headerlink" title="5.结尾"></a>5.结尾</h3><p>基于面向协议编程的<code>协议+服务注册+URL+反射</code>方案很好的解决了单纯<code>URL</code>或<code>反射</code>方案的缺点；它也有缺点，但显然优点大于缺点，所以还是很值得推荐的。目前有赞开源的<code>Bifrost</code>库除了<code>URL</code>路由方案外，也提供了基于协议的组件化方案，后续有时间会单开一篇梳理一下这个库~</p><hr><p>相关参考：</p><p>#<a href="https://github.com/davidli-/DaModule-Protocol">©服务协议注册方案demo</a></p><p>#<a href="https://github.com/davidli-/DaModules-Hardcore">©反射方案demo</a></p><p>#<a href="https://github.com/davidli-/HelModules-URL">©URL+Block方案demo</a></p><p>#<a href="https://github.com/youzan/Bifrost">©有赞Bifrost</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件化-反射方案</title>
    <link href="/2020/11/12/modules-runtime.html"/>
    <url>/2020/11/12/modules-runtime.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>上一篇文章中分析了组件化的目标和好处，同时梳理了基于<code>URL+Block</code>的路由组件化解决方案的原理、实践和优缺点。本文将继续介绍第二种解决方案：基于反射原理的组件化方案。</p><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h3><p>从<code>主页</code>跳转到<code>详情</code>，传入详情页所需的头像；</p><p>在详情中简单的修改信息之后，返回主页时更新主页的标题。</p><h3 id="3-思路"><a href="#3-思路" class="headerlink" title="3.思路"></a>3.思路</h3><p>基于反射原理的组件化方案，其首要目标还是实现各组件之间的通信，同时减少组件间的耦合。其实现原理如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_module_runtime.jpg" alt="组件化-反射方案"></p><h4 id="3-1-反射类名"><a href="#3-1-反射类名" class="headerlink" title="3.1.反射类名"></a>3.1.反射类名</h4><p>利用运行时接口将类名反射成类，如目标组件的类名：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Class *targetObj <span class="hljs-operator">=</span> NSClassFromString(NSString *aClassName)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="3-2-反射方法名"><a href="#3-2-反射方法名" class="headerlink" title="3.2.反射方法名"></a>3.2.反射方法名</h4><p>将方法名反射成SEL，如目标组件提供的接口：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">SEL sel <span class="hljs-operator">=</span> NSSelectorFromString(NSString *aSelectorName)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-调用"><a href="#3-3-调用" class="headerlink" title="3.3.调用"></a>3.3.调用</h4><p>通过 [targetObj performSelector:sel withObject:params] 实现与目标组件的通信：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(id)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector withObject:<span class="hljs-params">(id)</span>object;<br></code></pre></td></tr></table></figure><h4 id="3-4-优化"><a href="#3-4-优化" class="headerlink" title="3.4.优化"></a>3.4.优化</h4><p>由于 performSelector 传递的参数个数有限，且返回值只能为id类型，所以可使用 NSInvocation 作为备用方案：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSInvocation</span> *)invocationWithMethodSignature:(<span class="hljs-built_in">NSMethodSignature</span> *)sig; <span class="hljs-comment">// 创建实例</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-type">id</span> target; <span class="hljs-comment">//设置目标</span><br><span class="hljs-keyword">@property</span> SEL selector; <span class="hljs-comment">// 设置目标函数</span><br><br>- (<span class="hljs-type">void</span>)setArgument:(<span class="hljs-type">void</span> *)argumentLocation atIndex:(<span class="hljs-built_in">NSInteger</span>)idx; <span class="hljs-comment">//设置参数</span><br>- (<span class="hljs-type">void</span>)invoke; <span class="hljs-comment">// 发起调用</span><br>- (<span class="hljs-type">void</span>)getReturnValue:(<span class="hljs-type">void</span> *)retLoc; <span class="hljs-comment">// 获取返回值</span><br></code></pre></td></tr></table></figure><h3 id="4-CTMediator"><a href="#4-CTMediator" class="headerlink" title="4.CTMediator"></a>4.CTMediator</h3><p>反射方案利用了运行时的一些接口，如果你熟悉的话完全可以自己去尝试调用这些接口，实现组件间的通信。这里我想介绍的是一个用于实现组件间通信的三方库<a href="https://github.com/casatwy/CTMediator">CTMediator</a>，它正是基于OC的反射机制，帮我们封装了 Target-action 和 NSInvocation 操作。它提供了两种调用组件的方式：本地调用和远程调用，同时提供了其他副产品。这个库对实践基于反射原理的组件化解耦方案提供了很好的帮助，至少你可以拿来做个参考。</p><h4 id="4-1-代码"><a href="#4-1-代码" class="headerlink" title="4.1.代码"></a>4.1.代码</h4><p>这个库很精炼，只有两个文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// CTMediator.h</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CTMediator</span> : <span class="hljs-title">NSObject</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)sharedInstance;<br><br><span class="hljs-comment">// 远程App调用入口</span><br>- (<span class="hljs-type">id</span>)performActionWithUrl:(<span class="hljs-built_in">NSURL</span> *)url<br>                completion:(<span class="hljs-type">void</span>(^)(<span class="hljs-built_in">NSDictionary</span> *info))completion;<br><br><span class="hljs-comment">// 本地组件调用入口</span><br>- (<span class="hljs-type">id</span>)performTarget:(<span class="hljs-built_in">NSString</span> *)targetName<br>             action:(<span class="hljs-built_in">NSString</span> *)actionName<br>             params:(<span class="hljs-built_in">NSDictionary</span> *)params<br>  shouldCacheTarget:(<span class="hljs-type">BOOL</span>)shouldCacheTarget;<br><br>- (<span class="hljs-type">void</span>)releaseCachedTargetWithTargetName:(<span class="hljs-built_in">NSString</span> *)targetName;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// CTMediator.m</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CTMediator</span></span><br><br><span class="hljs-comment">/* 远程APP调用入口</span><br><span class="hljs-comment"> scheme://[target]/[action]?[params]</span><br><span class="hljs-comment"> url sample:</span><br><span class="hljs-comment"> aaa://targetA/actionB?id=1234</span><br><span class="hljs-comment"> */</span><br><br>- (<span class="hljs-type">id</span>)performActionWithUrl:(<span class="hljs-built_in">NSURL</span> *)url<br>                completion:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSDictionary</span> *))completion<br>&#123;<br>    <span class="hljs-built_in">NSMutableDictionary</span> *params = [[<span class="hljs-built_in">NSMutableDictionary</span> alloc] init];<br>    <span class="hljs-built_in">NSString</span> *urlString = [url query];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *param <span class="hljs-keyword">in</span> [urlString componentsSeparatedByString:<span class="hljs-string">@&quot;&amp;&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSArray</span> *elts = [param componentsSeparatedByString:<span class="hljs-string">@&quot;=&quot;</span>];<br>        <span class="hljs-keyword">if</span>([elts count] &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>        [params setObject:[elts lastObject] forKey:[elts firstObject]];<br>    &#125;<br>    <br>    <span class="hljs-comment">/* 这里这么写主要是出于安全考虑，防止黑客通过远程方式调用本地模块。</span><br><span class="hljs-comment">    这里的做法足以应对绝大多数场景，如果要求更加严苛，也可以做更加复杂的安全逻辑。*/</span><br>    <span class="hljs-built_in">NSString</span> *actionName = [url.path stringByReplacingOccurrencesOfString:<span class="hljs-string">@&quot;/&quot;</span> withString:<span class="hljs-string">@&quot;&quot;</span>];<br>    <span class="hljs-keyword">if</span> ([actionName hasPrefix:<span class="hljs-string">@&quot;native&quot;</span>]) &#123;<br>        <span class="hljs-keyword">return</span> @(<span class="hljs-literal">NO</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* 这个demo针对URL的路由处理非常简单，就只是取对应的target名字和method名字，</span><br><span class="hljs-comment">    但这已经足以应对绝大部份需求。如果需要拓展，可以在这个方法调用之前加入完整的路由逻辑</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">id</span> result = [<span class="hljs-keyword">self</span> performTarget:url.host<br>                             action:actionName<br>                             params:params<br>                  shouldCacheTarget:<span class="hljs-literal">NO</span>];<br>    <span class="hljs-keyword">if</span> (completion) &#123;<br>        <span class="hljs-keyword">if</span> (result) &#123;<br>            completion(@&#123;<span class="hljs-string">@&quot;result&quot;</span>:result&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            completion(<span class="hljs-literal">nil</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// ME:本地组件调用入口</span><br>- (<span class="hljs-type">id</span>)performTarget:(<span class="hljs-built_in">NSString</span> *)targetName<br>             action:(<span class="hljs-built_in">NSString</span> *)actionName<br>             params:(<span class="hljs-built_in">NSDictionary</span> *)params<br>  shouldCacheTarget:(<span class="hljs-type">BOOL</span>)shouldCacheTarget<br>&#123;<br>    <span class="hljs-built_in">NSString</span> *swiftModuleName = params[kCTMediatorParamsKeySwiftTargetModuleName];<br>    <br>    <span class="hljs-comment">// 反射target</span><br>    <span class="hljs-built_in">NSString</span> *targetClassString = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (swiftModuleName.length &gt; <span class="hljs-number">0</span>) &#123;<br>        targetClassString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@.Target_%@&quot;</span>, swiftModuleName, targetName];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// NOTICE: 就是这里给类名加了前缀!!!</span><br>        targetClassString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Target_%@&quot;</span>, targetName];<br>    &#125;<br>    <span class="hljs-built_in">NSObject</span> *target = <span class="hljs-keyword">self</span>.cachedTarget[targetClassString];<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">nil</span>) &#123;<br>        Class targetClass = <span class="hljs-built_in">NSClassFromString</span>(targetClassString);<br>        target = [[targetClass alloc] init];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 反射action</span><br>    <span class="hljs-built_in">NSString</span> *actionString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Action_%@:&quot;</span>, actionName];<br>    SEL action = <span class="hljs-built_in">NSSelectorFromString</span>(actionString);<br>    <br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-comment">/*这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。</span><br><span class="hljs-comment">        实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</span><br><span class="hljs-comment">         */</span><br>        [<span class="hljs-keyword">self</span> NoTargetActionResponseWithTargetString:targetClassString<br>                                      selectorString:actionString<br>                                        originParams:params];<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (shouldCacheTarget) &#123;<br>        <span class="hljs-keyword">self</span>.cachedTarget[targetClassString] = target;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> ([target respondsToSelector:action]) &#123;<br>        <span class="hljs-comment">// NOTICE: 调用 NSInvocation 进行通信</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> safePerformAction:action target:target params:params];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</span><br>        SEL action = <span class="hljs-built_in">NSSelectorFromString</span>(<span class="hljs-string">@&quot;notFound:&quot;</span>);<br>        <span class="hljs-keyword">if</span> ([target respondsToSelector:action]) &#123;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> safePerformAction:action target:target params:params];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/* 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。</span><br><span class="hljs-comment">            实际开发过程中，可以用前面提到的固定的target顶上的。</span><br><span class="hljs-comment">             */</span><br>            [<span class="hljs-keyword">self</span> NoTargetActionResponseWithTargetString:targetClassString<br>                                          selectorString:actionString<br>                                            originParams:params];<br>            [<span class="hljs-keyword">self</span>.cachedTarget removeObjectForKey:targetClassString];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">id</span>)safePerformAction:(SEL)action<br>                 target:(<span class="hljs-built_in">NSObject</span> *)target<br>                 params:(<span class="hljs-built_in">NSDictionary</span> *)params<br>&#123;<br>    <span class="hljs-built_in">NSMethodSignature</span>* methodSig = [target methodSignatureForSelector:action];<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* retType = [methodSig methodReturnType];<br>    <br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">// ME: 对目标组件返回值为非对象类型的情况进行特殊处理</span><br><br>    <span class="hljs-keyword">if</span> (strcmp(retType, <span class="hljs-keyword">@encode</span>(<span class="hljs-built_in">NSUInteger</span>)) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:methodSig];<br>        [invocation setArgument:&amp;params atIndex:<span class="hljs-number">2</span>];<br>        [invocation setSelector:action];<br>        [invocation setTarget:target];<br>        [invocation invoke];<br>        <span class="hljs-built_in">NSUInteger</span> result = <span class="hljs-number">0</span>;<br>        [invocation getReturnValue:&amp;result];<br>        <span class="hljs-keyword">return</span> @(result);<br>    &#125;<br><br>    <span class="hljs-comment">// ME: 返回值是对象类型则直接走此方法</span><br>    <span class="hljs-keyword">return</span> [target performSelector:action withObject:params];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>ps：库的作者提供了详细的注释，<code>// ME:</code>标注的注释是我添加，用来说明其中的业务逻辑。</p><h4 id="4-2-本地调用"><a href="#4-2-本地调用" class="headerlink" title="4.2.本地调用"></a>4.2.本地调用</h4><p><code>CTMediator</code>实现了本地调用功能，即“performTarget:action:params:shouldCacheTarget:”接口。</p><p>所谓本地调用，就是我们的应用内部组件之间的服务调用，比如主页组件调用详情组件的跳转服务，组件间主要是通过<code>performSelector</code>的方式进行通信，对于返回值为非对象类型的情况则使用<code>NSInvocation</code>进行通信。</p><p><code>[target performSelector:action withObject:params]</code>需要三个主要参数：</p><ul><li>当前对象</li></ul><p>即示例中的<code>target</code>，在组件化实践中则对应着目标组件服务类的一个实例。它是通过<code>NSClassFromString(@“targetClassString”)</code>接口将字符串类型的类名反射成真实的类，再调用实例化方法创建实例。</p><ul><li>SEL</li></ul><p>即示例中的<code>action</code>，对应的是目标组件服务类对外暴露的服务接口。它是通过<code>NSSelectorFromString(actionString)</code>接口将字符串类型的接口名反射成SEL，供运行时调用。</p><ul><li>方法参数</li></ul><p>即示例中的<code>params</code>，对应的是目标组件服务类接口中的参数。由于<code>performSelector</code>能传递的参数有限，此库要求外部调用者将多个参数包装在一个字典容器中，再由库内部将此参数传递给SEL。</p><h4 id="4-3-远程调用"><a href="#4-3-远程调用" class="headerlink" title="4.3.远程调用"></a>4.3.远程调用</h4><p>CTMediator还提供了远程调用接口，即库中提供的“-performActionWithUrl:completion:”接口。</p><p>所谓远程调用，就是别的应用向我们的应用发起的服务调用，大致过程如下：</p><ul><li>A应用通过<code>[[UIApplication sharedApplication] openURL:xxx]</code>传递一个指定格式的URL到B应用；</li><li>B应用在<code>-application:openURL:</code>回调中接收URL，再调用库中的<code>performActionWithUrl</code>开始处理此URL；</li><li><code>performActionWithUrl</code>中对URL中的参数进行解析之后，再通过<code>performTarget</code>调用本地组件提供服务。</li></ul><p>远程调用时传递的URL一定要按照约定的格式拼接，开发者应按照自己的规范自定义库文件中远程调用的相关逻辑；</p><p>基于URL的远程调用有个缺点，即URL中参数的类型将会受到限制，如传递图片、数据、block等类型时将很不方便。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5.示例"></a>5.示例</h3><p>着手实现章节开始时提出的场景需求：从<code>主页</code>组件跳转到<code>详情</code>组件；返回时更新主页组件的标题。</p><h4 id="5-1-目标组件"><a href="#5-1-目标组件" class="headerlink" title="5.1.目标组件"></a>5.1.目标组件</h4><p><code>详情</code>组件视图控制器：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailViewController</span> : <span class="hljs-title">UIViewController</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSDictionary</span> *params;  <span class="hljs-comment">// 接收外部组件传进来的参数</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailViewController.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIImageView</span> *mIconImv;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIImage</span> *image;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) DetailCallback callBack; <span class="hljs-comment">// 回调block</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DetailViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <br>    <span class="hljs-comment">// 获取参数</span><br>    <span class="hljs-keyword">self</span>.mIconImv.image = <span class="hljs-keyword">self</span>.params[k_Key_Image];<br>    <span class="hljs-keyword">self</span>.callBack = <span class="hljs-keyword">self</span>.params[k_Key_Block];<br>    <br>    <span class="hljs-built_in">UIButton</span> *btn = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>    [btn setTitle:<span class="hljs-string">@&quot;返回&quot;</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn addTarget:<span class="hljs-keyword">self</span> action:<span class="hljs-keyword">@selector</span>(onBackWithBlock) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];<br>    <span class="hljs-keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="hljs-built_in">UIBarButtonItem</span> alloc] initWithCustomView:btn];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)onBackWithBlock&#123;<br>    <span class="hljs-keyword">self</span>.callBack(); <span class="hljs-comment">//回传信息</span><br>    [<span class="hljs-keyword">self</span>.navigationController popViewControllerAnimated:<span class="hljs-literal">YES</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这是详情所在的视图控制器，其中定义了用于接收外部图片的属性<code>image</code>和处理回调的<code>callBack</code>闭包。视图加载时显示外部传进来的图片；退出详情页时回调<code>callBack</code>闭包以通知上层调用者处理自己的业务。</p><h4 id="5-2-暴露接口"><a href="#5-2-暴露接口" class="headerlink" title="5.2.暴露接口"></a>5.2.暴露接口</h4><p>详情组件<code>对外提供服务的类</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Target_DetailViewController</span> : <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-built_in">UIViewController</span>*)Action_showDetail:(<span class="hljs-built_in">NSDictionary</span>*)paramDic;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Target_DetailViewController.h&quot;</span></span><br><span class="hljs-comment">// 导入详情原类</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DetailViewController.h&quot;</span> <span class="hljs-comment">// 服务类可依赖组件原类</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Target_DetailViewController</span></span><br><br>- (<span class="hljs-built_in">UIViewController</span> *)Action_showDetail:(<span class="hljs-built_in">NSDictionary</span> *)paramDic&#123;<br><br>    <span class="hljs-comment">// 当前为业务实现层 属于组件的一部分，可以引用目标VC</span><br>    DetailViewController *controller = [[<span class="hljs-built_in">UIStoryboard</span> storyboardWithName:<span class="hljs-string">@&quot;Main&quot;</span> bundle:<span class="hljs-literal">nil</span>]<br>                                          instantiateViewControllerWithIdentifier:<span class="hljs-string">@&quot;DaDetailViewController&quot;</span>];<br>    <span class="hljs-comment">// 给目标传值</span><br>    controller.params = paramDic;<br>    <br>    <span class="hljs-keyword">return</span> controller;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>一些细节：</p><ul><li>详情组件对外提供的所有服务，都在这里定义和实现；</li><li>在此服务类的头文件中将服务接口暴露给外界；</li><li>此类是详情组件的一部分，可以导入和依赖详情原类；</li><li>注意上面的命名方式，类名前缀为<code>Target_</code>，而方法名前缀为<code>Action_</code>；</li></ul><p>关于最后一条，这是因为接下来使用到的通信类三方库<code>CTMediator</code>中做了特殊处理，所以我们需要按照通信层的要求进行命名，当然，你也可以按照自己的规范在原库中将<code>Target_</code>和<code>Action_</code>修改为你自己喜欢的前缀。</p><h4 id="5-3-通信类"><a href="#5-3-通信类" class="headerlink" title="5.3.通信类"></a>5.3.通信类</h4><p><code>中间通信层</code>，这是我们在三方库<code>CTMediator</code>基础上自定义的一个分类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CTMediator.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CTMediator</span> (<span class="hljs-title">Detail</span>)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 详情中间通信类对外提供的接口</span><br><span class="hljs-comment"> @param paramDic 参数</span><br><span class="hljs-comment"> @return 返回值</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-built_in">UIViewController</span>*)<span class="hljs-built_in">CTDetail</span>:(<span class="hljs-built_in">NSDictionary</span>*)paramDic;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;CTMediator+Detail.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CTMediator</span> (<span class="hljs-title">Detail</span>)</span><br><br>- (<span class="hljs-built_in">UIViewController</span> *)<span class="hljs-built_in">CTDetail</span>:(<span class="hljs-built_in">NSDictionary</span> *)paramDic&#123;<br>    <br>    <span class="hljs-comment">/* 调用CTMediator库的“performTarget”方法;</span><br><span class="hljs-comment">    使用字符串，结合反射机制，从而避免直接引用目标类，减少依赖</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> performTarget:<span class="hljs-string">@&quot;DetailViewController&quot;</span><br>                        action:<span class="hljs-string">@&quot;showDetail&quot;</span><br>                        params:paramDic<br>             shouldCacheTarget:<span class="hljs-literal">NO</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><code>-CTDetail:</code>是详情中间通信类暴露的一个接口，其他组件想调用详情组件的服务时从这里找即可~</p><p>单独提供这么一层，而非在调用详情组件服务的地方直接执行<code>perform</code>方法，主要是因为这里的类名和方法名都是明文，在没有代码补全功能的情况下，让别的组件的开发者每次调用时都自己写一遍极有可能会出错，也很不方便。这一层对这些操作进行了封装，外部调用者就不用再为此挠头。</p><p>另外这里的明文类名和方法名并没带前一小节提到的前缀，三方库<code>CTMediator</code>中会自动追加。</p><h4 id="5-4-调用服务"><a href="#5-4-调用服务" class="headerlink" title="5.4.调用服务"></a>5.4.调用服务</h4><p>在主页组件中<code>调用</code>详情组件的服务：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CTMediator+Detail.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HomeViewController</span></span><br><br>- (<span class="hljs-keyword">IBAction</span>)onShowDetail:(<span class="hljs-type">id</span>)sender &#123;<br>    <span class="hljs-built_in">UIButton</span> *btn = sender;<br>    <br>    <span class="hljs-comment">// 声明回调 从详情页面返回当前页面时更新标题</span><br>    DetailCallback block = ^()&#123;<br>        <span class="hljs-keyword">self</span>.title = <span class="hljs-string">@&quot;Info Checked&quot;</span>;<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 通过中间层调用别的组件，传递参数</span><br>    <span class="hljs-built_in">NSDictionary</span> *params = @&#123;k_Key_Image : btn.currentBackgroundImage, k_Key_Block : block&#125;;<br>    <span class="hljs-built_in">UIViewController</span> *controller = [[<span class="hljs-built_in">CTMediator</span> sharedInstance] <span class="hljs-built_in">CTDetail</span>:params];<br>    <span class="hljs-keyword">if</span> (controller) &#123;<br>        [<span class="hljs-keyword">self</span>.navigationController pushViewController:controller animated:<span class="hljs-literal">YES</span>];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在本次调用中，主页组件中并未直接引用详情组件的头文件，只是引用了详情组件的中间通信层<code>CTMediator+Detail.h</code>。主页组件最终通过详情中间通信层提供的接口实现了对详情组件的通信或者说服务的调用。</p><h3 id="6-目录结构"><a href="#6-目录结构" class="headerlink" title="6.目录结构"></a>6.目录结构</h3><p>整个工程的目录结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── AppDelegate<span class="hljs-selector-class">.h</span><br>├── AppDelegate<span class="hljs-selector-class">.m</span><br>├── Assets<span class="hljs-selector-class">.xcassets</span><br>│   ├── AppIcon<span class="hljs-selector-class">.appiconset</span><br>│   │   └── Contents<span class="hljs-selector-class">.json</span><br>│   └── Contents<span class="hljs-selector-class">.json</span><br>├── Base<span class="hljs-selector-class">.lproj</span><br>│   ├── LaunchScreen<span class="hljs-selector-class">.storyboard</span><br>│   └── Main<span class="hljs-selector-class">.storyboard</span><br>├── Defines<span class="hljs-selector-class">.h</span><br>├── Detail<br>│   ├── Controllers<br>│   │   ├── DetailViewController<span class="hljs-selector-class">.h</span><br>│   │   └── DetailViewController<span class="hljs-selector-class">.m</span><br>│   ├── Mediator<br>│   │   ├── CTMediator+Detail<span class="hljs-selector-class">.h</span><br>│   │   └── CTMediator+Detail<span class="hljs-selector-class">.m</span><br>│   └── Module+API<br>│       ├── Target_DetailViewController<span class="hljs-selector-class">.h</span><br>│       └── Target_DetailViewController<span class="hljs-selector-class">.m</span><br>├── Home<br>│   ├── HomeViewController<span class="hljs-selector-class">.h</span><br>│   └── HomeViewController<span class="hljs-selector-class">.m</span><br>├── Icons<br>│   ├── <span class="hljs-number">1</span>@<span class="hljs-number">2</span>x<span class="hljs-selector-class">.png</span><br>│   └── <span class="hljs-number">1</span>@<span class="hljs-number">3</span>x<span class="hljs-selector-class">.png</span><br>├── Info<span class="hljs-selector-class">.plist</span><br>└── <span class="hljs-selector-tag">main</span>.m<br></code></pre></td></tr></table></figure><h3 id="7-流程总结"><a href="#7-流程总结" class="headerlink" title="7.流程总结"></a>7.流程总结</h3><ul><li>定义目标组件；</li><li>定义目标组件的对外服务类和接口；</li><li>定义目标组件的中间通信层；</li><li>发起者与目标组件的中间通信层交互，调用目标组件的接口；</li><li>中间通信层调用CTMediator，通过运行时接口实现通信；</li></ul><h3 id="8-方案评价"><a href="#8-方案评价" class="headerlink" title="8.方案评价"></a>8.方案评价</h3><p>优点：</p><ul><li>巧妙的利用了运行时接口，通过反射机制完成组件间的通信和解耦；</li><li>组件之间不再引用对方头文件，而是通过中间通信层进行通信；</li><li>调用方组件只单向依赖了像<code>CTMediator+Detail</code>分类这样的中间通信层；</li><li>各大组件之间没有耦合，只以中间层为中心与其他组件进行通信，这种思想值得肯定。</li></ul><p>缺点：</p><ul><li>中间通信层中需要明文书写类名和方法名，这种硬编码没有代码补全的辅助，极可能出错且编译时不易察觉；</li><li>当调用的服务接口中需要传递实体类作为参数时，还需导入对方组件中实体类的头文件，还是有依赖；</li><li>受反射机制的限制，本地调用时通信层中接收的参数个数有限，所以只能以字典等容器的方式传值，不够灵活方便；</li><li>远程调用时，URL中参数的类型也会受到限制，只适合用来进行应用内部页面跳转或别的App调起我们本地的页面；</li></ul><h3 id="9-结尾"><a href="#9-结尾" class="headerlink" title="9.结尾"></a>9.结尾</h3><p>整体来看，基于反射原理的组件化解决方案还是不够完美，后续会继续介绍面向协议的服务注册组件化方案，待续~</p><hr><p>相关参考：</p><p>#<a href="https://github.com/davidli-/DaModules-Hardcore">©反射方案demo</a></p><p>#<a href="https://github.com/davidli-/HelModules-URL">©URL+Block方案demo</a></p><p>#<a href="https://github.com/davidli-/DaModule-Protocol">©服务协议注册方案demo</a></p><p>#<a href="https://github.com/youzan/Bifrost">©有赞Bifrost</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件化-URL路由方案</title>
    <link href="/2020/09/03/modules-url.html"/>
    <url>/2020/09/03/modules-url.html</url>
    
    <content type="html"><![CDATA[<h3 id="一、组件化"><a href="#一、组件化" class="headerlink" title="一、组件化"></a>一、组件化</h3><h4 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h4><p>为了解耦：把复杂系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</p><h4 id="2-好处"><a href="#2-好处" class="headerlink" title="2.好处"></a>2.好处</h4><ul><li>明确组件职责</li></ul><p>按合理的粒度将系统拆分成多个组件，确保组件各司其职，以便于复用。</p><ul><li>提升开发&#x2F;编译&#x2F;测试效率</li></ul><p>开发人员只须关注自己的组件，不再需要导入或编译其他组件，从而提升开发和编译速度。</p><ul><li>减少组件间的依赖</li></ul><p><code>通信层</code>实现了组件间的通信，而不用在组件间跳转、调用服务时引用其他组件的文件。</p><h4 id="3-方案"><a href="#3-方案" class="headerlink" title="3.方案"></a>3.方案</h4><p>目前 iOS 组件化的实践中，比较流行的解决方案可归纳为以下三种：</p><p>1.基于<code>URL</code>+<code>Block</code>的路由方案；</p><p>2.基于<code>反射</code>原理的方案；</p><p>3.面向<code>协议</code>的注册服务方案；</p><blockquote><p>“没有最优的方案，只有更适合自己的方案”。</p></blockquote><p>三种方案各有优缺点。你可只选其一，也可将它们组合起来使用。前提是要理解所选方案的特点，结合项目的实际需求进行取舍。</p><p>接下来的文章中，将陆续对这三种方案进行分析和梳理~</p><h3 id="二、URL路由方案"><a href="#二、URL路由方案" class="headerlink" title="二、URL路由方案"></a>二、URL路由方案</h3><h4 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h4><p>从<code>主页</code>跳转到<code>详情</code>，传入详情页所需的头像；</p><p>在详情中简单的修改信息之后，返回主页时更新主页的标题。</p><h4 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h4><p>这是一个简单的组件间页面跳转服务，在组件化之前，我们最常见的处理可能是：</p><ul><li>在主页中引用详情的<code>.h</code>头文件；</li><li>创建详情的<code>实例</code>；</li><li>通过详情提供的接口传入图片；</li><li>将主页设置为详情的代理；</li><li><code>push</code>到详情页。</li></ul><p>这种处理的问题在于：主页中依赖了详情的头文件，且直接持有了详情的实例；详情的delegate反过来持有了主页的实例，这样两个模块间就产生了依赖和耦合。这还只是主页到详情的一种情况，如果有其他模块同样需要跳转详情，则这些模块同样也会与详情之间产生耦合。</p><p>组件化的实践中，按照合理的粒度将系统划分为多个组件之后，主要的挑战就变成了如何实现各组件之间的通信，同时减少组件间的耦合。</p><p>针对这一问题，URL+Block路由方案的实现思路和原理如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_module_URL_Block.jpg" alt="组件化-URL-BLOCK"></p><h5 id="2-1-服务Block"><a href="#2-1-服务Block" class="headerlink" title="2.1.服务Block"></a>2.1.服务Block</h5><p>将创建详情实例的服务封装成一个block：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// DetailViewController.m</span><br>RouteHandler handler = ^ id (NSDictionary *parameters)&#123;<br>    <span class="hljs-keyword">return</span> [[DetailViewController alloc] <span class="hljs-keyword">init</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="2-2-服务URL"><a href="#2-2-服务URL" class="headerlink" title="2.2.服务URL"></a>2.2.服务URL</h5><p>定义URL，用它表示详情组件中的某项服务：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// Defines.h</span><br><span class="hljs-comment">// 简单的创建详情实例</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kRouteDetaiCreateIns = <span class="hljs-string">@&quot;//detail/create&quot;</span>;<br><span class="hljs-comment">// 创建详情实例并设置图片</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kRouteDetaiPushWithIcon = <span class="hljs-string">@&quot;//detail/push&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-3-映射URL与Block"><a href="#2-3-映射URL与Block" class="headerlink" title="2.3.映射URL与Block"></a>2.3.映射URL与Block</h5><p>在单例类<code>Router</code>中将表示某项服务的URL与真正封装了服务的Block映射到字典中：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Router bindURL:kRouteDetaiPushWithIcon toHandler:handler]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// Router.m</span><br><span class="hljs-comment">// MARK: 绑定URL-Block</span><br>+(<span class="hljs-type">void</span>)bindURL:(<span class="hljs-built_in">NSString</span> *)urlStr toHandler:(RouteHandler)handler&#123;<br>    [<span class="hljs-keyword">self</span>.routes setValue:handler forKey:urlStr];<br>&#125;<br><br>+ (<span class="hljs-built_in">NSMutableDictionary</span>*)routes &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSMutableDictionary</span> *_routes = <span class="hljs-literal">nil</span>;<br>        <span class="hljs-keyword">if</span> (!_routes) &#123;<br>            _routes = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        &#125;<br>        <span class="hljs-keyword">return</span> _routes;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-调用服务"><a href="#2-4-调用服务" class="headerlink" title="2.4.调用服务"></a>2.4.调用服务</h5><p>在主页中通过<code>Router</code>调用详情的服务并获取返回值：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIViewController</span> *vc = [Router handleURL:url complexParams:params completion:^(<span class="hljs-type">id</span> result) &#123;<br>    <span class="hljs-keyword">self</span>.title = <span class="hljs-string">@&quot;Updated&quot;</span>;<br>&#125;];<br>[<span class="hljs-keyword">self</span>.navigationController pushViewController:vc animated:<span class="hljs-literal">YES</span>];<br></code></pre></td></tr></table></figure><h5 id="2-5-服务路由查询"><a href="#2-5-服务路由查询" class="headerlink" title="2.5.服务路由查询"></a>2.5.服务路由查询</h5><p><code>+handleURL</code>接口内部会根据之前保存的URL-Block映射关系，以<code>url</code>为key去查询对应的Block并执行它：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-keyword">nullable</span> RouteHandler)handlerForURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.routes valueForKey:urlStr];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h4><h5 id="3-1-映射URL与服务"><a href="#3-1-映射URL与服务" class="headerlink" title="3.1.映射URL与服务"></a>3.1.映射URL与服务</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// Defines.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UrlsHeader_h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UrlsHeader_h</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-comment">// 详情页对外暴露的回调</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>(^DetailCallback)(<span class="hljs-type">void</span>);<br><br><span class="hljs-comment">// 简单的创建详情实例</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kRouteDetaiCreateIns = <span class="hljs-string">@&quot;//detail/create&quot;</span>;<br><span class="hljs-comment">// 创建详情实例并设置图片</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kRouteDetaiPushWithIcon = <span class="hljs-string">@&quot;//detail/push&quot;</span>;<br><span class="hljs-comment">// 跳转主页</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kRouteHome = <span class="hljs-string">@&quot;//home&quot;</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* UrlsHeader_h */</span></span><br></code></pre></td></tr></table></figure><p><code>Defines.h</code>头文件用于定义URL，也包括其他必要参数。它是一个通用文件，不属于某个组件，可在.pch文件中导入此头文件。</p><p>在这里你可以定义一个URL字符串<code>@&quot;//detail/push</code>，其中第一个字符串”detail”表示详情组件，第二个字符串”push“表示跳转功能。后面我们就使用此URL来实现从主页到详情的跳转。</p><h5 id="3-2-定义Router"><a href="#3-2-定义Router" class="headerlink" title="3.2.定义Router"></a>3.2.定义Router</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// Router.h</span><br><span class="hljs-comment">// 表示服务的block，接受字典类型的参数集合</span><br><span class="hljs-keyword">typedef</span> _Nullable <span class="hljs-type">id</span> (^RouteHandler)( <span class="hljs-built_in">NSDictionary</span> * _Nullable parameters);<br><span class="hljs-comment">// 回调block</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> (^RouteCompletion)(_Nullable <span class="hljs-type">id</span> result);<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Router</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">/// 绑定URL与Block</span><br><span class="hljs-comment">/// @param urlStr 对外暴露的代表某组件服务的URL</span><br><span class="hljs-comment">/// @param handler 服务接口，以block形式暴露给外部调用者</span><br>+ (<span class="hljs-type">void</span>)bindURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr <br>      toHandler:(<span class="hljs-keyword">nonnull</span> RouteHandler)handler;<br><br><span class="hljs-comment">/// 调用服务接口</span><br><span class="hljs-comment">/// @param urlStr 代表目标组件服务接口的URL</span><br><span class="hljs-comment">/// @param complexParams URL中不方便传递的参数</span><br><span class="hljs-comment">/// @param completion 回调</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr<br>complexParams:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)complexParams<br>              completion:(<span class="hljs-keyword">nullable</span> RouteCompletion)completion;<br><br><span class="hljs-comment">/// 该URL是否有与之对应的Block</span><br><span class="hljs-comment">/// @param urlStr URL字符串</span><br>+ (<span class="hljs-type">BOOL</span>)canHandleUrl:(<span class="hljs-built_in">NSString</span>*)urlStr;<br><br><span class="hljs-keyword">@end</span><br><br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><br><span class="hljs-comment">// Router.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Router.h&quot;</span></span><br><br><span class="hljs-keyword">static</span> Router *mInstance = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Router</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)sharedInstance&#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> alloc] init];<br>&#125;<br><br>+ (<span class="hljs-keyword">instancetype</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        mInstance = [<span class="hljs-variable language_">super</span> allocWithZone:zone];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> mInstance;<br>&#125;<br><br><span class="hljs-comment">// MARK: Getter&amp;Setter</span><br><br>+ (<span class="hljs-built_in">NSMutableDictionary</span>*)routes &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSMutableDictionary</span> *_routes = <span class="hljs-literal">nil</span>;<br>        <span class="hljs-keyword">if</span> (!_routes) &#123;<br>            _routes = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        &#125;<br>        <span class="hljs-keyword">return</span> _routes;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// MARK: 绑定URL-Block</span><br>+(<span class="hljs-type">void</span>)bindURL:(<span class="hljs-built_in">NSString</span> *)urlStr toHandler:(RouteHandler)handler&#123;<br>    [<span class="hljs-keyword">self</span>.routes setValue:handler forKey:urlStr];<br>&#125;<br><br><span class="hljs-comment">// MARK: 根据URL调用服务</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr<br>complexParams:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)complexParams<br>   completion:(<span class="hljs-keyword">nullable</span> RouteCompletion)completion &#123;<br>    <br>    <span class="hljs-comment">// 重新获取参数之前的URL.host和URL.path，如“//detail/push”</span><br>    <span class="hljs-built_in">NSString</span> *URLKey = [<span class="hljs-keyword">self</span> getKeyFromURL:urlStr];<br>    <br>    <span class="hljs-comment">// 查找url对应的block</span><br>    RouteHandler handler = [<span class="hljs-keyword">self</span> handlerForURL:URLKey];<br>    <br>    <span class="hljs-comment">//拼接参数</span><br>    <span class="hljs-built_in">NSDictionary</span> *paramsInURL = [<span class="hljs-keyword">self</span>.class parametersInURL:urlStr];<br>    <span class="hljs-built_in">NSMutableDictionary</span> *params = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithDictionary:complexParams];<br>    [params addEntriesFromDictionary:paramsInURL];<br>    <br>    <span class="hljs-type">id</span> obj = handler(params);<br>    <br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-comment">// MARK: 获取URL中?号之后的参数</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)parametersInURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span>*)urlStr &#123;<br>    <span class="hljs-built_in">NSURL</span> *URL = [<span class="hljs-built_in">NSURL</span> URLWithString:urlStr];<br>    <span class="hljs-built_in">NSMutableDictionary</span> *params = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-built_in">NSString</span> *query = URL.query;<br>    <span class="hljs-keyword">if</span>(query.length &gt; <span class="hljs-number">0</span>) &#123;<br>        params = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        <span class="hljs-built_in">NSArray</span> *list = [query componentsSeparatedByString:<span class="hljs-string">@&quot;&amp;&quot;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *param <span class="hljs-keyword">in</span> list) &#123;<br>            <span class="hljs-built_in">NSArray</span> *elts = [param componentsSeparatedByString:<span class="hljs-string">@&quot;=&quot;</span>];<br>            <span class="hljs-keyword">if</span>([elts count] &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">NSString</span> *decodedStr = [[elts lastObject] stringByRemovingPercentEncoding];<br>            [params setObject:decodedStr forKey:[elts firstObject]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> params;<br>&#125;<br><br><span class="hljs-comment">// MARK:根据URL获取对应的Block</span><br>+ (<span class="hljs-keyword">nullable</span> RouteHandler)handlerForURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.routes valueForKey:urlStr];<br>&#125;<br><br><span class="hljs-comment">// MARK:URL是否有与之对应的Block</span><br>+ (<span class="hljs-type">BOOL</span>)canHandleUrl:(<span class="hljs-built_in">NSString</span>*)urlStr&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> getKeyFromURL:urlStr].length != <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//  重新获取参数之前的URL.host和URL.path，如“//detail/push”</span><br>+ (<span class="hljs-built_in">NSString</span>*)getKeyFromURL:(<span class="hljs-built_in">NSString</span>*)urlStr&#123;<br>    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:urlStr];<br>    <span class="hljs-built_in">NSString</span> *host = url.host;<br>    <span class="hljs-built_in">NSString</span> *path = url.path;<br>    <span class="hljs-built_in">NSString</span> *URLKey = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;//%@%@&quot;</span>,host,path];<br>    <br>    <span class="hljs-keyword">return</span> URLKey;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这是URL路由方案中的<code>核心类</code>。其主要作用有：</p><ul><li>提供全局静态字典，以便保存URL与Block的映射关系；</li><li>提供接口以便调用方通过约定好的URL调用目标组件的服务；</li></ul><p>一些需要注意的细节：</p><p>1、<code>+bindURL</code>接口中的<code>urlStr</code>参数是代表目标组件服务接口的纯URL，如<code>&quot;//detail/push&quot;</code>，不带任何其他参数，在全局字典中保存映射关系时，key&#x3D;URL，value&#x3D;block。</p><p>2、<code>+handleURL</code>接口中的<code>urlStr</code>参数则是完整的URL，可包含调用方向目标组件传递的参数，如”&#x2F;&#x2F;detail&#x2F;push?a&#x3D;1&amp;b&#x3D;1”;</p><p>3、在<code>+handleURL</code>方法内根据URL查询Block时，key为从<code>urlStr</code>中拆分出的<code>url.host+url.path</code>部分，即<code>“//detail/push”</code>；</p><p>4、本示例中<code>Router.h</code>只提供了最简单和最主要的两个接口，实际使用中可根据需求自己扩展其他功能，这里不做过多的延伸，因为后面会讲到有赞开源的库<code>Bifrost</code>，那里进行了完善的封装。</p><h5 id="3-3-注册服务"><a href="#3-3-注册服务" class="headerlink" title="3.3.注册服务"></a>3.3.注册服务</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// DetailViewController.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailViewController</span> : <span class="hljs-title">UIViewController</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">UIImage</span> *img;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) DetailCallback callBack; <span class="hljs-comment">// 回调block</span><br><span class="hljs-keyword">@end</span><br><br>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br><span class="hljs-comment">// DetailViewController.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Router.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DetailViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIImageView</span> *mIconView;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DetailViewController</span></span><br><br>+ (<span class="hljs-type">void</span>)load&#123;<br>    <span class="hljs-comment">// 以block的形式封装对外服务</span><br>    RouteHandler handler = ^ <span class="hljs-type">id</span> (<span class="hljs-built_in">NSDictionary</span> *parameters)&#123;<br>        <span class="hljs-built_in">UIImage</span> *img = parameters[<span class="hljs-string">@&quot;img&quot;</span>];<br>        DetailCallback callback = parameters[<span class="hljs-string">@&quot;block&quot;</span>];<br>        DetailViewController *vc = [[<span class="hljs-built_in">UIStoryboard</span> storyboardWithName:<span class="hljs-string">@&quot;Main&quot;</span> bundle:<span class="hljs-literal">nil</span>]<br>                                    instantiateViewControllerWithIdentifier:<span class="hljs-string">@&quot;DetailViewController&quot;</span>];<br>        vc.img = img;<br>        vc.callBack = callback;<br>        <span class="hljs-keyword">return</span> vc;<br>    &#125;;<br>    <span class="hljs-comment">// 将URL与Block的关系注册到路由表中</span><br>    [Router bindURL:kRouteDetaiPushWithIcon toHandler:handler];<br>    <br>    <span class="hljs-comment">// 可注册多个Block，以便对外提供更多服务</span><br>    RouteHandler handler2 = ^ (<span class="hljs-built_in">NSDictionary</span> *params)&#123;<br>        <span class="hljs-keyword">return</span> [[DetailViewController alloc] init];<br>    &#125;;<br>    [Router bindURL:kRouteDetaiCreateIns toHandler:handler2];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    _mIconView.image = _img;<br>&#125;<br><br>- (<span class="hljs-keyword">IBAction</span>)onDismissAction:(<span class="hljs-type">id</span>)sender &#123;<br>    <span class="hljs-keyword">self</span>.callBack(); <span class="hljs-comment">//回调给服务调用方</span><br>    [<span class="hljs-keyword">self</span>.navigationController popViewControllerAnimated:<span class="hljs-literal">YES</span>];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++DetailViewController dealloced~~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这一步是在被调用的组件中进行的，即<code>DetailViewController</code>。注册的操作是在<code>+load()</code>方法中进行的，这样就能保证在应用启动阶段将表示当前组件服务接口的URL和block自动注册到<code>Router</code>中，以便后面随时调用。</p><p><code>+load()</code>方法中可以注册多个对外提供服务的block，就相当于对外提供了多个接口，区分好对应的URL即可。</p><h5 id="3-4-本地调用服务"><a href="#3-4-本地调用服务" class="headerlink" title="3.4.本地调用服务"></a>3.4.本地调用服务</h5><p>所谓本地调用，就是我们的应用内部组件之间的服务调用，比如主页调用详情的接口：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// HomeViewController.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Router.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HomeViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>&#125;<br><br>- (<span class="hljs-keyword">IBAction</span>)onPushAction:(<span class="hljs-type">id</span>)sender &#123;<br>    <span class="hljs-comment">// 声明回调 从头像页面返回当前页面时更新标题</span><br>    DetailCallback block = ^()&#123;<br>        <span class="hljs-keyword">self</span>.title = <span class="hljs-string">@&quot;Info Checked&quot;</span>;<br>    &#125;;<br>    <span class="hljs-built_in">NSDictionary</span> *params = @&#123;<span class="hljs-string">@&quot;img&quot;</span>:[<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;1&quot;</span>],<span class="hljs-string">@&quot;block&quot;</span>:block&#125;;<br>    <span class="hljs-built_in">NSString</span> *url = [kRouteDetaiPushWithIcon stringByAppendingString:<span class="hljs-string">@&quot;?num=1&amp;orderid=10001&quot;</span>];<br><br>    <span class="hljs-comment">// 调用服务</span><br>    <span class="hljs-built_in">UIViewController</span> *vc = [Router handleURL:url complexParams:params completion:^(<span class="hljs-type">id</span> result) &#123;<br>        <span class="hljs-keyword">self</span>.title = <span class="hljs-string">@&quot;Updated&quot;</span>;<br>    &#125;];<br>    [<span class="hljs-keyword">self</span>.navigationController pushViewController:vc animated:<span class="hljs-literal">YES</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li>调用方使用约定好的URL字符串指明要调用的服务接口；</li><li>将简单的参数以<code>URL.query</code>的形式拼接到URL中；</li><li>对于复杂的参数，可包装到字典<code>params</code>中；</li><li>回调函数中定义好自己的业务逻辑，作为<code>completion</code>参数；</li><li>通过<code>Router</code>调用服务，传入之前的参数，等待接收并处理返回值即可。</li></ul><h5 id="3-5-远程服务调用"><a href="#3-5-远程服务调用" class="headerlink" title="3.5.远程服务调用"></a>3.5.远程服务调用</h5><p>所谓远程调用，就是别的应用向我们的应用发起的服务调用，大致过程如下：</p><ul><li>别的应用通过<code>[[UIApplication sharedApplication] openURL:url]</code>传递指定格式的URL到我们的应用；</li><li>我们的应用在下面的回调中接收URL，经过Router查询和调用与URL绑定的服务Block：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)app <br>            openURL:(<span class="hljs-built_in">NSURL</span> *)url <br>            options:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">UIApplicationOpenURLOptionsKey</span>,<span class="hljs-type">id</span>&gt; *)options<br>&#123;<br>    <span class="hljs-type">BOOL</span> canHandle = [Router canHandleUrl:url.absoluteString];<br>    <span class="hljs-keyword">if</span> (canHandle) &#123;<br>        [Router handleURL:url.absoluteString complexParams:<span class="hljs-literal">nil</span> completion:^(<span class="hljs-type">id</span> result) &#123;<br>        &#125;];<br>    &#125;<br>    <span class="hljs-keyword">return</span> canHandle;<br>&#125;<br></code></pre></td></tr></table></figure><p>远程调用时传递的URL一定要按照约定的格式拼接；</p><p>基于URL的远程调用有个缺点，即URL中参数的类型将会受到限制，图片、数据、block等类型的参数将无法直接拼接到URL后面。</p><h4 id="4-流程总结"><a href="#4-流程总结" class="headerlink" title="4.流程总结"></a>4.流程总结</h4><ul><li>将组件对外提供的服务以Block的形式进行封装；</li><li>定义URL以表示组件对外提供的某个接口；</li><li>应用启动阶段在全局字典中保存URL与Block的映射关系；</li><li>简单参数拼接到URL中，复杂参数包装到complexParams字典中；</li><li>服务调用方传入URL，由Router查询并调用与之绑定的Block；</li></ul><h4 id="5-目录结构"><a href="#5-目录结构" class="headerlink" title="5.目录结构"></a>5.目录结构</h4><p>整个工程的目录结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── HelModules+URL<br>│   ├── AppDelegate<span class="hljs-selector-class">.h</span><br>│   ├── AppDelegate<span class="hljs-selector-class">.m</span><br>│   ├── Assets<span class="hljs-selector-class">.xcassets</span><br>│   │   ├── AppIcon<span class="hljs-selector-class">.appiconset</span><br>│   │   └── Contents<span class="hljs-selector-class">.json</span><br>│   ├── Base<span class="hljs-selector-class">.lproj</span><br>│   │   ├── LaunchScreen<span class="hljs-selector-class">.storyboard</span><br>│   │   └── Main<span class="hljs-selector-class">.storyboard</span><br>│   ├── Common<br>│   │   ├── Defines<span class="hljs-selector-class">.h</span><br>│   │   └── PrefixHeader<span class="hljs-selector-class">.pch</span><br>│   ├── Detail<br>│   │   ├── DetailViewController<span class="hljs-selector-class">.h</span><br>│   │   └── DetailViewController<span class="hljs-selector-class">.m</span><br>│   ├── Home<br>│   │   ├── HomeViewController<span class="hljs-selector-class">.h</span><br>│   │   └── HomeViewController<span class="hljs-selector-class">.m</span><br>│   ├── Icons<br>│   │   ├── <span class="hljs-number">1</span>@<span class="hljs-number">2</span>x<span class="hljs-selector-class">.png</span><br>│   │   └── <span class="hljs-number">1</span>@<span class="hljs-number">3</span>x<span class="hljs-selector-class">.png</span><br>│   ├── Info<span class="hljs-selector-class">.plist</span><br>│   ├── Routers<br>│   │   ├── Router<span class="hljs-selector-class">.h</span><br>│   │   └── Router<span class="hljs-selector-class">.m</span><br>│   └── <span class="hljs-selector-tag">main</span>.m<br></code></pre></td></tr></table></figure><h4 id="6-Bifrost"><a href="#6-Bifrost" class="headerlink" title="6.Bifrost"></a>6.Bifrost</h4><p>整个URL解耦方案的核心是<code>Router</code>类：</p><ul><li>提供注册接口，将URL与Block的映射关系保存到全局字典中；</li><li>根据URL查询并调用对应Block。</li></ul><p>这里着重推荐一下有赞开源的组件化库<a href="https://github.com/youzan/Bifrost">”#Bifrost“</a>，它提供了对Router完善的封装。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// Bifrost+Router.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Bifrost.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BFComplete(Params, Result) [Bifrost completeWithParameters:Params result:Result]</span><br><br><span class="hljs-comment">// default keys in the parameters of BifrostRouteHandler</span><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> * _Nonnull <span class="hljs-keyword">const</span> kBifrostRouteURL; <span class="hljs-comment">//the key for the raw url</span><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> * _Nonnull <span class="hljs-keyword">const</span> kBifrostRouteCompletion; <span class="hljs-comment">//the key for the completion block.</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The handler for a binded url</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param parameters containers above 2 keys and parameters from the query string and complexParams</span><br><span class="hljs-comment"> @return the obj returned by the handler</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> _Nullable <span class="hljs-type">id</span> (^BifrostRouteHandler)( <span class="hljs-built_in">NSDictionary</span> * _Nullable parameters);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The completion block to be invoked at the end of the router handler block</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param result completion result. defaultly it is the returned object of the BifrostRouteHandler.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> (^BifrostRouteCompletion)(_Nullable <span class="hljs-type">id</span> result);<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Bifrost</span> (<span class="hljs-title">Router</span>)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The method to bind a URL to handler</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param urlStr The URL string. Only scheme, host and api path will be used here.</span><br><span class="hljs-comment"> Its query string will be ignore here.</span><br><span class="hljs-comment"> @param handler the handler block.</span><br><span class="hljs-comment"> The BifrostRouteCompletion should be invoked at the end of the block</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">void</span>)bindURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr toHandler:(<span class="hljs-keyword">nonnull</span> BifrostRouteHandler)handler;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The method to unbind a URL</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param urlStr The URL string. Only scheme, host and api path will be used here.</span><br><span class="hljs-comment"> Its query string will be ignore here.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">void</span>)unbindURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Method to unbind all URLs</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">void</span>)unbindAllURLs;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The method to check whether a url can be handled</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param urlStr The URL string. Only scheme, host and api path will be used here.</span><br><span class="hljs-comment"> Its query string will be ignore here.</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">BOOL</span>)canHandleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Method to handle the URL</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param urlStr URL string</span><br><span class="hljs-comment"> @return the returned object of the url&#x27;s BifrostRouteHandler</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Method to handle the url with completion block</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param urlStr URL string</span><br><span class="hljs-comment"> @param completion The completion block</span><br><span class="hljs-comment"> @return the returned object of the url&#x27;s BifrostRouteHandler</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr<br>              completion:(<span class="hljs-keyword">nullable</span> BifrostRouteCompletion)completion;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The method to handle URL with complex parameters and completion block</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param urlStr URL string</span><br><span class="hljs-comment"> @param complexParams complex parameters that can&#x27;t be put in the url query strings</span><br><span class="hljs-comment"> @param completion The completion block</span><br><span class="hljs-comment"> @return the returned object of the url&#x27;s BifrostRouteHandler</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr<br>           complexParams:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)complexParams<br>              completion:(<span class="hljs-keyword">nullable</span> BifrostRouteCompletion)completion;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> Invoke the completion block in the parameters of BifrostRouteHandler.</span><br><span class="hljs-comment"> Recommend to use macro BFComplete for convenient.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> @param params parameters of BifrostRouteHandler</span><br><span class="hljs-comment"> @param result the result for the BifrostRouteCompletion</span><br><span class="hljs-comment"> */</span><br>+ (<span class="hljs-type">void</span>)completeWithParameters:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)params result:(_Nullable <span class="hljs-type">id</span>)result;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>从头文件中可以看到，<code>Bifrost</code>的主要功能包括：</p><ul><li>绑定URL-Block；</li><li>根据URL处理简单参数、复杂参数、带回调的服务调用；</li><li>解除单个或所有URL与Block的映射；</li><li>检测某个URL是否绑定了Block；</li></ul><p>具体的实现代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;Bifrost+Router.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BFLog(msg) NSLog(@<span class="hljs-string">&quot;[Bifrost] %@&quot;</span>, (msg))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BFKey(URL) [Bifrost keyForURL:URL]</span><br><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kBifrostRouteURL = <span class="hljs-string">@&quot;kBifrostRouteURL&quot;</span>;<br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> kBifrostRouteCompletion = <span class="hljs-string">@&quot;kBifrostRouteCompletion&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Bifrost</span> (<span class="hljs-title">Router</span>)</span><br><br><span class="hljs-comment">// 从带参数的URL中取出.host和.path部分，作为绑定block所用的键</span><br>+ (<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span>*)keyForURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span>*)urlStr &#123;<br>    <span class="hljs-built_in">NSURL</span> *URL = [<span class="hljs-built_in">NSURL</span> URLWithString:urlStr];<br>    <span class="hljs-built_in">NSString</span> *key = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@%@&quot;</span>, URL.host, URL.path];<br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br><br><span class="hljs-comment">// 取出URL.query部分，以&amp;分割参数，重新组成字典</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)parametersInURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span>*)urlStr &#123;<br>    <span class="hljs-built_in">NSURL</span> *URL = [<span class="hljs-built_in">NSURL</span> URLWithString:urlStr];<br>    <span class="hljs-built_in">NSMutableDictionary</span> *params = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-built_in">NSString</span> *query = URL.query;<br>    <span class="hljs-keyword">if</span>(query.length &gt; <span class="hljs-number">0</span>) &#123;<br>        params = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        <span class="hljs-built_in">NSArray</span> *list = [query componentsSeparatedByString:<span class="hljs-string">@&quot;&amp;&quot;</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> *param <span class="hljs-keyword">in</span> list) &#123;<br>            <span class="hljs-built_in">NSArray</span> *elts = [param componentsSeparatedByString:<span class="hljs-string">@&quot;=&quot;</span>];<br>            <span class="hljs-keyword">if</span>([elts count] &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">NSString</span> *decodedStr = [[elts lastObject] stringByRemovingPercentEncoding];<br>            [params setObject:decodedStr forKey:[elts firstObject]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> params;<br>&#125;<br><br><span class="hljs-comment">// 静态字典，全局一份，保存URL与Block的映射关系</span><br>+ (<span class="hljs-built_in">NSMutableDictionary</span>*)routes &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSMutableDictionary</span> *_routes = <span class="hljs-literal">nil</span>;<br>        <span class="hljs-keyword">if</span> (!_routes) &#123;<br>            _routes = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        &#125;<br>        <span class="hljs-keyword">return</span> _routes;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 保存URL与Block的映射关系</span><br>+ (<span class="hljs-type">void</span>)bindURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr toHandler:(<span class="hljs-keyword">nonnull</span> BifrostRouteHandler)handler &#123;<br>    [<span class="hljs-keyword">self</span>.routes setObject:handler forKey:BFKey(urlStr)];<br>&#125;<br><br><span class="hljs-comment">// 解除URL与Block的映射关系</span><br>+ (<span class="hljs-type">void</span>)unbindURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr &#123;<br>    [<span class="hljs-keyword">self</span>.routes removeObjectForKey:BFKey(urlStr)];<br>&#125;<br><br><span class="hljs-comment">// 清空所有的映射</span><br>+ (<span class="hljs-type">void</span>)unbindAllURLs &#123;<br>    [<span class="hljs-keyword">self</span>.routes removeAllObjects];<br>&#125;<br><br><span class="hljs-comment">// 根据URL查询已绑定的Block</span><br>+ (<span class="hljs-keyword">nullable</span> BifrostRouteHandler)handlerForURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.routes objectForKey:BFKey(urlStr)];<br>&#125;<br><br><span class="hljs-comment">// 检测URL是否绑定了Block</span><br>+ (<span class="hljs-type">BOOL</span>)canHandleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr &#123;<br>    <span class="hljs-keyword">if</span> (urlStr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span> handlerForURL:urlStr]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查询并调用URL绑定的block，url中包含了简单的参数</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> handleURL:urlStr complexParams:<span class="hljs-literal">nil</span> completion:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><span class="hljs-comment">// 查询并调用URL绑定的block，url中包含了简单的参数，同时附带回调函数</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr<br>              completion:(<span class="hljs-keyword">nullable</span> BifrostRouteCompletion)completion &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> handleURL:urlStr complexParams:<span class="hljs-literal">nil</span> completion:completion];<br>&#125;<br><br><span class="hljs-comment">// 查询并调用URL绑定的block，url中包含了简单的参数，复杂参数包含在complexParams字典中，同时附带回调函数</span><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)handleURL:(<span class="hljs-keyword">nonnull</span> <span class="hljs-built_in">NSString</span> *)urlStr<br>           complexParams:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)complexParams<br>              completion:(<span class="hljs-keyword">nullable</span> BifrostRouteCompletion)completion &#123;<br>    <span class="hljs-type">id</span> obj = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">@try</span> &#123;<br>        BifrostRouteHandler handler = [<span class="hljs-keyword">self</span> handlerForURL:urlStr];<br>        <span class="hljs-built_in">NSMutableDictionary</span> *params = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithDictionary:complexParams];<br>        [params addEntriesFromDictionary:[<span class="hljs-keyword">self</span>.class parametersInURL:urlStr]];<br>        [params setObject:urlStr forKey:kBifrostRouteURL];<br>        <span class="hljs-keyword">if</span> (completion) &#123;<br>            [params setObject:completion forKey:kBifrostRouteCompletion];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!handler) &#123;<br>            <span class="hljs-built_in">NSString</span> *reason = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Cannot find handler for route url %@&quot;</span>, urlStr];<br>            <span class="hljs-built_in">NSMutableDictionary</span> *userInfo = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>            [userInfo setValue:@(BFExceptionUrlHandlerNotFound) forKey:kBifrostExceptionCode];<br>            [userInfo setValue:urlStr forKey:kBifrostExceptionURLStr];<br>            [userInfo setValue:params forKey:kBifrostExceptionURLParams];<br>            <span class="hljs-built_in">NSException</span> *exception = [[<span class="hljs-built_in">NSException</span> alloc] initWithName:BifrostExceptionName<br>                                                                reason:reason<br>                                                              userInfo:userInfo];<br>            BifrostExceptionHandler handler = [<span class="hljs-keyword">self</span> getExceptionHandler];<br>            <span class="hljs-keyword">if</span> (handler) &#123;<br>                obj = handler(exception);<br>            &#125;<br>            BFLog(reason);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            obj = handler(params);<br>        &#125;<br>    &#125; <span class="hljs-keyword">@catch</span> (<span class="hljs-built_in">NSException</span> *exception) &#123;<br>        <span class="hljs-built_in">NSMutableDictionary</span> *userInfo = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithDictionary:exception.userInfo];<br>        [userInfo setValue:@(BFExceptionDefaultCode) forKey:kBifrostExceptionCode];<br>        [userInfo setValue:urlStr forKey:kBifrostExceptionURLStr];<br>        [userInfo setValue:complexParams forKey:kBifrostExceptionURLParams];<br>        <span class="hljs-built_in">NSException</span> *ex = [[<span class="hljs-built_in">NSException</span> alloc] initWithName:exception.name<br>                                                     reason:exception.reason<br>                                                   userInfo:userInfo];<br>        BifrostExceptionHandler handler = [<span class="hljs-keyword">self</span> getExceptionHandler];<br>        <span class="hljs-keyword">if</span> (handler) &#123;<br>            obj = handler(ex);<br>        &#125;<br>        BFLog(exception.reason);<br>    &#125; <span class="hljs-keyword">@finally</span> &#123;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 从参数列表中查询并调用回调函数</span><br>+ (<span class="hljs-type">void</span>)completeWithParameters:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSDictionary</span>*)params result:(_Nullable <span class="hljs-type">id</span>)result &#123;<br>    BifrostRouteCompletion completion = params[kBifrostRouteCompletion];<br>    <span class="hljs-keyword">if</span> (completion) &#123;<br>        completion(result);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>库的实现并不复杂，各接口的作用已经在上面标明。它提供了异常情况的报错，同时URL和参数的处理也值得借鉴。</p><h4 id="7-方案评价"><a href="#7-方案评价" class="headerlink" title="7.方案评价"></a>7.方案评价</h4><p>无论是我们自己的<code>Router</code>还是有赞的<code>Bifrost</code>，其实现组件化的思路都是一样的：都是URL与Block的绑定和路由。</p><p><strong>优点：</strong></p><ul><li>巧妙的利用了URL的通用性，支持多端统一跳转；</li><li>在应用启动阶段即完URL与成服务block的绑定；</li><li>组件之间通过Router进行通信，不再需要引用对方的头文件；</li></ul><p>缺点：</p><ul><li>远程调用时，只支持简单参数；</li><li>本地调用时，传递复杂参数只能包装到complexParams字典中，不够灵活；</li><li>组件间需要传递实体数据时，还需要导入对方的实体头文件，还是有依赖。</li></ul><p>综合来看，在进行组件化时，基于URL-Block的路由方案只适合用来进行简单的本地和远程界面跳转，但其Router路由的思路是值得借鉴的。下一篇将继续介绍基于反射原理的组件化方案~</p><hr><p>相关参考：</p><p>#<a href="https://github.com/davidli-/HelModules-URL">©URL+Block方案demo</a></p><p>#<a href="https://github.com/davidli-/DaModules-Hardcore">©反射方案demo</a></p><p>#<a href="https://github.com/davidli-/DaModule-Protocol">©服务协议注册方案demo</a></p><p>#<a href="https://github.com/youzan/Bifrost">©有赞Bifrost</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用架构模式</title>
    <link href="/2020/09/01/patterns.html"/>
    <url>/2020/09/01/patterns.html</url>
    
    <content type="html"><![CDATA[<h3 id="一-架构模式"><a href="#一-架构模式" class="headerlink" title="一.架构模式"></a>一.架构模式</h3><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h4><blockquote><p>架构模式，用于描述软件系统里的基本的结构组织或纲要。架构模式提供了一些定义好的子系统，指定它们的责任，并给出把它们组织在一起的法则和指南。常见的架构模式有：分层模式、微核模式、管道与过滤器、MVC模式、REST模式、SOA模式。</p></blockquote><h4 id="2-起源"><a href="#2-起源" class="headerlink" title="2.起源"></a>2.起源</h4><p>软件开发中需求变动往往导致代码的修改，而一些代码尤其是大型系统的码理解起来并不容易，只有当时的开发者比较清楚，其他人很难接手。修改这种代码时往往会碰到“触一发而动全身”的问题，因为有“代码耦合”问题。代码耦合让整个系统变得难以理解、修改、分工、集成。针对耦合问题软件界进行了大量的理论研究和实践，最后发现：系统的架构设计，是改善耦合的最好方式~</p><h4 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点"></a>3.特点</h4><p>优秀架构模式的共同点:</p><ul><li>任务均衡分摊给具有清晰角色的实体；</li><li>高内聚、低耦合；</li><li>高重用性、低维护成本；</li><li>可单独测试。</li></ul><h4 id="4-区分"><a href="#4-区分" class="headerlink" title="4.区分"></a>4.区分</h4><p>区分两个名词：<code>架构模式</code>与<code>设计模式</code>：</p><p><code>设计模式</code>是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式一共有23种，常见的有工厂模式、单例模式、代理模式、观察者模式、策略模式等。</p><p>一个构架往往用到多个设计模式，如<code>mvc</code>架构是观察者模式、策略模式和组合模式的演变。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_ori_mvc.jpg" alt="传统MVC"></p><p>上图是传统的<code>MVC</code>架构，项目中的代码被整合为<code>视图</code>、<code>模型</code>、<code>控制器</code>三个角色。</p><ul><li>当用户操作一个视图时，会产生一个事件并交给控制器；</li><li>控制器收到事件后会采用一种<code>策略</code>：要求模型更新数据的状态或者要求视图更新样式；</li><li>模型中数据变化后则会<code>通知</code>视图更新界面。</li></ul><h3 id="二-MVC"><a href="#二-MVC" class="headerlink" title="二.MVC"></a>二.MVC</h3><h4 id="1-Apple版MVC"><a href="#1-Apple版MVC" class="headerlink" title="1.Apple版MVC"></a>1.Apple版MVC</h4><p>上图是传统的MVC模式，虽然也区分了三种角色，但是它们互相之间都有耦合，尤其是模型和视图之间。而视图和模型往往是最需要复用的，所以，最合理的设计是保持二者的独立性。因此 Apple 设计了自己的MVC版本，通过控制器来实现视图与模型的解耦。</p><h4 id="2-角色划分"><a href="#2-角色划分" class="headerlink" title="2.角色划分"></a>2.角色划分</h4><p><img src="https://davidlii.nos-eastchina1.126.net/pic_apple_mvc.jpg" alt="cocoaMVC"></p><h5 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h5><p>持有数据、封装处理数据的业务，为<code>控制器</code>提供数据接口。<code>模型</code>不应与<code>视图</code>层有任何关联。</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>展示数据和信息并允许用户编辑数据。</p><p><code>视图</code>应像UIButton一样可复用、可配置并保持统一性。</p><p><code>视图</code>不能绑定<code>模型</code>，所以<code>视图</code>需要一种机制来知晓<code>模型</code>中数据的变化。</p><h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p><code>控制器</code>作为中间人连接<code>模型</code>与<code>视图</code>。</p><p>为<code>视图</code>提供需要显示的数据；</p><p>响应用户的操作并调用<code>模型</code>中的业务更新数据；将数据的变化通知给视图。</p><p>控制器也用来管理对象的生命周期，定义相关业务以实现一些设置和指定的任务。</p><h4 id="3-现实中的MVC"><a href="#3-现实中的MVC" class="headerlink" title="3.现实中的MVC"></a>3.现实中的MVC</h4><p>理想中视图与控制器应相互独立，但实际开发过程中视图层往往紧密耦合在控制层里：控制器要负责维护视图的生命周期，响应用户在视图层的操作，实现诸如<code>Tableview</code>等视图的代理等，<code>MVC</code>事实上变成了<code>M-VC</code>。</p><p>理想中视图与模型应相互独立，但实际中可能会遇到这总情形：初始化<code>Cell</code>时经常会直接传入<code>Model</code>对象，形成视图与模型的耦合。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">UITableViewCell</span> *)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView<br>cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath<br>&#123;<br>    CustomTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="hljs-string">@&quot;Goods&quot;</span>];<br>    cell.goods = <span class="hljs-keyword">self</span>.dataSource[indexPath.row]; <span class="hljs-comment">//绑定Model</span><br>    <span class="hljs-keyword">return</span> cell;<br>&#125;<br></code></pre></td></tr></table></figure><p>理想中模型应持有数据、封装处理数据的业务、提供数据接口，但实践中模型被简单的设计为只有一些属性的类，数据相关的业务都被放在了控制器中。当需要修改数据的业务逻辑时，如更换网络通讯库、更新json解析时的某个字段，就需要在控制器中进行修改。</p><p>理想中上面的<code>Cell</code>不应引用模型对象，那么<code>Cell</code>的设置就要放到控制器中，这会增加控制器中的代码量。另外像网络请求、工具方法等不应放在视图和模型层里，而放在控制器里也会造成控制器的臃肿。这些就是<code>Massive View Controller</code>的由来，形象表示如下：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_mass_controller.png" alt="mass"></p><p>当业务逻辑和展示逻辑都在控制器中时，很难进行单元测试。所以控制器中只应存放一些不能复用的代码，其他代码尽量分离出去。</p><p>不能复用的代码包括：</p><ul><li>初始化View 和 Model的语句；</li><li>根据View 层用户操作调用 Model 层处理数据的语句；</li><li>用来接收 Model 层数据的回调、代理，和通知 View 层更新视图的逻辑；</li></ul><p>可分离的代码包括：</p><ul><li>在自定义类中搭建视图结构，通过代理将用户操作回调给控制器；</li><li>将诸如TableView的代理抽离到单独的类中(参考AFN中请求回调的处理方式)；</li><li>将转换 Model 层回调数据的业务抽离到单独的类中；</li></ul><h3 id="三-MVP"><a href="#三-MVP" class="headerlink" title="三.MVP"></a>三.MVP</h3><h4 id="1-角色划分"><a href="#1-角色划分" class="headerlink" title="1.角色划分"></a>1.角色划分</h4><p><img src="https://davidlii.nos-eastchina1.126.net/pic_arch_mvp.png" alt="iOS架构模式-MVP"></p><h5 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h5><p>与 MVC 中的模型类似。</p><h5 id="视图-1"><a href="#视图-1" class="headerlink" title="视图"></a>视图</h5><p>由”视图+控制器“组成，作用：</p><p>界面元素布局和执行动画；</p><p>将用户操作事件交给<code>P</code>层处理并展示处理结果；</p><p>P层中的业务逻辑处理完毕后通过代理告知<code>视图</code>刷新界面；</p><p>控制器负责生成视图，实现视图的代理和数据源以及界面的跳转等。</p><h5 id="P层"><a href="#P层" class="headerlink" title="P层"></a>P层</h5><p>作为<code>视图</code>与<code>模型</code>的中间人，实现视图与模型的解耦：</p><p>定义响应视图中事件的接口，实现事件对应的处理逻辑；</p><p>调用模型的接口以获取数据，加工数据并将其封装成视图适用的数据和状态。</p><p>MVP 由 MVC 演化而来，它对 MVC 中的控制器进行了优化而生成<code>Presenter</code>。<code>P层</code>与 MVC 中的控制器一样负责核心逻辑。不一样的是<code>P层</code>通过接口和协议传递数据，从而使视图和模型解耦，更加专注于自身业务逻辑。因为主要的逻辑在<code>P层</code>，所以可以方便的对其进行单元测试。</p><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例:"></a>2.示例:</h4><p>一个简单场景：请求加载一页数据；进度指示器根据加载状态显示&#x2F;隐藏。</p><h5 id="V层"><a href="#V层" class="headerlink" title="V层"></a>V层</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;ViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Presenter.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;UserViewProtocol.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br>&lt;UserViewProtocol,<br><span class="hljs-built_in">UITableViewDataSource</span>&gt;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSArray</span> *friendlyUIData;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) Presenter *presenter;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UITableView</span> *tableview;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIActivityIndicatorView</span> *indicator;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad<br>&#123;<br>[<span class="hljs-variable language_">super</span> viewDidLoad];<br><span class="hljs-keyword">self</span>.presenter = [Presenter new];   <span class="hljs-comment">//持有P层对象</span><br>[<span class="hljs-keyword">self</span>.presenter confDelegate:<span class="hljs-keyword">self</span>]; <span class="hljs-comment">//设置代理</span><br>[<span class="hljs-keyword">self</span>.presenter fetchData];         <span class="hljs-comment">//向P层发送命令</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -Tableview datasource</span><br>- (<span class="hljs-built_in">NSInteger</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView <br>numberOfRowsInSection:(<span class="hljs-built_in">NSInteger</span>)section<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.friendlyUIData.count;<br>&#125;<br><br>- (<span class="hljs-built_in">UITableViewCell</span> *)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView<br>         cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath<br>&#123;<br><span class="hljs-built_in">UITableViewCell</span> *cell = [tableView <br>dequeueReusableCellWithIdentifier:<span class="hljs-string">@&quot;cell&quot;</span> forIndexPath:indexPath];<br>cell.textLabel.text = [<span class="hljs-keyword">self</span>.friendlyUIData[indexPath.row] <br>valueForKey:<span class="hljs-string">@&quot;name&quot;</span>];<br><br><span class="hljs-keyword">return</span> cell;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -UserView Protocol</span><br><br><span class="hljs-comment">//P层的代理方法</span><br>-(<span class="hljs-type">void</span>)userViewDataSource:(<span class="hljs-built_in">NSArray</span>*)data<br>&#123;<br><span class="hljs-keyword">self</span>.friendlyUIData = data;  <span class="hljs-comment">//通过代理回调，收到P层返回的数据</span><br>[<span class="hljs-keyword">self</span>.tableview reloadData]; <span class="hljs-comment">//更新UI</span><br>&#125;<br><br>-(<span class="hljs-type">void</span>) showIndicator<br>&#123;<br><span class="hljs-keyword">self</span>.indicator.hidden = <span class="hljs-literal">NO</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>) hideIndicator<br>&#123;<br><span class="hljs-keyword">self</span>.indicator.hidden = <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ViewController</code>与<code>tableview</code>构成了 MVP 中的视图层，负责界面的显示和更新。它实现了<code>tableview</code>的协议及用户交互的协议<code>UserViewProtocol</code>，等待 <code>Presenter</code>的命令被动更新UI。</p><h5 id="P层-1"><a href="#P层-1" class="headerlink" title="P层"></a>P层</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Presenter.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;UserViewProtocol.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Presenter</span> : <span class="hljs-title">NSObject</span></span><br>-(<span class="hljs-type">void</span>)confDelegate:(<span class="hljs-type">id</span> &lt;UserViewProtocol&gt;)view;<br>-(<span class="hljs-type">void</span>)fetchData;<span class="hljs-comment">//模拟获取网络数据</span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>Presenter中定义外部接口，供View层调用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Presenter.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Presenter.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;UserService.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Presenter</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) UserService *userService;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">weak</span>) <span class="hljs-type">id</span> &lt;UserViewProtocol&gt; mDelegate;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Presenter</span></span><br><br>- (<span class="hljs-type">void</span>)confDelegate:(<span class="hljs-type">id</span>&lt;UserViewProtocol&gt;)view<br>&#123;<br><span class="hljs-keyword">self</span>.mDelegate = view;<br><span class="hljs-keyword">self</span>.userService  = [UserService new];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)fetchData&#123;<br>[<span class="hljs-keyword">self</span> getUserDatas];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)getUserDatas&#123;<br>[<span class="hljs-keyword">self</span>.mDelegate showIndicator];<br>    <span class="hljs-comment">//调用M层，模拟网络请求</span><br>[_userService getUserInfosSuccess:^(<span class="hljs-built_in">NSDictionary</span> *dic)<br>    &#123;<br>        <span class="hljs-comment">//获取到数据 通知View层更新UI</span><br>[<span class="hljs-keyword">self</span>.mDelegate hideIndicator];<br>[<span class="hljs-keyword">self</span>.mDelegate userViewDataSource:[<span class="hljs-keyword">self</span> processOriginDataToUIFriendlyData:userArr]];<br>&#125; andFail:^(<span class="hljs-built_in">NSDictionary</span> *dic) &#123;<br>&#125;];<br>&#125;<br><br><span class="hljs-comment">//处理数据，输出成UI需要的数据</span><br>-(<span class="hljs-built_in">NSArray</span> *)processOriginDataToUIFriendlyData:(<span class="hljs-built_in">NSArray</span> *) originData<br>&#123;<br><span class="hljs-comment">//略..</span><br><span class="hljs-keyword">return</span> friendlyUIData;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>其中的-confDelegate方法中有两个作用：</p><ul><li>将实现了<code>UserViewProtocol</code>协议的对象绑定到 Presenter 上。</li><li>持有一个<code>M层</code>对象(UserService)以发起网络请求。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//UserViewProtocol.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">UserViewProtocol</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><br>-(<span class="hljs-type">void</span>) userViewDataSource:(<span class="hljs-built_in">NSArray</span>*)data;<br>-(<span class="hljs-type">void</span>) showIndicator;<br>-(<span class="hljs-type">void</span>) hideIndicator;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这个协议是P层的一部分，其中定义的方法就是<code>P层</code>对<code>视图</code>层发送的命令。<code>View</code>层实现了此协议，在<code>Model</code>层拿到数据并通过block返回给<code>P层</code>后，<code>P层</code>会通过代理，通知<code>View</code>层更新UI。</p><h5 id="M层"><a href="#M层" class="headerlink" title="M层"></a>M层</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//UserService.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>(^SuccessHandler)(<span class="hljs-built_in">NSDictionary</span> *dic);<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>(^FailHandler)(<span class="hljs-built_in">NSDictionary</span> *dic);<br><br><span class="hljs-comment">//Model层，用来发起网络请求并返回数据给Presenter。</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UserService</span> : <span class="hljs-title">NSObject</span></span><br>-(<span class="hljs-type">void</span>)getUserInfosSuccess:(SuccessHandler )success andFail:(FailHandler) fail;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//UserService.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;UserService.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UserService</span></span><br><br>-(<span class="hljs-type">void</span>)getUserInfosSuccess:(SuccessHandler )success <br>andFail:(FailHandler) fail<br>&#123;<br><span class="hljs-built_in">NSArray</span>  *result =@[@&#123;<span class="hljs-string">@&quot;name&quot;</span>:<span class="hljs-string">@&quot;Tom&quot;</span>,<span class="hljs-string">@&quot;age&quot;</span>:@<span class="hljs-number">25</span>&#125;];<br>dispatch_after(dispatch_time(<br>                                 DISPATCH_TIME_NOW, <br>                                 (int64_t)(<span class="hljs-number">2</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)),<br>                   dispatch_get_main_queue(), ^&#123;<br>success(@&#123;<span class="hljs-string">@&quot;data&quot;</span>:result&#125;);<br>&#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>UserService属于<code>M层</code>，用来请求数据给<code>P层</code>。当<code>M层</code>数据发生变化时（如网络请求返回数据），通过<code>block</code>回调给<code>P层</code>，<code>P层</code>再将处理后的数据通过<code>代理</code>反馈给<code>View层</code>并由后者更新界面。</p><p>使用 MVP 会增加代码量，但是总体上职责清晰，各层通过定义的API、代理或block回调进行通信，减少了代码的复杂性。</p><h3 id="三-MVVM"><a href="#三-MVVM" class="headerlink" title="三.MVVM"></a>三.MVVM</h3><h4 id="1-角色划分-1"><a href="#1-角色划分-1" class="headerlink" title="1.角色划分"></a>1.角色划分</h4><p><img src="https://davidlii.nos-eastchina1.126.net/pic_arch_mvvm.png" alt="image"></p><h5 id="模型-2"><a href="#模型-2" class="headerlink" title="模型"></a>模型</h5><p>与 MVP 中的模型类似。</p><h5 id="视图-2"><a href="#视图-2" class="headerlink" title="视图"></a>视图</h5><p>View+Controller组成，负责显示UI。</p><p>绑定<code>ViewModel</code>中的属性，触发<code>ViewModel</code>中的命令。</p><h5 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h5><p>负责用户输入内容的验证逻辑（如用户名、密码的合法性）；</p><p>视图显示逻辑；暴露公开的属性和命令供<code>视图</code>层进行绑定；</p><p>从<code>Model</code>层获取数据，转换成<code>视图</code>层可展示的数据（如TableView 的 DataSource）。</p><h5 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h5><p>在 MVVM 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现<code>视图</code>层和<code>ViewModel</code>的同步，避免编写大量繁杂的胶水代码。著名的RAC库就提供了这种绑定能力。</p><h4 id="2-角色细解"><a href="#2-角色细解" class="headerlink" title="2.角色细解"></a>2.角色细解</h4><h5 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h5><p>MVVM是微软提出的，是在 MVP 的基础上发展起来的。因此 MVVM 各层的职责基本上与 MVP 的类似，其中<code>VM</code>对应<code>P层</code>。MVVM 相对于 MVP 改良了什么呢？答案就是 <code>数据绑定</code>。</p><p>在 MVP 中，从用户点击开始，一个完整的响应流程是：<code>视图</code>调用<code>P层</code>处理业务逻辑，<code>P层</code>调用<code>模型</code>处理数据，处理完成后 <code>P层</code>再通过代理回调<code>视图</code>。这里要反复同步<code>P层</code>的状态，当事件多起来时这样写就有点麻烦。</p><p>而在 MVVM 中， <code>View</code>与<code>VM层</code>之间多了数据绑定的操作，这意味着当<code>VM层</code>的数据变化时，你只需要更新<code>VM层</code>的某个属性，那么绑定了该属性的<code>视图</code>层会相应的更新UI，自动实现状态的同步。</p><h5 id="ViewModel-1"><a href="#ViewModel-1" class="headerlink" title="ViewModel"></a>ViewModel</h5><p>MVVM 模式中，<code>ViewModel</code>存在的目的在于抽离<code>Controller</code>中的展示业务逻辑，而不是代替<code>Controller</code>本身。所以它不负责视图的操作，也就不需要持有任何的视图对象，更不能包含视图的<code>push/present</code>等跳转逻辑。这里，Controller 要做的仅是将<code>视图</code>和<code>ViewModel</code>进行绑定，同时管理各个<code>视图</code>。所以实际上我们的 MVVM 也可以看成<code>M-VM-C-V</code>。</p><h4 id="3-示例1-OC"><a href="#3-示例1-OC" class="headerlink" title="3.示例1:OC"></a>3.示例1:OC</h4><p>场景：点击刷新按钮，请求数据；进度指示器根据请求状态显示&#x2F;隐藏；</p><h5 id="View层与绑定"><a href="#View层与绑定" class="headerlink" title="View层与绑定"></a>View层与绑定</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewControllerII</span> ()</span><br>&lt;<span class="hljs-built_in">UITableViewDataSource</span>,<br><span class="hljs-built_in">UITableViewDelegate</span>&gt;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UITableView</span> *mTableview;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIActivityIndicatorView</span> *mIndicator;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) RACViewModel *mViewModel; <span class="hljs-comment">//VM对象</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewControllerII</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    [<span class="hljs-keyword">self</span> setUps];        <span class="hljs-comment">//设置UI</span><br>    [<span class="hljs-keyword">self</span> bindViewModel]; <span class="hljs-comment">//创建VM并绑定其属性</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -BUsiness</span><br><br>- (<span class="hljs-type">void</span>)setUps&#123;<br>    <br>    _mIndicator.hidden = <span class="hljs-literal">YES</span>;<br>    <br>    <span class="hljs-built_in">UIButton</span> *btn = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br>    [btn setTitle:<span class="hljs-string">@&quot;reload&quot;</span> forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn setTitleColor:[<span class="hljs-built_in">UIColor</span> blackColor] forState:<span class="hljs-built_in">UIControlStateNormal</span>];<br>    [btn sizeToFit];<br><br>    <span class="hljs-comment">//监听刷新按钮点击事件</span><br>    [[btn rac_signalForControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>] subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        @strongify(<span class="hljs-keyword">self</span>)<br>        <br>        <span class="hljs-keyword">self</span>.mIndicator.hidden = <span class="hljs-literal">NO</span>;<br>        [<span class="hljs-keyword">self</span>.mViewModel.fetchCommand execute:<span class="hljs-literal">nil</span>];<span class="hljs-comment">//执行ViewModel中的RACCommand</span><br>    &#125;];<br>    <span class="hljs-keyword">self</span>.navigationItem.rightBarButtonItem = [[<span class="hljs-built_in">UIBarButtonItem</span> alloc] initWithCustomView:btn];<br>    <br>    <span class="hljs-keyword">self</span>.mTableview.tableFooterView = [[<span class="hljs-built_in">UIView</span> alloc] initWithFrame:<span class="hljs-built_in">CGRectZero</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)bindViewModel&#123;<br>    <br>    <span class="hljs-comment">//监听VM的canReload字段</span><br>    @weakify(<span class="hljs-keyword">self</span>)<br>    [RACObserve(<span class="hljs-keyword">self</span>.mViewModel, canReload) subscribeNext:^(<span class="hljs-type">id</span> x) &#123;<br>        @strongify(<span class="hljs-keyword">self</span>);<br>        [<span class="hljs-keyword">self</span>.mTableview canReload];<br>        <span class="hljs-keyword">self</span>.mIndicator.hidden = <span class="hljs-literal">YES</span>;<br>    &#125;];<br><br>    <span class="hljs-comment">//监听进度指示器的hidden属性 同步动画状态</span><br>    [RACObserve(<span class="hljs-keyword">self</span>.mIndicator, hidden) subscribeNext:^(<span class="hljs-built_in">NSNumber</span> *hiddenNum) &#123;<br>        @strongify(<span class="hljs-keyword">self</span>);<br>        <span class="hljs-type">BOOL</span> hidden = hiddenNum.boolValue;<br>        <span class="hljs-keyword">if</span> (hidden) &#123;<br>            [<span class="hljs-keyword">self</span>.mIndicator stopAnimating];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            [<span class="hljs-keyword">self</span>.mIndicator startAnimating];<br>        &#125;<br>    &#125;];<br>&#125;<br><br>- (RACViewModel *)mViewModel&#123;<br>    <span class="hljs-keyword">if</span> (!_mViewModel) &#123;<br>        _mViewModel = [[RACViewModel alloc] init];<br>    &#125;<br>    <span class="hljs-keyword">return</span> _mViewModel;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -Tableview Data&amp;Delegate</span><br>-(<span class="hljs-built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="hljs-built_in">UITableView</span> *)tableView&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>-(<span class="hljs-built_in">NSInteger</span>)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="hljs-built_in">NSInteger</span>)section&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.mViewModel.cellNums; <span class="hljs-comment">//计算业务交给ViewModel处理</span><br>&#125;<br><br>-(<span class="hljs-built_in">UITableViewCell</span> *)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath&#123;<br>    <span class="hljs-built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:<span class="hljs-string">@&quot;cell&quot;</span>];<br>    <span class="hljs-built_in">UILabel</span> *label = [cell viewWithTag:<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//由VM处理数据转换业务</span><br>    label.text = [<span class="hljs-keyword">self</span>.mViewModel convertedTextAtIndexPath:indexPath];<br><br>    <span class="hljs-keyword">return</span> cell;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>以上是<code>View</code>层，由ViewController与其中的tableView、按钮、进度小菊花共同组成；</p><p>这里创建并持有<code>VM</code>层对象<code>mViewModel</code>，同时绑定了VM层的属性(canReload)；</p><p>点击按钮即会向<code>VM</code>层的<code>fetchCommand</code>发送指令请求数据；</p><p><code>VM</code>层拿到数据后，<code>View</code>层不再需要代理或block，而是直接在订阅的<code>VM</code>层信号回调中更新UI；</p><p>更新UI所需的数据及其转换等业务逻辑均交由<code>VM</code>层处理。</p><h5 id="ViewModel-2"><a href="#ViewModel-2" class="headerlink" title="ViewModel"></a>ViewModel</h5><p>头文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;RACCommand.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;RACSignal.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RACViewModel</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-comment">//属性对外只读 供View层绑定监听</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSUInteger</span> cellNums;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-type">BOOL</span> canReload;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">strong</span>) RACCommand *fetchCommand; <span class="hljs-comment">//对外提供的指令</span><br><br>- (<span class="hljs-built_in">NSString</span>*)convertedTextAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span>*)indexPath;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>m文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;ReactiveCocoa.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;RACHttpRequestManager.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;RACEXTScope.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;RACModel.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RACViewModel</span>()</span><br><span class="hljs-comment">//属性对内可读可写</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readwrite</span>) <span class="hljs-built_in">NSUInteger</span> cellNums;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readwrite</span>) <span class="hljs-type">BOOL</span> canReload;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readwrite</span>, <span class="hljs-keyword">strong</span>) RACCommand *fetchCommand;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSArray</span> *mItemsArr;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RACViewModel</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)init<br>&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">//创建指令</span><br>        <span class="hljs-keyword">self</span>.fetchCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="hljs-type">id</span> input) &#123;<br>            <span class="hljs-comment">//返回M层请求数据的信号</span><br>            <span class="hljs-keyword">return</span> [[RACHttpRequestManager shareManager] fetchRequest];<br>        &#125;];<br><br>        <span class="hljs-comment">//订阅M层返回的信号</span><br>        @weakify(<span class="hljs-keyword">self</span>)<br>        [[<span class="hljs-keyword">self</span>.fetchCommand.executionSignals switchToLatest] subscribeNext:^(<span class="hljs-built_in">NSArray</span> *dataArr) &#123;<br>            @strongify(<span class="hljs-keyword">self</span>)<br>            <span class="hljs-keyword">if</span> (dataArr) &#123;<br>                <span class="hljs-keyword">self</span>.mItemsArr = dataArr;<br>            &#125;<br>        &#125;];<br><br>        <span class="hljs-comment">//监听数据源变化</span><br>        [RACObserve(<span class="hljs-keyword">self</span>, mItemsArr) subscribeNext:^(<span class="hljs-built_in">NSArray</span> *x) &#123;<br>            @strongify(<span class="hljs-keyword">self</span>)<br>            <span class="hljs-keyword">self</span>.cellNums = x.count;<br>            <span class="hljs-keyword">self</span>.canReload = <span class="hljs-literal">YES</span>;<span class="hljs-comment">//修改V层绑定的属性，触发V层更新TableView</span><br>        &#125;];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">//处理V层的数据转换业务</span><br>- (<span class="hljs-built_in">NSString</span> *)convertedTextAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath<br>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.mItemsArr.count) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">@&quot;0&quot;</span>;<br>    &#125;<br>    RACModel *model = <span class="hljs-keyword">self</span>.mItemsArr[indexPath.row];<br>    <span class="hljs-built_in">NSString</span> *str = model.title;<br>    <span class="hljs-keyword">return</span> [str <span class="hljs-keyword">copy</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这是<code>ViewModel</code>层，定义了一些属性供<code>View</code>层绑定和监听；</p><p>同时定义了处理<code>View</code>层数据转换的业务逻辑；</p><p>当收到<code>View</code>层交互指令后，本层会调用<code>Model</code>层去请求数据，并在信号回调中处理数据;</p><p>通过修改对外暴露的属性字段(self.canReload)，通知<code>View</code>层更新UI；</p><h5 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h5><p>Model实体类：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">RACModel </span>: NSObject<br><span class="hljs-variable">@property</span> (nonatomic, copy) NSString *title;<br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@implementation</span> RACModel<br><br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><p>数据请求类.h：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;RACModel.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ReactiveCocoa.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;AFHTTPRequestOperationManager+RACSupport.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RACHttpRequestManager</span> : <span class="hljs-title">AFHTTPRequestOperationManager</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)shareManager;<br>- (RACSignal*)fetchRequest;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>数据请求.m：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;RACHttpRequestManager.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;RACModel.h&quot;</span></span><br><br><span class="hljs-keyword">static</span> RACHttpRequestManager *mManager;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RACHttpRequestManager</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)shareManager<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        mManager = [[<span class="hljs-keyword">self</span> alloc] init];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> mManager;<br>&#125;<br><br>- (RACSignal*)fetchRequest<br>&#123;<br>    RACSignal *s = [RACSignal createSignal:^RACDisposable *(<span class="hljs-type">id</span>&lt;RACSubscriber&gt; subscriber) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++on RACSignal in fetch~&quot;</span>);<br>        <span class="hljs-comment">//模拟网络请求 5秒后返回数据</span><br>        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">5</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++Http responsed!&quot;</span>);<br>            <span class="hljs-built_in">NSMutableArray</span> *mutArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithCapacity:<span class="hljs-number">15</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>                RACModel *model = [[RACModel alloc] init];<br>                model.title = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%d&quot;</span>,i];<br>                [mutArr addObject:model];<br>            &#125;<br>            [subscriber sendNext:mutArr];<br>        &#125;);<br>        <span class="hljs-keyword">return</span> [RACDisposable disposableWithBlock:^&#123;<br>        &#125;];<br>    &#125;];<br>    <br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这是一个数据请求的工具类，是<code>Model</code>层的一部分，对外提供了数据请求的信号<code>fetchRequest</code>以供订阅。数据返回后被解析成<code>RACModel</code>实体数组；<code>VM</code>通过其内部的订阅回调收到这个数组，修改<code>View</code>层绑定的对应属性，通知<code>View</code>层更新UI。</p><ul><li>以上实践中，<code>View</code>层持有<code>ViewModel</code>并绑定其暴露的属性；</li><li><code>ViewModel</code>持有<code>Model</code>层实例，并订阅了其请求数据的信号；</li><li>当用户点击reload按钮后，<code>ViewModel</code>层收到指令并通过<code>Model</code>层请求数据；</li><li><code>Model</code>层在请求的数据返回后通过信号告知<code>ViewModel</code>；</li><li><code>ViewModel</code>处理数据并通过修改<code>View</code>层绑定的属性告知其更新UI；</li></ul><p>可以看到，各层的职责也是非常清晰，通过绑定属性和订阅信号，各层处理相关业务的代码都内聚在自己的层里，这也很好的体现了“高内聚，低耦合”的架构设计要求。</p><h4 id="4-示例2-Swift"><a href="#4-示例2-Swift" class="headerlink" title="4.示例2:Swift"></a>4.示例2:Swift</h4><p>场景：本地校验输入的登录文本格式，合规时发送请求；</p><p>要求：</p><ul><li>用户名与密码均须大于6个字符；</li><li>用户名或密码小于6个字符时显示提示文案；</li><li>用户名与密码小于6字符时登录按钮显示灰色不可点击，均大于6字符时变蓝可点击；</li><li>点击登录按钮，发起请求并根据结果显示提示；</li></ul><p><img src="https://davidlii.nos-eastchina1.126.net/pic_rx_mvvm_getin.jpg" alt="RxSwift登录"></p><h5 id="View与绑定"><a href="#View与绑定" class="headerlink" title="View与绑定"></a>View与绑定</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> RxSwift<br><span class="hljs-keyword">import</span> RxCocoa<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DKRxGetInController</span>: <span class="hljs-title class_">UIViewController</span> &#123;<br>    <br>    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> <span class="hljs-type">DKNameTf</span>: <span class="hljs-type">UITextField</span>!<br>    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> <span class="hljs-type">DKPswTf</span>: <span class="hljs-type">UITextField</span>!<br>    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> <span class="hljs-type">DKNameTips</span>: <span class="hljs-type">UILabel</span>!<br>    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> <span class="hljs-type">DKPswTips</span>: <span class="hljs-type">UILabel</span>!<br>    <span class="hljs-keyword">@IBOutlet</span> <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> <span class="hljs-type">DKGetInBtn</span>: <span class="hljs-type">UIButton</span>!<br>    <br>    <span class="hljs-keyword">let</span> disposeBag <span class="hljs-operator">=</span> <span class="hljs-type">DisposeBag</span>()<br>    <br>    <span class="hljs-comment">//ViewModel</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> aGetinVM:<span class="hljs-type">DKRxGetInViewModel</span> <span class="hljs-operator">=</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">DKRxGetInViewModel</span>(name: <span class="hljs-type">DKNameTf</span>.rx.text.orEmpty.asObservable(), psw: <span class="hljs-type">DKPswTf</span>.rx.text.orEmpty.asObservable())<br>    &#125;()<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        <br>        <span class="hljs-comment">//将昵称的输入结果与提示文本的“隐藏”属性进行绑定</span><br>        aGetinVM.nameObs.bind(to: <span class="hljs-type">DKNameTips</span>.rx.isHidden).disposed(by: disposeBag)<br>        <span class="hljs-comment">//将昵称的输入结果与密码输入框的“是否可用”属性进行绑定，昵称输入合规时才能输入密码</span><br>        aGetinVM.nameObs.bind(to: <span class="hljs-type">DKPswTf</span>.rx.isEnabled).disposed(by: disposeBag)<br>        <br>        <span class="hljs-comment">//将密码的输入结果与提示文本的“隐藏”属性进行绑定</span><br>        aGetinVM.pswObs.bind(to: <span class="hljs-type">DKPswTips</span>.rx.isHidden).disposed(by: disposeBag)<br>        <br>        <span class="hljs-comment">//组合昵称与密码信号，昵称与密码同时满足条件时，登录按钮方可用</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> aGetinVM.allObs.subscribe&#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.<span class="hljs-type">DKGetInBtn</span>.backgroundColor <span class="hljs-operator">=</span> (<span class="hljs-variable">$0</span> <span class="hljs-operator">?</span> <span class="hljs-type">UIColor</span>.blue : <span class="hljs-type">UIColor</span>.lightGray)<br>        &#125;<br>        aGetinVM.allObs.bind(to: <span class="hljs-type">DKGetInBtn</span>.rx.isEnabled).disposed(by: disposeBag)<br>        <br>        <span class="hljs-comment">//给登录按钮添加点击事件</span><br>        <span class="hljs-type">DKGetInBtn</span>.rx.tap.subscribe&#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span><br>            <span class="hljs-comment">//发起登录请求</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.aGetinVM.fetchUserinfo(name: (<span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.<span class="hljs-type">DKNameTf</span>.text)<span class="hljs-operator">!</span>, psw: (<span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.<span class="hljs-type">DKPswTf</span>.text)<span class="hljs-operator">!</span>).subscribe &#123; (ob) <span class="hljs-keyword">in</span><br>                <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.showAlert()<br>            &#125; onError: &#123; (error) <span class="hljs-keyword">in</span><br>                <span class="hljs-built_in">print</span>(error.localizedDescription)<br>            &#125;<br>        &#125;.disposed(by: disposeBag)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">touchesBegan</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">touches</span>: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">UITouch</span>&gt;, <span class="hljs-params">with</span> <span class="hljs-params">event</span>: <span class="hljs-type">UIEvent</span>?) &#123;<br>        view.endEditing(<span class="hljs-literal">true</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">showAlert</span>() &#123;<br>        <span class="hljs-keyword">let</span> alert <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertController</span>.<span class="hljs-keyword">init</span>(title: <span class="hljs-string">&quot;提示&quot;</span>, message: <span class="hljs-string">&quot;登录成功！&quot;</span>, preferredStyle: .alert)<br>        <span class="hljs-keyword">let</span> action <span class="hljs-operator">=</span> <span class="hljs-type">UIAlertAction</span>.<span class="hljs-keyword">init</span>(title: <span class="hljs-string">&quot;Ok&quot;</span>, style: .default, handler: <span class="hljs-literal">nil</span>)<br>        alert.addAction(action)<br>        present(alert, animated: <span class="hljs-literal">true</span>, completion: <span class="hljs-literal">nil</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">#file</span>, <span class="hljs-keyword">#function</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是<code>View</code>层，它持有一个<code>VM</code>实例并将输入框的文本与<code>VM</code>中的属性进行双向绑定。提示文本是否显示、输入框是否允许输入、登录按钮的状态都是根据输入内容是否合规来决定的。这些校验的逻辑均在<code>VM</code>中处理；点击登录按钮时通过<code>VM</code>发起请求，结果返回后显示对应的提示。</p><h5 id="ViewModel-3"><a href="#ViewModel-3" class="headerlink" title="ViewModel"></a>ViewModel</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> RxSwift<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DKRxGetInViewModel</span> &#123;<br>    <br>    <span class="hljs-comment">//声明可观察属性 供View层绑定</span><br>    <span class="hljs-keyword">let</span> nameObs: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Bool</span>&gt;<br>    <span class="hljs-keyword">let</span> pswObs: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Bool</span>&gt;<br>    <span class="hljs-keyword">let</span> allObs: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Bool</span>&gt;<br>    <br>    <span class="hljs-comment">//Model层</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> aModel <span class="hljs-operator">=</span> <span class="hljs-type">DKModel</span>()<br>    <br>    <span class="hljs-comment">//初始化并定义业务逻辑</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">String</span>&gt;, <span class="hljs-params">psw</span>: <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">String</span>&gt;) &#123;<br>        <br>        <span class="hljs-comment">//创建信号1：“昵称”输入框</span><br>        nameObs <span class="hljs-operator">=</span> name.map &#123; text <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">return</span> text.count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">6</span>  <span class="hljs-comment">//昵称须&gt;6个字符</span><br>        &#125;<br>        <br>        <span class="hljs-comment">//创建信号2：“密码”输入框</span><br>        pswObs <span class="hljs-operator">=</span> psw.map &#123; <span class="hljs-variable">$0</span>.count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">6</span> &#125; <span class="hljs-comment">//密码须&gt;6个字符</span><br>        <br>        <span class="hljs-comment">//组合昵称与密码两个信号</span><br>        allObs <span class="hljs-operator">=</span> <span class="hljs-type">Observable</span>.combineLatest(nameObs, pswObs) &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-variable">$1</span> &#125; <span class="hljs-comment">//&amp;&amp;：需要昵称与密码同时满足条件</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//发起登录请求</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchUserinfo</span>(<span class="hljs-params">name</span>:<span class="hljs-type">String</span>, <span class="hljs-params">psw</span>: <span class="hljs-type">String</span>)-&gt;<span class="hljs-type">Observable</span>&lt;[<span class="hljs-type">String</span>: <span class="hljs-keyword">Any</span>]&gt; &#123;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.create &#123; [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (ob) -&gt; <span class="hljs-type">Disposable</span> <span class="hljs-keyword">in</span><br>            <br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.aModel.fetchUserinfo(name: name, psw: psw).subscribe &#123; (dic) <span class="hljs-keyword">in</span><br>                ob.onNext(dic)<br>            &#125; onError: &#123; (error) <span class="hljs-keyword">in</span><br>                <span class="hljs-built_in">print</span>(error)<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Disposables</span>.create()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个比较简单的<code>VM</code>，里面定义了校验用户名与密码的逻辑；</p><p>它持有一个<code>Model</code>层实例，在给<code>View</code>层的接口中通过<code>Model</code>发起登录请求并回调结果。</p><h5 id="Model-1"><a href="#Model-1" class="headerlink" title="Model"></a>Model</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import RxSwift<br>import RxAlamofire<br><br><span class="hljs-keyword">class</span> DKModel &#123;<br>    <span class="hljs-keyword">let</span> disposeBag = <span class="hljs-constructor">DisposeBag()</span><br>    <br>    func fetch<span class="hljs-constructor">Userinfo(<span class="hljs-params">name</span>:String, <span class="hljs-params">psw</span>: String)</span>-&gt;Observable&lt;<span class="hljs-literal">[S<span class="hljs-identifier">tring</span>: A<span class="hljs-identifier">ny</span>]</span>&gt; &#123;<br>        <br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>create &#123; <span class="hljs-literal">[<span class="hljs-identifier">weak</span> <span class="hljs-identifier">self</span>]</span> (ob) -&gt; Disposable <span class="hljs-keyword">in</span><br>            <span class="hljs-comment">//模拟URL</span><br>            <span class="hljs-keyword">let</span> urlString = <span class="hljs-string">&quot;https://www.douban.com/j/app/radio/channels&quot;</span><br>            <span class="hljs-keyword">let</span> url = <span class="hljs-constructor">URL(<span class="hljs-params">string</span>:<span class="hljs-params">urlString</span>)</span>!<br>             <br>            <span class="hljs-comment">//创建并发起请求</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RxAlamofire</span>.</span></span>request(.get, url)<br>                .response<span class="hljs-constructor">JSON()</span><br>                .subscribe(onNext: &#123;<br>                    response <span class="hljs-keyword">in</span><br>                    <span class="hljs-keyword">let</span> json = response.value <span class="hljs-keyword">as</span>! <span class="hljs-literal">[S<span class="hljs-identifier">tring</span>: A<span class="hljs-identifier">ny</span>]</span><br>                    ob.on<span class="hljs-constructor">Next(<span class="hljs-params">json</span>)</span> <span class="hljs-comment">//回调数据</span><br>                &#125;, onError: &#123; (error) <span class="hljs-keyword">in</span><br>                    ob.on<span class="hljs-constructor">Error(<span class="hljs-params">error</span>)</span><br>                &#125;).disposed(by: self!.disposeBag)<br>            <br>            return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Disposables</span>.</span></span>create<span class="hljs-literal">()</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是<code>Model</code>层，其中定义了给<code>VM</code>使用的登录接口，接口内发起登录请求并回调登录结果。</p><p>在Swift版示例中，各层也比较清晰，每层内部的代码高度内聚。比较示例1，它更好的实现了<code>View</code>与<code>VM</code>的双向绑定，即输入内容与校验结果绑定，校验结果与提示文本和登录按钮的状态绑定。</p><h4 id="5-使用规范"><a href="#5-使用规范" class="headerlink" title="5.使用规范"></a>5.使用规范</h4><ul><li>MMVM 中<code>V层</code>绑定了<code>ViewModel</code>，反过来不行，<code>ViewModel</code>中不能包含<code>View</code>；</li><li>MMVM 中<code>ViewModel</code>绑定了<code>Model</code>层，反过来也不行；</li><li>Controller尽量不涉及业务逻辑，让<code>ViewModel</code>去做；</li><li>Controller是中间人，接收<code>View</code>的事件、调用<code>ViewModel</code>的方法、响应<code>VM</code>的变化；</li><li>ViewModel 避免过于臃肿，否则重蹈 Controller 的覆辙变得难以维护，可拆分成子VM；</li><li>MVVM 配合某种绑定机制时效果最好（如RAC）。</li></ul><h3 id="四-后记"><a href="#四-后记" class="headerlink" title="四.后记"></a>四.后记</h3><p>架构一直在演进过程中，考虑到项目大小、所用语言、学习成本等因素，没有最好的架构，只有适合自己的架构。我们要根据实际需求，不断学习和调整。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html">AppleDoc-MVC</a></p><p>#<a href="http://blog.sunnyxx.com/tags/Reactive-Cocoa-Tutorial/">©sunnyxx-RAC</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的Pod库</title>
    <link href="/2019/08/31/podspec.html"/>
    <url>/2019/08/31/podspec.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用三方库时基本的语法是：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&#x27;pod-Name&#x27;</span><br></code></pre></td></tr></table></figure><p>之后通过以下命令导入此库:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pod <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>pod会从官方索引库中查找并导入此三方库。有时我们不希望自己的库对外公开，如只在公司范围内使用，这时就可以在代码托管平台发布一个私有库，导入库时通过<code>:source =&gt;</code>指定私有库的远程索引库地址即可。</p><p>本篇文章将记录下从私有库到公开库的完整发布流程~</p><h3 id="1、远程索引仓库"><a href="#1、远程索引仓库" class="headerlink" title="1、远程索引仓库"></a>1、远程索引仓库</h3><p><code>GitHub</code>-&gt;&gt;<code>New repository</code>，创建新的索引仓库~</p><h3 id="2、本地索引仓库"><a href="#2、本地索引仓库" class="headerlink" title="2、本地索引仓库"></a>2、本地索引仓库</h3><h4 id="2-1-查看本地仓库"><a href="#2-1-查看本地仓库" class="headerlink" title="2.1.查看本地仓库"></a>2.1.查看本地仓库</h4><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pod repo</span><br></code></pre></td></tr></table></figure><p><code>/Users/Macmafia/.cocoapods</code>的目录结构如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">.<br>└── repos<br>    └── <span class="hljs-keyword">master</span><br>        <span class="hljs-title">├── CocoaPods-version</span>.yml<br>        ├── README.md<br>        └── Specs<br></code></pre></td></tr></table></figure><h4 id="2-2-本地索引仓库"><a href="#2-2-本地索引仓库" class="headerlink" title="2.2.本地索引仓库"></a>2.2.本地索引仓库</h4><p>创建本地索引仓库，并与远程仓库关联：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pod repo add davidlii https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/davidli-/</span>davidlii.git<br></code></pre></td></tr></table></figure><h4 id="2-3-确认"><a href="#2-3-确认" class="headerlink" title="2.3.确认"></a>2.3.确认</h4><p>确认本地索引仓库是否创建成功：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pod repo</span><br></code></pre></td></tr></table></figure><p>现在，<code>/Users/Macmafia/.cocoapods</code>目录中结构如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">.<br>└── repos<br>    ├── davidlii<br>    │   └── README.md<br>    └── <span class="hljs-keyword">master</span><br>        <span class="hljs-title">├── CocoaPods-version</span>.yml<br>        ├── README.md<br>        └── Specs<br></code></pre></td></tr></table></figure><p>其中<code>davidlii</code>目录即为刚创建的本地仓库。</p><h3 id="3、远程代码库"><a href="#3、远程代码库" class="headerlink" title="3、远程代码库"></a>3、远程代码库</h3><p>上面创建的是”索引”仓库，存放的是”.podspec”索引文件。这一步将要创建的是”代码”仓库，存放的是自制库的相关代码。步骤同#1章节，另取新名DaKit~</p><h3 id="4、本地代码库"><a href="#4、本地代码库" class="headerlink" title="4、本地代码库"></a>4、本地代码库</h3><p>创建本地代码库：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd 代码库的目录 (我的是<span class="hljs-regexp">/Documents/</span>)<br>pod lib create DaKit<br></code></pre></td></tr></table></figure><p>这一步会让你做一些选择，根据自己的情况在终端中输入即可，我的选择按顺序分别为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span><span class="hljs-selector-class">.iOS</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.ObjC</span><br><span class="hljs-number">3</span><span class="hljs-selector-class">.Yes</span><br><span class="hljs-number">4</span><span class="hljs-selector-class">.None</span><br><span class="hljs-number">5</span><span class="hljs-selector-class">.No</span><br><span class="hljs-number">6</span>.Da<br></code></pre></td></tr></table></figure><p>选择完成后，开始生成本地代码库，之后会自动打开自制库的示例工程，其物理目录结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs stylus">/Users/Macmafia/Documents/DaKit/<br>.<br>├── DaKit<br>│   ├── Assets<br>│   └── Classes<br>├── DaKit<span class="hljs-selector-class">.podspec</span><br>├── Example<br>│   ├── DaKit<br>│   │   ├── Base<span class="hljs-selector-class">.lproj</span><br>│   │   │   ├── LaunchScreen<span class="hljs-selector-class">.storyboard</span><br>│   │   │   └── Main<span class="hljs-selector-class">.storyboard</span><br>│   │   ├── DaAppDelegate<span class="hljs-selector-class">.h</span><br>│   │   ├── DaAppDelegate<span class="hljs-selector-class">.m</span><br>│   │   ├── DaKit-Info<span class="hljs-selector-class">.plist</span><br>│   │   ├── DaKit-Prefix<span class="hljs-selector-class">.pch</span><br>│   │   ├── DaViewController<span class="hljs-selector-class">.h</span><br>│   │   ├── DaViewController<span class="hljs-selector-class">.m</span><br>│   │   ├── Images<span class="hljs-selector-class">.xcassets</span><br>│   │   │   └── AppIcon<span class="hljs-selector-class">.appiconset</span><br>│   │   │       └── Contents<span class="hljs-selector-class">.json</span><br>│   │   ├── en<span class="hljs-selector-class">.lproj</span><br>│   │   │   └── InfoPlist<span class="hljs-selector-class">.strings</span><br>│   │   └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.m</span><br>│   ├── DaKit<span class="hljs-selector-class">.xcodeproj</span><br>│   │   ├── project<span class="hljs-selector-class">.pbxproj</span><br>│   │   ├── project<span class="hljs-selector-class">.xcworkspace</span><br>│   │   │   └── contents<span class="hljs-selector-class">.xcworkspacedata</span><br>│   │   └── xcshareddata<br>│   │       └── xcschemes<br>│   │           └── DaKit-Example<span class="hljs-selector-class">.xcscheme</span><br>│   ├── DaKit<span class="hljs-selector-class">.xcworkspace</span><br>│   │   ├── contents<span class="hljs-selector-class">.xcworkspacedata</span><br>│   │   ├── xcshareddata<br>│   │   │   └── IDEWorkspaceChecks<span class="hljs-selector-class">.plist</span><br>│   │   └── xcuserdata<br>│   │       └── Macmafia<span class="hljs-selector-class">.xcuserdatad</span><br>│   │           └── UserInterfaceState<span class="hljs-selector-class">.xcuserstate</span><br>│   ├── Podfile<br>│   ├── Podfile<span class="hljs-selector-class">.lock</span><br>│   ├── Pods<br>│   │   ├── Headers<br>│   │   ├── Local\ Podspecs<br>│   │   │   └── DaKit<span class="hljs-selector-class">.podspec</span><span class="hljs-selector-class">.json</span><br>│   │   ├── Manifest<span class="hljs-selector-class">.lock</span><br>│   │   ├── Pods<span class="hljs-selector-class">.xcodeproj</span><br>│   │   │   ├── project<span class="hljs-selector-class">.pbxproj</span><br>│   │   │   └── xcuserdata<br>│   │   │       └── Macmafia<span class="hljs-selector-class">.xcuserdatad</span><br>│   │   │           └── xcschemes<br>│   │   │               ├── DaKit<span class="hljs-selector-class">.xcscheme</span><br>│   │   │               ├── Pods-DaKit_Example<span class="hljs-selector-class">.xcscheme</span><br>│   │   │               ├── Pods-DaKit_Tests<span class="hljs-selector-class">.xcscheme</span><br>│   │   │               └── xcschememanagement<span class="hljs-selector-class">.plist</span><br>│   │   └── Target\ Support\ Files<br>│   │       ├── DaKit<br>│   │       │   ├── DaKit-Info<span class="hljs-selector-class">.plist</span><br>│   │       │   ├── DaKit-dummy<span class="hljs-selector-class">.m</span><br>│   │       │   ├── DaKit-prefix<span class="hljs-selector-class">.pch</span><br>│   │       │   ├── DaKit-umbrella<span class="hljs-selector-class">.h</span><br>│   │       │   ├── DaKit<span class="hljs-selector-class">.modulemap</span><br>│   │       │   └── DaKit<span class="hljs-selector-class">.xcconfig</span><br>│   │       ├── Pods-DaKit_Example<br>│   │       │   ├── Pods-DaKit_Example-Info<span class="hljs-selector-class">.plist</span><br>│   │       │   ├── Pods-DaKit_Example-acknowledgements<span class="hljs-selector-class">.markdown</span><br>│   │       │   ├── Pods-DaKit_Example-acknowledgements<span class="hljs-selector-class">.plist</span><br>│   │       │   ├── Pods-DaKit_Example-dummy<span class="hljs-selector-class">.m</span><br>│   │       │   ├── Pods-DaKit_Example-frameworks<span class="hljs-selector-class">.sh</span><br>│   │       │   ├── Pods-DaKit_Example-umbrella<span class="hljs-selector-class">.h</span><br>│   │       │   ├── Pods-DaKit_Example<span class="hljs-selector-class">.debug</span><span class="hljs-selector-class">.xcconfig</span><br>│   │       │   ├── Pods-DaKit_Example<span class="hljs-selector-class">.modulemap</span><br>│   │       │   └── Pods-DaKit_Example<span class="hljs-selector-class">.release</span><span class="hljs-selector-class">.xcconfig</span><br>│   │       └── Pods-DaKit_Tests<br>│   │           ├── Pods-DaKit_Tests-Info<span class="hljs-selector-class">.plist</span><br>│   │           ├── Pods-DaKit_Tests-acknowledgements<span class="hljs-selector-class">.markdown</span><br>│   │           ├── Pods-DaKit_Tests-acknowledgements<span class="hljs-selector-class">.plist</span><br>│   │           ├── Pods-DaKit_Tests-dummy<span class="hljs-selector-class">.m</span><br>│   │           ├── Pods-DaKit_Tests-umbrella<span class="hljs-selector-class">.h</span><br>│   │           ├── Pods-DaKit_Tests<span class="hljs-selector-class">.debug</span><span class="hljs-selector-class">.xcconfig</span><br>│   │           ├── Pods-DaKit_Tests<span class="hljs-selector-class">.modulemap</span><br>│   │           └── Pods-DaKit_Tests<span class="hljs-selector-class">.release</span><span class="hljs-selector-class">.xcconfig</span><br>│   └── Tests<br>│       ├── Tests-Info<span class="hljs-selector-class">.plist</span><br>│       ├── Tests-Prefix<span class="hljs-selector-class">.pch</span><br>│       ├── Tests<span class="hljs-selector-class">.m</span><br>│       └── en<span class="hljs-selector-class">.lproj</span><br>│           └── InfoPlist<span class="hljs-selector-class">.strings</span><br>├── LICENSE<br>├── README<span class="hljs-selector-class">.md</span><br>└── _Pods<span class="hljs-selector-class">.xcodeproj</span> -&gt; Example/Pods/Pods.xcodeproj<br></code></pre></td></tr></table></figure><h3 id="5、添加库文件"><a href="#5、添加库文件" class="headerlink" title="5、添加库文件"></a>5、添加库文件</h3><p>将自己的库文件拖入<code>/DaKit/DaKit/Classes</code>目录中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">.<br>├── DaKit<br>│   ├── Assets<br>│   └── Classes<br>│       └── Runtime<br>│           ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DaClassInfo</span>.</span></span>h<br>│           ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DaClassInfo</span>.</span></span>m<br>│           ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DaKakashi</span>.</span></span>h<br>│           └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DaSerialize</span>.</span></span>h<br>├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DaKit</span>.</span></span>podspec<br>├── Example<br>│   ├── DaKit<br></code></pre></td></tr></table></figure><p>这里的<code>Runtime</code>即为我自己的库文件所在目录，下面是四个Da开头的库文件~</p><h3 id="6、安装库文件"><a href="#6、安装库文件" class="headerlink" title="6、安装库文件"></a>6、安装库文件</h3><p>cd 到Example目录下，执行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pod <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>这一步会将刚才拖入到 Classes 目录中的文件导入到示例工程中；</p><p>导入后的库文件可在 DaKit.xcworkspace 的 Pods.xcodeproj 中查看。</p><h3 id="7、修改-podspec文件"><a href="#7、修改-podspec文件" class="headerlink" title="7、修改.podspec文件"></a>7、修改.podspec文件</h3><p>DaKit工程根目录下.podspec文件的内容如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-title class_">Pod::Spec</span>.new <span class="hljs-keyword">do</span> |<span class="hljs-params">s</span>|<br>  s.name             = <span class="hljs-string">&#x27;DaKit&#x27;</span><br>  s.version          = <span class="hljs-string">&#x27;0.1.1&#x27;</span><br>  s.summary          = <span class="hljs-string">&#x27;davidlii\&#x27;s Kit for iOS developing~&#x27;</span><br><br><span class="hljs-comment"># This description is used to generate tags and improve search results.</span><br><span class="hljs-comment">#   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="hljs-comment">#   * Try to keep it short, snappy and to the point.</span><br><span class="hljs-comment">#   * Write the description between the DESC delimiters below.</span><br><span class="hljs-comment">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span><br><br>  s.description      = <span class="hljs-string">&lt;&lt;-DESC</span><br><span class="hljs-string">                       Kit to simplify your developing process, I will continuously update this Kit.</span><br><span class="hljs-string">                       DESC</span><br><br>  s.homepage         = <span class="hljs-string">&#x27;https://github.com/davidli-/DaKit&#x27;</span><br>  s.screenshots      = <span class="hljs-string">&#x27;https://davidlii.nos-eastchina1.126.net/pic_DaKit.png&#x27;</span><br>  s.license          = &#123; <span class="hljs-symbol">:type</span> =&gt; <span class="hljs-string">&#x27;MIT&#x27;</span>, <span class="hljs-symbol">:file</span> =&gt; <span class="hljs-string">&#x27;LICENSE&#x27;</span> &#125;<br>  s.author           = &#123; <span class="hljs-string">&#x27;davidlii&#x27;</span> =&gt; <span class="hljs-string">&#x27;macmafia@sina.cn&#x27;</span> &#125;<br>  s.source           = &#123; <span class="hljs-symbol">:git</span> =&gt; <span class="hljs-string">&#x27;https://github.com/davidli-/DaKit.git&#x27;</span>, <span class="hljs-symbol">:tag</span> =&gt; s.version.to_s &#125;<br>  s.social_media_url = <span class="hljs-string">&#x27;https://davidlii.cn&#x27;</span><br><br>  s.ios.deployment_target = <span class="hljs-string">&#x27;8.0&#x27;</span><br><br>  s.source_files = <span class="hljs-string">&#x27;DaKit/Classes/**/*&#x27;</span><br>  <br>  <span class="hljs-comment"># s.resource_bundles = &#123;</span><br>  <span class="hljs-comment">#   &#x27;DaKit&#x27; =&gt; [&#x27;DaKit/Assets/*.png&#x27;]</span><br>  <span class="hljs-comment"># &#125;</span><br><br>  <span class="hljs-comment"># s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27;</span><br>  <span class="hljs-comment"># s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span><br>  <span class="hljs-comment"># s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>根据需要，修改对应的选项，修改之后重新编译项目，测试是否能通过编译~</p><h3 id="8、远程代码仓库"><a href="#8、远程代码仓库" class="headerlink" title="8、远程代码仓库"></a>8、远程代码仓库</h3><p>回到代码库根目录，提交代码到远程代码仓库，大致过程如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m “x”<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//github.com/davidli-/DaKit.git(远程代码库的地址)</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> origin master<br></code></pre></td></tr></table></figure><p>设置标签：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">版本号</span><br><span class="hljs-title">git</span> push —-tags (注意：一定要先将<span class="hljs-keyword">tag</span>推送到远程仓库，否则后面验证仓库时无法通过验证)<br></code></pre></td></tr></table></figure><p>CocoaPods 依赖于标签，标签的版本号须与.podspec文件中的版本号保持一致~</p><h3 id="9、验证podspec文件"><a href="#9、验证podspec文件" class="headerlink" title="9、验证podspec文件"></a>9、验证podspec文件</h3><p>验证可分为两种：验证本地和远程仓库，都稍微费些时间。</p><h4 id="9-1-只验证本地仓库"><a href="#9-1-只验证本地仓库" class="headerlink" title="9.1.只验证本地仓库"></a>9.1.只验证本地仓库</h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">pod <span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">lint</span> 仓库名.<span class="hljs-title">podspec</span></span><br></code></pre></td></tr></table></figure><h4 id="9-2-验证远程仓库"><a href="#9-2-验证远程仓库" class="headerlink" title="9.2.验证远程仓库"></a>9.2.验证远程仓库</h4><p>既验证本地仓库又验证远程仓库：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">pod spec lint 仓库名<span class="hljs-string">.podspec</span> <span class="hljs-params">--verbose</span> <span class="hljs-params">--allow-warnings</span><br></code></pre></td></tr></table></figure><p>如果验证通过，则会显示如下样式：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">** <span class="hljs-keyword">BUILD</span> SUCCEEDED **<br>    <br>   Testing <span class="hljs-keyword">with</span> <span class="hljs-symbol">`xcodebuild`</span>. <br> -&gt; DaKit (<span class="hljs-number">0.1</span><span class="hljs-number">.1</span>)<br>    - NOTE  | xcodebuild:  note: <span class="hljs-keyword">Using</span> new <span class="hljs-keyword">build</span> <span class="hljs-keyword">system</span><br>    - NOTE  | [iOS] xcodebuild:  note: Planning <span class="hljs-keyword">build</span><br>    - NOTE  | [iOS] xcodebuild:  note: Constructing <span class="hljs-keyword">build</span> description<br><br>Analyzed <span class="hljs-number">1</span> podspec.<br><br>DaKit.podspec passed validation.<br></code></pre></td></tr></table></figure><h3 id="10、推送索引文件"><a href="#10、推送索引文件" class="headerlink" title="10、推送索引文件"></a>10、推送索引文件</h3><p>将本地索引文件推送到远程索引库：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">pod repo <span class="hljs-built_in">push</span> 本地索引库 索引文件名 --<span class="hljs-built_in">verbose</span> --allow-<span class="hljs-built_in">warnings</span><br></code></pre></td></tr></table></figure><p>我的为：pod repo push davidlii DaKit.podspec –verbose –allow-warnings</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">. . . 日志<br>Pushing the `davidlii&#x27; repo<br><br>  $ /usr/bin/git -C /Users/Macmafia/.cocoapods/repos/davidlii push origin <span class="hljs-keyword">master</span><br>  <span class="hljs-title">To</span> https://github.com/davidli-/davidlii.git<br>     <span class="hljs-number">6</span>f4b19f..ebd5059  <span class="hljs-keyword">master</span> <span class="hljs-title">-&gt; master</span><br></code></pre></td></tr></table></figure><p>看到这些即表示推送成功，此时查看本地索引库，其目录变成：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/Users/Macmafia/.cocoapods<br>.<br>└── repos<br>    ├── davidlii<br>    │   └── DaKit<br>    │       └── <span class="hljs-number">0.1</span>.<span class="hljs-number">1</span><br>    └── <span class="hljs-keyword">master</span><br>        <span class="hljs-title">└── Specs</span><br></code></pre></td></tr></table></figure><p>davidlii 目录下多出了<code>DaKit</code>目录和刚提交的库文件标签<code>0.1.1</code>，即表示索引创建成功~</p><h3 id="11、导入库私有库"><a href="#11、导入库私有库" class="headerlink" title="11、导入库私有库"></a>11、导入库私有库</h3><p>到目前为止我们发布的还只是私有库，尚无法通过<code>pod search</code>命令从官方<code>master</code>索引库中查找的到~</p><p>此私有库可在自己的项目或公司范围内使用，只需在想要使用此库的工程中修改Podfile文件：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean">########<br><br>use_frameworks!<br><br># 指定自制库DaKit的远程索引库地址<br># 方式<span class="hljs-number">1</span>：source <span class="hljs-string">&#x27;https://github.com/davidli-/davidlii.git&#x27;</span><br><br>target <span class="hljs-string">&#x27;ASDF&#x27;</span> do<br># 方式<span class="hljs-number">2</span>：<br>    pod <span class="hljs-string">&#x27;DaKit&#x27;</span>, :source =&gt; <span class="hljs-string">&#x27;https://github.com/davidli-/davidlii.git&#x27;</span><br>end<br><br>########<br></code></pre></td></tr></table></figure><p>即使用<code>:source =&gt;</code>指定私有库的远程索引库地址即可~</p><h3 id="12、发布公开库"><a href="#12、发布公开库" class="headerlink" title="12、发布公开库"></a>12、发布公开库</h3><ul><li>注册pod trunk</li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">pod trunk register 邮箱 ‘名称’</span> <span class="hljs-literal">--</span><span class="hljs-comment">description=‘xxx’</span> <span class="hljs-literal">--</span><span class="hljs-comment">verbose</span><br></code></pre></td></tr></table></figure><ul><li>验证邮箱</li></ul><p>前往注册时的邮箱点击链接即可完成验证~</p><ul><li>确认注册信息</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pod trunk <span class="hljs-keyword">me</span><br></code></pre></td></tr></table></figure><h3 id="13、提交-podspec文件"><a href="#13、提交-podspec文件" class="headerlink" title="13、提交.podspec文件"></a>13、提交.podspec文件</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">pod trunk push DaKit.podspec --allow-warnings<br><br><span class="hljs-comment">// 日志</span><br>Updating spec repo <span class="hljs-code">`master`</span><br>Validating podspec<br><span class="hljs-code"> -&gt; DaKit (0.1.1)</span><br><span class="hljs-code">    - NOTE  | xcodebuild:  note: Using new build system</span><br><span class="hljs-code">    - NOTE  | [iOS] xcodebuild:  note: Planning build</span><br><span class="hljs-code">    - NOTE  | [iOS] xcodebuild:  note: Constructing build description</span><br><br>Updating spec repo <span class="hljs-code">`master`</span><br><br><span class="hljs-code">--------------------------------------------------------------------------------</span><br><span class="hljs-code"> 🎉  Congrats</span><br><span class="hljs-code"></span><br><span class="hljs-code"> 🚀  DaKit (0.1.1) successfully published</span><br><span class="hljs-code"> 📅  August 31st, 08:23</span><br><span class="hljs-code"> 🌎  https://cocoapods.org/pods/DaKit</span><br><span class="hljs-code"> 👍  Tell your friends!</span><br><span class="hljs-code">--------------------------------------------------------------------------------</span><br></code></pre></td></tr></table></figure><h3 id="14、搜索自己的库"><a href="#14、搜索自己的库" class="headerlink" title="14、搜索自己的库"></a>14、搜索自己的库</h3><ul><li>查询trunk</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">pod trunk me<br><span class="hljs-bullet">  -</span> Name:     davidlii<br><span class="hljs-bullet">  -</span> Email:    macmafia@sina.cn<br><span class="hljs-bullet">  -</span> Since:    August 31st, 04:20<br><span class="hljs-bullet">  -</span> Pods:<br><span class="hljs-bullet">    -</span> DaKit<br><span class="hljs-bullet">  -</span> Sessions:<br><span class="hljs-bullet">    -</span> August 31st, 04:20 - January 6th, 2020 09:14. IP: 183.156.110.234<br></code></pre></td></tr></table></figure><p>可以看到<code>Pods:</code>目录下顺利出现了自制的库 DaKit。</p><ul><li>查询pod</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pod search DaKit</span><br></code></pre></td></tr></table></figure><p>如果显示以下结果，则提交公开库成功：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-punctuation">-&gt;</span> <span class="hljs-title function_ invoke__">DaKit</span> (<span class="hljs-number">0.1</span>.<span class="hljs-number">1</span>)<br>   davidlii<span class="hljs-symbol">&#x27;s</span> Kit <span class="hljs-keyword">for</span> <span class="hljs-title class_">iOS</span> developing~<br>   pod <span class="hljs-symbol">&#x27;DaKit</span>&#x27;, &#x27;~&gt; <span class="hljs-number">0.1</span>.<span class="hljs-number">1</span>&#x27;<br>   - Homepage: https:<span class="hljs-comment">//github.com/davidli-/DaKit</span><br>   - Source:   https:<span class="hljs-comment">//github.com/davidli-/DaKit.git</span><br>   - Versions: <span class="hljs-number">0.1</span>.<span class="hljs-number">1</span> [davidlii repo]<br></code></pre></td></tr></table></figure><p>如果无法查到，则先更新索引库，再重新查找：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">pod repo <span class="hljs-keyword">update</span><br>pod <span class="hljs-keyword">search</span> DaKit<br></code></pre></td></tr></table></figure><h3 id="15、导入公开库"><a href="#15、导入公开库" class="headerlink" title="15、导入公开库"></a>15、导入公开库</h3><p>修改Podfile文件：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">#######<br><br>use_frameworks!<br><br>target <span class="hljs-string">&#x27;ASDF&#x27;</span> do<br># 使用公开库<br>    pod <span class="hljs-string">&#x27;DaKit&#x27;</span><br>end<br>#######<br></code></pre></td></tr></table></figure><p>导入库文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pod <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><h3 id="16、使用公开库"><a href="#16、使用公开库" class="headerlink" title="16、使用公开库"></a>16、使用公开库</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 实体类 ***********</span><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">Card </span>: NSObject<br><span class="hljs-variable">@property</span> (nonatomic) int cardNumber; <span class="hljs-comment">// 编号</span><br><span class="hljs-variable">@property</span> (nonatomic) float money;    <span class="hljs-comment">// 余额</span><br><span class="hljs-variable">@end</span><br><br>#import <span class="hljs-string">&quot;Card.h&quot;</span><br><br><span class="hljs-comment">// 导入头文件</span><br>#import &lt;DaKit/DaSerialize.h&gt;<br>#import &lt;DaKit/DaKakashi.h&gt;<br></code></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@implementation</span> Card<br><br><span class="hljs-comment">// 使用宏</span><br><span class="hljs-built_in">DaSerialize</span>()<br><span class="hljs-built_in">DaKakashi</span>()<br><br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 测试 ***********</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Card.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;DaKit/DaClassInfo.h&gt;</span></span><br><br>- (<span class="hljs-type">void</span>)example&#123;<br>    Card *card = [[Card alloc] init];<br>    card.cardNumber = <span class="hljs-number">100</span>;<br>    card.money = <span class="hljs-number">50000000</span>;<br><br>    <span class="hljs-comment">// 序列化</span><br>    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSKeyedArchiver</span> archivedDataWithRootObject:card];<br>    Card *card2 = [<span class="hljs-built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];<br>    <br>    <span class="hljs-comment">// 复制</span><br>    Card *card3 = [card2 <span class="hljs-keyword">copy</span>];<br><br>    <span class="hljs-comment">// 获取类的信息</span><br>    <span class="hljs-built_in">NSArray</span> *ivars = [DaClassInfo ivarListWithClass:[Card <span class="hljs-keyword">class</span>]];<br>    <span class="hljs-built_in">NSArray</span> *props = [DaClassInfo propertyListWithClass:[Card <span class="hljs-keyword">class</span>]];<br>    <span class="hljs-built_in">NSArray</span> *meths = [DaClassInfo methodListWithClass:[Card <span class="hljs-keyword">class</span>]];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>至此，私有库和公有库的创建与使用均已完成，过程中还有一些ruby源和网络等问题，折腾了好一会儿，每个人的情况可能都不尽相同，这里就不一一罗列了。库已提交，以后就可以快乐的更新啦~</p><p>欢迎使用与指正~</p><hr><p>相关参考：</p><p>#<a href="https://github.com/davidli-/DaKit">©DaKit</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github访问慢？</title>
    <link href="/2019/07/23/github.html"/>
    <url>/2019/07/23/github.html</url>
    
    <content type="html"><![CDATA[<p>Github为国外网站，所以域名解析时速度慢的。。解决此问题有俩方法：</p><ul><li>挂VPN</li><li>修改hosts配置</li></ul><p>本文讲的是第二种，修改hosts文件，具体步骤如下：</p><h2 id="1、打开host文件"><a href="#1、打开host文件" class="headerlink" title="#1、打开host文件"></a>#1、打开host文件</h2><ul><li>直接通过Finder</li></ul><p>快捷键 command + shift + G，输入“&#x2F;etc”，回车即可进入etc文件夹，找到hosts文件，直接通过系统的“文本编辑”打开即可。</p><ul><li>使用终端打开</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><p>输入密码后会看到目前hosts文件的配置信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment">##</span><br><span class="hljs-comment"># Host Database</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># localhost is used to configure the loopback interface</span><br><span class="hljs-comment"># when the system is booting.  Do not change this entry.</span><br><span class="hljs-comment">##</span><br><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>localhost<br><span class="hljs-number">255.255</span>.<span class="hljs-number">255.255</span>broadcasthost<br>::<span class="hljs-number">1</span>             localhost <br></code></pre></td></tr></table></figure><h2 id="2、查询Github域名对应的ip地址"><a href="#2、查询Github域名对应的ip地址" class="headerlink" title="#2、查询Github域名对应的ip地址"></a>#2、查询Github域名对应的ip地址</h2><p>在浏览器中访问 <a href="https://www.ipaddress.com/">此网站</a>，在其搜索框中分别输入“github.com” 与 “github.global.ssl.fastly.net”，查询并记录下其对应的ip地址。我的查询结果如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.30.253.112</span> github.com<br><span class="hljs-number">151.101.13.194</span>github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure><h2 id="3、修改hosts文件"><a href="#3、修改hosts文件" class="headerlink" title="#3、修改hosts文件"></a>#3、修改hosts文件</h2><p>通过“文本编辑”工具 或者 终端中使用 vi 命令打开hosts文件，将上面两行记录写入hosts文件，保存并退出。结果如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">##<br># Host Database<br>#<br># localhost is used to configure the loopback interface<br># when the system is booting.  Do not change this entry.<br>##<br><span class="hljs-number">127.0.0.1</span>localhost<br><span class="hljs-number">255.255.255.255</span>broadcasthost<br>::<span class="hljs-number">1</span>             localhost <br><br><span class="hljs-number">192.30.253.112</span> github.com<br><span class="hljs-number">151.101.13.194</span>github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure><h2 id="4、重新访问-Github-com"><a href="#4、重新访问-Github-com" class="headerlink" title="#4、重新访问 Github.com~"></a>#4、重新访问 Github.com~</h2><p>现在，重新访问 <a href="https://github.com/">Github.com</a> 试试~</p><hr><p>相关参考：</p><p>#<a href="https://blog.csdn.net/wu__di/article/details/50538916">©传送门</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分包配置</title>
    <link href="/2019/06/18/majia.html"/>
    <url>/2019/06/18/majia.html</url>
    
    <content type="html"><![CDATA[<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="https://davidlii.nos-eastchina1.126.net/pic_majia_catelog.png" alt="catelog"></p><h3 id="Xcode-默认配置"><a href="#Xcode-默认配置" class="headerlink" title="Xcode 默认配置"></a>Xcode 默认配置</h3><p>Xcode 在生成项目时已经帮我们配置好了两个环境，并且已经在同一个scheme下做好了配置：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_schemeeditor.png" alt="scheme"></p><p>#<strong>Debug</strong></p><p>测试环境，一般 Build、Run、Test 和 Analyze，都在这个环境中进行。</p><p>#<strong>Release</strong></p><p>生产环境，Profile 和 Archive 打包上传商店时，使用这个环境。</p><p>查看<code>Build Settings</code>，你能看到每个设置下都分两种环境，可以做不同的设置。</p><p>有时我们需要的不止这两种环境，可能还需要企业版，又或者需要刷排名引流，这时就需要我们自己配置这些分包了。分包配置的大致原理是：同一个 <code>TARGET</code> 中设置不同的 <code>Configurations</code>，从而区分各种环境。下面将介绍具体的配置步骤~</p><h3 id="1-配置-PROJECT"><a href="#1-配置-PROJECT" class="headerlink" title="1.配置 PROJECT"></a>1.配置 PROJECT</h3><h4 id="1-1-info"><a href="#1-1-info" class="headerlink" title="1.1.info"></a>1.1.info</h4><p><code>PROJECT</code>-&gt;<code>info</code>-&gt;<code>Configurations</code>，点下方<code>+</code>，复制一份<code>Debug</code>或者<code>Rlease</code>的配置，重新命名，如<code>InHouse</code>。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_project_info_configurarations.png" alt="info-configurations"></p><h4 id="1-2-Build-Settings"><a href="#1-2-Build-Settings" class="headerlink" title="1.2.Build Settings"></a>1.2.Build Settings</h4><p><code>PROJECT</code>-&gt;<code>Build Settings</code>，点顶部搜索框左边的<code>+</code>，Add User-Defined Settings，设置一个自定义的宏，如<code>APP_NAME</code>，分别输入名称。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_buldset-userdefine.png" alt="buildset-userdefine"></p><h3 id="2-配置-TARGETS"><a href="#2-配置-TARGETS" class="headerlink" title="2.配置 TARGETS"></a>2.配置 TARGETS</h3><p><code>TARGETS</code>会自动继承<code>PROJECT</code>中的配置；反过来，对<code>TARGETS</code>所做的修改并不会主动映射到<code>PROJECT</code>中，需要手动复制。不复制也可以，不影响正常使用，因为 Xcode 会以<code>TARGETS</code>中的配置为准。</p><h4 id="2-1-Build-Settings"><a href="#2-1-Build-Settings" class="headerlink" title="2.1.Build Settings"></a>2.1.Build Settings</h4><p><code>TARGETS</code>-&gt;<code>Build Settings</code>中翻到底，<code>User-Defined</code>选项中自动继承了<code>PROJECT</code>中<code>APP_NAME</code>的配置。同样可以在这里点顶部的<code>+</code>，Add User-Defined Settings，添加新的配置项，如<code>APP_BUNDLE_ID</code>。在<code>TARGETS</code>-&gt;<code>info</code>中修改 Bundle display name 为<code>$&#123;APP_NAME&#125;</code>。这样就可以给不同分包起不同的名字，或者不同的 Bundle Identifier。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_display_name.png" alt="APP_NAME"></p><h4 id="2-3-配置-preprocessor-Macros"><a href="#2-3-配置-preprocessor-Macros" class="headerlink" title="2.3.配置 preprocessor Macros"></a>2.3.配置 preprocessor Macros</h4><p>这是预处理的宏，后面代码中可作为<code>标记</code>区分不同环境。可自行设置:</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_macros.png" alt="Macros"></p><h4 id="2-4-代码中使用"><a href="#2-4-代码中使用" class="headerlink" title="2.4.代码中使用"></a>2.4.代码中使用</h4><p>以 UIabel 上的文字显示为例，要求不同环境中显示对应的环境名：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sqf">- <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>      <span class="hljs-comment">//Debug</span><br>      <span class="hljs-variable">_mLable</span>.<span class="hljs-built_in">text</span> = @<span class="hljs-string">&quot;DEBUG&quot;</span>;<br>  <span class="hljs-meta">#elif M_InHouse</span><br>      <span class="hljs-comment">//InHouse</span><br>      <span class="hljs-variable">_mLable</span>.<span class="hljs-built_in">text</span> = @<span class="hljs-string">&quot;InHouse&quot;</span>;<br>  <span class="hljs-meta">#elif M_Release</span><br>      <span class="hljs-comment">//Release</span><br>      <span class="hljs-variable">_mLable</span>.<span class="hljs-built_in">text</span> = @<span class="hljs-string">&quot;Release&quot;</span>;<br>  <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-comment">//Invalid</span><br>      <span class="hljs-variable">_mLable</span>.<span class="hljs-built_in">text</span> = @<span class="hljs-string">&quot;默认值&quot;</span>;<br>  <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这里就是通过使用<code>#ifdef</code>、<code>#elif</code>、<code>#else</code>来判断是否有某个宏定义，而这些宏定义正是之前我们在 preprocessor Macros 中定义好的一些标记。运行查看效果即可~</p><h3 id="3-配置-Scheme"><a href="#3-配置-Scheme" class="headerlink" title="3.配置 Scheme"></a>3.配置 Scheme</h3><p><code>Scheme</code>-&gt;<code>Manage Schemes</code>-&gt;<code>齿轮</code>，复制一份并重新命名为<code>Release</code>或者<code>InHouse</code>。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_manage_scheme.png" alt="Manage Schemes"></p><p><code>Edit Scheme</code>，将 Build&#x2F;Run&#x2F;Test&#x2F;Profile&#x2F;Analyze&#x2F;Archive 的 Build Configuration 设置成<code>PROJECT</code>中的 Configurations 中对应的名字，如<code>Rlease</code>、<code>InHouse</code>。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_edit_scheme.png" alt="Edit Scheme"></p><p>这一步配置 scheme 是为打包时更容易的区分环境，以防失误导致打错包。同时，如果你使用了脚本进行打包或者给不同分包替换图片素材时，也可以通过这个 scheme 进行区分。</p><h3 id="4-配置-Pod-工程"><a href="#4-配置-Pod-工程" class="headerlink" title="4.配置 Pod 工程"></a>4.配置 Pod 工程</h3><p>如果工程集成了三方库，那么<code>Pods</code>工程也需要针对分包进行配置：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_majia_pod.png" alt="pods"></p><p>这里的<code>Configurations</code>与原工程中一致即可。</p><h3 id="5-脚本替换素材"><a href="#5-脚本替换素材" class="headerlink" title="5.脚本替换素材"></a>5.脚本替换素材</h3><p>我的工程目录：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── AutoBuild<br>│   ├── ExportOptions<span class="hljs-selector-class">.plist</span><br>│   ├── Header<span class="hljs-selector-class">.plist</span><br>│   ├── replace_res<span class="hljs-selector-class">.sh</span><br>│   └── res<br>│       ├── drawable<br>│       ├── <span class="hljs-attribute">icon</span><br>│       └── launcher<br>├── Majia<br>│   ├── AppDelegate<span class="hljs-selector-class">.h</span><br>│   ├── AppDelegate<span class="hljs-selector-class">.m</span><br>│   ├── Assets<span class="hljs-selector-class">.xcassets</span><br>│   │   ├── AppIcon<span class="hljs-selector-class">.appiconset</span><br>│   │   ├── Contents<span class="hljs-selector-class">.json</span><br>│   │   └── LaunchImage<span class="hljs-selector-class">.launchimage</span><br>│   ├── Info<span class="hljs-selector-class">.plist</span><br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.m</span><br>│   └── res<br>├── Majia<span class="hljs-selector-class">.xcodeproj</span><br>├── Majia<span class="hljs-selector-class">.xcworkspace</span><br>├── Podfile<br>├── Podfile<span class="hljs-selector-class">.lock</span><br>├── Pods<br>└──autobuild.sh<br></code></pre></td></tr></table></figure><p>根据不同分包的需要，使用脚本替换素材<code>replace_res.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-comment">#works for  Xcode 7.0+ only</span><br><br><span class="hljs-comment">#获取命令行中接收到的scheme</span><br>TARGET_SCHEMES=<span class="hljs-variable">$1</span><br><br><span class="hljs-keyword">if</span> [ ! -n <span class="hljs-string">&quot;<span class="hljs-variable">$TARGET_SCHEMES</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt; TARGET_SCHEMES is missing!!!&quot;</span><br>  <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start replacing RES at <span class="hljs-subst">$(date)</span> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span><br><br>AUTOBUILD_PATH=<span class="hljs-variable">$PWD</span><br>PROJECT_ROOT_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/..&quot;</span><br><br><span class="hljs-comment">#导出配置</span><br>EXPORT_ICON_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/res/icon&quot;</span><br>EXPORT_LAUNCHER_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/res/launcher&quot;</span><br>EXPORT_DRAWABLE_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/res/drawable&quot;</span><br><br><span class="hljs-comment">#icon Assets assets</span><br>ICON_ASSETS=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/Majia/Assets.xcassets/AppIcon.appiconset/&quot;</span><br>LAUNCHER_ASSETS=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/Majia/Assets.xcassets/LaunchImage.launchimage/&quot;</span><br>DRAWABLE_ASSETS=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/Majia/res/&quot;</span><br><br><span class="hljs-comment">#replace icons</span><br><span class="hljs-built_in">cp</span> -R -a <span class="hljs-string">&quot;<span class="hljs-variable">$EXPORT_ICON_PATH</span>/<span class="hljs-variable">$TARGET_SCHEMES</span>/.&quot;</span> <span class="hljs-variable">$ICON_ASSETS</span><br><span class="hljs-comment">#replace launchers</span><br><span class="hljs-built_in">cp</span> -R -a <span class="hljs-string">&quot;<span class="hljs-variable">$EXPORT_LAUNCHER_PATH</span>/<span class="hljs-variable">$TARGET_SCHEMES</span>/.&quot;</span> <span class="hljs-variable">$LAUNCHER_ASSETS</span><br><span class="hljs-comment">#replace drawables</span><br><span class="hljs-built_in">cp</span> -R -a <span class="hljs-string">&quot;<span class="hljs-variable">$EXPORT_DRAWABLE_PATH</span>/<span class="hljs-variable">$TARGET_SCHEMES</span>/.&quot;</span> <span class="hljs-variable">$DRAWABLE_ASSETS</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finish replacing RES at <span class="hljs-subst">$(date)</span> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span><br></code></pre></td></tr></table></figure><p>在终端里 cd 到根目录下的<code>AutoBuild</code>目录执行该脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">./replace_res.sh InHouse</span><br></code></pre></td></tr></table></figure><p>脚本后的参数是你想替换素材的分包<code>scheme</code>。</p><h4 id="6-脚本打包"><a href="#6-脚本打包" class="headerlink" title="6.脚本打包"></a>6.脚本打包</h4><p>cd 到根目录下，执行下面的打包脚本<code>autobuild.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-comment">#works for  Xcode 7.0+ only</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start at <span class="hljs-subst">$(date)</span> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span><br><br>PROJECT_ROOT_PATH=<span class="hljs-variable">$PWD</span><br>AUTOBUILD_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/AutoBuild&quot;</span><br><br>CURRENT_DATE=$(<span class="hljs-built_in">date</span> +%Y_%m%d_%H%M)<br>WORKSPACE_NAME=<span class="hljs-string">&quot;Majia.xcworkspace&quot;</span><br><br><span class="hljs-comment">#导出配置</span><br>HEADER_PLIST=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/Header.plist&quot;</span><br>EXPORT_PLIST=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/ExportOptions.plist&quot;</span><br><br><span class="hljs-comment">#Info key</span><br>KEY_SCHEME=<span class="hljs-string">&quot;KEY_SCHEME&quot;</span><br>KEY_APP_NAME=<span class="hljs-string">&quot;KEY_APP_NAME&quot;</span><br>KEY_TEAM_ID=<span class="hljs-string">&quot;KEY_TEAM_ID&quot;</span><br>KEY_DEV_ID=<span class="hljs-string">&quot;KEY_DEV_ID&quot;</span><br><br><span class="hljs-comment">#Flavors</span><br>InHouse=&#123;<span class="hljs-variable">$KEY_SCHEME</span>:<span class="hljs-string">&quot;InHouse&quot;</span>,<span class="hljs-variable">$KEY_APP_NAME</span>:<span class="hljs-string">&quot;InHouse&quot;</span>,<span class="hljs-variable">$KEY_TEAM_ID</span>:<span class="hljs-string">&quot;your_team_ID&quot;</span>,<span class="hljs-variable">$KEY_DEV_ID</span>:<span class="hljs-string">&quot;your_team&quot;</span>&#125;<br>Release=&#123;<span class="hljs-variable">$KEY_SCHEME</span>:<span class="hljs-string">&quot;Release&quot;</span>,<span class="hljs-variable">$KEY_APP_NAME</span>:<span class="hljs-string">&quot;Release&quot;</span>,<span class="hljs-variable">$KEY_TEAM_ID</span>:<span class="hljs-string">&quot;your_team_ID&quot;</span>,<span class="hljs-variable">$KEY_DEV_ID</span>:<span class="hljs-string">&quot;your_team&quot;</span>&#125;<br><br><span class="hljs-comment">#SELECT FLAVORS</span><br>FLAVORS=(<span class="hljs-variable">$Release</span>,<span class="hljs-variable">$InHouse</span>)<br><br><span class="hljs-comment">#Parse method</span><br><span class="hljs-function"><span class="hljs-title">parse_json</span></span>()&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span> | sed <span class="hljs-string">&#x27;s/.*&#x27;</span><span class="hljs-variable">$2</span><span class="hljs-string">&#x27;:\([^,&#125;]*\).*/\1/&#x27;</span><br>&#125;<br><br><span class="hljs-comment">#build release apps directory</span><br>BUILD_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/Build&quot;</span><br>RELEASE_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$BUILD_DIR</span>/Products&quot;</span><br><br><span class="hljs-built_in">rm</span> -rdf <span class="hljs-variable">$BUILD_DIR</span><br><br><span class="hljs-comment">#final binarys&#x27; directory</span><br>OUT_BINARY_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/binarys_<span class="hljs-variable">$CURRENT_DATE</span>&quot;</span><br><br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-variable">$OUT_BINARY_DIR</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$OUT_BINARY_DIR</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">for</span> ((i = 0; i &lt; <span class="hljs-variable">$&#123;#FLAVORS[@]&#125;</span>; i++))<br><span class="hljs-keyword">do</span><br>  <br>  <span class="hljs-comment">#parse elements</span><br>  TARGET_SCHEMES=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_SCHEME</span>)<br>  TARGET_APP_NAMES=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_APP_NAME</span>)<br>  TARGET_TEAM_IDS=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_TEAM_ID</span>)<br>  TARGET_DEV_IDS=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_DEV_ID</span>)<br><br>  <span class="hljs-comment">#reset export options plist</span><br>  <span class="hljs-built_in">rm</span> <span class="hljs-variable">$EXPORT_PLIST</span><br>  <br>  <span class="hljs-built_in">cat</span> <span class="hljs-variable">$HEADER_PLIST</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;plist version=\&quot;1.0\&quot;&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;dict&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;key&gt;teamID&lt;/key&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;string&gt;<span class="hljs-variable">$TARGET_TEAM_IDS</span>&lt;/string&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;key&gt;method&lt;/key&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; target scheme <span class="hljs-variable">$TARGET_SCHEMES</span>&quot;</span><br>  <br>  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$TARGET_SCHEMES</span> = <span class="hljs-string">&quot;InHouse&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;string&gt;enterprise&lt;/string&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enterprise Done&quot;</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;string&gt;app-store&lt;/string&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; app-store Done&quot;</span><br>  <span class="hljs-keyword">fi</span><br>  <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;key&gt;uploadSymbols&lt;/key&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;true/&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;/dict&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;/plist&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br>  <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reset export options Done&quot;</span><br><br>  <span class="hljs-built_in">cd</span> <span class="hljs-variable">$AUTOBUILD_PATH</span><br>  ./replace_res.sh <span class="hljs-variable">$TARGET_SCHEMES</span><br><br>  <span class="hljs-comment"># return root</span><br>  <span class="hljs-built_in">cd</span> <span class="hljs-variable">$PROJECT_ROOT_PATH</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reset res Done&quot;</span><br>  <br>  <span class="hljs-comment">#export files</span><br>  ARCHIVE_FILE=<span class="hljs-string">&quot;<span class="hljs-variable">$OUT_BINARY_DIR</span>/<span class="hljs-variable">$TARGET_APP_NAMES</span>.xcarchive&quot;</span><br>  DSYMS_FILE=<span class="hljs-string">&quot;<span class="hljs-variable">$TARGET_APP_NAMES</span>.dSYMs.zip&quot;</span><br>  <br>  <span class="hljs-comment">#clean prject</span><br>  xcodebuild -workspace <span class="hljs-variable">$WORKSPACE_NAME</span> -scheme <span class="hljs-variable">$TARGET_SCHEMES</span> -configuration <span class="hljs-variable">$TARGET_APP_NAMES</span> clean<br>  <br>  <span class="hljs-comment">#build &amp; archive</span><br>  xcodebuild archive -workspace <span class="hljs-variable">$WORKSPACE_NAME</span> -scheme <span class="hljs-variable">$TARGET_SCHEMES</span> -configuration <span class="hljs-variable">$TARGET_APP_NAMES</span> -archivePath <span class="hljs-variable">$ARCHIVE_FILE</span><br>  <br>  <span class="hljs-built_in">cd</span> <span class="hljs-variable">$ARCHIVE_FILE</span><br>  zip -r <span class="hljs-variable">$DSYMS_FILE</span> <span class="hljs-string">&quot;dSYMs&quot;</span><br>  <span class="hljs-built_in">mv</span> <span class="hljs-variable">$DSYMS_FILE</span> <span class="hljs-variable">$OUT_BINARY_DIR</span><br>  <br>  <span class="hljs-comment"># return root</span><br>  <span class="hljs-built_in">cd</span> <span class="hljs-variable">$PROJECT_ROOT_PATH</span><br>  <br>  <span class="hljs-comment">#export</span><br>  xcodebuild -exportArchive -archivePath <span class="hljs-variable">$ARCHIVE_FILE</span> -exportPath <span class="hljs-variable">$OUT_BINARY_DIR</span> -exportOptionsPlist <span class="hljs-variable">$EXPORT_PLIST</span><br>  <br>  <span class="hljs-comment">#rename ipa file failed since creating ipa file is asynchronized</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;apple id paired&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$OUT_BINARY_DIR</span>/$TARGET_APP_NAMES_<span class="hljs-variable">$TARGET_DEV_IDS</span>&quot;</span><br>  <br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="hljs-variable">$TARGET_SCHEMES</span> single loop Done&quot;</span><br>  <br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finish at <span class="hljs-subst">$(date)</span> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span><br></code></pre></td></tr></table></figure><p>根据需要修改脚本中的 teamID 和开发者证书信息，修改将要打包的 scheme，cd 到工程根目录执行脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">./autobuild.sh</span><br></code></pre></td></tr></table></figure><p>此脚本做了以下几件事：</p><ul><li>生成打包所需的 ExportOptions.plist；</li><li>自动执行 <code>replace_res.sh</code> 脚本替换素材，你无须手动执行了；</li><li>根据指定的 <code>scheme</code> 执行 archive；</li><li>导出<code>dSYM</code>文件；</li><li>导出 ipa。</li></ul><h3 id="7-小缺点"><a href="#7-小缺点" class="headerlink" title="7.小缺点"></a>7.小缺点</h3><p>根据我自己的使用情况来看，配置过多分包时，在 Xcode 中打开<code>Build Settings</code>会非常卡。这可能是因为 Xcode 中的各种配置从本质上来说都是保存在 plist 中，加载此配置文件时，要读取N个分包的节点，是需要花费一定时间。</p><hr><p>相关参考：</p><p>#<a href="https://github.com/davidli-/Majia.git">©项目代码</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用安全</title>
    <link href="/2019/05/01/safeapp.html"/>
    <url>/2019/05/01/safeapp.html</url>
    
    <content type="html"><![CDATA[<p>这段时间 iOS12 越狱工具发布了，屁颠屁颠的去研究了一键砸壳，昨天忽然想起来之前公司的产品被人破解，拿到了关键信息进而薅羊毛的事。那时的解决方案是检测异常请求和独立出一个加密<code>framework</code>。现在想想，这些措施都太简单或者不够高效，还需要更进一步研究应用的安全问题。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_safe_app.png" alt="纲目"></p><h3 id="1-被破解的危害"><a href="#1-被破解的危害" class="headerlink" title="1.被破解的危害"></a>1.被破解的危害</h3><ul><li>被人逆向分析通信协议、API、核心算法等；</li><li>篡改IPA、植入广告和木马；</li><li>重打包并发布盗版应用；</li><li>破解内购；</li></ul><h3 id="2-防范"><a href="#2-防范" class="headerlink" title="2.防范"></a>2.防范</h3><p>在这方面我是真没有经验，于是抱着学习的态度去查看了相关的论坛和资料，学学别人的经验，这里做一个简单的记录~</p><h4 id="2-1-检测是否越狱（念茜）"><a href="#2-1-检测是否越狱（念茜）" class="headerlink" title="2.1.检测是否越狱（念茜）"></a>2.1.检测是否越狱（念茜）</h4><p>这是最常见的被动防御方法，比如当应用启动时，先检测设备是否已经越狱，如果已越狱则禁止应用启动；在用户发起内购支付时，如果发现设备已越狱，则直接拒绝内购请求并给出相应的提示。根据我的测试，<code>部落冲突</code>游戏就是通过闪退直接禁止越狱设备启动自己，而腾讯旗下的产品基本上都会在越狱设备发起支付时给出提示，<code>别踩音乐块儿</code>也是如此。</p><p>以下摘自<a href="https://blog.csdn.net/yiyaaixuexi/article/details/20286929">念茜</a>的博客：</p><ul><li>检测越狱文件或目录</li></ul><p>越狱后的设备中会有相关的文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/Applications/</span>Cydia.app<br><span class="hljs-regexp">/Library/</span>MobileSubstrate/MobileSubstrate.dylib<br><span class="hljs-regexp">/bin/</span>bash<br><span class="hljs-regexp">/usr/</span>sbin/sshd<br><span class="hljs-regexp">/etc/</span>apt<br></code></pre></td></tr></table></figure><p>检测方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+(<span class="hljs-type">BOOL</span>)isJailbroken&#123;<br><span class="hljs-keyword">if</span> ([[<span class="hljs-built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="hljs-string">@&quot;/Applications/Cydia.app&quot;</span>])&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>检测 Cydia 的 URL scheme</li></ul><p>越狱后的设备一般都会安装 Cydia，这里可以通过检测其 URL Scheme 来反推设备是否越狱。这个方法在 iOS9 之后会因为权限问题而出现问题，所以你需要配置好<code>LSApplicationQueriesSchemes</code>白名单。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(<span class="hljs-string">[[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;cydia://package/com.example.package&quot;]]</span>)&#123;<br>     NSLog(@<span class="hljs-string">&quot;Device is jailbroken&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>读取应用列表，看有无权限:</li></ul><p>在未越狱的情况下，用户是没有权限查看设备上的某些目录的，也就无法知晓有哪些已安装的应用，除非你像某些三方市场一样用苹果的私有API，但这会导致上架被拒。所以，我们可以利用这一特性来检测设备是否越狱：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span> ([[<span class="hljs-built_in">NSFileManager</span> defaultManager] fileExistsAtPath:<span class="hljs-string">@&quot;/User/Applications/&quot;</span>])&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Device is jailbroken&quot;</span>);<br>    <span class="hljs-built_in">NSArray</span> *applist = [[<span class="hljs-built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:<span class="hljs-string">@&quot;/User/Applications/&quot;</span><br>                                            error:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;applist = %@&quot;</span>,applist);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用 stat 系列函数检测 Cydia 等工具：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#import <span class="hljs-string">&lt;sys/stat.h&gt;</span>  </span><br>     <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkCydia</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  </span><br><span class="hljs-function">  </span>&#123;  <br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_info;  <br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">stat</span>(<span class="hljs-string">&quot;/Applications/Cydia.app&quot;</span>, &amp;stat_info)) &#123;  <br>          <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;Device is jailbroken&quot;</span>);  <br>      &#125;  <br>  &#125;<br></code></pre></td></tr></table></figure><ul><li>检测 DYLD_INSERT_LIBRARIES 环境变量</li></ul><p><code>DYLD_INSERT_LIBRARIES</code>是一个环境变量，<code>dyld</code>动态链接器在加载二进制文件时会检测这个变量，如果有配置过则会加载其指向的动态库，从而实现动态注入并将程序的内存dump出来，这正是越狱设备中调试时常用的方法。所以我们可以检测此环境变量来确定设备是否越狱：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void print<span class="hljs-constructor">Env(<span class="hljs-params">void</span>)</span><br>&#123;<br>  <span class="hljs-built_in">char</span> *env = getenv(<span class="hljs-string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>);<br>  <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-params">env</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>未越狱设备返回结果是null，已越狱设备返回自己的配置。</p><h4 id="2-2-代码-amp-逻辑混淆"><a href="#2-2-代码-amp-逻辑混淆" class="headerlink" title="2.2.代码 &amp; 逻辑混淆"></a>2.2.代码 &amp; 逻辑混淆</h4><ul><li>关键字：类名、属性、方法名等；</li><li>常量：URL、字符串；</li><li>将原逻辑拆分成各种怪癖语法；</li></ul><p>代码混淆和逻辑混淆，其本质上只是在应用编译时将指定的字符串或逻辑进行混淆替换，从而增加应用破解后阅读源码的难度。具体的混淆方法，我之前的文章中也已经介绍过，这里不再赘述~</p><h4 id="2-3-RESTRICT反动态库注入"><a href="#2-3-RESTRICT反动态库注入" class="headerlink" title="2.3.__RESTRICT反动态库注入"></a>2.3.__RESTRICT反动态库注入</h4><blockquote><p>restrict，C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</p></blockquote><p>restrict是c99标准引入的，它只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式。即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改，而不能通过其它途径(其它变量或指针)来修改；这样做的好处是，能帮助编译器进行更好的优化代码，生成更有效率的汇编代码。如 int *restrict ptr, ptr 指向的内存单元只能被 ptr 访问到，任何同样指向这个内存单元的其他指针都是未定义的，直白点就是无效指针。</p><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ar[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> * restrict restar=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-type">int</span> *par=ar;<br></code></pre></td></tr></table></figure><p>这里说明restar是访问由malloc()分配的内存的唯一且初始的方式。par就不是了。</p><p>通过在 Xcode 里的 Other Linker Flags 设置参数，可以防止应用的二进制文件被注入 dylib（仅限于iOS 10 以下系统）。dylib 无法注入，也就意味着没办法用<code>cycript</code>动态调试进程</p><ul><li>Other Linker Flags 参数：</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">-Wl,-sectcreate,__RESTRICT,__restrict,<span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>参考博文：</p><ul><li><a href="https://baike.baidu.com/item/restrict/7384270?fr=aladdin">百科-restrict</a></li><li><a href="https://www.cnblogs.com/ciml/p/7551193.html">反注入</a></li><li><a href="http://bbs.iosre.com/t/tweak-app-app-tweak/438">iosre论坛snakeninny</a></li><li><a href="https://pewpewthespells.com/blog/blocking_code_injection_on_ios_and_os_x.html">pewpewthespells-blocking_code_injection</a></li></ul><h4 id="2-4-反ptrace调试"><a href="#2-4-反ptrace调试" class="headerlink" title="2.4.反ptrace调试"></a>2.4.反ptrace调试</h4><p><code>ptrace</code>是系统函数，此函数提供一个进程去监听和控制另一个进程，并且可以检测被控制进程的内存和寄存器里面的数据。<code>ptrace</code>可以用来实现断点调试和系统调用跟踪。</p><p>参考博文：<a href="https://www.jianshu.com/p/ebdfb0a25c85">https://www.jianshu.com/p/ebdfb0a25c85</a></p><h4 id="2-5-第三方加固"><a href="#2-5-第三方加固" class="headerlink" title="2.5.第三方加固"></a>2.5.第三方加固</h4><p>缺点：</p><ul><li>安装包变大；</li><li>运行速度变慢；</li></ul><p>第三方加固提供商：</p><ul><li>网易易盾</li><li>百度加固</li><li>腾讯乐固</li><li>通付盾</li></ul><p>根据应用对安全等级的要求衡量成本~~</p><hr><p>相关参考：</p><p>#<a href="https://blog.csdn.net/yiyaaixuexi/article/details/20286929">©念茜</a></p><p>#<a href="https://www.cnblogs.com/ciml/p/7551193.html">©反注入</a></p><p>#<a href="http://bbs.iosre.com/t/tweak-app-app-tweak/438">©iosre论坛snakeninny</a>  </p><p>#<a href="https://pewpewthespells.com/blog/blocking_code_injection_on_ios_and_os_x.html">©pewpewthespells-blocking_code_injection</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向工程</title>
    <link href="/2019/04/26/reverse.html"/>
    <url>/2019/04/26/reverse.html</url>
    
    <content type="html"><![CDATA[<p>一般来说，软件逆向工程可以看作<code>系统分析</code>和<code>代码分析</code>两个阶段的有机结合。在<code>系统分析</code>阶段，我们从整体上观察目标程序的行为特征，文件的组织架构，从而找到我们感兴趣的地方。<code>代码分析</code>阶段，利用各种工具对程序本身的二进制文件进行分析，从而了解目标软件的实现，进而借鉴其设计思路、内部算法、反思教训等。</p><h3 id="1-设备越狱"><a href="#1-设备越狱" class="headerlink" title="1.设备越狱"></a>1.设备越狱</h3><p>通过<code>爱思</code>、<code>PP助手</code>、<code>同步助手</code>、<code>unc0ver</code>等工具，对已经备份过的设备进行越狱；</p><h3 id="2-安装插件"><a href="#2-安装插件" class="headerlink" title="2.安装插件"></a>2.安装插件</h3><h4 id="2-1-OpenSSH"><a href="#2-1-OpenSSH" class="headerlink" title="2.1.OpenSSH"></a>2.1.OpenSSH</h4><p>OpenSSH 会在 iOS 设备上安装 SSH 服务，从而给外界提供了一个通过 SSH 接入 iOS 设备的途径。常用的有两个命令：</p><p><code>ssh</code>，用于远程登录：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.31</span>.<span class="hljs-number">242</span><br></code></pre></td></tr></table></figure><p><code>scp</code>，用于远程拷贝文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>本地拷贝到手机<br>$ scp <span class="hljs-regexp">/path/</span>localFile root@<span class="hljs-number">192.168</span>.<span class="hljs-number">31.242</span>:<span class="hljs-regexp">/path/</span>remoteFile <br><span class="hljs-regexp">//</span>手机拷贝到本地<br>$ scp root@<span class="hljs-number">192.168</span>.<span class="hljs-number">31.242</span>:<span class="hljs-regexp">/path/</span>remoteFile <span class="hljs-regexp">/path/</span>localFile <br></code></pre></td></tr></table></figure><p>使用 Cydia 在线源直接搜索 OpenSSH 即可找到并安装。</p><p>注意：iOS设备上有 <code>root</code>和<code>mobile</code>两个用户，在安装完 SSH 后记得修改默认登录密码“alpine”，防止病毒通过 ssh 以 root 用户身份登录设备。安装SSH和修改密码的方法，一般在Cydia的首页都有说明，可按照说明一步步操作即可。</p><h4 id="2-2-Cycript"><a href="#2-2-Cycript" class="headerlink" title="2.2.Cycript"></a>2.2.Cycript</h4><p>Cycript 是逆向工程中用来进行动态分析的利器，能够让开发人员在命令行下和应用交互，在执行时查看和改动应用，如帮助我们在运行时查看应用视图层级、函数等信息。</p><ul><li>安装方法1：</li></ul><p>从 Cydia 自带源<code>Cydia/Telesphoreo</code>下载安装。</p><ul><li>安装方法2：</li></ul><p>在 <a href="http://www.cycript.org/debs/?C=M;O=D">官网</a> 中找到<code>cycript_0.9.501_iphoneos-arm.deb</code>和<code>libffi_1:3.0.10-5_iphoneos-arm.deb</code>这两个安装包，下载到 MacOS 上。用 sftp 上传上面两个文件到设备上：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ sftp root@<span class="hljs-number">192.168</span>.<span class="hljs-number">31.242</span><br>sftp&gt; <span class="hljs-keyword">put</span> cycript_0.<span class="hljs-number">9.501</span>_iphoneos-arm.<span class="hljs-keyword">deb</span><br>sftp&gt; <span class="hljs-keyword">put</span> libffi_1:<span class="hljs-number">3.0</span>.<span class="hljs-number">10</span>-<span class="hljs-number">5</span>_iphoneos-arm.<span class="hljs-keyword">deb</span><br></code></pre></td></tr></table></figure><p>上传进度100%后，用 dpkg -i来安装deb包：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.31</span>.<span class="hljs-number">242</span><br>~ root<span class="hljs-comment"># dpkg -i cycript_0.9.501_iphoneos-arm.deb</span><br></code></pre></td></tr></table></figure><ul><li>安装方法3：</li></ul><p>ssh登录后，输入以下命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install cycrypt<br></code></pre></td></tr></table></figure><p>执行 cycript，如果出现cy#符号，则安装完毕:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">~ root<span class="hljs-comment"># cycript</span><br>cy<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h3 id="3-dumpdecrypted-dylib"><a href="#3-dumpdecrypted-dylib" class="headerlink" title="3.dumpdecrypted.dylib"></a>3.dumpdecrypted.dylib</h3><p>从 Github 上下载 dumpdecrypted 源码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/stefanesser/</span>dumpdecrypted.git dumpdecrypted<br>Cloning into <span class="hljs-string">&#x27;dumpdecrypted&#x27;</span>...<br>remote: Counting objects: <span class="hljs-number">31</span>, done.<br>remote: Total <span class="hljs-number">31</span> (delta <span class="hljs-number">0</span>), reused <span class="hljs-number">0</span> (delta <span class="hljs-number">0</span>), pack-reused <span class="hljs-number">31</span><br>Unpacking objects: <span class="hljs-number">100</span>% (<span class="hljs-number">31</span>/<span class="hljs-number">31</span>), done.<br></code></pre></td></tr></table></figure><p>进入<code>dumpdecrypted</code>目录查看有哪些文件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> dumpdecrypted/<br><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>Makefile    README      dumpdecrypted.c<br></code></pre></td></tr></table></figure><p>编译 dumpdecrypted.dylib</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ make<br>`xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--find</span> gcc` -Os  -Wimplicit -isysroot `xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--show-sdk-path</span>` -F`xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--show-sdk-path</span>`/System/Library/Frameworks -F`xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--show-sdk-path</span>`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -c -o dumpdecrypted<span class="hljs-selector-class">.o</span> dumpdecrypted<span class="hljs-selector-class">.c</span> <br><span class="hljs-number">2018</span>-<span class="hljs-number">07</span>-<span class="hljs-number">27</span> <span class="hljs-number">22</span>:<span class="hljs-number">09</span>:<span class="hljs-number">19.065</span> xcodebuild<span class="hljs-selector-attr">[1941:437762]</span> <span class="hljs-selector-attr">[MT]</span> PluginLoading: Required plug-<span class="hljs-keyword">in</span> compatibility UUID <span class="hljs-number">426</span>A087B-D3AA-<span class="hljs-number">431</span>A-AFDF-F135EC00DE1C <span class="hljs-keyword">for</span> plug-<span class="hljs-keyword">in</span> at path <span class="hljs-string">&#x27;~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/VVDocumenter-Xcode.xcplugin&#x27;</span> not present <span class="hljs-keyword">in</span> DVTPlugInCompatibilityUUIDs<br>`xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--find</span> gcc` -Os  -Wimplicit -isysroot `xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--show-sdk-path</span>` -F`xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--show-sdk-path</span>`/System/Library/Frameworks -F`xcrun <span class="hljs-attr">--sdk</span> iphoneos <span class="hljs-attr">--show-sdk-path</span>`/System/Library/PrivateFrameworks -arch armv7 -arch armv7s -arch arm64 -dynamiclib -o dumpdecrypted<span class="hljs-selector-class">.dylib</span> dumpdecrypted<span class="hljs-selector-class">.o</span><br>ld: warning: directory not found <span class="hljs-keyword">for</span> option <span class="hljs-string">&#x27;-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks&#x27;</span><br>ld: warning: directory not found <span class="hljs-keyword">for</span> option <span class="hljs-string">&#x27;-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks&#x27;</span><br>ld: warning: directory not found <span class="hljs-keyword">for</span> option <span class="hljs-string">&#x27;-F/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS11.4.sdk/System/Library/PrivateFrameworks&#x27;</span><br></code></pre></td></tr></table></figure><p><code>make</code>命令执行完之后会在当前目录下生成一个<code>dumpdecrypted.dylib</code>文件，这就是后面用来砸壳用的榔头。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span><br>Makefiledumpdecrypted.cdumpdecrypted.o<br>READMEdumpdecrypted.dylib<br></code></pre></td></tr></table></figure><h3 id="4-定位进程"><a href="#4-定位进程" class="headerlink" title="4.定位进程"></a>4.定位进程</h3><p>关闭设备中所有的应用，打开<code>央视影音</code>(Cbox)。 </p><p>通过ssh，以 root 身份登录设备：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.31</span>.<span class="hljs-number">242</span><br></code></pre></td></tr></table></figure><p>用<code>adv-cmds</code>命令行插件自带的<code>ps</code>命令，定位<code>央视影音</code>进程：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">~ root# ps -e | <span class="hljs-keyword">grep</span> <span class="hljs-regexp">/var/</span><br> <span class="hljs-number">5193</span> ??         <span class="hljs-number">0</span>:<span class="hljs-number">01.90</span> <span class="hljs-regexp">/var/</span>containers<span class="hljs-regexp">/Bundle/</span>Application<span class="hljs-regexp">/BE3F444E-5002-40A6-AFF3-71DB398DAB18/M</span>obileMail.app/MobileMail<br> <span class="hljs-number">5195</span> ??         <span class="hljs-number">6</span>:<span class="hljs-number">05.27</span> <span class="hljs-regexp">/var/</span>containers<span class="hljs-regexp">/Bundle/</span>Application<span class="hljs-regexp">/B3248F78-A0C2-4965-8E2F-B3CEE38E71C0/</span>DYZB.app/DYZB<br> <span class="hljs-number">5218</span> ??        <span class="hljs-number">12</span>:<span class="hljs-number">15.94</span> <span class="hljs-regexp">/var/</span>containers<span class="hljs-regexp">/Bundle/</span>Application<span class="hljs-regexp">/9437BC53-681D-4F41-889C-5DE6DAAD33CD/</span>Cbox.app/Cbox<br> <span class="hljs-number">5317</span> ??         <span class="hljs-number">0</span>:<span class="hljs-number">40.58</span> <span class="hljs-regexp">/var/</span>containers<span class="hljs-regexp">/Bundle/</span>Application<span class="hljs-regexp">/6EE6BF3A-94DB-4356-811C-5CD35CEAD4CC/</span>XMFilmTelevision.app/XMFilmTelevision<br> <span class="hljs-number">5860</span> ??         <span class="hljs-number">0</span>:<span class="hljs-number">00.58</span> <span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span>C73F08EB-<span class="hljs-number">2</span>C9B-<span class="hljs-number">4169</span>-<span class="hljs-number">9</span>C2C-<span class="hljs-number">8</span>E933417465B<span class="hljs-regexp">/BlockerTest.app/</span>PlugIns<span class="hljs-regexp">/Blocker.appex/</span>Blocker<br> <span class="hljs-number">5861</span> ??         <span class="hljs-number">0</span>:<span class="hljs-number">25.78</span> <span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span>EA8607BE-AD62-<span class="hljs-number">4179</span>-B060-E939B00FD212<span class="hljs-regexp">/Shadowrocket.app/</span>PlugIns<span class="hljs-regexp">/Today.appex/</span>Today<br> <span class="hljs-number">5862</span> ??         <span class="hljs-number">0</span>:<span class="hljs-number">00.84</span> <span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span>B6364A33-<span class="hljs-number">5</span>BEF-<span class="hljs-number">4059</span>-<span class="hljs-number">8491</span>-EF8DB484176C<span class="hljs-regexp">/Shortcuts.app/</span>PlugIns<span class="hljs-regexp">/ShortcutsWidget.appex/</span>ShortcutsWidget<br> <span class="hljs-number">5863</span> ??         <span class="hljs-number">0</span>:<span class="hljs-number">01.37</span> <span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span>B2D9F8D2-<span class="hljs-number">3853</span>-<span class="hljs-number">4</span>BE6-<span class="hljs-number">8500</span>-<span class="hljs-number">8</span>D4FE4140A4E<span class="hljs-regexp">/Weather.app/</span>PlugIns<span class="hljs-regexp">/WeatherAppTodayWidget.appex/</span>WeatherAppTodayWidget<br> <span class="hljs-number">6034</span> ??         <span class="hljs-number">0</span>:<span class="hljs-number">00.16</span> <span class="hljs-regexp">/private/</span>var<span class="hljs-regexp">/containers/</span>Bundle<span class="hljs-regexp">/Application/</span>C73F08EB-<span class="hljs-number">2</span>C9B-<span class="hljs-number">4169</span>-<span class="hljs-number">9</span>C2C-<span class="hljs-number">8</span>E933417465B<span class="hljs-regexp">/BlockerTest.app/</span>PlugIns<span class="hljs-regexp">/Tunnel.appex/</span>Tunnel<br> <span class="hljs-number">6247</span> ttys000    <span class="hljs-number">0</span>:<span class="hljs-number">00.02</span> <span class="hljs-keyword">grep</span> <span class="hljs-regexp">/var/</span><br></code></pre></td></tr></table></figure><p>第一行的数字是进程对应的PID，最后一行就是进程所在的目录。使用<code>ps -e</code>命令时终端里会列出一堆系统进程和应用，它们往往以<code>/usr/</code>和<code>/System/</code>开头，而我们下载的应用一般以<code>/var/</code>开头，所以这里可以添加一个过滤条件<code>ps -e | grep /var/</code>，这样结果就简化许多。</p><p>因为设备上只打开了一个应用，所以含有<code>/var/containers/Bundle/Application/</code>字样的结果就是storeApp可执行文件的全路径，这里我需要记录下来的是<code>央视影音</code>这个进程：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>containers<span class="hljs-regexp">/Bundle/</span>Application<span class="hljs-regexp">/9437BC53-681D-4F41-889C-5DE6DAAD33CD/</span>Cbox.app/Cbox<br></code></pre></td></tr></table></figure><h3 id="5-Documents-目录"><a href="#5-Documents-目录" class="headerlink" title="5.Documents 目录"></a>5.Documents 目录</h3><p>通过<code>cycript -p</code>命令监听 <code>Cbox</code>进程：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">~ root<span class="hljs-comment"># cycript -p Cbox</span><br></code></pre></td></tr></table></figure><p>也可以通过<code>Cbox</code>的<code>PID</code>来监听：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">~ root<span class="hljs-comment"># cycript -p 5218</span><br></code></pre></td></tr></table></figure><p>接着在<code>cy#</code>后面输入：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">cy# [[<span class="hljs-built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="hljs-built_in">NSDocumentDirectory</span> inDomains:<span class="hljs-built_in">NSUserDomainMask</span>]<br></code></pre></td></tr></table></figure><p>这一步是用 Cycript 找出<code>Cbox</code>的<code>Documents</code>目录，输出结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">#&quot;/var/mobile/Containers/Data/Application/D02582B3<span class="hljs-string">-66</span>D3<span class="hljs-string">-4</span>EF1-A6C2<span class="hljs-string">-6129</span>D4E1B9CA/Documents/&quot;<br></code></pre></td></tr></table></figure><p>这里<code>/var/mobile/Containers/Data/Application/D02582B3-66D3-4EF1-A6C2-6129D4E1B9CA/Documents/</code>就是我们要找的目录，<code>Ctrl + D</code>退出 Cycript 模式。</p><h3 id="6-拷贝动态库"><a href="#6-拷贝动态库" class="headerlink" title="6.拷贝动态库"></a>6.拷贝动态库</h3><p>将步骤#3 中编译的<code>dumpdecrypted.dylib</code>拷贝到刚才的<code>Documents</code>目录下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>scp /<span class="hljs-title class_">Users</span>/davidli/<span class="hljs-title class_">Documents</span>/dumpdecrypted/dumpdecrypted.dylib root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.31</span>.<span class="hljs-number">242</span><span class="hljs-symbol">:/var/mobile/Containers/Data/Application/D02582B3-</span><span class="hljs-number">66</span>D3<span class="hljs-number">-4</span>EF1-<span class="hljs-title class_">A6C2</span><span class="hljs-number">-6129</span>D4E1B9CA/<span class="hljs-title class_">Documents</span>/<br></code></pre></td></tr></table></figure><p>另外，你也可以使用<code>iTools</code>或者<code>iFunBox</code>等工具来完成。</p><h3 id="7-砸壳"><a href="#7-砸壳" class="headerlink" title="7.砸壳"></a>7.砸壳</h3><p>从应用商店下载的应用是被苹果特殊加密过的，可执行文件被套上了一层保护壳，想 dump 出它的头文件等，需要先解密应用的可执行文件，这个过程就被称为<code>砸壳</code>。</p><p><code>dumpdecrypted</code>就是一款有名的砸壳软件，其工作原理是：将应用运行起来（iOS系统会先解密应用可执行文件再启动），然后遍历 <code>Load Command</code> 中所有 <code>LC_ENCRYPTION_INFO</code> 或 <code>LC_ENCRYPTION_INFO_64</code>指令的信息，将对应解密后的数据从内存中 dump 出来，复写到 mach-o 文件中，得到一个新的可执行程序。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">~ root# cd <span class="hljs-regexp">/var/m</span>obile<span class="hljs-regexp">/Containers/</span>Data<span class="hljs-regexp">/Application/</span>D02582B3-<span class="hljs-number">66</span>D3-<span class="hljs-number">4</span>EF1-A6C2-<span class="hljs-number">6129</span>D4E1B9CA<span class="hljs-regexp">/Documents/</span><br>root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib <span class="hljs-regexp">/var/</span>containers<span class="hljs-regexp">/Bundle/</span>Application<span class="hljs-regexp">/9437BC53-681D-4F41-889C-5DE6DAAD33CD/</span>Cbox.app/Cbox<br></code></pre></td></tr></table></figure><p>这里的<code>DYLD_INSERT_LIBRARIES</code>是一个环境变量，我们的<code>dumpdecrypted.dylib</code>就是要通过这个环境变量注入到应用中。</p><p>上述命令执行完毕后会在当前目录生成<code>Cbox.decrypted</code>，即砸壳之后 App 的可执行文件。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">root<span class="hljs-comment"># ls</span><br>Cbox.decrypted     dumpdecrypted.dylib <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><h3 id="8-拷贝-decrypted"><a href="#8-拷贝-decrypted" class="headerlink" title="8.拷贝.decrypted"></a>8.拷贝.decrypted</h3><p>将 Cbox.decrypted 拷贝到自己的电脑上：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>scp root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.31</span>.<span class="hljs-number">242</span><span class="hljs-symbol">:/var/mobile/Containers/Data/Application/D02582B3-</span><span class="hljs-number">66</span>D3<span class="hljs-number">-4</span>EF1-<span class="hljs-title class_">A6C2</span><span class="hljs-number">-6129</span>D4E1B9CA/<span class="hljs-title class_">Documents</span>/<span class="hljs-title class_">Cbox</span>.decrypted /<span class="hljs-title class_">Users</span>/davidli/<span class="hljs-title class_">Documents</span>/decrypted<br></code></pre></td></tr></table></figure><h3 id="9-反汇编"><a href="#9-反汇编" class="headerlink" title="9.反汇编"></a>9.反汇编</h3><p>接下来就可以对此砸壳后的文件进行静态分析了，如用<code>class-dump</code>导出 App 的头文件、用 <code>Hopper Disassembler</code>查看伪代码。</p><h4 id="9-1-class-dump"><a href="#9-1-class-dump" class="headerlink" title="9.1.class-dump"></a>9.1.class-dump</h4><p>class-dump 是用来 dump 目标对象的 类、分类、协议信息的工具，这一点与<code>otool</code>类似。它利用 OC 语言的 runtime 特性，将存储在 Mach-O 文件中的头文件信息提取出来，并生成对应的.h文件。在<a href="http://stevenygard.com/projects/class-dump/"> 传送门 </a>下载最新安装包，然后把<code>class-dump</code>文件放到<code>/usr/local/bin</code>目录下， 在终端输入<code>class-dump</code>，显示<code>class-dump</code>的版本后，就可以正常使用 class-dump 命令了。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ <span class="hljs-keyword">class</span>-dump<br><span class="hljs-keyword">class</span>-dump 3.5 (64 bit)<br>Usage: <span class="hljs-keyword">class</span>-dump [options] &lt;mach-o-<span class="hljs-keyword">file</span>&gt;<br><br>  where options are:<br>        -a             show instance variable offsets<br>        -A             show implementation addresses<br>        --<span class="hljs-keyword">arch</span> &lt;<span class="hljs-keyword">arch</span>&gt;  choose a specific architecture from a universal binary (ppc, ppc64, i386, x86_64, armv6, armv7, armv7s, arm64)<br>        -C &lt;regex&gt;     only <span class="hljs-keyword">display</span> classes matching regular expression<br>        -f &lt;str&gt;       find string <span class="hljs-keyword">in</span> method name<br>        -<span class="hljs-keyword">H</span>             <span class="hljs-keyword">generate</span> header files <span class="hljs-keyword">in</span> current directory, or directory specified with -o<br>        -I             <span class="hljs-keyword">sort</span> classes, categories, and protocols <span class="hljs-keyword">by</span> inheritance (overrides -s)<br>        -o &lt;<span class="hljs-keyword">dir</span>&gt;       output directory used <span class="hljs-keyword">for</span> -<span class="hljs-keyword">H</span><br>        -r             recursively <span class="hljs-keyword">expand</span> frameworks and fixed VM shared libraries<br>        -s             <span class="hljs-keyword">sort</span> classes and categories <span class="hljs-keyword">by</span> name<br>        -S             <span class="hljs-keyword">sort</span> methods <span class="hljs-keyword">by</span> name<br>        -t             suppress header <span class="hljs-keyword">in</span> output, <span class="hljs-keyword">for</span> testing<br>        --<span class="hljs-keyword">list</span>-arches  <span class="hljs-keyword">list</span> the arches <span class="hljs-keyword">in</span> the <span class="hljs-keyword">file</span>, then <span class="hljs-keyword">exit</span><br>        --sdk-ios      specify iOS SDK <span class="hljs-keyword">version</span> (will look <span class="hljs-keyword">in</span> /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS&lt;<span class="hljs-keyword">version</span>&gt;.sdk<br>        --sdk-<span class="hljs-keyword">mac</span>      specify <span class="hljs-keyword">Mac</span> OS X <span class="hljs-keyword">version</span> (will look <span class="hljs-keyword">in</span> /Developer/SDKs/MacOSX&lt;<span class="hljs-keyword">version</span>&gt;.sdk<br>        --sdk-root     specify the full SDK root path (or <span class="hljs-keyword">use</span> --sdk-ios/--sdk-<span class="hljs-keyword">mac</span> <span class="hljs-keyword">for</span> a shortcut)<br><br></code></pre></td></tr></table></figure><p>使用 class-dump 导出二进制文件中的.h</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span>-<span class="hljs-keyword">dump</span> [--arch armv7] -H -s <span class="hljs-regexp">/目标二进制文件路径 -o /</span>导出目录<br></code></pre></td></tr></table></figure><p>导出的文件列表如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">$ ls<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAAlertItem</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AACloseNotifyReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AACloseNotifyRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AACloseReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AACloseRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AALaunchByMoneyReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AALaunchByMoneyRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AALaunchByPersonReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AALaunchByPersonRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AALaunchItem</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAListRecord</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAOperationReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAOperationRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAPayReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAPayRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAPaySuccReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAPaySuccRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAPayUrgeReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAPayUrgeRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAPayer</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAQueryDetailReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAQueryDetailRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAQueryListReq</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AAQueryListRes</span>.</span></span>h<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AARealNameItem</span>.</span></span>h<br>ABNewPersonViewControllerDelegate-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Protocol</span>.</span></span>h<br>ABPeoplePickerNavigationControllerDelegate-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Protocol</span>.</span></span>h<br>...<br></code></pre></td></tr></table></figure><h4 id="9-2-Hopper"><a href="#9-2-Hopper" class="headerlink" title="9.2.Hopper"></a>9.2.Hopper</h4><p>class-dump 只能查看目标 APP 的头文件，无法查看.m 文件和具体的代码，所以就需要使用到反汇编器。这里介绍的是<code>Hopper Disassembler</code>，它是一款二进制反汇编器，能反编译出二进制文件中的所有函数和实现，包括伪代码以及控制流图(Control Flow Graph)，支持 ARM 指令集并针对 OC 做了优化。官网 <a href="https://www.hopperapp.com/">传送门</a>，下载试用版就够用了。</p><p>将目标二进制文件拖到 <code>Hopper Disassembler</code> 面板中：（如果是第三方市场下载的越狱应用，须将<code>.ipa</code>文件后缀改为<code>.zip</code>，解压后在<code>/Payload</code>目录下找到<code>.app</code>文件，右键 <code>显示包含内容</code> 即可看到目标二进制文件）</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_disassembler1.png" alt="disassembler1"></p><p>选择需要反编译的架构之后点<code>OK</code>，接下来 Hopper 就会自动加载二进制文件的各个<code>segment</code>。加载完成后即可看到如下界面：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_disassembler3.png" alt="disassembler3"></p><p>左边是符号 Label 等区域，中间是 ARM 的汇编代码，右边是相关信息栏。</p><p>在 Label 区搜索栏中输入想要的函数名，双击搜索结果列表中对应的行即可自动跳转到该方法的内存地址处。不过这里显示的都是 ARM 汇编指令，其中还包括了很多<code>r0~r8</code>等寄存器，阅读性不高。所以可以使用上面提到的伪代码功能，快捷键 <code>Option + Enter</code> 或者点击右上角面板中的 <code>if(b)f(x)</code>按钮即可自动弹出伪代码视图，这些就是具体的代码逻辑：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_disassembler5.png" alt="disassembler3"></p><p><strong>ps:</strong> Hopper 除了可以查看汇编代码以外，还可以直接对 Mach-O 文件进行修改，然后重新生成二进制文件，替换原二进制文件后重新打包即可实现某些特殊目的，如去广告、微信自动抢红包、VIP加速等。这些内容及ARM汇编指令待后面继续研究。。</p><hr><p>相关参考：</p><p>#©沙梓社·吴航【iOS应用逆向工程】</p><p>#<a href="http://bbs.iosre.com/">©iosre论坛</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reveal调试界面</title>
    <link href="/2019/04/01/reveal.html"/>
    <url>/2019/04/01/reveal.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="1-1-场景"><a href="#1-1-场景" class="headerlink" title="1.1.场景"></a>1.1.场景</h4><ul><li>场景1</li></ul><p>我们在模拟器或真机上调试自家应用时，一般的过程可能是：</p><p>修改界面元素 → 编译运行 → 效果不满意继续修改 → 编译运行</p><p>当某些效果需要反复调试时，很多时间会浪费在编译运行阶段，尤其是当你的应用比较复杂时。</p><p>解决这个痛点有多种方式，如使用<code>RN</code>、<code>Flutter</code>等框架，它们都支持实时渲染，不过这些都涉及到成本的取舍。</p><ul><li>场景2</li></ul><p>有时我们需要研究某些第三方应用的界面布局，如做竞品分析或者学习优秀应用的设计，可问题在于我们有拿不到这些应用的源码，挠头~</p><p>解决这个痛点时，我所知道的是可以通过<code>砸壳</code>+<code>反编译</code>来获取这些应用的伪代码，修改后重新签名打包看效果。但伪代码可读性差，非所见即所得，也不能实时调试。</p><hr><p>要解决上面两种场景下的界面调试问题，更便捷的<code>Reveal</code>就派上用场了~</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal.png" alt="reveal"></p><h4 id="1-2-描述"><a href="#1-2-描述" class="headerlink" title="1.2.描述"></a>1.2.描述</h4><p>下面是摘自<a href="https://revealapp.com/">官网</a>的描述：</p><blockquote><p>Reveal brings powerful runtime view debugging to iOS developers. With advanced visualisations, comprehensive inspectors and the ability to modify applications on the fly, you’ll be debugging view layout and rendering problems in seconds.</p></blockquote><p><code>Reveal</code>是一款面向iOS开发者的视图调试工具。它具有可视化、综合检视、可修改、实时显示结果的特点。</p><h4 id="1-3-作用"><a href="#1-3-作用" class="headerlink" title="1.3.作用"></a>1.3.作用</h4><ul><li>3D展示应用中的视图及其层级关系；</li><li>支持检视图层layer；</li><li>支持检视手势Gesture Recognizers、修改其行为；</li><li>支持检视自动布局Auto Layout信息；</li></ul><h4 id="1-4-对象"><a href="#1-4-对象" class="headerlink" title="1.4.对象"></a>1.4.对象</h4><ul><li>Xcode编译出的、在模拟器上运行的自家测试版应用；</li><li>真机上运行的第三方或自家的商店版应用；</li></ul><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><p><code>Reveal</code>是一款收费应用，个人版售价$59，商业版$119，企业版另议，有能力的话还是支持一下正版吧。网上有破解版仅供学习使用，这里就不放传送门了。另外你需要一台越狱后的设备以便调试第三方应用。你也可以直接在模拟器上调试，不过只能调试自家应用。不论是调试三方应用还是自家应用，你都需要集成reveal的库文件，只是两者的集成方式稍有不同。</p><h3 id="3-集成"><a href="#3-集成" class="headerlink" title="3.集成"></a>3.集成</h3><h4 id="3-1-自家应用"><a href="#3-1-自家应用" class="headerlink" title="3.1.自家应用"></a>3.1.自家应用</h4><p>要调试自家应用，除了在MAC上安装<code>Reveal</code>外，你还需要在自己的工程中集成reveal库：</p><blockquote><p>We maintain a CocoaPods Podspec for integrating Reveal into your Xcode projects.</p></blockquote><ul><li>修改Podfile：</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">target <span class="hljs-string">&#x27;YourMainAppTargetName&#x27;</span> <span class="hljs-keyword">do</span><br>    pod <span class="hljs-string">&#x27;Reveal-SDK&#x27;</span>, :<span class="hljs-function"><span class="hljs-params">configurations</span> =&gt;</span> [<span class="hljs-string">&#x27;Debug&#x27;</span>]<br>end<br></code></pre></td></tr></table></figure><ul><li>导入RevealServer.framework</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pod <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><ul><li>编译运行，模拟器中应用跑起来之后，Reveal界面中会自动显示该应用。具体的效果如下：</li></ul><p><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal_cocoapods_server.png" alt="reveal_cocoapods_server"></p><ul><li>愉快的调试吧（界面是不是很眼熟？）</li></ul><p><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal_debug_views.png" alt="reveal_debug_views"></p><blockquote><p>WARNING: Never ship a product which has been linked with the Reveal Server framework. The Podfile example below will only link the Reveal Server framework into builds of your app compiled using the “Debug” configuration.</p></blockquote><p>注意！！来自官方的警告：不要将集成了Reveal Server framework的应用提交到商店！！！</p><h4 id="3-2-第三方应用"><a href="#3-2-第三方应用" class="headerlink" title="3.2.第三方应用"></a>3.2.第三方应用</h4><ul><li>MAC上启动Reveal → Help → Show Reveal Library in Finder → iOS-Libraries:</li></ul><p><img src="https://davidlii.nos-eastchina1.126.net/pic_revealLib.png" alt="REVEAL"></p><ul><li>选择RevealServer.framework静态库:</li></ul><p><img src="https://davidlii.nos-eastchina1.126.net/pic_revealserver_framework.png" alt="revealserver_framework"></p><ul><li>终端中通过<code>scp</code>命令，拷贝库到设备的&#x2F;Library&#x2F;Frameworks&#x2F;目录下：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这个IP地址是手机所在WiFi的IP地址<br>scp -r RevealServer.framework root@<span class="hljs-number">192.168</span>.xx.xxx:<span class="hljs-regexp">/Library/</span>Frameworks/ <br></code></pre></td></tr></table></figure><ul><li>重启SpringBoard，以便让导入的 RevealServer 库生效：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//手机/设备所在WiFi的IP地址</span><br>$ ssh root@<span class="hljs-number">192.168</span><span class="hljs-number">.31</span>.xx<br><span class="hljs-comment">// 输入root用户的密码，默认值alphine，修改过的话自行输入</span><br>root@<span class="hljs-number">192.168</span><span class="hljs-number">.31</span>.xx<span class="hljs-number">&#x27;</span>s password:<br><span class="hljs-comment">//重启springboard</span><br>Hes-iPhone:~ root<span class="hljs-meta"># killall SpringBoard</span><br></code></pre></td></tr></table></figure><ul><li><p>越狱手机上，在Cydia商店中搜索并安装Reveal2Loader：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal_tweek_1.PNG" alt="reveal_tweek_1"></p></li><li><p>手机设置中找到reveal：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal_tweek_2.jpeg" alt="reveal_tweek_2"></p></li><li><p>设置需要调试的应用，打开对应的开关即可：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal_tweek_3.PNG" alt="reveal_tweek_3"></p></li><li><p>设备上启动要调试的应用，MAC上的Reveal能自动检测到此待调试的应用：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal_baidu.png" alt="reveal_baidu"></p></li><li><p>点击待调试的应用即可进入调试界面：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_reveal_baidu_debug.png" alt="reveal_baidu_debug"></p></li><li><p>接下来就可以愉快的调试了~</p></li></ul><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h3><p><code>Reveal</code>支持 USB 和 WiFi 两种连接模式，如果在自己的设备上调试第三方应用，你需要确保手机通过数据线连接到MAC上，或者让手机与MAC处于同一WiFi环境中。</p><p>不要将集成了Reveal Server framework的应用提交到商店！！</p><hr><p>相关参考：</p><p>#<a href="https://www.jianshu.com/p/f2970ef365fe">©reveal的三种集成方式</a></p><p>#<a href="https://www.jianshu.com/p/213ddc050ff2">©reveal的集成</a></p><p>#<a href="https://blog.csdn.net/yishengzhiai005/article/details/103456794?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5">©越狱设备调试第三方应用</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>frida一键砸壳</title>
    <link href="/2019/03/31/frida.html"/>
    <url>/2019/03/31/frida.html</url>
    
    <content type="html"><![CDATA[<p>前两天重新给我的 iOS12 设备越狱，然后砸壳和反编译一个应用，结果又是<code>ps</code>命令出错、又是<code>cycript</code>命令出错，到处查资料，折腾了好久。后来发现竟然有<code>一键砸壳</code>的工具<code>frida</code>，这里含泪记录下来整个砸壳的流程~</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_frida.png" alt="纲目"></p><p>frida官网：<a href="https://www.frida.re/docs/home/">https://www.frida.re/docs/home/</a></p><h3 id="1-iOS设备配置"><a href="#1-iOS设备配置" class="headerlink" title="1.iOS设备配置"></a>1.iOS设备配置</h3><h4 id="1-1-越狱"><a href="#1-1-越狱" class="headerlink" title="1.1.越狱"></a>1.1.越狱</h4><p>我的设备是 iOS12.1，所以使用目前最新的越狱工具<code>uncc0ver</code>，版本号<code>v3.0.3~b48</code>，可以到 <a href="https://app.ignition.fun/">这里</a> 下载。下载完成后启动<code>unc0ver</code>，点击<code>jailbreak</code>即可自动完成越狱并安装 Cydia 商店。</p><h4 id="1-2-frida插件"><a href="#1-2-frida插件" class="headerlink" title="1.2.frida插件"></a>1.2.frida插件</h4><p>在 Cydia 中添加”<a href="https://build.frida.re&quot;/">https://build.frida.re&quot;</a> 源并安装<code>frida</code>插件。</p><h3 id="2-Mac配置"><a href="#2-Mac配置" class="headerlink" title="2.Mac配置"></a>2.Mac配置</h3><h4 id="2-1-usbmuxd"><a href="#2-1-usbmuxd" class="headerlink" title="2.1.usbmuxd"></a>2.1.usbmuxd</h4><p>通常情况下，我们调试越狱设备时会用到<code>ssh</code>远程登录设备，它依赖于 TCP 连接。而<code>usbmuxd</code>则用<code>usb</code>(数据线)连接代替了<code>ssh</code>连接，将 iOS 设备端口映射到 Mac 本地端口，使得在没有网络的情况下也可以连接设备。</p><ul><li>安装 usbmuxd；</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ <span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>usbmuxd<br></code></pre></td></tr></table></figure><ul><li><p>设备通过数据线连接到 Mac 上；</p></li><li><p>端口映射；</p></li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>iproxy <span class="hljs-number">2222</span> <span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><p>将设备上<code>22</code>端口号映射到电脑上<code>2222</code>端口。</p><h4 id="2-2-pip"><a href="#2-2-pip" class="headerlink" title="2.2.pip"></a>2.2.pip</h4><p><code>pip</code>是 Python 包管理工具,该工具提供了对 Python 包的查找、下载、安装、卸载的功能。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>sudo easy_install pip<br></code></pre></td></tr></table></figure><h4 id="2-3-frida"><a href="#2-3-frida" class="headerlink" title="2.3.frida"></a>2.3.frida</h4><p>安装和升级<code>frida</code>：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ pip install --<span class="hljs-keyword">user</span> <span class="hljs-title">frida</span><br></code></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ sudo easy_install <span class="hljs-comment">--upgrade frida</span><br></code></pre></td></tr></table></figure><h4 id="2-4-frida-tools"><a href="#2-4-frida-tools" class="headerlink" title="2.4.frida-tools"></a>2.4.frida-tools</h4><p>这是<code>frida</code>的命令行界面(CLI)，后面我们正是使用它自带的一些命令来查看或者调试应用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ pip <span class="hljs-keyword">install</span> frida-tools<br></code></pre></td></tr></table></figure><h4 id="2-5-frida-ios-dump"><a href="#2-5-frida-ios-dump" class="headerlink" title="2.5.frida-ios-dump"></a>2.5.frida-ios-dump</h4><p>在桌面新建文件夹<code>Frida</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> Frida</span><br></code></pre></td></tr></table></figure><p>将<code>frida-ios-dump</code>克隆到刚才的文件夹中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/AloneMonkey/</span>frida-ios-dump Frida/<br></code></pre></td></tr></table></figure><p>安装依赖：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> Frida<br><span class="hljs-variable">$</span> sudo pip install <span class="hljs-literal">-r</span> requirements.txt<br></code></pre></td></tr></table></figure><p>修改<code>dump.py</code>配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">User</span> = <span class="hljs-string">&#x27;root&#x27;</span><br><span class="hljs-attr">Password</span> = ‘alpine’<br><span class="hljs-attr">Host</span> = <span class="hljs-string">&#x27;localhost&#x27;</span><br><span class="hljs-attr">Port</span> = <span class="hljs-number">2222</span><br></code></pre></td></tr></table></figure><p>这里的<code>Password</code>要与越狱后<code>root</code>身份的密码一致，默认为<code>alpine</code>。一般越狱后考虑到 ssh 的安全问题，一般都要修改<code>root</code>和<code>mobile</code>身份的密码，所以这里要根据你自己的设置而修改。</p><h3 id="3-砸壳"><a href="#3-砸壳" class="headerlink" title="3.砸壳"></a>3.砸壳</h3><h4 id="3-1-查看进程"><a href="#3-1-查看进程" class="headerlink" title="3.1.查看进程"></a>3.1.查看进程</h4><p>接下来就可以进入实战阶段了，你可以使用<code>frida</code>指令查看正在运行的或者全部已安装的进程的信息。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># Connect Frida to an iPad over USB and list running processes</span><br><span class="hljs-variable">$ </span>frida-ps -U<br><br><span class="hljs-comment"># List running applications</span><br><span class="hljs-variable">$ </span>frida-ps -Ua<br><br><span class="hljs-comment"># List installed applications</span><br><span class="hljs-variable">$ </span>frida-ps -Uai<br><br><span class="hljs-comment"># Connect Frida to the specific device</span><br><span class="hljs-variable">$ </span>frida-ps -D <span class="hljs-number">0</span>216027d1d6d3a03<br></code></pre></td></tr></table></figure><p>比如我查看当前设备中已经打开的应用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ frida-ps -Ua<br> PID  Name    Identifier<br>----  ------  -------------------------<br><span class="hljs-number">1509</span>  Filza   com<span class="hljs-selector-class">.tigisoftware</span><span class="hljs-selector-class">.Filza</span><br><span class="hljs-number">1250</span>  微信      com<span class="hljs-selector-class">.tencent</span><span class="hljs-selector-class">.xin</span><br><span class="hljs-number">1251</span>  支付宝     com<span class="hljs-selector-class">.alipay</span><span class="hljs-selector-class">.iphoneclient</span><br><span class="hljs-number">1441</span>  斗鱼      tv<span class="hljs-selector-class">.douyu</span><span class="hljs-selector-class">.live</span><br><span class="hljs-number">1525</span>  照片      com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.mobileslideshow</span><br><span class="hljs-number">1246</span>  百度手机卫士  com<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.security</span><br><span class="hljs-number">1501</span>  网易新闻    com<span class="hljs-selector-class">.netease</span><span class="hljs-selector-class">.news</span><br><span class="hljs-number">1249</span>  邮件      com<span class="hljs-selector-class">.apple</span><span class="hljs-selector-class">.mobilemail</span> <br></code></pre></td></tr></table></figure><p>第一列是进程<code>ID</code>，第二列是进程<code>名称</code>，第三列是进程<code>bundle id</code>。</p><h4 id="3-2-开始砸壳"><a href="#3-2-开始砸壳" class="headerlink" title="3.2.开始砸壳"></a>3.2.开始砸壳</h4><p>重点 lei 了~砸壳时我们使用的是刚才克隆而来的<code>frida-ios-dump</code>中的<code>./dump.py</code>这个 Python 脚本文件。使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> Frida</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./dump.py 微信</span><br></code></pre></td></tr></table></figure><p>砸壳时使用<code>名称</code>和<code>bundle id</code>都可以。注意，执行<code>$ ./dump.py xxx</code>时，被砸壳的应用一定要是在<code>运行</code>状态，不能在后台，也不能锁屏。如果此应用没有在运行状态，那么执行完此命令后，该应用会自动运行起来，这时再运行一次上面的命令即可。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Start</span> the target app 微信<br><span class="hljs-attribute">Dumping</span> 微信 to /var/folders/<span class="hljs-number">18</span>/prkfmw9150xbt4s2b47hhff40000gn/T<br><span class="hljs-attribute">start</span> dump /var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/WeChat<br><span class="hljs-attribute">WeChat</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">80</span>.<span class="hljs-number">3</span>M/<span class="hljs-number">80</span>.<span class="hljs-number">3</span>M<span class="hljs-meta"> [00:05&lt;00:00, 16.1MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/zstd.framework/zstd<br><span class="hljs-attribute">zstd</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">682</span>k/<span class="hljs-number">682</span>k<span class="hljs-meta"> [00:00&lt;00:00, 3.99MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/TXLiteAVSDK_Smart_No_VOD.framework/TXLiteAVSDK_Smart_No_VOD<br><span class="hljs-attribute">TXLiteAVSDK_Smart_No_VOD</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">5</span>.<span class="hljs-number">21</span>M/<span class="hljs-number">5</span>.<span class="hljs-number">21</span>M<span class="hljs-meta"> [00:00&lt;00:00, 11.3MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/matrixreport.framework/matrixreport<br><span class="hljs-attribute">matrixreport</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">460</span>k/<span class="hljs-number">460</span>k<span class="hljs-meta"> [00:00&lt;00:00, 3.90MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/YTFaceProSDK.framework/YTFaceProSDK<br><span class="hljs-attribute">YTFaceProSDK</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">13</span>.<span class="hljs-number">1</span>M/<span class="hljs-number">13</span>.<span class="hljs-number">1</span>M<span class="hljs-meta"> [00:01&lt;00:00, 13.7MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/GPUImage.framework/GPUImage<br><span class="hljs-attribute">GPUImage</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">1</span>.<span class="hljs-number">21</span>M/<span class="hljs-number">1</span>.<span class="hljs-number">21</span>M<span class="hljs-meta"> [00:00&lt;00:00, 7.08MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/WCDB.framework/WCDB<br><span class="hljs-attribute">WCDB</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">4</span>.<span class="hljs-number">25</span>M/<span class="hljs-number">4</span>.<span class="hljs-number">25</span>M<span class="hljs-meta"> [00:00&lt;00:00, 11.5MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/MMCommon.framework/MMCommon<br><span class="hljs-attribute">MMCommon</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">1</span>.<span class="hljs-number">18</span>M/<span class="hljs-number">1</span>.<span class="hljs-number">18</span>M<span class="hljs-meta"> [00:00&lt;00:00, 5.37MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/MultiMedia.framework/MultiMedia<br><span class="hljs-attribute">MultiMedia</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">7</span>.<span class="hljs-number">66</span>M/<span class="hljs-number">7</span>.<span class="hljs-number">66</span>M<span class="hljs-meta"> [00:00&lt;00:00, 12.3MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/QBar.framework/QBar<br><span class="hljs-attribute">QBar</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">2</span>.<span class="hljs-number">62</span>M/<span class="hljs-number">2</span>.<span class="hljs-number">62</span>M<span class="hljs-meta"> [00:00&lt;00:00, 10.0MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/QMapKit.framework/QMapKit<br><span class="hljs-attribute">QMapKit</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">3</span>.<span class="hljs-number">79</span>M/<span class="hljs-number">3</span>.<span class="hljs-number">79</span>M<span class="hljs-meta"> [00:00&lt;00:00, 10.3MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/ConfSDK.framework/ConfSDK<br><span class="hljs-attribute">ConfSDK</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">4</span>.<span class="hljs-number">01</span>M/<span class="hljs-number">4</span>.<span class="hljs-number">01</span>M<span class="hljs-meta"> [00:00&lt;00:00, 10.8MB/s]</span><br><span class="hljs-attribute">start</span> dump /private/var/containers/Bundle/Application/F441A6E7-<span class="hljs-number">863</span>E-<span class="hljs-number">4</span>A1C-AAEB-ECD4F9555208/WeChat.app/Frameworks/mars.framework/mars<br><span class="hljs-attribute">mars</span>.fid: <span class="hljs-number">100</span>%|██████████| <span class="hljs-number">8</span>.<span class="hljs-number">79</span>M/<span class="hljs-number">8</span>.<span class="hljs-number">79</span>M<span class="hljs-meta"> [00:00&lt;00:00, 13.4MB/s]</span><br><span class="hljs-attribute">Expression_46</span>@<span class="hljs-number">2</span>x.png: <span class="hljs-number">211</span>MB<span class="hljs-meta"> [00:31, 6.96MB/s]</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">00</span>B<span class="hljs-meta"> [00:00, ?B/s]Generating &quot;微信.ipa&quot;</span><br></code></pre></td></tr></table></figure><p>脚本会自动在当前目录中生成 dump 之后的<code>微信.ipa</code>文件，这就是我们想要的砸壳后的文件了~~</p><h3 id="4-Hopper反编译"><a href="#4-Hopper反编译" class="headerlink" title="4.Hopper反编译"></a>4.Hopper反编译</h3><p>拿到砸壳后的<code>ipa</code>之后，使用解压缩软件将其解压后会得到一个<code>Payload</code>文件夹，里面就是 ipa 对应的二进制文件。打开<code>Hopper disassembler</code>，将二进制文件拖到其窗口中，自动开始反编译过程~</p><h3 id="5-CrackerXI"><a href="#5-CrackerXI" class="headerlink" title="5.CrackerXI"></a>5.CrackerXI</h3><p><strong>更新：</strong>偶然发现了一个叫<code>CrackerXI</code>的插件。其主要作用有：</p><ul><li>应用砸壳；</li><li>去掉各种软件的证书；</li></ul><p>看到<code>砸壳</code>字眼，是不是眼前一亮，没错它也可以用来一键砸壳，而且从操作上来讲比<code>frida</code>更加便捷。</p><ul><li>在 cydiakk 中文源中搜索并安装这个插件；</li><li>回到桌面打开这个应用，进入设置中打开 crackerXI Hook 开关；</li><li>回到 Applist 界面点击目标应用，自动启动并跳转到目标应用；</li><li>目标应用启动后会弹出是否砸壳的选项框，选择 YES 即可跳回工具开始砸壳；</li><li>最终砸壳后的 ipa 文件被保存在&#x2F;var&#x2F;mobile&#x2F;Documents&#x2F;CrackerXI目录中；</li><li>使用 Mac 上的 iTools等助手将文件导出，解压后即可开始反编译。</li></ul><p>根据我的测试，被砸壳的应用一定要在非启动状态，就是说一定要由<code>CrackerXI</code>来启动目标应用，所以我猜它的原理应该也是在应用二进制文件启动加载阶段，注入自己的动态库并开始砸壳。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_crackerXI.PNG" alt="crackerXI"></p><p>懒人改变世界~~</p><hr><p>相关参考：</p><p>#<a href="https://www.frida.re/docs/installation/">©frida官网</a></p><p>#<a href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump/">©AloneMonkey - 一条命令完成砸壳</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS12越狱填坑</title>
    <link href="/2019/03/28/jailbreak.html"/>
    <url>/2019/03/28/jailbreak.html</url>
    
    <content type="html"><![CDATA[<p>最近看到有新版的iOS12越狱工具发布，一时手痒，于是将手里的设备进行了越狱。这中间又出了各种问题，在这里记录下来，顺便给后面踩坑的同学做个参考~</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_jailbreak_ios12.png" alt="纲目"></p><h3 id="1-越狱工具"><a href="#1-越狱工具" class="headerlink" title="1.越狱工具"></a>1.越狱工具</h3><p><code>unc0ver</code>jailbreak for iOS 11.0-12.1.2，版本号为 v3.0.0~b48，手机 Safari 中打开 <a href="https://app.ignition.fun/">这里</a>，在第二个 Tab 的<code>jailbreaks</code>选项中找到<code>unc0ver-new beta</code>，下载完成后进入<code>unc0ver</code>，点 jailberak 即可自动越狱。</p><p>越狱完成后会自动安装 Cydia~</p><h3 id="2-Cydia联网失败"><a href="#2-Cydia联网失败" class="headerlink" title="2.Cydia联网失败"></a>2.Cydia联网失败</h3><h4 id="2-1-乐网"><a href="#2-1-乐网" class="headerlink" title="2.1.乐网"></a>2.1.乐网</h4><p>下载爱思手机助手，搜索并安装<code>乐网</code>，启动后打开开关，再进入 Cydia 即可。</p><h4 id="2-2-插件"><a href="#2-2-插件" class="headerlink" title="2.2.插件"></a>2.2.插件</h4><p>你也可以在 Cydia 中添加<code>贴吧源</code> <a href="http://apt.cydiaba.cn/">http://apt.cydiaba.cn</a> ，搜索并安装<code>联网修正</code>插件即可。</p><h3 id="3-搜不到OpenSSH"><a href="#3-搜不到OpenSSH" class="headerlink" title="3.搜不到OpenSSH"></a>3.搜不到OpenSSH</h3><h4 id="添加新的源"><a href="#添加新的源" class="headerlink" title="添加新的源"></a>添加新的源</h4><ul><li><p>蚂蚁源：<a href="http://apt.cydia.love/">http://apt.cydia.love</a></p></li><li><p>Cydia贴吧源：<a href="http://apt.cydiaba.cn/">http://apt.cydiaba.cn</a></p></li><li><p>saurik源：<a href="http://apt.saurik.com/cydia">http://apt.saurik.com/cydia</a></p></li><li><p>雷锋源：<a href="http://apt.abcydia.com/">http://apt.abcydia.com</a></p></li></ul><h3 id="4-修改密码"><a href="#4-修改密码" class="headerlink" title="4.修改密码"></a>4.修改密码</h3><p>iOS设备上有<code>root</code>和<code>mobile</code>两个用户，在安装完 SSH 后记得修改默认的登录密码“alpine”，防止病毒通过 ssh 以 root 用户身份登录设备。</p><p>ssh登录设备</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ ssh <span class="hljs-symbol">root@</span><span class="hljs-number">192.168</span><span class="hljs-number">.31</span>.xx <span class="hljs-comment">//设备所在WiFi的IP地址</span><br></code></pre></td></tr></table></figure><ul><li>修改 root 密码：</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">~ root<span class="hljs-meta"># passwd</span><br>changing password <span class="hljs-keyword">for</span> root.<br>New password:<span class="hljs-type"></span><br>Retype <span class="hljs-keyword">new</span> <span class="hljs-type">password</span>:<br>~ root<span class="hljs-meta"># </span><br></code></pre></td></tr></table></figure><ul><li>修改 mobile 密码：</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">~ root<span class="hljs-meta"># passwd mobile</span><br>changing password <span class="hljs-keyword">for</span> mobile.<br>New password:<span class="hljs-type"></span><br>Retype <span class="hljs-keyword">new</span> <span class="hljs-type">password</span>:<br>~ root<span class="hljs-meta"># </span><br></code></pre></td></tr></table></figure><p>你也可以在 Cydia 中下载<code>Mterminal</code>命令行工具，按照上面的操作修改密码。</p><h3 id="5-重启后越狱状态恢复"><a href="#5-重启后越狱状态恢复" class="headerlink" title="5.重启后越狱状态恢复"></a>5.重启后越狱状态恢复</h3><p>打开<code>unc0ver-settings-Restore RootFS</code>选项清除越狱信息，重新越狱。</p><h3 id="6-重新越狱后ssh登录失败"><a href="#6-重新越狱后ssh登录失败" class="headerlink" title="6.重新越狱后ssh登录失败"></a>6.重新越狱后ssh登录失败</h3><p>失败信息如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@</span><br><span class="hljs-comment">@</span>    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     <span class="hljs-comment">@</span><br><span class="hljs-comment">@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><span class="hljs-comment">@@</span><br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right <span class="hljs-built_in">now</span> (man-in-the-middle attack)!<br>It is also possible that a host <span class="hljs-built_in">key</span> has just been changed.<br>The fingerprint <span class="hljs-keyword">for</span> the RSA key sent by the remote host is<br>SHA256:eiVsYjmcqRFD46WOMhcQPxRJSgPDbndRDq2/+3Zxaw4.<br>Please contact your system administrator.<br>Add correct host key in /Users/Macmafia/.ssh/known_hosts to get rid of this message.<br>Offending RSA key in /Users/Macmafia/.ssh/known_hosts:8<br>RSA host key <span class="hljs-keyword">for</span> 192.168.31.xx has changed and you have requested strict checking.<br>Host key verification failed.<br></code></pre></td></tr></table></figure><p>Mac中进入~&#x2F;.ssh目录，打开<code>known_hosts</code>文件并将 wifi 的 ip 地址及其对应的公钥字符串删除，重新 ssh 登录即可。</p><h3 id="7-cycript安装失败"><a href="#7-cycript安装失败" class="headerlink" title="7.cycript安装失败"></a>7.cycript安装失败</h3><ul><li>cycript插件</li></ul><p>Cydia 中默认已安装<code>cycript</code>，添加大佬源：apt.saurik.com&#x2F;cydia，更新<code>cycript</code>插件。</p><ul><li>apt安装</li></ul><p>ssh登录后，$ apt-get install cycrypt</p><ul><li>官网</li></ul><p>1、到官网下载<code>cycript_0.9.501_iphoneos-arm.deb</code>和<code>libffi_1:3.0.10-5_iphoneos-arm.deb</code>包；</p><p>2、sftp命令传送文件到设备中：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ sftp root@wifi ip地址<br>sftp&gt; <span class="hljs-keyword">put</span> cycript_0.<span class="hljs-number">9.501</span>_iphoneos-arm.<span class="hljs-keyword">deb</span><br>sftp&gt; <span class="hljs-keyword">put</span> libffi_1:<span class="hljs-number">3.0</span>.<span class="hljs-number">10</span>-<span class="hljs-number">5</span>_iphoneos-arm.<span class="hljs-keyword">deb</span><br></code></pre></td></tr></table></figure><p>3、dpkg安装</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>ssh root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">101</span><br>~ root<span class="hljs-comment"># dpkg -i cycript_0.9.501_iphoneos-arm.deb</span><br></code></pre></td></tr></table></figure><h3 id="8-“ps-e”命令报错"><a href="#8-“ps-e”命令报错" class="headerlink" title="8.“ps-e”命令报错"></a>8.“ps-e”命令报错</h3><p>报错信息：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">-<span class="hljs-keyword">sh</span>: /usr/bin/<span class="hljs-keyword">ps</span>: Bad CPU <span class="hljs-built_in">type</span> in <span class="hljs-built_in">executable</span><br></code></pre></td></tr></table></figure><p>方案：Cydia 中将<code>adv-cmds</code>插件降级到”119-6”；</p><h3 id="9-“cycript-p”命令出错"><a href="#9-“cycript-p”命令出错" class="headerlink" title="9.“cycript -p”命令出错"></a>9.“cycript -p”命令出错</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">iPhone:~ root# cycript -p NewsBoard<br><span class="hljs-literal">[<span class="hljs-number">3345</span>]</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DarwinInjector</span>.</span></span>cpp<span class="hljs-literal">[<span class="hljs-number">246</span>]</span>: <span class="hljs-constructor">_krncall(<span class="hljs-params">mach_vm_read_overwrite</span>)</span> =<span class="hljs-number">10000003</span><br>*** <span class="hljs-constructor">_assert(<span class="hljs-params">status</span> <span class="hljs-operator">==</span> 0)</span>:../<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Inject</span>.</span></span>cpp(<span class="hljs-number">143</span>):InjectLibrary<br></code></pre></td></tr></table></figure><p>这会导致接下来无法查询到进程的<code>Document</code>目录，进而无法导入砸壳动态库。<a href="http://bbs.iosre.com/">论坛</a>里的方案都试过了，暂时解决不了。这里我们可以换个不那么酷的方式，在 Cydia 安装的<code>Filza</code>插件，找到“&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;”目录，这里会显示应用的名字。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_filza.PNG" alt="filza"></p><p>选择目标进程，点击进入对应的<code>Documents</code>目录即可~</p><hr><p>相关参考：</p><p>#<a href="https://www.cnblogs.com/mengfanrong/p/5096590.html">©ssh远程登录报错</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本混淆代码</title>
    <link href="/2019/03/25/confusion.html"/>
    <url>/2019/03/25/confusion.html</url>
    
    <content type="html"><![CDATA[<h3 id="1、逆向-amp-破解："><a href="#1、逆向-amp-破解：" class="headerlink" title="1、逆向&amp;破解："></a>1、逆向&amp;破解：</h3><ul><li>通过 dumpdecrypted 给 APP 砸壳；</li><li>通过 class-dump 查看 .h文件里的函数；</li><li>通过 Hopper、IDA Pro 等工具反编译后分析业务代码；</li><li>通过 Reveal 在运行时调试和修改 iOS应用的 UI；</li></ul><h3 id="2、混淆代码"><a href="#2、混淆代码" class="headerlink" title="2、混淆代码"></a>2、混淆代码</h3><p>类名、方法名、变量名等会暴露APP的很多关键信息，攻击者通过 class-dump 得到头文件后，可以根据提取到的这些字符串，快速找到相关逻辑的处理函数，从而进行分析破解。所以，代码混淆很有必要性。混淆的主旨思想是：</p><ul><li>在开发阶段保留清晰可读的代码；</li><li>在编译打包后的代码中，把一些敏感字符串变为为无意义的符号；</li><li>增加攻击者阅读代码的难度以及根据字符串静态搜索的难度；</li></ul><p>当然，手动替换工程中所有的类名、方法名、变量名，这肯定会是很大的一个工作量。所以，我们可以智能一点，使用脚本来帮我们做。通过脚本，扫描工程目录下所有.h &amp; .m 文件，并对其中的敏感内容做替换。另外，可以配合 #define 别名的方式，增加破译难度。</p><h3 id="3、混淆的实现："><a href="#3、混淆的实现：" class="headerlink" title="3、混淆的实现："></a>3、混淆的实现：</h3><h4 id="3-1-在工程的根目录下，新建两个文件："><a href="#3-1-在工程的根目录下，新建两个文件：" class="headerlink" title="3.1.在工程的根目录下，新建两个文件："></a>3.1.在工程的根目录下，新建两个文件：</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cd Desktop/CodeMix  <span class="hljs-comment">//工程根目录</span><br>touch <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Confusion</span>.</span></span>sh  <span class="hljs-comment">//脚本</span><br>touch <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToBeConfused</span>.</span></span><span class="hljs-built_in">list</span> <span class="hljs-comment">//存放所有需要替换的敏感字</span><br></code></pre></td></tr></table></figure><p><strong>Confusion.sh</strong>，一个 shell 脚本文件，用来自动寻找工程目录下.h与.m文件中的所有敏感字，将它们替换为无意义的字符并定义成宏。</p><p><strong>ToBeConfused.list</strong>， 用来保存所有需要替换的敏感字，其后缀格式无所谓，比如.text也可以。shell 脚本会从此文件中逐行取字符并把它替换为无意义的字符。</p><h4 id="3-2-MapOfConfusion-h"><a href="#3-2-MapOfConfusion-h" class="headerlink" title="3.2.MapOfConfusion.h"></a>3.2.MapOfConfusion.h</h4><p>在工程根目录下，新建 MapOfConfusion.h 文件。此文件与上面两个文件在同一目录下。作用是在混淆代码时，把自动生成的字符串定义成宏，存放在此文件中。</p><h4 id="3-3-设置脚本"><a href="#3-3-设置脚本" class="headerlink" title="3.3.设置脚本"></a>3.3.设置脚本</h4><p>编辑 Confusion.sh 文件，输入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env bash</span><br><br>TABLENAME=symbols<br><br>SYMBOL_DB_FILE=<span class="hljs-string">&quot;symbols&quot;</span><br><br><span class="hljs-comment">#ToBeConfused.list 路径</span><br>STRING_SYMBOL_FILE=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_DIR</span>/ToBeConfused.list&quot;</span><br><br><span class="hljs-comment">#项目文件路径</span><br>CONFUSE_FILE=<span class="hljs-string">&quot;<span class="hljs-variable">$SRCROOT</span>&quot;</span><br><br><span class="hljs-comment">#MapOfConfusion.h 路径</span><br>HEAD_FILE=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_DIR</span>/MapOfConfusion.h&quot;</span><br><br><span class="hljs-built_in">export</span> LC_CTYPE=C<br><br><span class="hljs-comment">#取以.m或.h结尾的文件以+号或-号开头的行</span><br><span class="hljs-comment">#|去掉所有+号或－号|用空格代替符号|n个空格跟着&lt;号 替换成 &lt;号</span><br><span class="hljs-comment">#|开头不能是IBAction|用空格split字串取第二部分|排序|去重复|删除空行</span><br><span class="hljs-comment">#|删掉以init开头的行&gt;写进ToBeConfused.list</span><br><br>grep -h -r -I  <span class="hljs-string">&quot;^[-+]&quot;</span> <span class="hljs-variable">$CONFUSE_FILE</span>  --include <span class="hljs-string">&#x27;*.[mh]&#x27;</span> |sed <span class="hljs-string">&quot;s/[+-]//g&quot;</span>|sed <span class="hljs-string">&quot;s/[();,: *^/&#123;]/ /g&quot;</span>|sed <span class="hljs-string">&quot;s/[ ]*&lt;/&lt;/&quot;</span>| sed <span class="hljs-string">&quot;/^[ ]*IBAction/d&quot;</span>|awk <span class="hljs-string">&#x27;&#123;split($0,b,&quot; &quot;); print b[2]; &#125;&#x27;</span>| <span class="hljs-built_in">sort</span>|<span class="hljs-built_in">uniq</span> |sed <span class="hljs-string">&quot;/^$/d&quot;</span>|sed -n <span class="hljs-string">&quot;/^xMix_/p&quot;</span> &gt;<span class="hljs-variable">$STRING_SYMBOL_FILE</span><br><br><br><span class="hljs-comment">#维护数据库方便日后作排重,以下代码来自念茜的博客</span><br><span class="hljs-function"><span class="hljs-title">createTable</span></span>()<br>&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;create table <span class="hljs-variable">$TABLENAME</span>(src text, des text);&quot;</span> | sqlite3 <span class="hljs-variable">$SYMBOL_DB_FILE</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">insertValue</span></span>()<br>&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;insert into <span class="hljs-variable">$TABLENAME</span> values(&#x27;<span class="hljs-variable">$1</span>&#x27; ,&#x27;<span class="hljs-variable">$2</span>&#x27;);&quot;</span> | sqlite3 <span class="hljs-variable">$SYMBOL_DB_FILE</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">query</span></span>()<br>&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;select * from <span class="hljs-variable">$TABLENAME</span> where src=&#x27;<span class="hljs-variable">$1</span>&#x27;;&quot;</span> | sqlite3 <span class="hljs-variable">$SYMBOL_DB_FILE</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">ramdomString</span></span>()<br>&#123;<br>openssl rand -<span class="hljs-built_in">base64</span> 64 | <span class="hljs-built_in">tr</span> -<span class="hljs-built_in">cd</span> <span class="hljs-string">&#x27;a-zA-Z&#x27;</span> |<span class="hljs-built_in">head</span> -c 16<br><br>&#125;<br><br><span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$SYMBOL_DB_FILE</span><br><span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$HEAD_FILE</span><br>createTable<br><br><span class="hljs-built_in">touch</span> <span class="hljs-variable">$HEAD_FILE</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;#ifndef MapOfConfusion_h</span><br><span class="hljs-string">#define MapOfConfusion_h&#x27;</span> &gt;&gt; <span class="hljs-variable">$HEAD_FILE</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;//confuse string at `date`&quot;</span> &gt;&gt; <span class="hljs-variable">$HEAD_FILE</span><br><span class="hljs-built_in">cat</span> <span class="hljs-string">&quot;<span class="hljs-variable">$STRING_SYMBOL_FILE</span>&quot;</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> -ra line; <span class="hljs-keyword">do</span><br><span class="hljs-keyword">if</span> [[ ! -z <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> ]]; <span class="hljs-keyword">then</span><br>ramdom=`ramdomString`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span> <span class="hljs-variable">$ramdom</span><br>insertValue <span class="hljs-variable">$line</span> <span class="hljs-variable">$ramdom</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#define <span class="hljs-variable">$line</span> <span class="hljs-variable">$ramdom</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$HEAD_FILE</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;#endif&quot;</span> &gt;&gt; <span class="hljs-variable">$HEAD_FILE</span><br><br>sqlite3 <span class="hljs-variable">$SYMBOL_DB_FILE</span> .dump<br></code></pre></td></tr></table></figure><p>上面的脚本会从工程根目录（$SRCROOT）下的所有.m和.h文件中，自动找出以“xMix_”开头的待混淆函数名，写入 ToBeConfused.list 文件中。然后再从 ToBeConfused.list 中逐行提取函数名进行宏定义，宏定义使用随机字符串。然后写到 MapOfConfusion.h 文件中。</p><p>编辑完成后保存，然后执行下面命令，把 Confusion.sh 设置成可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x Confusion.sh<br></code></pre></td></tr></table></figure><h4 id="3-4-添加-Run-Script"><a href="#3-4-添加-Run-Script" class="headerlink" title="3.4.添加 Run Script"></a>3.4.添加 Run Script</h4><p>工程 Targets-》build phases-》New Run script Phase，设置.sh文件路径：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$PROJECT</span>_DIR/Confusion.sh</span><br></code></pre></td></tr></table></figure><h4 id="3-5-添加-PCH-文件"><a href="#3-5-添加-PCH-文件" class="headerlink" title="3.5.添加 PCH 文件"></a>3.5.添加 PCH 文件</h4><p>工程根目录下，新建 PrefixHeader.pch 文件，并导入 MapOfConfusion.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PrefixHeader_pch</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PrefixHeader_pch</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;MapOfConfusion.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* PrefixHeader_pch */</span></span><br></code></pre></td></tr></table></figure><p>工程 Targets-》build Settings 中搜索Prefix Header，设置好 pch 路径：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$PROJECT</span>_DIR/PrefixHeader.pch</span><br></code></pre></td></tr></table></figure><h4 id="3-6-添加以xMix-开头的测试代码："><a href="#3-6-添加以xMix-开头的测试代码：" class="headerlink" title="3.6.添加以xMix_开头的测试代码："></a>3.6.添加以xMix_开头的测试代码：</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> : <span class="hljs-title">UIViewController</span></span><br><br>- (<span class="hljs-type">void</span>)xMix_Function1;<br>- (<span class="hljs-type">void</span>)xMix_Function2WithName:(<span class="hljs-built_in">NSString</span> *)param1 xMix_Gender:(<span class="hljs-type">int</span>)param2;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="3-7-build-amp-class-dump"><a href="#3-7-build-amp-class-dump" class="headerlink" title="3.7.build &amp; class-dump"></a>3.7.build &amp; class-dump</h4><p>build 之后，打开 MapOfConfusion.h 文件，可以看到以xMix_开头的方法名都已被宏定义为一个随机字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MapOfConfusion_h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MapOfConfusion</span><br><span class="hljs-comment">//confuse string at Fri Dec 29 21:15:24 CST 2017</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xMix_Function1 vKfXvdhupKXlBptl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xMix_Function2WithName xRDhGWmotGCNvgqp</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><p>打包之后，得到 ipa 文件，使用 class-dump 工具反编译出 ViewController.h 文件即可查看混淆之后的代码。（略）</p><hr><p>相关参考：</p><p>#<a href="http://blog.csdn.net/yiyaaixuexi/article/details/29201699">©念茜</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本打包与上传</title>
    <link href="/2019/03/23/shell-ipa.html"/>
    <url>/2019/03/23/shell-ipa.html</url>
    
    <content type="html"><![CDATA[<h3 id="打包流程："><a href="#打包流程：" class="headerlink" title="打包流程："></a>打包流程：</h3><ol><li>编译.xcarchive包；</li><li>生成.ipa文件；</li><li>上传到苹果商店或第三方平台。</li></ol><h3 id="自动化："><a href="#自动化：" class="headerlink" title="自动化："></a>自动化：</h3><p>这里所说的自动化，主要是通过shell脚本，利用 Command Line Tools 提供的 <code>xcodebuild</code> 命令来编译和导出 ipa，再通过 Application Loader 提供的 <code>altool</code> 命令行工具，或者其他三方平台提供的命令行工具上传 ipa 和 dSYM 文件。</p><h4 id="清理构建目录"><a href="#清理构建目录" class="headerlink" title="清理构建目录"></a>清理构建目录</h4><p>编译前先clean，相当于在 Xcode 进行 Product -&gt; clean。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">xcodebuild</span> \<br>clean -configuration <span class="hljs-variable">$&#123;development_mode&#125;</span><br></code></pre></td></tr></table></figure><p><code>-configuration</code> 用来表示打包的方式，相当于打包前配置 Edit scheme -&gt; info -&gt; Build configuration，告诉编译器打出来的包是何种包，比如 Release、InHouse等。</p><h4 id="编译xcarchive包"><a href="#编译xcarchive包" class="headerlink" title="编译xcarchive包"></a>编译xcarchive包</h4><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nsis">xcodebuild <span class="hljs-params">archive</span> \<br>-workspace <span class="hljs-variable">$&#123;project_path&#125;</span>/<span class="hljs-variable">$&#123;project_name&#125;</span>.xcworkspace \<br>-scheme <span class="hljs-variable">$&#123;scheme_name&#125;</span> \<br>-configuration <span class="hljs-variable">$&#123;development_mode&#125;</span> \<br>-<span class="hljs-params">archive</span>Path <span class="hljs-variable">$&#123;build_path&#125;</span>/<span class="hljs-variable">$&#123;project_name&#125;</span>.xc<span class="hljs-params">archive</span><br></code></pre></td></tr></table></figure><p><code>-workspace</code>表示工作空间，一个项目中有多个<code>project</code>时，比如通过 pod 集成了三方库后都会自动创建一个新的工作空间。如果没有，可以不加这个参数。<code>-archivePath</code>，用来配置生成的.xcarchive的路径。</p><h4 id="导出ipa文件"><a href="#导出ipa文件" class="headerlink" title="导出ipa文件"></a>导出ipa文件</h4><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis">xcodebuild -export<span class="hljs-params">Archive</span> -<span class="hljs-params">archive</span>Path <span class="hljs-variable">$&#123;build_path&#125;</span>/<span class="hljs-variable">$&#123;project_name&#125;</span>.xc<span class="hljs-params">archive</span> \<br>-configuration <span class="hljs-variable">$&#123;development_mode&#125;</span> \<br>-exportPath <span class="hljs-variable">$&#123;exportIpaPath&#125;</span> \<br>-exportOptionsPlist <span class="hljs-variable">$&#123;exportOptionsPlistPath&#125;</span><br></code></pre></td></tr></table></figure><p><code>-exportPath</code>表示 ipa 文件的输出路径；</p><p><code>-exportOptionsPlist</code>表示 ExportOptions.plist 配置文件的路径。此 plist 是打包时必须的文件，在手动打包并 export 出 ipa 包时，可以在 ipa 包的同级目录下找到，可以拿过来用，或者通过 Xcode 手动创建一份。如果有多个渠道包，也可以通过脚本生成对应的 plist。</p><p>#示例：ExportOptions.plist</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">plist</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="hljs-string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plist</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>teamID<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>略略略<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>method<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>enterprise<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>uploadSymbols<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">true</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plist</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：Xcode9 之后，ExportOptions.plist 需要指定的信息有变，具体可以参考 <a href="https://blog.csdn.net/andanlan/article/details/78113330?locationNum=9&fps=1">这里</a>~</p><p><strong>#完整示例</strong></p><p>下面是完整的 shell 脚本，实现了编译.xcarchive、导出 ipa 与 dSYM，命名为<code>autobuild.sh</code>，放在工程根目录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br><span class="hljs-comment">#works for  Xcode 7.0+ only</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start at <span class="hljs-subst">$(date)</span> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span><br><br>PROJECT_ROOT_PATH=<span class="hljs-variable">$PWD</span><br>AUTOBUILD_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/AutoBuild&quot;</span><br><br>CURRENT_DATE=$(<span class="hljs-built_in">date</span> +%Y_%m%d_%H%M)<br>WORKSPACE_NAME=<span class="hljs-string">&quot;Demo.xcworkspace&quot;</span><br><br><span class="hljs-comment">#导出配置</span><br>HEADER_PLIST=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/Header.plist&quot;</span><br>EXPORT_PLIST=<span class="hljs-string">&quot;<span class="hljs-variable">$AUTOBUILD_PATH</span>/ExportOptions.plist&quot;</span><br><br><span class="hljs-comment">#Info key</span><br>KEY_SCHEME=<span class="hljs-string">&quot;KEY_SCHEME&quot;</span><br>KEY_APP_NAME=<span class="hljs-string">&quot;KEY_APP_NAME&quot;</span><br>KEY_TEAM_ID=<span class="hljs-string">&quot;KEY_TEAM_ID&quot;</span><br>KEY_DEV_ID=<span class="hljs-string">&quot;KEY_DEV_ID&quot;</span><br><br><span class="hljs-comment">#Flavors</span><br>DemoInHouse=&#123;<span class="hljs-variable">$KEY_SCHEME</span>:<span class="hljs-string">&quot;DemoInHouse&quot;</span>,<span class="hljs-variable">$KEY_APP_NAME</span>:<span class="hljs-string">&quot;InHouse&quot;</span>,<span class="hljs-variable">$KEY_TEAM_ID</span>:<span class="hljs-string">&quot;xxxxxxxxxx&quot;</span>,<span class="hljs-variable">$KEY_DEV_ID</span>:<span class="hljs-string">&quot;xxx&quot;</span>&#125;<br>DemoRelease=&#123;<span class="hljs-variable">$KEY_SCHEME</span>:<span class="hljs-string">&quot;DemoRelease&quot;</span>,<span class="hljs-variable">$KEY_APP_NAME</span>:<span class="hljs-string">&quot;Release&quot;</span>,<span class="hljs-variable">$KEY_TEAM_ID</span>:<span class="hljs-string">&quot;xxxxxxxxxx&quot;</span>,<span class="hljs-variable">$KEY_DEV_ID</span>:<span class="hljs-string">&quot;xxx&quot;</span>&#125;<br><br>FLAVORS=(<span class="hljs-variable">$DemoInHouse</span>)<br><br><span class="hljs-comment">#Parse method</span><br><span class="hljs-function"><span class="hljs-title">parse_json</span></span>()&#123;<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span> | sed <span class="hljs-string">&#x27;s/.*&#x27;</span><span class="hljs-variable">$2</span><span class="hljs-string">&#x27;:\([^,&#125;]*\).*/\1/&#x27;</span><br>&#125;<br><br><span class="hljs-comment">#build release apps directory</span><br>BUILD_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/Build&quot;</span><br>RELEASE_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$BUILD_DIR</span>/Products&quot;</span><br><br><span class="hljs-built_in">rm</span> -rdf <span class="hljs-variable">$BUILD_DIR</span><br><br><span class="hljs-comment">#final binarys&#x27; directory</span><br>OUT_BINARY_DIR=<span class="hljs-string">&quot;<span class="hljs-variable">$PROJECT_ROOT_PATH</span>/binarys_<span class="hljs-variable">$CURRENT_DATE</span>&quot;</span><br><br><span class="hljs-keyword">if</span> [ ! -d <span class="hljs-variable">$OUT_BINARY_DIR</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$OUT_BINARY_DIR</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">for</span> ((i = 0; i &lt; <span class="hljs-variable">$&#123;#FLAVORS[@]&#125;</span>; i++))<br><span class="hljs-keyword">do</span><br><span class="hljs-comment">#parse elements</span><br>TARGET_SCHEMES=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_SCHEME</span>)<br>TARGET_APP_NAMES=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_APP_NAME</span>)<br>TARGET_TEAM_IDS=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_TEAM_ID</span>)<br>TARGET_DEV_IDS=$(parse_json <span class="hljs-variable">$&#123;FLAVORS[$i]&#125;</span> <span class="hljs-variable">$KEY_DEV_ID</span>)<br><br><span class="hljs-comment">#reset export options plist</span><br><span class="hljs-built_in">rm</span> <span class="hljs-variable">$EXPORT_PLIST</span><br><br><span class="hljs-built_in">cat</span> <span class="hljs-variable">$HEADER_PLIST</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;plist version=\&quot;1.0\&quot;&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;dict&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;key&gt;teamID&lt;/key&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;string&gt;<span class="hljs-variable">$TARGET_TEAM_IDS</span>&lt;/string&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;key&gt;method&lt;/key&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; target scheme <span class="hljs-variable">$TARGET_SCHEMES</span>&quot;</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$TARGET_SCHEMES</span> = <span class="hljs-string">&quot;DemoInHouse&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;string&gt;enterprise&lt;/string&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; enterprise Done&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;string&gt;app-store&lt;/string&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; app-store Done&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;key&gt;uploadSymbols&lt;/key&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;true/&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;/dict&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;/plist&gt;&quot;</span> &gt;&gt; <span class="hljs-variable">$EXPORT_PLIST</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reset export options Done&quot;</span><br><br><span class="hljs-comment">#替换素材</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$AUTOBUILD_PATH</span><br>./replace_res.sh <span class="hljs-variable">$TARGET_SCHEMES</span><br><br><span class="hljs-comment"># return root</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$PROJECT_ROOT_PATH</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reset res Done&quot;</span><br><br><span class="hljs-comment">#export files</span><br>ARCHIVE_FILE=<span class="hljs-string">&quot;<span class="hljs-variable">$OUT_BINARY_DIR</span>/<span class="hljs-variable">$TARGET_APP_NAMES</span>.xcarchive&quot;</span><br>DSYMS_FILE=<span class="hljs-string">&quot;<span class="hljs-variable">$TARGET_APP_NAMES</span>.dSYMs.zip&quot;</span><br><br><span class="hljs-comment">#clean prject</span><br>xcodebuild -workspace <span class="hljs-variable">$WORKSPACE_NAME</span> -scheme <span class="hljs-variable">$TARGET_SCHEMES</span> -configuration <span class="hljs-variable">$TARGET_APP_NAMES</span> clean<br><br><span class="hljs-comment">#build &amp; archive</span><br>xcodebuild archive -workspace <span class="hljs-variable">$WORKSPACE_NAME</span> -scheme <span class="hljs-variable">$TARGET_SCHEMES</span> -configuration <span class="hljs-variable">$TARGET_APP_NAMES</span> -archivePath <span class="hljs-variable">$ARCHIVE_FILE</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$ARCHIVE_FILE</span><br>zip -r <span class="hljs-variable">$DSYMS_FILE</span> <span class="hljs-string">&quot;dSYMs&quot;</span><br><span class="hljs-built_in">mv</span> <span class="hljs-variable">$DSYMS_FILE</span> <span class="hljs-variable">$OUT_BINARY_DIR</span><br><br><span class="hljs-comment"># return root</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$PROJECT_ROOT_PATH</span><br><br><span class="hljs-comment">#export</span><br>xcodebuild -exportArchive -archivePath <span class="hljs-variable">$ARCHIVE_FILE</span> -exportPath <span class="hljs-variable">$OUT_BINARY_DIR</span> -exportOptionsPlist <span class="hljs-variable">$EXPORT_PLIST</span><br><br><span class="hljs-comment">#rename ipa file failed since creating ipa file is asynchronized</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;apple id paired&quot;</span> &gt;&gt; <span class="hljs-string">&quot;<span class="hljs-variable">$OUT_BINARY_DIR</span>/$TARGET_APP_NAMES_<span class="hljs-variable">$TARGET_DEV_IDS</span>&quot;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="hljs-variable">$TARGET_SCHEMES</span> single loop Done&quot;</span><br><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finish at <span class="hljs-subst">$(date)</span> &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span><br></code></pre></td></tr></table></figure><p>使用时先根据需要打包的版本，修改<code>FLAVORS=($DemoInHouse)</code>中的内容。如果只打一个包，更换$后的命名即可；如果需要打多个包，则在输入多个包名，以逗号隔开，如:<code>FLAVORS=($DemoInHouse,$DemoRelease)</code>。最后，在终端中<code>./autobuild.sh</code>，直接执行脚本即可。</p><h4 id="验证并上传到商店"><a href="#验证并上传到商店" class="headerlink" title="验证并上传到商店"></a>验证并上传到商店</h4><p>Xcode 集成了 Application Loader，你可以用它来手动上传 App 的二进制文件。这里继续使用脚本的方式，通过 Application Loader 的命令行工具 altool 来验证二进制文件并上传到商店。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//altool工具路径</span><br>altoolPath=<span class="hljs-string">&quot;/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool&quot;</span><br><span class="hljs-comment">//验证</span><br><span class="hljs-string">&quot;$altoolPath&quot;</span> <span class="hljs-attr">--validate-app</span> -f $&#123;exportIpaPath&#125;/$&#123;scheme_name&#125;<span class="hljs-selector-class">.ipa</span> -u appleID -<span class="hljs-selector-tag">p</span> password -t ios <span class="hljs-attr">--output-format</span> xml<br><span class="hljs-comment">//上传</span><br><span class="hljs-string">&quot;$altoolPath&quot;</span> <span class="hljs-attr">--upload-app</span> -f $&#123;exportIpaPath&#125;/$&#123;scheme_name&#125;<span class="hljs-selector-class">.ipa</span> -u appleID -<span class="hljs-selector-tag">p</span> password -t ios <span class="hljs-attr">--output-format</span> xml<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>详细说明</th></tr></thead><tbody><tr><td>–validate-app</td><td>您要验证指定的 App。</td></tr><tr><td>–upload-app</td><td>您要上传指定的 App。</td></tr><tr><td>-f file</td><td>正在验证或上传的 App 的路径和文件名。</td></tr><tr><td>-u username</td><td>您的用户名。</td></tr><tr><td>-p password</td><td>您的用户密码。</td></tr><tr><td>–output-format [xml or normal]</td><td>您想让 Application Loader 以结构化的 XML 格式还是非结构化的文本格式返回输出信息。默认情况下，Application Loader 以文本格式返回输出信息。</td></tr></tbody></table><h4 id="上传到Fir"><a href="#上传到Fir" class="headerlink" title="上传到Fir"></a>上传到Fir</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">firApiToken</span>=<span class="hljs-string">&quot;xxxxxxxxxxx&quot;</span><br>fir publish <span class="hljs-variable">$exportIpaPath</span>/<span class="hljs-variable">$scheme_name</span>.ipa -T <span class="hljs-string">&quot;<span class="hljs-variable">$firApiToken</span>&quot;</span><br></code></pre></td></tr></table></figure><p>注意：使用脚本上传到Fir平台前，需要先安装 fir-cli：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">gem install fir-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h4 id="上传到蒲公英"><a href="#上传到蒲公英" class="headerlink" title="上传到蒲公英"></a>上传到蒲公英</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">curl</span> <span class="hljs-operator">-F</span> <span class="hljs-string">&quot;file=@<span class="hljs-variable">$exportIpaPath</span>/<span class="hljs-variable">$scheme_name</span>.ipa&quot;</span> <span class="hljs-operator">-F</span> <span class="hljs-string">&quot;uKey=xxx&quot;</span> <span class="hljs-operator">-F</span> <span class="hljs-string">&quot;_api_key=xxx https://qiniu-storage.pgyer.com/apiv1/app/upload</span><br></code></pre></td></tr></table></figure><p>请根据开发者自己的账号，将其中的 uKey 和 _api_key 的值替换为相应的值。完整的使用规则请看 <a href="https://www.pgyer.com/doc/api">这里</a>~</p><h4 id="上传符号表"><a href="#上传符号表" class="headerlink" title="上传符号表"></a>上传符号表</h4><p>如果应用接入了崩溃分析工具，会要求将dSYM文件上传到对应平台的后台中，比如接入bugly时，可以通过以下脚本上传符号表文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar buglySymboliOS.jar -d -i <span class="hljs-variable">$dSYM</span> -u -<span class="hljs-built_in">id</span> <span class="hljs-string">&quot;xx&quot;</span> -key <span class="hljs-string">&quot;xx&quot;</span> -package <span class="hljs-string">&quot;com.xx.xx&quot;</span> -version <span class="hljs-string">&quot;<span class="hljs-variable">$version</span>&quot;</span> -o <span class="hljs-string">&quot;xx.zip&quot;</span><br></code></pre></td></tr></table></figure><p>bugly 上传 dSYM 文件需要事先下载一个工具包，具体的配置和使用方法可以参考 <a href="https://bugly.qq.com/docs/user-guide/symbol-configuration-ios/?v=20180709165613#_4">这里</a>~</p><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><p>当然，还有一些更专业化的自动化部署和发布工具，如：</p><ul><li>Jenkins</li><li>FastLane</li></ul><p>这些工具极大地简化了我们手动发布时的一些枯燥、重复的工作，比如截图、代码签名以及发布。这里就不一一介绍了，可以自行到其官网查询~</p><hr><p>相关参考：</p><p>#<a href="https://www.jianshu.com/p/05dc9f925467">©JiaJung-自动打包发布到Fir和AppStore</a></p><p>#<a href="https://www.jianshu.com/p/bd4c22952e01">©zackzheng-详解Shell脚本实现iOS自动化编译打包提交</a></p><p>#<a href="https://github.com/webfrogs/xcode_shell">©Github.webfrogs-xcode_shell</a></p><p>#<a href="https://blog.csdn.net/cdut100/article/details/76381605">©FastLane-自动化打包发布</a></p><p>#<a href="https://help.apple.com/itc/apploader/#/apdATD1E53-D1E1A1303-D1E53A1126">©Application Loader-altool工具</a></p><p>#<a href="https://blog.csdn.net/andanlan/article/details/78113330?locationNum=9&fps=1">©树叶有砖攻-Xcode9 xcodebuild export plist 配置</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mach-O</title>
    <link href="/2019/03/16/macho.html"/>
    <url>/2019/03/16/macho.html</url>
    
    <content type="html"><![CDATA[<p>Xcode 构建一个程序的过程中，会把源文件 (.m 和 .h) 文件转换为一个可执行文件（Mach-O executable）。这个可执行文件中包含的字节码将会被 CPU (iOS 设备中的 ARM 处理器或 Mac 上的 Intel 处理器) 执行。当然，我们也可以不使用 Xcode，而是通过苹果提供的命令行工具（command line tools）来构建一个程序。</p><h2 id="1-不使用-Xcode-的-Hello-World"><a href="#1-不使用-Xcode-的-Hello-World" class="headerlink" title="#1 不使用 Xcode 的 Hello World"></a>#1 不使用 Xcode 的 Hello World</h2><p>通过终端 (Terminal)，创建一个包含一个 C 文件的文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> command-line</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> !$</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">touch</span> helloworld.c</span><br></code></pre></td></tr></table></figure><p>使用文本编辑器来编辑这个文件：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">open -e helloworld.c<br></code></pre></td></tr></table></figure><p>输入如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存并返回到终端，然后运行如下命令编译 helloworld.c 文件：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>xcrun clang helloworld.c<br></code></pre></td></tr></table></figure><p>这里会产生一个名为 a.out 的文件，使用file命令查看其信息:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ file <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.out</span> <br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.out</span>: Mach-O <span class="hljs-number">64</span>-bit executable x86_64<br></code></pre></td></tr></table></figure><p>这个 a.out 文件就是使用 clang 编译器将 helloworld.c 编译后产生的一个 Mach-O 格式的二进制文件。注意，如果没有指定名字，那么编译器会默认的将其指定为 a.out。</p><p>然后我们执行此二进制文件，终端中的输出结果如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>./a.<span class="hljs-keyword">out</span> <br>Hello World!<br></code></pre></td></tr></table></figure><hr><h2 id="2-Mach-O（可执行文件格式）"><a href="#2-Mach-O（可执行文件格式）" class="headerlink" title="#2 Mach-O（可执行文件格式）"></a>#2 Mach-O（可执行文件格式）</h2><p>Mach-O 是 Mach object 文件格式的缩写，类似于 windows 环境下的 PE 格式、Linux 环境下的 ELF 格式。我们平时见到的可执行文件、dSYM符号文件、Dylib动态库、Framework 等使用的都是这种格式。</p><blockquote><p>Mach-O提供更多的可扩展性和更快的符号表信息存取。</p></blockquote><blockquote><p>Mach-O应用在基于Mach核心的系统上，目前NeXTSTEP、Darwin、Mac OS X（iPhone）都是使用这种可执行文件格式。</p></blockquote><p>Mach-O 文件的结构由 Header、Load commands、Data（包含Segement的具体数据）组成。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_mach_o.jpg" alt="image"></p><p>上面我们编译出的可执行文件 a.out 使用的也是这种格式。</p><p>#示例1：使用 otool 命令查看 a.out 文件的内部结构</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><code class="hljs dns">$ otool -l a.out <br>a.out:<br>Mach header<br>      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags<br> <span class="hljs-number">0</span>xfeedfacf <span class="hljs-number">16777223</span>          <span class="hljs-number">3</span>  <span class="hljs-number">0</span>x80           <span class="hljs-number">2</span>    <span class="hljs-number">15</span>       <span class="hljs-number">1200</span> <span class="hljs-number">0x00200085</span><br>Load command <span class="hljs-number">0</span><br>      cmd LC_SEGMENT_64<br>  cmdsize <span class="hljs-number">72</span><br>  segname __PAGEZERO<br>   vmaddr <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br>   vmsize <span class="hljs-number">0</span>x0000<span class="hljs-number">000100000000</span><br>  fileoff <span class="hljs-number">0</span><br> filesize <span class="hljs-number">0</span><br>  maxprot <span class="hljs-number">0x00000000</span><br> initprot <span class="hljs-number">0x00000000</span><br>   nsects <span class="hljs-number">0</span><br>    flags <span class="hljs-number">0</span>x0<br>Load command <span class="hljs-number">1</span><br>      cmd LC_SEGMENT_64<br>  cmdsize <span class="hljs-number">472</span><br>  segname __TEXT<br>   vmaddr <span class="hljs-number">0</span>x0000<span class="hljs-number">000100000000</span><br>   vmsize <span class="hljs-number">0</span>x00000<span class="hljs-number">00000001000</span><br>  fileoff <span class="hljs-number">0</span><br> filesize <span class="hljs-number">4096</span><br>  maxprot <span class="hljs-number">0x00000007</span><br> initprot <span class="hljs-number">0x00000005</span><br>   nsects <span class="hljs-number">5</span><br>    flags <span class="hljs-number">0</span>x0<br>Section<br>  sectname __text<br>   segname __TEXT<br>      addr <span class="hljs-number">0</span>x0000<span class="hljs-number">000100000f50</span><br>      size <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000034</span><br>    offset <span class="hljs-number">3920</span><br>     align <span class="hljs-number">2</span>^<span class="hljs-number">4</span> (<span class="hljs-number">16</span>)<br>    reloff <span class="hljs-number">0</span><br>    nreloc <span class="hljs-number">0</span><br>     flags <span class="hljs-number">0x80000400</span><br> reserved1 <span class="hljs-number">0</span><br> reserved2 <span class="hljs-number">0</span><br>Section<br>  sectname __stubs<br>   segname __TEXT<br>      addr <span class="hljs-number">0</span>x0000<span class="hljs-number">000100000f84</span><br>      size <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000006</span><br>    offset <span class="hljs-number">3972</span><br>     align <span class="hljs-number">2</span>^<span class="hljs-number">1</span> (<span class="hljs-number">2</span>)<br>    reloff <span class="hljs-number">0</span><br>    nreloc <span class="hljs-number">0</span><br>     flags <span class="hljs-number">0x80000408</span><br> reserved1 <span class="hljs-number">0</span> (index into indirect symbol table)<br> reserved2 <span class="hljs-number">6</span> (size of stubs)<br>Section<br>  sectname __stub_helper<br>   segname __TEXT<br>      addr <span class="hljs-number">0</span>x0000000100000f8c<br>      size <span class="hljs-number">0</span>x000000000000001a<br>    offset <span class="hljs-number">3980</span><br>     align <span class="hljs-number">2</span>^<span class="hljs-number">2</span> (<span class="hljs-number">4</span>)<br>    reloff <span class="hljs-number">0</span><br>    nreloc <span class="hljs-number">0</span><br>     flags <span class="hljs-number">0x80000400</span><br> reserved1 <span class="hljs-number">0</span><br> reserved2 <span class="hljs-number">0</span><br>Section<br>  sectname __cstring<br>   segname __TEXT<br>      addr <span class="hljs-number">0</span>x0000000100000fa6<br>      size <span class="hljs-number">0</span>x000000000000000e<br>    offset <span class="hljs-number">4006</span><br>     align <span class="hljs-number">2</span>^<span class="hljs-number">0</span> (<span class="hljs-number">1</span>)<br>    reloff <span class="hljs-number">0</span><br>    nreloc <span class="hljs-number">0</span><br>     flags <span class="hljs-number">0x00000002</span><br> reserved1 <span class="hljs-number">0</span><br> reserved2 <span class="hljs-number">0</span><br>Section<br>  sectname __unwind_info<br>   segname __TEXT<br>      addr <span class="hljs-number">0</span>x0000000100000fb4<br>      size <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000048</span><br>    offset <span class="hljs-number">4020</span><br>     align <span class="hljs-number">2</span>^<span class="hljs-number">2</span> (<span class="hljs-number">4</span>)<br>    reloff <span class="hljs-number">0</span><br>    nreloc <span class="hljs-number">0</span><br>     flags <span class="hljs-number">0x00000000</span><br> reserved1 <span class="hljs-number">0</span><br> reserved2 <span class="hljs-number">0</span><br>Load command <span class="hljs-number">2</span><br>      cmd LC_SEGMENT_64<br>  cmdsize <span class="hljs-number">232</span><br>  segname __DATA<br>   vmaddr <span class="hljs-number">0</span>x0000<span class="hljs-number">000100001000</span><br>   vmsize <span class="hljs-number">0</span>x00000<span class="hljs-number">00000001000</span><br>  fileoff <span class="hljs-number">4096</span><br> filesize <span class="hljs-number">4096</span><br>  maxprot <span class="hljs-number">0x00000007</span><br> initprot <span class="hljs-number">0x00000003</span><br>   nsects <span class="hljs-number">2</span><br>    flags <span class="hljs-number">0</span>x0<br>Section<br>  sectname __nl_symbol_ptr<br>   segname __DATA<br>      addr <span class="hljs-number">0</span>x0000<span class="hljs-number">000100001000</span><br>      size <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000010</span><br>    offset <span class="hljs-number">4096</span><br>     align <span class="hljs-number">2</span>^<span class="hljs-number">3</span> (<span class="hljs-number">8</span>)<br>    reloff <span class="hljs-number">0</span><br>    nreloc <span class="hljs-number">0</span><br>     flags <span class="hljs-number">0x00000006</span><br> reserved1 <span class="hljs-number">1</span> (index into indirect symbol table)<br> reserved2 <span class="hljs-number">0</span><br>Section<br>  sectname __la_symbol_ptr<br>   segname __DATA<br>      addr <span class="hljs-number">0</span>x0000<span class="hljs-number">000100001010</span><br>      size <span class="hljs-number">0</span>x00000<span class="hljs-number">00000000008</span><br>    offset <span class="hljs-number">4112</span><br>     align <span class="hljs-number">2</span>^<span class="hljs-number">3</span> (<span class="hljs-number">8</span>)<br>    reloff <span class="hljs-number">0</span><br>    nreloc <span class="hljs-number">0</span><br>     flags <span class="hljs-number">0x00000007</span><br> reserved1 <span class="hljs-number">3</span> (index into indirect symbol table)<br> reserved2 <span class="hljs-number">0</span><br>Load command <span class="hljs-number">3</span><br>      cmd LC_SEGMENT_64<br>  cmdsize <span class="hljs-number">72</span><br>  segname __LINKEDIT<br>   vmaddr <span class="hljs-number">0</span>x0000<span class="hljs-number">000100002000</span><br>   vmsize <span class="hljs-number">0</span>x00000<span class="hljs-number">00000001000</span><br>  fileoff <span class="hljs-number">8192</span><br> filesize <span class="hljs-number">240</span><br>  maxprot <span class="hljs-number">0x00000007</span><br> initprot <span class="hljs-number">0x00000001</span><br>   nsects <span class="hljs-number">0</span><br>    flags <span class="hljs-number">0</span>x0<br>Load command <span class="hljs-number">4</span><br>            cmd LC_DYLD_INFO_ONLY<br>        cmdsize <span class="hljs-number">48</span><br>     rebase_off <span class="hljs-number">8192</span><br>    rebase_size <span class="hljs-number">8</span><br>       bind_off <span class="hljs-number">8200</span><br>      bind_size <span class="hljs-number">24</span><br>  weak_bind_off <span class="hljs-number">0</span><br> weak_bind_size <span class="hljs-number">0</span><br>  lazy_bind_off <span class="hljs-number">8224</span><br> lazy_bind_size <span class="hljs-number">16</span><br>     export_off <span class="hljs-number">8240</span><br>    export_size <span class="hljs-number">48</span><br>Load command <span class="hljs-number">5</span><br>     cmd LC_SYMTAB<br> cmdsize <span class="hljs-number">24</span><br>  symoff <span class="hljs-number">8296</span><br>   nsyms <span class="hljs-number">4</span><br>  stroff <span class="hljs-number">8376</span><br> strsize <span class="hljs-number">56</span><br>Load command <span class="hljs-number">6</span><br>            cmd LC_DYSYMTAB<br>        cmdsize <span class="hljs-number">80</span><br>      ilocalsym <span class="hljs-number">0</span><br>      nlocalsym <span class="hljs-number">0</span><br>     iextdefsym <span class="hljs-number">0</span><br>     nextdefsym <span class="hljs-number">2</span><br>      iundefsym <span class="hljs-number">2</span><br>      nundefsym <span class="hljs-number">2</span><br>         tocoff <span class="hljs-number">0</span><br>           ntoc <span class="hljs-number">0</span><br>      modtaboff <span class="hljs-number">0</span><br>        nmodtab <span class="hljs-number">0</span><br>   extrefsymoff <span class="hljs-number">0</span><br>    nextrefsyms <span class="hljs-number">0</span><br> indirectsymoff <span class="hljs-number">8360</span><br>  nindirectsyms <span class="hljs-number">4</span><br>      extreloff <span class="hljs-number">0</span><br>        nextrel <span class="hljs-number">0</span><br>      locreloff <span class="hljs-number">0</span><br>        nlocrel <span class="hljs-number">0</span><br>Load command <span class="hljs-number">7</span><br>          cmd LC_LOAD_DYLINKER<br>      cmdsize <span class="hljs-number">32</span><br>         name /usr/lib/dyld (offset <span class="hljs-number">12</span>)<br>Load command <span class="hljs-number">8</span><br>     cmd LC_UUID<br> cmdsize <span class="hljs-number">24</span><br>    uuid <span class="hljs-number">6122E2B2</span>-<span class="hljs-number">9651-3991</span>-B2BA-<span class="hljs-number">15</span>B45ADC0C6B<br>Load command <span class="hljs-number">9</span><br>      cmd LC_VERSION_MIN_MACOSX<br>  cmdsize <span class="hljs-number">16</span><br>  version <span class="hljs-number">10</span>.<span class="hljs-number">13</span><br>      sdk <span class="hljs-number">10</span>.<span class="hljs-number">13</span><br>Load command <span class="hljs-number">10</span><br>      cmd LC_SOURCE_VERSION<br>  cmdsize <span class="hljs-number">16</span><br>  version <span class="hljs-number">0</span>.<span class="hljs-number">0</span><br>Load command <span class="hljs-number">11</span><br>       cmd LC_MAIN<br>   cmdsize <span class="hljs-number">24</span><br>  entryoff <span class="hljs-number">3920</span><br> stacksize <span class="hljs-number">0</span><br>Load command <span class="hljs-number">12</span><br>          cmd LC_LOAD_DYLIB<br>      cmdsize <span class="hljs-number">56</span><br>         name /usr/lib/libSystem.B.dylib (offset <span class="hljs-number">24</span>)<br>   time stamp <span class="hljs-number">2</span> Thu Jan  <span class="hljs-number">1 08:00:02</span> <span class="hljs-number">1970</span><br>      current version <span class="hljs-number">1252.50.4</span><br>compatibility version <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br>Load command <span class="hljs-number">13</span><br>      cmd LC_FUNCTION_STARTS<br>  cmdsize <span class="hljs-number">16</span><br>  dataoff <span class="hljs-number">8288</span><br> datasize <span class="hljs-number">8</span><br>Load command <span class="hljs-number">14</span><br>      cmd LC_DATA_IN_CODE<br>  cmdsize <span class="hljs-number">16</span><br>  dataoff <span class="hljs-number">8296</span><br> datasize <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2-1-Header"><a href="#2-1-Header" class="headerlink" title="##2.1.Header"></a>##2.1.Header</h3><p>头部主要用来规定这个文件是什么，以及文件是如何被加载的（通过 otool -h 可以打印出头信息）。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ otool -h a.out <br>Mach header<br>      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags<br> 0xfeedfacf<span class="hljs-number"> 16777223 </span>        <span class="hljs-number"> 3 </span> 0x80          <span class="hljs-number"> 2 </span>  <span class="hljs-number"> 15 </span>     <span class="hljs-number"> 1200 </span>0x00200085<br></code></pre></td></tr></table></figure><ul><li>32 位架构下 Header 的数据结构：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header</span> &#123;<br>    <span class="hljs-type">uint32_t</span>    magic;      <span class="hljs-comment">/* mach magic number identifier */</span><br>    <span class="hljs-type">cpu_type_t</span>  cputype;    <span class="hljs-comment">/* cpu specifier */</span><br>    <span class="hljs-type">cpu_subtype_t</span>   cpusubtype; <span class="hljs-comment">/* machine specifier */</span><br>    <span class="hljs-type">uint32_t</span>    filetype;   <span class="hljs-comment">/* type of file */</span><br>    <span class="hljs-type">uint32_t</span>    ncmds;      <span class="hljs-comment">/* number of load commands */</span><br>    <span class="hljs-type">uint32_t</span>    sizeofcmds; <span class="hljs-comment">/* the size of all the load commands */</span><br>    <span class="hljs-type">uint32_t</span>    flags;      <span class="hljs-comment">/* flags */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>64 位架构下 Header 的数据结构：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header</span> &#123;<br>    <span class="hljs-type">uint32_t</span>    magic;      <span class="hljs-comment">/* mach magic number identifier */</span><br>    <span class="hljs-type">cpu_type_t</span>  cputype;    <span class="hljs-comment">/* cpu specifier */</span><br>    <span class="hljs-type">cpu_subtype_t</span>   cpusubtype; <span class="hljs-comment">/* machine specifier */</span><br>    <span class="hljs-type">uint32_t</span>    filetype;   <span class="hljs-comment">/* type of file */</span><br>    <span class="hljs-type">uint32_t</span>    ncmds;      <span class="hljs-comment">/* number of load commands */</span><br>    <span class="hljs-type">uint32_t</span>    sizeofcmds; <span class="hljs-comment">/* the size of all the load commands */</span><br>    <span class="hljs-type">uint32_t</span>    flags;      <span class="hljs-comment">/* flags */</span><br>    <span class="hljs-type">uint32_t</span>    reserved;   <span class="hljs-comment">/* reserved */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>64 位架构只比 32 位架构多了一个 reserved 字段。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">参数：<span class="hljs-built_in">magic</span><br></code></pre></td></tr></table></figure><p>表示当前二进制文件的类型，不同类型的二进制文件有自己独特的”魔数值”。加载器通过这个魔数值来判断这是什么样的文件，例如32位 Mach-O 文件的魔术值是 0xfeedface、64位 Mach-O 文件的魔术值是 0xfeedfacf、胖二进制文件的魔数值是 0xcafebabe。所以这个字段也可以用于快速确认该文件用于64位还是32位。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">参数：cpu<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>cup的类型（如 iOS设备的ARM、Mac上的Intel）。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">参数：cpusub<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>cup的子类型（如armv7、arm64等）。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">参数：file<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>文件类型（如可执行文件、库文件、dSYM文件等），具体枚举如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">* Constants <span class="hljs-keyword">for</span> the filetype field of the mach_header<br> */<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_OBJECT   0x1     <span class="hljs-comment">/* relocatable object file */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_EXECUTE  0x2     <span class="hljs-comment">/* demand paged executable file */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_FVMLIB   0x3     <span class="hljs-comment">/* fixed VM shared library file */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_CORE     0x4     <span class="hljs-comment">/* core file */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_PRELOAD  0x5     <span class="hljs-comment">/* preloaded executable file */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_DYLIB    0x6     <span class="hljs-comment">/* dynamically bound shared library */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_DYLINKER 0x7     <span class="hljs-comment">/* dynamic link editor */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_BUNDLE   0x8     <span class="hljs-comment">/* dynamically bound bundle file */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_DYLIB_STUB   0x9     <span class="hljs-comment">/* shared library stub for static */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_DSYM     0xa     <span class="hljs-comment">/* companion file with only debug */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_KEXT_BUNDLE  0xb     <span class="hljs-comment">/* x86_64 kexts */</span></span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：ncmds<br></code></pre></td></tr></table></figure><p>指的是加载命令(Load Commands)的数量，如上面#示例1中 a.out 文件的 ncmds 是 15 个，编号为 0-14。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：sizeofcmds<br></code></pre></td></tr></table></figure><p>表示 N 个 Load Commands 的总字节大小， Load Commands 区域是紧接着 Header 区域的。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">参数：<span class="hljs-keyword">flags</span><br></code></pre></td></tr></table></figure><p>标志位，具体枚举值定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_NOUNDEFS  0x1 <span class="hljs-comment">//目前没有未定义的符号，不存在链接依赖</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_DYLDLINK  0x4 <span class="hljs-comment">//该文件是dyld的输入文件，无法被再次静态链接</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_PIE 0x200000  <span class="hljs-comment">//加载程序在随机地址空间（ASLR），只在 MH_EXECUTE中使用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MH_TWOLEVEL 0x80 <span class="hljs-comment">// 两级名称空间</span></span><br>...<br></code></pre></td></tr></table></figure><h3 id="2-2-Load-commands"><a href="#2-2-Load-commands" class="headerlink" title="##2.2. Load commands"></a>##2.2. Load commands</h3><p>Load commands 跟在 Header 部分的后面，这些加载指令负责在 Mach-O 文件加载解析时告诉加载器如何处理二进制数据：有些命令是由内核处理的，有些是由动态链接器处理的，最终会根据 cmd 字段的不同类型，使用不同的函数来加载。</p><p>Load commands 的结构定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">load_command</span> &#123;<br>    <span class="hljs-type">uint32_t</span> cmd;       <span class="hljs-comment">/* type of load command */</span><br>    <span class="hljs-type">uint32_t</span> cmdsize;   <span class="hljs-comment">/* total size of command in bytes */</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">参数：<span class="hljs-keyword">cmd</span><br></code></pre></td></tr></table></figure><p>代表 Load commands 的类型，如 LC_SEGMENT_64、LC_UUID、LC-CODE-SIGNATURE 等等。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：cmdsize<br></code></pre></td></tr></table></figure><p>代表 Load commands 的大小。</p><p>下面列举几个看上去比较熟悉的 Load commands…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将文件的32位 或 64位的段映射到进程地址空间</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC_SEGMENT  0x1 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC_SEGMENT_64   0x19    </span><br><br><span class="hljs-comment">// 唯一的 UUID，标示二进制文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC_UUID  0x1b    <span class="hljs-comment">/* the uuid */</span></span><br><br><span class="hljs-comment">// 启动动态加载连接器</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC_LOAD_DYLINKER 0xe <span class="hljs-comment">/* load a dynamic linker */</span></span><br><br><span class="hljs-comment">// 代码签名和加密</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC_CODE_SIGNATURE 0x1d   <span class="hljs-comment">/* local of code signature */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LC_ENCRYPTION_INFO 0x21 <span class="hljs-comment">/* encrypted segment information */</span></span><br></code></pre></td></tr></table></figure><p>以 LC_SEGMENT_64 类型为例，它代表将文件中64位的段映射到进程的地址空间。它的结构定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">segment_command_64</span> &#123; <span class="hljs-comment">/* for 64-bit architectures */</span><br>    <span class="hljs-type">uint32_t</span>    cmd;        <span class="hljs-comment">/* LC_SEGMENT_64 */</span><br>    <span class="hljs-type">uint32_t</span>    cmdsize;    <span class="hljs-comment">/* includes sizeof section_64 structs */</span><br>    <span class="hljs-type">char</span>        segname[<span class="hljs-number">16</span>];    <span class="hljs-comment">/* segment name */</span><br>    <span class="hljs-type">uint64_t</span>    vmaddr;     <span class="hljs-comment">/* memory address of this segment */</span><br>    <span class="hljs-type">uint64_t</span>    vmsize;     <span class="hljs-comment">/* memory size of this segment */</span><br>    <span class="hljs-type">uint64_t</span>    fileoff;    <span class="hljs-comment">/* file offset of this segment */</span><br>    <span class="hljs-type">uint64_t</span>    filesize;   <span class="hljs-comment">/* amount to map from the file */</span><br>    <span class="hljs-type">vm_prot_t</span>   maxprot;    <span class="hljs-comment">/* maximum VM protection */</span><br>    <span class="hljs-type">vm_prot_t</span>   initprot;   <span class="hljs-comment">/* initial VM protection */</span><br>    <span class="hljs-type">uint32_t</span>    nsects;     <span class="hljs-comment">/* number of sections in segment */</span><br>    <span class="hljs-type">uint32_t</span>    flags;      <span class="hljs-comment">/* flags */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面解释一下各参数的作用。。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：segname<br></code></pre></td></tr></table></figure><p>段的名称，下面的##2.3小结中有更详细的介绍。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：vmaddr<br></code></pre></td></tr></table></figure><p>段的虚拟内存地址。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：vmsize<br></code></pre></td></tr></table></figure><p>段的虚拟内存大小</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：fileoff<br></code></pre></td></tr></table></figure><p>段在文件中偏移量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：filesize<br></code></pre></td></tr></table></figure><p>段在文件中的大小。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：nsects<br></code></pre></td></tr></table></figure><p>段中有多少 secetion。</p><p>以上面 <strong>#示例1</strong> 中的 Load command 0 为例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Load</span> command <span class="hljs-number">0</span><br>      <span class="hljs-attribute">cmd</span> LC_SEGMENT_64<br>  <span class="hljs-attribute">cmdsize</span> <span class="hljs-number">72</span><br>  <span class="hljs-attribute">segname</span> __PAGEZERO<br>   <span class="hljs-attribute">vmaddr</span> <span class="hljs-number">0</span>x0000000000000000<br>   <span class="hljs-attribute">vmsize</span> <span class="hljs-number">0</span>x0000000100000000<br>  <span class="hljs-attribute">fileoff</span> <span class="hljs-number">0</span><br> <span class="hljs-attribute">filesize</span> <span class="hljs-number">0</span><br>  <span class="hljs-attribute">maxprot</span> <span class="hljs-number">0</span>x00000000<br> <span class="hljs-attribute">initprot</span> <span class="hljs-number">0</span>x00000000<br>   <span class="hljs-attribute">nsects</span> <span class="hljs-number">0</span><br>    <span class="hljs-attribute">flags</span> <span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>它就是告诉加载器将该段文件的内容加载到内存中：从 fileoff 处加载 filesize 大小到虚拟内存 vmaddr 处。由于这里在内存地址空间中是 _PAGEZERO 段（这个段不具有访问权限，用来处理空指针）所以各参数都是零。</p><h3 id="2-3-Segments（段数据）"><a href="#2-3-Segments（段数据）" class="headerlink" title="##2.3. Segments（段数据）"></a>##2.3. Segments（段数据）</h3><p>Segments 包含了很多 segment，每一个 segment 定义了一些 Mach-O 文件的数据、地址和内存保护属性，这些数据在动态链接器加载程序时被映射到了虚拟内存中。每个段都有不同的功能，一般包括：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__PAGEZERO</span><br></code></pre></td></tr></table></figure><p>空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用；</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">__<span class="hljs-built_in">TEXT</span><br></code></pre></td></tr></table></figure><p>包含了执行代码以及其他只读数据。 为了让内核将它直接从可执行文件映射到共享内存， 静态连接器设置该段的虚拟内存权限为不允许写。当这个段被映射到内存后可以被所有进程共享（这主要用在 Frameworks、 Bundles和共享库等程序中，也可以为同一个可执行文件的多个进程拷贝使用）。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__DATA</span><br></code></pre></td></tr></table></figure><p>包含了程序数据，该段可写；</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__OBJC</span><br></code></pre></td></tr></table></figure><p>Objective-C运行时支持库；</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__LINKEDIT</span><br></code></pre></td></tr></table></figure><p>含有为动态链接库使用的原始数据，比如符号，字符串，重定位表条目等等。</p><h3 id="2-4-section（区数据）"><a href="#2-4-section（区数据）" class="headerlink" title="##2.4. section（区数据）"></a>##2.4. section（区数据）</h3><p>一般段又会按不同的功能划分为几个区（section）。区的字母为小写，同样加两个下划线作为前缀。下面列出段中可能包含的 section：</p><ul><li>__TEXT段</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__text</span>, <span class="hljs-variable">__cstring</span>, <span class="hljs-variable">__picsymbol_stub</span>, <span class="hljs-variable">__symbol_stub</span>, <span class="hljs-variable">__const</span>, <span class="hljs-variable">__litera14</span>, <span class="hljs-variable">__litera18</span>;<br></code></pre></td></tr></table></figure><ul><li>__DATA段</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__data</span>, <span class="hljs-variable">__la_symbol_ptr</span>, <span class="hljs-variable">__nl_symbol_ptr</span>, <span class="hljs-variable">__dyld</span>, <span class="hljs-variable">__const</span>, <br><span class="hljs-variable">__mod_init_func</span>, <span class="hljs-variable">__mod_term_func</span>, <span class="hljs-variable">__bss</span>, <span class="hljs-variable">__commom</span>;<br></code></pre></td></tr></table></figure><ul><li>__IMPORT段</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__jump_table</span>, <span class="hljs-variable">__pointers</span>;<br></code></pre></td></tr></table></figure><p>其中 __TEXT 段中的 __text 是实际上的代码部分；__DATA 段的 __data 是实际的初始数据。</p><p>section 的数据结构：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">section</span> &#123; <span class="hljs-comment">/* for 32-bit architectures */</span><br>    <span class="hljs-type">char</span>        sectname[<span class="hljs-number">16</span>];   <span class="hljs-comment">/* name of this section */</span><br>    <span class="hljs-type">char</span>        segname[<span class="hljs-number">16</span>];    <span class="hljs-comment">/* segment this section goes in */</span><br>    <span class="hljs-type">uint32_t</span>    addr;       <span class="hljs-comment">/* memory address of this section */</span><br>    <span class="hljs-type">uint32_t</span>    size;       <span class="hljs-comment">/* size in bytes of this section */</span><br>    <span class="hljs-type">uint32_t</span>    offset;     <span class="hljs-comment">/* file offset of this section */</span><br>    <span class="hljs-type">uint32_t</span>    align;      <span class="hljs-comment">/* section alignment (power of 2) */</span><br>    <span class="hljs-type">uint32_t</span>    reloff;     <span class="hljs-comment">/* file offset of relocation entries */</span><br>    <span class="hljs-type">uint32_t</span>    nreloc;     <span class="hljs-comment">/* number of relocation entries */</span><br>    <span class="hljs-type">uint32_t</span>    flags;      <span class="hljs-comment">/* flags (section type and attributes)*/</span><br>    <span class="hljs-type">uint32_t</span>    reserved1;  <span class="hljs-comment">/* reserved (for offset or index) */</span><br>    <span class="hljs-type">uint32_t</span>    reserved2;  <span class="hljs-comment">/* reserved (for count or sizeof) */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其中部分参数的介绍:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：sectname<br></code></pre></td></tr></table></figure><p>section 的名字，如上面提到的 __text、__cstring等。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">参数：segname<br></code></pre></td></tr></table></figure><p>section 所属的 segment，比如 __TEXT。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">参数：<span class="hljs-keyword">addr</span><br></code></pre></td></tr></table></figure><p>section 在内存的起始位置。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">参数：size<br></code></pre></td></tr></table></figure><p>section 的大小。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">参数：<span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure><p>section 的文件偏移量。</p><p>#示例2：通过 otool –s查看某个 section 的信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ otool -s __TEXT __text a.out<br>a.out:<br>Contents of (__TEXT,__text) section<br>0000000100000f50 <span class="hljs-number"> 55 </span>48<span class="hljs-number"> 89 </span>e5<span class="hljs-number"> 48 </span>83 ec<span class="hljs-number"> 20 </span>48 8d<span class="hljs-number"> 05 </span>47<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>c7 <br>0000000100000f60 <span class="hljs-number"> 45 </span>fc<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 89 </span>7d f8<span class="hljs-number"> 48 </span>89<span class="hljs-number"> 75 </span>f0<span class="hljs-number"> 48 </span>89 c7 <br>0000000100000f70  b0<span class="hljs-number"> 00 </span>e8 0d<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>31 c9<span class="hljs-number"> 89 </span>45 ec<span class="hljs-number"> 89 </span>c8<span class="hljs-number"> 48 </span>83 <br>0000000100000f80  c4<span class="hljs-number"> 20 </span>5d c3 <br></code></pre></td></tr></table></figure><p>由于-s __TEXT __text 很常见，otool 对其设置了一个缩写 -t 。我们还可以通过添加 -v 来查看反汇编代码：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ otool -t -v a.out<br>a.out:<br>(__TEXT<span class="hljs-punctuation">,</span>__text) <span class="hljs-keyword">section</span><br>_main:<br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">50</span>  pushq <span class="hljs-variable">%rbp</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">51</span>  movq  <span class="hljs-variable">%rsp</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rbp</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">54</span>  subq  $<span class="hljs-number">0x20</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsp</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">58</span>  leaq  <span class="hljs-number">0x47</span>(<span class="hljs-variable">%rip</span>)<span class="hljs-punctuation">,</span> <span class="hljs-variable">%rax</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">5</span>f  movl  $<span class="hljs-number">0x0</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">4</span>(<span class="hljs-variable">%rbp</span>)<br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">66</span>  movl  <span class="hljs-variable">%edi</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">8</span>(<span class="hljs-variable">%rbp</span>)<br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">69</span>  movq  <span class="hljs-variable">%rsi</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">10</span>(<span class="hljs-variable">%rbp</span>)<br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">6</span>d  movq  <span class="hljs-variable">%rax</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rdi</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">70</span>  movb  $<span class="hljs-number">0x0</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%al</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">72</span>  callq <span class="hljs-number">0x100000f84</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">77</span>  xorl  <span class="hljs-variable">%ecx</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%ecx</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">79</span>  movl  <span class="hljs-variable">%eax</span><span class="hljs-punctuation">,</span> <span class="hljs-number">-0</span><span class="hljs-keyword">x</span><span class="hljs-number">14</span>(<span class="hljs-variable">%rbp</span>)<br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">7</span><span class="hljs-keyword">c</span>  movl  <span class="hljs-variable">%ecx</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%eax</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">7</span>e  addq  $<span class="hljs-number">0x20</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%rsp</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">82</span>  popq  <span class="hljs-variable">%rbp</span><br><span class="hljs-number">0000000100000</span>f<span class="hljs-number">83</span>  retq<br></code></pre></td></tr></table></figure><hr><h2 id="3-Mach-O-amp-胖文件"><a href="#3-Mach-O-amp-胖文件" class="headerlink" title="#3 Mach-O &amp; 胖文件"></a>#3 Mach-O &amp; 胖文件</h2><p>OS X 有两种类型的目标文件：Mach-O 和 <strong>universal binary</strong> ，后者就是通用二进制文件，也叫胖文件。区别在于：</p><ul><li><p>Mach-O 文件只包含一种架构（i386、x86_64、arm64 等等）的对象代码；</p></li><li><p>胖文件可能同时包含若干“包含不同架构（i386、arm、arm64 等等）对象代码”的对象文件。</p></li></ul><p>实际上 universal binary 文件只不过是将支持不同架构的 Mach-O 文件打包在一起，再在文件起始位置加上 fat_header 来说明所包含的 Mach-O 文件支持的架构和偏移地址信息。</p><p>胖文件的结构︰</p><table><thead><tr><th align="center">fat_header</th></tr></thead><tbody><tr><td align="center">fat_arch</td></tr><tr><td align="center">fat_arch</td></tr><tr><td align="center">。。。</td></tr></tbody></table><p>其中 fat_header 的数据结构在 mach-o/fat.h 头文件上定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FAT_MAGIC   0xcafebabe</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FAT_CIGAM  0xbebafeca  <span class="hljs-comment">/* NXSwapLong(FAT_MAGIC) */</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fat_header</span> &#123;<br>    <span class="hljs-type">uint32_t</span>    magic;        <span class="hljs-comment">/* FAT_MAGIC */</span><br>    <span class="hljs-type">uint32_t</span>    nfat_arch;    <span class="hljs-comment">/* number of structs that follow */</span><br>&#125;;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fat_arch</span> &#123;<br>    <span class="hljs-type">cpu_type_t</span>  cputype;  <span class="hljs-comment">/* cpu specifier (int) */</span><br>    <span class="hljs-type">cpu_subtype_t</span>   cpusubtype;   <span class="hljs-comment">/* machine specifier (int) */</span><br>    <span class="hljs-type">uint32_t</span>    offset;       <span class="hljs-comment">/* file offset to this object file */</span><br>    <span class="hljs-type">uint32_t</span>    size;     <span class="hljs-comment">/* size of this object file */</span><br>    <span class="hljs-type">uint32_t</span>    align;        <span class="hljs-comment">/* alignment as a power of 2 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>参数说明:</p><ul><li>magic字段</li></ul><p>就是上面说的魔数，加载器通过这个魔数值来判断这是什么样的文件，胖二进制文件的魔数值是0xcafebabe；</p><ul><li>nfat_arch字段</li></ul><p>是指当前的胖二进制文件包含了多少个不同架构的 Mach-O 文件。有多少个不同架构的 Mach-O 文件，就有多少个 fat_arch，用于说明对应 Mach-O 文件大小、支持的CPU架构、偏移地址等；</p><p>大部分情况下，xxx.app&#x2F;xxx 文件并不是 Mach-O 格式文件，由于现在需要支持不同 CPU 架构的 iOS 设备，我们编译打包出来的执行文件一般都是胖文件。当然，支持的架构越多，最终打出来的包就会越大，所以项目里的 Architectures 和 Valid Architectures 选项要根据需求来配置哟。</p><p>#示例3：WeChat.app&#x2F;WeChat 文件的信息</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">$ <span class="hljs-keyword">file</span> WeChat<br>WeChat: Mach-O universal binary <span class="hljs-keyword">with</span> <span class="hljs-number">2</span> architectures: <br>[arm_v7:Mach-O executable arm_v7] [arm64]<br>WeChat (<span class="hljs-keyword">for</span> <span class="hljs-keyword">architecture</span> armv7):  Mach-O executable arm_v7<br>WeChat (<span class="hljs-keyword">for</span> <span class="hljs-keyword">architecture</span> arm64):  Mach-O <span class="hljs-number">64</span>-<span class="hljs-built_in">bit</span> executable arm64<br></code></pre></td></tr></table></figure><p>最后，了解 Mach-O 文件对于使用 dSYM 解析崩溃日志、逆向工程、bitcode、应用瘦身等会有很大的帮助！更多相关的内容之后继续慢慢研究。。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/videos/play/wwdc2016/406/?time=90">©WWDC 2016</a></p><p>#<a href="http://wiki.jikexueyuan.com/project/objc/Build-tool/6-3.html">©极客学院</a></p><p>#<a href="https://www.jianshu.com/p/bcc7ba20f900">©简书1</a></p><p>#<a href="https://www.jianshu.com/p/54d842db3f69">©简书2</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPA 重新签名</title>
    <link href="/2019/03/15/resign.html"/>
    <url>/2019/03/15/resign.html</url>
    
    <content type="html"><![CDATA[<h2 id="1、需求："><a href="#1、需求：" class="headerlink" title="1、需求："></a>1、需求：</h2><ul><li>非企业证书签名的 <code>ipa</code> 想要在企业内分发。</li><li>对商店中下载的应用砸壳并修改内容后，希望重新打包并安装到手机上；</li></ul><p>这些都需要对<code>ipa</code>重新签名~</p><h2 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h2><p>移除原有签名，通过<code>codesign</code>工具对原 ipa 使用新证书重新签名并得到新的安装包。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ codesign<br>Usage: codesign -s identity <span class="hljs-comment">[-fv*]</span> <span class="hljs-comment">[-o flags]</span> <span class="hljs-comment">[-r reqs]</span> <span class="hljs-comment">[-i ident]</span> path ... # sign<br>       codesign -v <span class="hljs-comment">[-v*]</span> <span class="hljs-comment">[-R=&lt;req string&gt;|-R &lt;req file path&gt;]</span> path|<span class="hljs-comment">[+]</span>pid ... # verify<br>       codesign -d <span class="hljs-comment">[options]</span> path ... # display contents<br>       codesign -h pid ... # display hosting paths<br></code></pre></td></tr></table></figure><h2 id="3、流程"><a href="#3、流程" class="headerlink" title="3、流程"></a>3、流程</h2><h3 id="3-1-准备工作："><a href="#3-1-准备工作：" class="headerlink" title="3.1.准备工作："></a>3.1.准备工作：</h3><ul><li>解压ipa</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>unzip xx.ipa<br></code></pre></td></tr></table></figure><ul><li>找到开发者证书</li></ul><p>证书可以在钥匙串中查找，也可以通过下面的命令行来查找：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ <span class="hljs-keyword">security</span> find-<span class="hljs-keyword">identity</span> -p codesigning -v<br></code></pre></td></tr></table></figure><ul><li>找到开发环境配置文件并复制到<code>xx.app</code>文件夹下</li></ul><p>如果是自己的 ipa 那么这个<code>.mobileprovision</code>文件可以直接使用现成的，从<code>Xcode-&gt;账户</code>中找到，show in finder 后复制一份重命名为<code>embedded.mobileprovision</code>，拖到<code>.app</code>文件夹下即可</p><p>也可以使用命令行操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> xx.mobileprovision Payload/xx.app/embedded.mobileprovision</span><br></code></pre></td></tr></table></figure><p>注意：复制到<code>xx.app</code>目录下的配置文件一定要命名为<code>embedded.mobileprovision</code>！</p><ul><li>修改包的 Bundle Identifier</li></ul><p>如果是别人的 ipa 那么就要需要修改原安装包的<code>info.plist</code>中的<code>Bundle identifier</code>，使其与配置文件中的<code>Bundle Identifier</code>保持一致：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ <span class="hljs-regexp">/usr/</span>libexec<span class="hljs-regexp">/PlistBuddy -c &quot;Set :CFBundleIdentifier com.xx.xx&quot; Payload/</span>xx.app/Info.plist<br></code></pre></td></tr></table></figure><ul><li>生成新的 entitlements.plist</li></ul><p><a href="https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/AboutEntitlements.html">Entitlements</a> 是应用功能和授权相关的文件，涉及到iCloud、推送等功能的配置信息。可以通过开发环境配置文件重新生成一份，后面签名要用到：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ security cms -D -<span class="hljs-selector-tag">i</span> xx<span class="hljs-selector-class">.mobileprovision</span> &gt; profile.plist<br></code></pre></td></tr></table></figure><p>上面会生成一个完整的 plist，我们只需要里面的<code>Entitlements</code>字段，执行命令行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ <span class="hljs-regexp">/usr/</span>libexec/PlistBuddy -x -c <span class="hljs-string">&#x27;Print :Entitlements&#x27;</span> profile.plist &gt; entitlements.plist<br></code></pre></td></tr></table></figure><p>结果如下:</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_entitleplist.png" alt="plist"></p><ul><li>移除之前的签名文件夹：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">rm</span> -rf Payload/xx.app/_CodeSignature</span><br></code></pre></td></tr></table></figure><h3 id="3-2-重新签名："><a href="#3-2-重新签名：" class="headerlink" title="3.2.重新签名："></a>3.2.重新签名：</h3><p>重新签名有顺序，先把<code>framework</code>和<code>dylib</code>签名，最后再签名<code>xx.app/xx</code>，顺序弄错了，就算签名成功也可能会安装失败!</p><ul><li>重新签名framework：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ codesign -f -s <span class="hljs-string">&quot;iPhone Distribution: xxxx (xx)&quot;</span> --entitlements entitlements.plist <span class="hljs-regexp">/Payload/</span>xx.app<span class="hljs-regexp">/Frameworks/yy</span>.framework<br></code></pre></td></tr></table></figure><ul><li>重新签名应用的执行文件</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ codesign -f -s <span class="hljs-string">&quot;iPhone Distribution: xxxx (xx)&quot;</span> --entitlements entitlements.plist Payload<span class="hljs-regexp">/xx.app/</span>xx<br></code></pre></td></tr></table></figure><ul><li>查看应用签名信息</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">codesign -vv -d Payload/xx.app</span><br></code></pre></td></tr></table></figure><h3 id="3-3-调试"><a href="#3-3-调试" class="headerlink" title="3.3.调试"></a>3.3.调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ios-deploy -d -b Payload/xx.app</span><br></code></pre></td></tr></table></figure><p>出现<code>success</code>字样，就说明成功了~</p><p>如果遇到错误提示：“Error: There was an internal API error. AMDeviceSecureInstallApplication(0, device, url, options, install_callback, 0)”,就可能存在有 framework 或者 dylib 未签名的情况。这时就需要把 app 文件夹下的 framework 全都签名。</p><p>重新打包，生成新的ipa</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ zip -r <span class="hljs-keyword">new</span><span class="hljs-type"></span>.ipa Payload/<br></code></pre></td></tr></table></figure><p>接下来就可以通过 iTunes 或第三方工具安装到手机了~</p><hr><p>相关参考：</p><p>#<a href="https://www.jb51.net/article/132328.htm">©传送门</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dSYM+.crash解析</title>
    <link href="/2019/03/12/dsym.html"/>
    <url>/2019/03/12/dsym.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、dSYM"><a href="#一、dSYM" class="headerlink" title="一、dSYM"></a>一、<strong>dSYM</strong></h2><h4 id="1-dSYM"><a href="#1-dSYM" class="headerlink" title="1.dSYM"></a>1.dSYM</h4><p>调试符号表，是苹果为调试和定位问题而使用的一种调试文件。调试符号信息在构建应用时就保存在<code>Mach-O</code>文件中了，而<code>.dSYM</code>就是从<code>Mach-O</code>文件中抽取调试信息而得到的一个单独的文件目录。它使用的是 DWARF 结构，在 .xcarchive 目录中其层次结构如下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.xcarchive</span><br><span class="hljs-params">--dSYMs</span><br>  |<span class="hljs-params">--Your</span>.app.dSYM<br>    |<span class="hljs-params">--Contents</span><br>      |<span class="hljs-params">--Resources</span><br>        |<span class="hljs-params">--DWARF</span><br></code></pre></td></tr></table></figure><p>要生成 dSYM 文件，你可以在 Xcode 的<code>Build Settings</code>中这样设置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Generate <span class="hljs-built_in">Debug</span> Symbols = <span class="hljs-literal">YES</span><br><span class="hljs-built_in">Debug</span> Information Format = <span class="hljs-string">&quot;DWARF with dSYM File&quot;</span><br></code></pre></td></tr></table></figure><p>反之，如果你不想生成 dSYM 文件，则可以这样配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Generate <span class="hljs-built_in">Debug</span> Symbols = <span class="hljs-literal">NO</span><br>或者<br><span class="hljs-built_in">Debug</span> Information Format = <span class="hljs-string">&quot;DWARF&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-DWARF"><a href="#2-DWARF" class="headerlink" title="2.DWARF"></a>2.DWARF</h4><p>DWARF（DebuggingWith Arbitrary Record Formats），是 ELF 和 Mach-O 等文件格式中用来存储和处理调试信息的标准格式，<code>.dSYM</code>中真正保存符号表数据的是<code>DWARF</code>文件。DWARF 中不同的数据都保存在相应的<code>section</code>(节)中，ELF文件里所有的 section 名称都以<code>.debug_</code>开头，如下：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> Section Name         </span>|<span class="hljs-string"> Contents                                          </span>|<br>|<span class="hljs-string"> -------------------- </span>|<span class="hljs-string"> ------------------------------------------------  </span>|<br>|<span class="hljs-string"> .debug_abbrev        </span>|<span class="hljs-string"> Abbreviations used in the .debug_info section     </span>|<br>|<span class="hljs-string"> .debug_aranges       </span>|<span class="hljs-string"> A mapping between memory address and compilation  </span>|<br>|<span class="hljs-string"> .debug_frame         </span>|<span class="hljs-string"> Call Frame Information                            </span>|<br>|<span class="hljs-string"> .debug_info          </span>|<span class="hljs-string"> The core DWARF data containing DIEs               </span>|<br>|<span class="hljs-string"> .debug_line          </span>|<span class="hljs-string"> Line Number Program                               </span>|<br>|<span class="hljs-string"> .debug_loc           </span>|<span class="hljs-string"> Macro descriptions                                </span>|<br>|<span class="hljs-string"> .debug_macinfo       </span>|<span class="hljs-string"> A lookup table for global objects and functions   </span>|<br>|<span class="hljs-string"> .debug_pubnames      </span>|<span class="hljs-string"> A lookup table for global objects and functions   </span>|<span class="hljs-string"> </span><br><span class="hljs-string"></span>|<span class="hljs-string"> .debug_pubtypes      </span>|<span class="hljs-string"> A lookup table for global types                   </span>|<br>|<span class="hljs-string"> .debug_ranges        </span>|<span class="hljs-string"> Address ranges referenced by DIEs                 </span>|<br>|<span class="hljs-string"> .debug_str           </span>|<span class="hljs-string"> String table used by .debug_info</span><br></code></pre></td></tr></table></figure><p>Mach-O中关于<code>section</code>的命名和ELF稍有区别，把名称前的<code>.</code>换成了<code>_</code>，例如<code>.debug_info</code>变成了<code>_debug_info</code>。</p><p>保存在 DAWARF 中的信息是高度压缩的，可以通过<code>dwarfdump</code>命令从中提取出可读信息。前文所述的那些 section 中，定位闪退日志只需要用到<code>.debug_info</code>和<code>.debug_line</code>。由于解析出来的数据量较大，为了方便查看，就将其保存在文本中。两个 section 的数据提取方式如下：</p><ul><li>.debug_info</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ dwarfdump -e --debug-<span class="hljs-meta">info</span> YourApp.dSYM/Contents/Resources/DWARF &gt; <span class="hljs-meta">info</span>-e.txt<br></code></pre></td></tr></table></figure><ul><li>.debug_line</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ dwarfdump -e --<span class="hljs-keyword">debug</span>-<span class="hljs-keyword">line</span> YourApp.dSYM/Contents/Resources/DWARF &gt; <span class="hljs-keyword">line</span>-e.txt<br></code></pre></td></tr></table></figure><h4 id="3-闪退解析过程"><a href="#3-闪退解析过程" class="headerlink" title="3.闪退解析过程"></a>3.闪退解析过程</h4><ul><li>计算闪退地址对应符号表中的地址</li></ul><p>下面的第二章节中会详细讲解闪退日志中的<code>stack address</code>、<code>load address</code>以及怎样计算闪退地址在符号表中的 <code>symbol address</code>，这里以 0x52846 为例。</p><ul><li>.debug_info</li></ul><p><code>.debug_info</code>中最基本的描述单元为DIE（Debug Information Entry），首先我们要根据符号表闪退地址<code>0x52846</code>从<code>.debug_info</code>中取出包含这个地址的DIE单元。为了简单起见，直接贴出了从 info-e.txt 中取出的对应DIE，其部分内容如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-number">0</span><span class="hljs-variable">x00062112</span>:     <span class="hljs-variable">function</span> [<span class="hljs-number">99</span>] *<br>                <span class="hljs-variable">low</span> <span class="hljs-function"><span class="hljs-title">pc</span>( <span class="hljs-number">0</span><span class="hljs-variable">x000502e0</span> )</span><br>                <span class="hljs-variable">high</span> <span class="hljs-function"><span class="hljs-title">pc</span>( <span class="hljs-number">0</span><span class="hljs-variable">x00053730</span> )</span><br>                <span class="hljs-variable">frame</span> <span class="hljs-function"><span class="hljs-title">base</span>( <span class="hljs-variable">r7</span> )</span><br>                <span class="hljs-variable"><span class="hljs-class">object</span></span> <span class="hljs-function"><span class="hljs-title">pointer</span>( &#123;<span class="hljs-number">0</span><span class="hljs-variable">x0006212a</span>&#125; )</span><br>                <span class="hljs-function"><span class="hljs-title">name</span>( <span class="hljs-string">&quot;-[OBDFirstConnectViewController showOilPricePickerView]&quot;</span> )</span><br>                <span class="hljs-variable">decl</span> <span class="hljs-function"><span class="hljs-title">file</span>( <span class="hljs-string">&quot;/YourSourcePath/OBDFirstConnectViewController.m&quot;</span> )</span><br>                <span class="hljs-variable">decl</span> <span class="hljs-function"><span class="hljs-title">line</span>( <span class="hljs-number">870</span> )</span><br>                <span class="hljs-function"><span class="hljs-title">prototyped</span>( <span class="hljs-number">0</span><span class="hljs-variable">x01</span> )</span><br>                <span class="hljs-variable">APPLE</span> <span class="hljs-variable">instruction</span> <span class="hljs-variable">set</span> <span class="hljs-function"><span class="hljs-title">architecture</span>( <span class="hljs-number">0</span><span class="hljs-variable">x01</span> )</span><br></code></pre></td></tr></table></figure><p>可以看出，该DIE包含的是方法-[OBDFirstConnectViewController showOilPricePickerView]的内容，其地址范围是 0x000502e0–0x00053730，我们的目标地址 0x52846 正是在这个范围内，所以可以判定闪退发生在该方法的某一行中。</p><p>需要指出的是，上面这段DIE是为了介绍方便直接贴出来的，实际应用的时候需要通过搜索算法找出包含目标符号表闪退地址（这里是0x52846）的DIE。</p><p>从上述DIE中我们可以获取到这些信息：</p><ol><li>闪退所在源码文件：&#x2F;YourSourcePath&#x2F;OBDFirstConnectViewController.m</li><li>发生闪退的方法：-[OBDFirstConnectViewController showOilPricePickerView]</li><li>发生闪退的方法在源文件中的行号：870</li></ol><ul><li>. debug_line</li></ul><p>截止目前，我们可以获取到发生了闪退的方法的相关信息，但要想确定闪退发生的具体行号，还需要.debug_line 的帮助。</p><p>.debug_line 以一个方法为基本块，记了该方法中每一行对应的符号表地址。通过.debug_info 得知闪退发生的方法地址范围是 0x000502e0–0x00053730，通过起始地址 0x000502e0 再解析. debug_line 得到的 line-e.txt 中直接搜索即可得到闪退所在方法的. debug_line 数据，内容如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0</span>x000000<span class="hljs-number">00000502e0</span>    <span class="hljs-number">870</span> /YourSourcePath/OBDFirstConnectViewController.m<br><span class="hljs-number">0</span>x000000<span class="hljs-number">00000502e0</span>      <span class="hljs-number">0</span><br><span class="hljs-number">0</span>x000000<span class="hljs-number">00000502f0</span>    <span class="hljs-number">872</span><br><span class="hljs-number">0</span>x000000000005033c    <span class="hljs-number">873</span><br><span class="hljs-number">0</span>x00000<span class="hljs-number">00000050374</span>    <span class="hljs-number">874</span><br><span class="hljs-number">0</span>x000000000005039e    <span class="hljs-number">875</span><br><span class="hljs-number">0</span>x000000<span class="hljs-number">00000503c8</span>    <span class="hljs-number">876</span><br>...<br><span class="hljs-number">0</span>x00000<span class="hljs-number">00000052812</span>    <span class="hljs-number">880</span><br><span class="hljs-number">0</span>x000000000005283e    <span class="hljs-number">881</span><br><span class="hljs-number">0</span>x00000<span class="hljs-number">00000052846</span>    <span class="hljs-number">882</span><br><span class="hljs-number">0</span>x000000<span class="hljs-number">00000528c8</span>    <span class="hljs-number">883</span><br>...<br></code></pre></td></tr></table></figure><p>. debug_line 段的第一行内容标识了该方法的起始符号表地址，行号及方法所在文件路径，通过之前得到的闪退地址<code>0x52846</code>即可得知闪退发生在<code>882</code>行。</p><p>至此我们已经根据闪退地址解析出了闪退发生位置的详细信息：</p><ol><li>闪退所在源码文件：&#x2F;YourSourcePath&#x2F;OBDFirstConnectViewController.m；</li><li>发生闪退的方法：-[OBDFirstConnectViewController showOilPricePickerView]；</li><li>发生闪退的方法在源文件中的行号：870；</li><li>闪退发生在源文件中得行号：882。</li></ol><h2 id="二、-crash文件"><a href="#二、-crash文件" class="headerlink" title="二、.crash文件"></a>二、.crash文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Incident Identifier:</span> <span class="hljs-number">28593639</span><span class="hljs-number">-9021</span><span class="hljs-string">-4BF9-A730-0A4E644EE52E</span><br><span class="hljs-attr">CrashReporter Key:</span>   <span class="hljs-string">cf719616d48fff95262c17eaf002e4de3d3f9842</span><br><span class="hljs-attr">Hardware Model:</span>      <span class="hljs-string">iPhone8,1</span><br><span class="hljs-attr">Process:</span>             <span class="hljs-string">WeChat</span> [<span class="hljs-number">25431</span>]<br><span class="hljs-attr">Path:</span>                <span class="hljs-string">/var/../WeChat.app/WeChat</span><br><span class="hljs-attr">Identifier:</span>          <span class="hljs-string">com.tencent.xin</span><br><span class="hljs-attr">Version:</span>             <span class="hljs-number">6.5</span><span class="hljs-number">.7</span><span class="hljs-number">.32</span> <span class="hljs-string">(6.5.7)</span><br><span class="hljs-attr">Code Type:</span>           <span class="hljs-string">ARM-64</span> <span class="hljs-string">(Native)</span><br><span class="hljs-attr">Parent Process:</span>      <span class="hljs-string">launchd</span> [<span class="hljs-number">1</span>]<br><br><span class="hljs-attr">Date/Time:</span>           <span class="hljs-number">2017-04-29 14:12:13.13</span> <span class="hljs-string">+0800</span><br><span class="hljs-attr">Launch Time:</span>         <span class="hljs-number">2017-04-26 03:26:06.06</span> <span class="hljs-string">+0800</span><br><span class="hljs-attr">OS Version:</span>          <span class="hljs-string">iOS</span> <span class="hljs-number">9.3</span><span class="hljs-number">.5</span> <span class="hljs-string">(13G36)</span><br><span class="hljs-attr">Report Version:</span>      <span class="hljs-number">105</span><br><br><span class="hljs-attr">Exception Type:</span>  <span class="hljs-number">00000020</span><br><span class="hljs-attr">Exception Codes:</span> <span class="hljs-number">0x000000008badf00d</span><br><span class="hljs-attr">Exception Note:</span>  <span class="hljs-string">SIMULATED</span> <span class="hljs-string">(this</span> <span class="hljs-string">is</span> <span class="hljs-string">NOT</span> <span class="hljs-string">a</span> <span class="hljs-string">crash)</span><br><span class="hljs-attr">Highlighted by Thread:</span>  <span class="hljs-number">0</span><br><br><span class="hljs-attr">Thread 0 name:  Dispatch queue:</span> <span class="hljs-string">com.apple.main-thread</span><br><span class="hljs-attr">Thread 0:</span><br><span class="hljs-number">0</span>   <span class="hljs-string">libsystem_kernel.dylib</span>            <span class="hljs-number">0x0000000180f99014</span> <span class="hljs-number">0x180f98000</span> <span class="hljs-string">+</span> <span class="hljs-number">4116</span><br><span class="hljs-number">1</span>   <span class="hljs-string">libdispatch.dylib</span>                 <span class="hljs-number">0x0000000180e763e8</span> <span class="hljs-number">0x180e64000</span> <span class="hljs-string">+</span> <span class="hljs-number">74728</span><br><span class="hljs-number">2</span>   <span class="hljs-string">FrontBoardServices</span>                <span class="hljs-number">0x0000000182db63d4</span> <span class="hljs-number">0x182d94000</span> <span class="hljs-string">+</span> <span class="hljs-number">140244</span><br><span class="hljs-number">3</span>   <span class="hljs-string">FrontBoardServices</span>                <span class="hljs-number">0x0000000182d9e910</span> <span class="hljs-number">0x182d94000</span> <span class="hljs-string">+</span> <span class="hljs-number">43280</span><br><span class="hljs-number">15</span>  <span class="hljs-string">GraphicsServices</span>                  <span class="hljs-number">0x0000000182be0088</span> <span class="hljs-number">0x182bd4000</span> <span class="hljs-string">+</span> <span class="hljs-number">49288</span><br><span class="hljs-number">16</span>  <span class="hljs-string">UIKit</span>                             <span class="hljs-number">0x00000001865e6088</span> <span class="hljs-number">0x186568000</span> <span class="hljs-string">+</span> <span class="hljs-number">516232</span><br><span class="hljs-number">17</span>  <span class="hljs-string">WeChat</span>                            <span class="hljs-number">0x00000001000fbea4</span> <span class="hljs-number">0x100058000</span> <span class="hljs-string">+</span> <span class="hljs-number">671396</span><br><br><span class="hljs-attr">Binary Images:</span><br><span class="hljs-number">0x100058000</span> <span class="hljs-bullet">-</span> <span class="hljs-number">0x1033c3fff</span> <span class="hljs-string">WeChat</span> <span class="hljs-string">arm64</span>  <span class="hljs-string">&lt;8b7a21136f4434dfb2771b8a4218a0f1&gt;</span> <br><span class="hljs-string">/var/containers/Bundle/Application/26524DA8-D1E8-430D-8ECA-9D5ABE3CE3CA/WeChat.app/WeChat</span><br><span class="hljs-string">..</span><br></code></pre></td></tr></table></figure><p>上面是一个crash文件的大致内容，为了简洁删除了一部分。</p><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1.参数"></a>1.参数</h4><ul><li><strong>uuid：</strong></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Incident</span> Identifier: <span class="hljs-number">28593639</span>-<span class="hljs-number">9021</span>-<span class="hljs-number">4</span>BF9-A730-<span class="hljs-number">0</span>A4E644EE52E<br></code></pre></td></tr></table></figure><p>这是闪退文件中的 uuid ，根据这个 uuid 可确定与 dSYM 文件是否匹配，方法如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dwarfdump <span class="hljs-attr">--uuid</span> appName<span class="hljs-selector-class">.app</span>.dSYM/<br></code></pre></td></tr></table></figure><p>这个命令行会打印出该 dSYM 文件内所有架构的 uuid。</p><ul><li><strong>进程名[ID]</strong></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Process</span>:             WeChat<span class="hljs-meta"> [25431]</span><br></code></pre></td></tr></table></figure><p>上面 “WeChat” 表示的是闪退所在进程的名字，括号中的数字即为此进程的ID。</p><ul><li><strong>CPU架构：</strong></li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">Code</span> <span class="hljs-built_in">Type</span>:           ARM<span class="hljs-number">-64</span> (Native)<br></code></pre></td></tr></table></figure><ul><li><strong>程序运行时的映射信息:（Binary Images）</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Binary Images:<br><span class="hljs-number">0</span>x100058000 - <span class="hljs-number">0</span>x1033c3fff WeChat arm64  &lt;<span class="hljs-number">8</span>b7a21136f4434dfb2771b8a4218a0f1&gt; <br><span class="hljs-regexp">/var/</span>containers<span class="hljs-regexp">/Bundle/</span>Application<span class="hljs-regexp">/26524DA8-D1E8-430D-8ECA-9D5ABE3CE3CA/</span>WeChat.app/WeChat<br></code></pre></td></tr></table></figure><ol><li>第一列，应用二进制文件中代码段的起始地址~终止地址；（0x100058000 - 0x1033c3fff）</li><li>第二列，映射文件名；（WeChat）</li><li>第三列，uuid；（8b7a21136f4434dfb2771b8a4218a0f1）</li><li>第四列，映射文件路径；</li></ol><ul><li><strong>闪退的堆栈信息（Thread Backtrace）：</strong></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0</span>   libsystem_kernel<span class="hljs-number">.</span>dylib            <span class="hljs-number">0x0000000180f99014</span> <span class="hljs-number">0x180f98000</span> + <span class="hljs-number">4116</span><br><span class="hljs-number">1</span>   libdispatch<span class="hljs-number">.</span>dylib                 <span class="hljs-number">0x0000000180e763e8</span> <span class="hljs-number">0x180e64000</span> + <span class="hljs-number">74728</span><br><span class="hljs-number">2</span>   FrontBoardServices                <span class="hljs-number">0x0000000182db63d4</span> <span class="hljs-number">0x182d94000</span> + <span class="hljs-number">140244</span><br><span class="hljs-number">3</span>   FrontBoardServices                <span class="hljs-number">0x0000000182d9e910</span> <span class="hljs-number">0x182d94000</span> + <span class="hljs-number">43280</span><br>..<br><span class="hljs-number">15</span>  GraphicsServices                  <span class="hljs-number">0x0000000182be0088</span> <span class="hljs-number">0x182bd4000</span> + <span class="hljs-number">49288</span><br><span class="hljs-number">16</span>  UIKit                             <span class="hljs-number">0x00000001865e6088</span> <span class="hljs-number">0x186568000</span> + <span class="hljs-number">516232</span><br><span class="hljs-number">17</span>  WeChat                            <span class="hljs-number">0x00000001000fbea4</span> <span class="hljs-number">0x100058000</span> + <span class="hljs-number">671396</span><br></code></pre></td></tr></table></figure><ol><li>第一列：调用顺序；（0、1、2、3）</li><li>第二列：二进制库名；（WeChat、UIKit）</li><li>第三列：进程在运行时发生闪退处的地址；(stack address)</li><li>第四列：进程运行时的起始地址；(load address)</li><li>第五列：闪退处距离进程起始地址的偏移量；(slide)</li></ol><p>注意！！这里的 “stack address” 与 “load address” 都是16进制的，而 “slide” 则是10进制的。</p><h4 id="2-stack-address"><a href="#2-stack-address" class="headerlink" title="2.stack address"></a>2.stack address</h4><p>计算一下你就会发现，上面堆栈信息中，第四列+第五列 的内容与第三列在实质上是一样的。以下面的闪退堆栈信息的第 9 行为例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">Thread <span class="hljs-number">0</span>:<br><span class="hljs-number">0</span>   libobjc<span class="hljs-number">.</span>A<span class="hljs-number">.</span>dylib         <span class="hljs-number">0x33f10f60</span> <span class="hljs-number">0x33efe000</span> + <span class="hljs-number">77664</span><br><span class="hljs-number">1</span>   Foundation              <span class="hljs-number">0x273526ac</span> <span class="hljs-number">0x2734a000</span> + <span class="hljs-number">34476</span><br><span class="hljs-number">9</span>   Your                    <span class="hljs-number">0x000f0846</span> <span class="hljs-number">0xa2000</span> + <span class="hljs-number">321606</span><br><span class="hljs-number">28</span>  Your                    <span class="hljs-number">0x0024643a</span> <span class="hljs-number">0xa2000</span> + <span class="hljs-number">1721402</span><br><span class="hljs-number">29</span>  libdyld<span class="hljs-number">.</span>dylib           <span class="hljs-number">0x34484aac</span> <span class="hljs-number">0x34483000</span> + <span class="hljs-number">6828</span><br><br>Binary Images:<br><span class="hljs-number">0xa2000</span> - <span class="hljs-number">0x541fff</span> Your armv7<br>/var/mobile/Containers/Bundle/Application/645D3184-4C20-<span class="hljs-number">4161</span>-924B-BDE170FA64CC/Your<span class="hljs-number">.</span>app/Your<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">stack address <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x000f0846<span class="hljs-comment">;</span><br>load address <span class="hljs-operator">=</span> <span class="hljs-number">0</span>xa2000<span class="hljs-comment">;</span><br><span class="hljs-attribute">slide</span> <span class="hljs-operator">=</span> <span class="hljs-number">321606</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>将 slide 转换为 16 进制后（即 0x4E846）与 load address 相加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">0x000f0846</span> = <span class="hljs-number">0</span>xa2000 + <span class="hljs-number">0</span>x4E846<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>所以，我们可以得出这么一个公式：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">stack address</span> = load address + slide;<br></code></pre></td></tr></table></figure><p>注意！！这里 “stack address” 和 “load address” 均为程序在运行时的地址。要想利用符号表解析出闪退对应位置，需要计算出符号表中对应的闪退堆栈地址（symbol address）。</p><h4 id="3-symbol-address"><a href="#3-symbol-address" class="headerlink" title="3.symbol address"></a>3.symbol address</h4><p>我们打开一个应用时，内核会为该应用创建一个新的进程，并把应用的二进制文件加载到一片虚拟地址空间中。iOS4.3 后为了阻止内存溢出攻击苹果在iOS中使用了 <a href="https://ctinusdev.github.io/2017/08/20/Mach-OBasis_ASLR/">ASLR</a> 技术。这样进程每次启动时，地址空间都会被简单地随机化，所以每次加载时地址都不一样。这里的随机只是偏移不是搅乱，实现方式是通过内核将 Mach-O 的段“平移”某个随机数。</p><p>根据虚拟内存偏移量不变原理，只要提供了符号表 __TEXT 段的起始地址(vmaddr)，再加上偏移量（这里为0x4E846）就能得到符号表中的堆栈地址（symbol address），计算方法为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">symbol address</span> = vmaddr + slide;<br></code></pre></td></tr></table></figure><p>如何获取符号表中的 __TEXT 段起始地址呢?</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$otool</span> -l xx.app.dSYM<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/DWARF/</span>xx<br></code></pre></td></tr></table></figure><p>注意把 xx 替换为你自己的应用名。运行结果中的片段如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Load</span> command <span class="hljs-number">3</span><br>      <span class="hljs-attribute">cmd</span> LC_SEGMENT<br>  <span class="hljs-attribute">cmdsize</span> <span class="hljs-number">736</span><br>  <span class="hljs-attribute">segname</span> __TEXT<br>   <span class="hljs-attribute">vmaddr</span> <span class="hljs-number">0</span>x00004000<br>   <span class="hljs-attribute">vmsize</span> <span class="hljs-number">0</span>x00700000<br>  <span class="hljs-attribute">fileoff</span> <span class="hljs-number">0</span><br> <span class="hljs-attribute">filesize</span> <span class="hljs-number">0</span><br>  <span class="hljs-attribute">maxprot</span> <span class="hljs-number">0</span>x00000005<br> <span class="hljs-attribute">initprot</span> <span class="hljs-number">0</span>x00000005<br>   <span class="hljs-attribute">nsects</span> <span class="hljs-number">10</span><br>    <span class="hljs-attribute">flags</span> <span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>其中的 vmaddr 0x00004000 字段即为 __TEXT 段的起始地址。</p><p>由公式：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">symbol address</span> = vmaddr + slide;<br></code></pre></td></tr></table></figure><p>可得出：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">0x52846</span> = <span class="hljs-number">0</span>x4000 + <span class="hljs-number">0</span>x4E846<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>即符号表中的闪退地址 &#x3D; 0x52846，接下来就可以根据这个地址解析出闪退位置了。</p><h2 id="三、解析方案"><a href="#三、解析方案" class="headerlink" title="三、解析方案"></a>三、解析方案</h2><h3 id="1-dwarfdump"><a href="#1-dwarfdump" class="headerlink" title="1.dwarfdump"></a>1.dwarfdump</h3><p>命令如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-variable">$dwarfdump</span> --<span class="hljs-keyword">arch</span> armv7 Your.<span class="hljs-keyword">app</span>.dSYM --<span class="hljs-keyword">lookup</span> 0x52846 | grep &#x27;<span class="hljs-keyword">Line</span> <span class="hljs-keyword">table</span>&#x27;<br></code></pre></td></tr></table></figure><p>需要注意的是：这里的 armv7 是运行设备的 CPU 指令集，而不是二进制文件的指令集。比如 armv7 指令集的二进制文件运行在 arm64 指令集的设备上，这个地方应该写 arm64。</p><ul><li>–lookup 后面跟的一定是经过准确计算的符号表中的闪退地址</li><li>使用 dwarfdump 解析的结果较杂乱，因此使用 grep 命令抓取其中关键点展示出来</li></ul><p>运行结果如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Line</span> <span class="hljs-keyword">table</span> dir : <span class="hljs-string">&#x27;/data/.../Src/OBDConnectSetting/Controller&#x27;</span><br><span class="hljs-type">Line</span> <span class="hljs-keyword">table</span> file: <span class="hljs-string">&#x27;OBDFirstConnectViewController.m&#x27;</span> <span class="hljs-type">line</span> <span class="hljs-number">882</span>, <span class="hljs-keyword">column</span> <span class="hljs-number">5</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">start</span> address <span class="hljs-number">0x000000000052768</span><br></code></pre></td></tr></table></figure><p>其中第一行是编译时文件目录，第二行包含了闪退发生的文件名称以及文件中具体行号等信息，有了这些信息就能准确定位闪退原因啦。</p><hr><h3 id="2-atos"><a href="#2-atos" class="headerlink" title="2.atos"></a>2.atos</h3><p>atos 命令可以解析出指定某一行的堆栈，使用方式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$atos</span> -o <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/crash/</span>AppName.app/AppName -arch armv7 <span class="hljs-number">0</span>x52846<br></code></pre></td></tr></table></figure><p>其执行结果如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">-<span class="hljs-selector-attr">[OBDFirstConnectViewController showOilPricePickerView]</span> (in Your) (OBDFirstConnectViewController.m:<span class="hljs-number">882</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="3-无需计算闪退地址"><a href="#3-无需计算闪退地址" class="headerlink" title="3.无需计算闪退地址"></a>3.无需计算闪退地址</h3><p>atos 还提供了另外一种无需计算闪退地址对应的符号表地址的方式，命令格式如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$atos</span> -o Your.app.dSYM<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/DWARF/</span>Your -arch armv7 -l [load address] [stack address]<br></code></pre></td></tr></table></figure><p>其中 -l 选项指定了二进制文件在运行时的 <strong>load address</strong> (0xa2000)，后面跟的是闪退发生时的 <strong>stack address</strong> (0x000f0846)。解析结果：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">-<span class="hljs-selector-attr">[OBDFirstConnectViewController showOilPricePickerView]</span> (in Your) (OBDFirstConnectViewController.m:<span class="hljs-number">882</span>)<br></code></pre></td></tr></table></figure><h3 id="4-shell脚本"><a href="#4-shell脚本" class="headerlink" title="4.shell脚本"></a>4.shell脚本</h3><p>桌面新建一个crash文件夹，把dSYM文件、友盟日志txt 及 shell 脚本放进来。</p><ul><li>友盟日志内容：</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">Application received signal SIGSEGV<br>(null)<br>((<br><span class="hljs-number">0</span> CoreFoundation<span class="hljs-number">0x0000000190f311b8</span> <span class="hljs-number">0x0000000190e01000</span> + <span class="hljs-number">1245624</span><br><span class="hljs-number">1</span> libobjc<span class="hljs-number">.</span>A<span class="hljs-number">.</span>dylib<span class="hljs-number">0x000000018f96855c</span> objc_exception_throw + <span class="hljs-number">56</span><br><span class="hljs-number">2</span> CoreFoundation<span class="hljs-number">0x0000000190f3108c</span> <span class="hljs-number">0x0000000190e01000</span> + <span class="hljs-number">1245324</span><br><span class="hljs-number">3</span> Foundation<span class="hljs-number">0x00000001919e902c</span> <span class="hljs-number">0x000000019193b000</span> + <span class="hljs-number">712748</span><br><span class="hljs-number">4</span> UIKit<span class="hljs-number">0x00000001976c5704</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">9365252</span><br><span class="hljs-number">5</span> UIKit<span class="hljs-number">0x00000001976c5afc</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">9366268</span><br><span class="hljs-number">6</span> UIKit<span class="hljs-number">0x00000001976c6f0c</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">9371404</span><br><span class="hljs-number">7</span> UIKit<span class="hljs-number">0x00000001975f1c10</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">8498192</span><br><span class="hljs-number">8</span> UIKit<span class="hljs-number">0x00000001975f1e28</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">8498728</span><br><span class="hljs-number">9</span> MyApp<span class="hljs-number">0x0000000100223668</span> <span class="hljs-number">0x00000001000ac000</span> + <span class="hljs-number">1537640</span><br><span class="hljs-number">10</span> MyApp<span class="hljs-number">0x00000001001e1588</span> <span class="hljs-number">0x00000001000ac000</span> + <span class="hljs-number">1267080</span><br><span class="hljs-number">11</span> UIKit<span class="hljs-number">0x00000001973aef80</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">6127488</span><br><span class="hljs-number">12</span> UIKit<span class="hljs-number">0x00000001973b2748</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">6141768</span><br><span class="hljs-number">13</span> UIKit<span class="hljs-number">0x0000000196f7973c</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">1713980</span><br><span class="hljs-number">14</span> UIKit<span class="hljs-number">0x0000000196e180f0</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">266480</span><br><span class="hljs-number">15</span> UIKit<span class="hljs-number">0x00000001973a2680</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">6076032</span><br><span class="hljs-number">16</span> UIKit<span class="hljs-number">0x00000001973a21e0</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">6074848</span><br><span class="hljs-number">17</span> UIKit<span class="hljs-number">0x00000001973a149c</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">6071452</span><br><span class="hljs-number">18</span> UIKit<span class="hljs-number">0x0000000196e1630c</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">258828</span><br><span class="hljs-number">19</span> UIKit<span class="hljs-number">0x0000000196de6da0</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">64928</span><br><span class="hljs-number">20</span> MyApp<span class="hljs-number">0x00000001005b01b4</span> __cxa_throw + <span class="hljs-number">2250128</span><br><span class="hljs-number">21</span> UIKit<span class="hljs-number">0x00000001975d075c</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">8361820</span><br><span class="hljs-number">22</span> UIKit<span class="hljs-number">0x00000001975ca130</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">8335664</span><br><span class="hljs-number">23</span> CoreFoundation<span class="hljs-number">0x0000000190edeb5c</span> <span class="hljs-number">0x0000000190e01000</span> + <span class="hljs-number">908124</span><br><span class="hljs-number">24</span> CoreFoundation<span class="hljs-number">0x0000000190ede4a4</span> <span class="hljs-number">0x0000000190e01000</span> + <span class="hljs-number">906404</span><br><span class="hljs-number">25</span> CoreFoundation<span class="hljs-number">0x0000000190edc0a4</span> <span class="hljs-number">0x0000000190e01000</span> + <span class="hljs-number">897188</span><br><span class="hljs-number">26</span> CoreFoundation<span class="hljs-number">0x0000000190e0a2b8</span> CFRunLoopRunSpecific + <span class="hljs-number">444</span><br><span class="hljs-number">27</span> GraphicsServices<span class="hljs-number">0x00000001928be198</span> GSEventRunModal + <span class="hljs-number">180</span><br><span class="hljs-number">28</span> UIKit<span class="hljs-number">0x0000000196e517fc</span> <span class="hljs-number">0x0000000196dd7000</span> + <span class="hljs-number">501756</span><br><span class="hljs-number">29</span> UIKit<span class="hljs-number">0x0000000196e4c534</span> UIApplicationMain + <span class="hljs-number">208</span><br><span class="hljs-number">30</span> MyApp<span class="hljs-number">0x00000001001b5804</span> <span class="hljs-number">0x00000001000ac000</span> + <span class="hljs-number">1087492</span><br><span class="hljs-number">31</span> libdyld<span class="hljs-number">.</span>dylib<span class="hljs-number">0x000000018fded5b8</span> <span class="hljs-number">0x000000018fde9000</span> + <span class="hljs-number">17848</span><br>)<br><br>dSYM UUID: 1852C4B7-<span class="hljs-number">8391</span>-<span class="hljs-number">3615</span>-ADA5-2EE58D11DDED<br><span class="hljs-meta">CPU</span> Type: armv7<br>Slide Address: <span class="hljs-number">0x00004000</span><br>Binary Image: MyApp<br>Base Address: <span class="hljs-number">0x000ca000</span><br></code></pre></td></tr></table></figure><ul><li>shell脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs bash">DSYM=<span class="hljs-variable">$1</span><br>LOGFILE=<span class="hljs-variable">$2</span><br><br><span class="hljs-keyword">if</span> [ ! -n <span class="hljs-string">&quot;<span class="hljs-variable">$DSYM</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt; DSYM is missing!!!&quot;</span><br>  <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ ! -n <span class="hljs-string">&quot;<span class="hljs-variable">$LOGFILE</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&gt;&gt;&gt;&gt; log file is missing!!!&quot;</span><br>  <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span> <br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/////////////////////&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; Info get... &quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/////////////////////&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><br>DSYM_UUID_KEY=<span class="hljs-string">&quot;dSYM UUID: &quot;</span><br>DSYM_CPUTYPE_KEY=<span class="hljs-string">&quot;CPU Type: &quot;</span><br>DSYM_BINARY_KEY=<span class="hljs-string">&quot;Binary Image: &quot;</span><br><br><span class="hljs-comment"># first loop get uuid, cpu, binary</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> singleLine<br><span class="hljs-keyword">do</span><br>str=<span class="hljs-string">&quot;<span class="hljs-variable">$singleLine</span>&quot;</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$str</span> == <span class="hljs-variable">$DSYM_UUID_KEY</span>* ]]; <span class="hljs-keyword">then</span><br>UUID=<span class="hljs-variable">$&#123;str#*&quot;$DSYM_UUID_KEY&quot;&#125;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Log UUID: &quot;</span><span class="hljs-variable">$UUID</span>; <br><span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$str</span> == <span class="hljs-variable">$DSYM_CPUTYPE_KEY</span>* ]]; <span class="hljs-keyword">then</span><br>CPU=<span class="hljs-variable">$&#123;str#*&quot;$DSYM_CPUTYPE_KEY&quot;&#125;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Log CPU: &quot;</span><span class="hljs-variable">$CPU</span>; <br><span class="hljs-keyword">elif</span> [[ <span class="hljs-variable">$str</span> == <span class="hljs-variable">$DSYM_BINARY_KEY</span>* ]]; <span class="hljs-keyword">then</span><br>BINARY=<span class="hljs-variable">$&#123;str#*&quot;$DSYM_BINARY_KEY&quot;&#125;</span>;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Log BINARY: &quot;</span><span class="hljs-variable">$BINARY</span>; <br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-variable">$LOGFILE</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/////////////////////&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; Info check... &quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/////////////////////&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><br>checkUUID=`dwarfdump --uuid <span class="hljs-variable">$DSYM</span> -<span class="hljs-built_in">arch</span> <span class="hljs-variable">$CPU</span>`<br>checkUUID=<span class="hljs-variable">$&#123;checkUUID#*&quot;UUID: &quot;&#125;</span><br>checkUUID=<span class="hljs-variable">$&#123;checkUUID%&quot; ($CPU)&quot;*&#125;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;DSYM UUID: <span class="hljs-variable">$checkUUID</span>&quot;</span><br><br><span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$UUID</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$checkUUID</span>&quot;</span> ]]; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;UUID check passed.&quot;</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Warning!!!!!! UUID is not the same.. even though the code could be.&quot;</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/////////////////////&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot; Log trace... &quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/////////////////////&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">#final loop get trace</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> singleLine<br><span class="hljs-keyword">do</span><br>str=<span class="hljs-string">&quot;<span class="hljs-variable">$singleLine</span>&quot;</span><br> <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$str</span> == <span class="hljs-variable">$DSYM_BINARY_KEY</span>* ]]; <span class="hljs-keyword">then</span><br><span class="hljs-comment">#delete image</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">else</span><br><br><span class="hljs-comment"># 匹配并删除第一个空格及其左边的所有字符，结果如下：</span><br><span class="hljs-comment"># MyApp0x0000000100223668 0x00000001000ac000 + 1537640</span><br>str=<span class="hljs-variable">$&#123;str#*&quot; &quot;&#125;</span><br><br><span class="hljs-comment"># 如果当前行是我们自己项目的日志</span><br><span class="hljs-keyword">if</span> [[ <span class="hljs-variable">$str</span> == *<span class="hljs-variable">$BINARY</span>* ]]; <span class="hljs-keyword">then</span><br><br><span class="hljs-comment"># 匹配并删除第一个制表符及其左边的所有字符，即去掉第一列行号、第二列项目名，结果如下：</span><br><span class="hljs-comment"># 0x0000000100223668 0x00000001000ac000 + 1537640</span><br>str=<span class="hljs-variable">$&#123;str#*&quot;&quot;&#125;</span>;<br><br><span class="hljs-comment"># 匹配并删除&quot;空格+空格&quot;及其右边的所有字符，即去掉第一列行号、第二列项目名、第四列slide，结果如下：</span><br><span class="hljs-comment"># 0x0000000100223668 0x00000001000ac000</span><br>str=<span class="hljs-variable">$&#123;str%&quot; + &quot;*&#125;</span><br><br><span class="hljs-comment"># 以空格为分隔符，分别提取前后两部分字符</span><br>s1=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span> | awk -F <span class="hljs-string">&quot; &quot;</span> <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)   <span class="hljs-comment"># 获取第1部分并赋值给变量，即为stack address</span><br>s2=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$str</span> | awk -F <span class="hljs-string">&quot; &quot;</span> <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)   <span class="hljs-comment"># 获取第2部分并赋值给变量，即为load address</span><br><span class="hljs-comment"># echo &quot;stack address:$s1,load address:$s2&quot;</span><br><br><span class="hljs-comment"># 开始解析日志</span><br><span class="hljs-built_in">echo</span> `atos -o <span class="hljs-variable">$DSYM</span>/Contents/Resources/DWARF/<span class="hljs-variable">$BINARY</span> -<span class="hljs-built_in">arch</span> <span class="hljs-variable">$CPU</span> -l <span class="hljs-variable">$s2</span> <span class="hljs-variable">$s1</span>`<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">done</span> &lt; <span class="hljs-variable">$LOGFILE</span><br></code></pre></td></tr></table></figure><p>执行脚本:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/trace_dsyms.sh Release.dSYM/</span> crash<br></code></pre></td></tr></table></figure><p>解析后的闪退堆栈如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br> Info get... <br>/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><br>Log <span class="hljs-variable constant_">UUID</span>: 1852C4B7-<span class="hljs-number">8391</span>-<span class="hljs-number">3615</span>-<span class="hljs-variable constant_">ADA5</span>-2EE58D11DDED<br>Log <span class="hljs-variable constant_">CPU</span>: armv7<br>Log <span class="hljs-variable constant_">BINARY</span>: MyApp<br><br>/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br> Info check... <br>/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><br><span class="hljs-variable constant_">DSYM</span> <span class="hljs-variable constant_">UUID</span>: 1852C4B7-<span class="hljs-number">8391</span>-<span class="hljs-number">3615</span>-<span class="hljs-variable constant_">ADA5</span>-2EE58D11DDED<br><span class="hljs-variable constant_">UUID</span> check passed.<br><br>/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br> Log trace... <br>/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><br>-[TLTaoBaoBindViewController setUps] (<span class="hljs-keyword">in</span> MyApp) (TLTaoBaoBindViewController.<span class="hljs-symbol">m:</span><span class="hljs-number">234</span>)<br>-[MBProgressHUD labelText] (<span class="hljs-keyword">in</span> MyApp) (MBProgressHUD.<span class="hljs-symbol">h:</span><span class="hljs-number">313</span>)<br>[invalid usage]: slide is <span class="hljs-keyword">not</span> a recognized number<br>-[TLLoginManager <span class="hljs-symbol">httpTelLoginWithDistrict:</span><span class="hljs-symbol">mobile:</span><span class="hljs-symbol">captcha:</span><span class="hljs-symbol">fromVC:</span>] (<span class="hljs-keyword">in</span> MyApp) (TLLoginManager.<span class="hljs-symbol">m:</span><span class="hljs-number">277</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="5-symbolicatecrash"><a href="#5-symbolicatecrash" class="headerlink" title="5.symbolicatecrash"></a>5.symbolicatecrash</h3><p><strong>symbolicatecrash</strong> 是Xcode自带的一个分析工具，可以通过机器上的闪退日志和应用的.dSYM文件定位发生闪退的位置，把crash日志中的地址替换成代码相应位置。</p><p>1、文件准备：<strong>.app</strong> 与 <strong>.dSYM</strong> 文件</p><ul><li>拷贝 <strong>.crash</strong> 文件到桌面新建的crash文件夹内；</li><li>Xcode-&gt;Window-&gt;Organizer-&gt;APP-&gt;Show in Finder；</li><li><strong>.xcarchive</strong>文件-&gt;显示包内容，找到 <em>.app.dSYM 与</em> .app文件，并复制到 crash 目录中；</li></ul><p>2、找到symbolicatecrash</p><ul><li>终端中执行下面命令：</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">find</span> <span class="hljs-regexp">/Applications/</span>Xcode.app -name symbolicatecrash -type f<br></code></pre></td></tr></table></figure><ul><li>稍等就会输出symbolicatecrash路径</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>SharedFrameworks<span class="hljs-regexp">/DVTFoundation.framework/</span>Versions<span class="hljs-regexp">/A/</span>Resources/symbolicatecrash<br></code></pre></td></tr></table></figure><ul><li>拷贝symbolicatecrash到crash目录中，与上面俩文件放到一起。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp <span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>SharedFrameworks<span class="hljs-regexp">/DVTFoundation.framework/</span>Versions<span class="hljs-regexp">/A/</span>Resources<span class="hljs-regexp">/symbolicatecrash /</span>Users<span class="hljs-regexp">/xxx/</span>Desktop/crash<br><br></code></pre></td></tr></table></figure><p>3、执行symbolicatecrash</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/Desktop/</span>crash<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/symbolicatecrash /</span>Users<span class="hljs-regexp">/xxx/</span>Desktop<span class="hljs-regexp">/crash/</span>xxx.crash <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/Desktop/</span>crash/xxx.app.dSYM &gt; new_symbol.crash<br></code></pre></td></tr></table></figure><ul><li>这时候终端有可能会出现：</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>&quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.<br></code></pre></td></tr></table></figure><ul><li>输入命令：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">DEVELOPER_DIR</span>=<span class="hljs-string">&quot;/Applications/XCode.app/Contents/Developer&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>再执行，这时候终端将会进行处理了。</p></li><li><p>终端完成后，在 crash 文件夹里会多出一个new_symbol.crash文件，打开即可查看BUG详情。</p></li></ul><hr><p>相关参考：</p><p>#<a href="http://foggry.com/blog/2015/07/27/ru-he-shou-dong-jie-xi-crashlog/">©王中周-手动解析CrashLog之—-方法篇</a></p><p>#<a href="http://foggry.com/blog/2015/08/10/ru-he-shou-dong-jie-xi-crashlogzhi-yuan-li-pian/">©王中周-手动解析CrashLog之—-原理篇</a></p><p>#<a href="https://ctinusdev.github.io/2017/08/20/Mach-OBasis_ASLR/">©ctinusdev-Mach-O文件介绍之ASLR</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用的启动过程</title>
    <link href="/2019/02/25/launch.html"/>
    <url>/2019/02/25/launch.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章整理自 <a href="https://techblog.toutiao.com/2017/01/17/iosspeed/">头条技术</a> 和 <a href="https://www.jianshu.com/p/43db6b0aab8e">DevilH</a> 等的博客，具体请看最后的参考链接。</p></blockquote><h2 id="启动过程分解"><a href="#启动过程分解" class="headerlink" title="启动过程分解"></a>启动过程分解</h2><p>应用启动的过程可分为两步：</p><blockquote><p><strong>t</strong>（总）&#x3D; <strong>t1</strong>（<code>main函数</code>之前） + <strong>t2</strong>（<code>main函数</code>之后）</p></blockquote><p><strong>t1</strong>：加载系统动态库和应用可执行文件；</p><p><strong>t2</strong>：构建界面并完成渲染和展示：<code>main函数</code>到<code>-application:didFinishLaunchingWithOptions:</code>回调执行结束；</p><h3 id="1、main-函数之前"><a href="#1、main-函数之前" class="headerlink" title="1、main 函数之前"></a>1、main 函数之前</h3><p>main函数之前启动过程的简单总结：</p><ol><li>系统内核<code>XNU</code>先读取应用的可执行文件，加载动态链接器<code>dyld</code>；</li><li>动态链接器初始化运行环境，加载程序相关依赖库，并对这些库进行链接；</li><li>接着调用每个依赖库的初始化方法（runtime在这一步被初始化）；</li><li>初始化程序可执行文件。这时runtime会初始化所有类的类结构，调用所有的<code>+load</code>方法；</li><li>最后<code>dyld</code>返回<code>main函数</code>地址，<code>main函数</code>被调用，来到我们的程序入口。</li></ol><h4 id="1-1-加载可执行文件"><a href="#1-1-加载可执行文件" class="headerlink" title="1.1.加载可执行文件"></a>1.1.加载可执行文件</h4><p>大致的过程是：</p><ul><li>内核启动进程管理器，为我们的应用创建新的进程；</li><li>调用<code>load_machfile()</code>函数加载<code>Mach-O</code>，这里会设置虚拟内存大小、设置<code>ASLR</code>随机数；<code>load_machfile()</code>内部继续调用<code>parse_machfile()</code>函数对<code>Mach-O</code>文件进行深度解析；</li><li><code>parse_machfile</code>先将<code>Mach-O</code>文件的所有的加载命令<code>Load Commends</code>映射进内核的内存，再分三趟解析这些加载命令。应用的可执行文件和<code>dyld</code>都是<code>Mach-O</code>文件，<code>parse_machfile()</code>在解析可执行文件时会继续调用<code>load_dylinker()</code>来处理加载命令<code>LC_LOAD_DYLINKER</code>；</li><li><code>load_dylinker</code>内递归调用<code>parse_machfile</code>解析<code>dyld</code>，成功后<code>dyld</code>开始加载共享库；</li><li>解析完可执行二进制文件类型的<code>Mach-O</code>文件后(假设为A)，会得到A的入口点；但线程并不会立刻进入到这个入口点。因为还要加载动态链接器<code>dyld</code>，在<code>load_dylinker()</code>中，<code>dyld</code>会保存A的入口点，递归调用<code>parse_machfile()</code>后，将线程入口点设为<code>dyld</code>的入口点。<code>dyld</code>完成加载库的工作之后，再将入口点设回A的入口点，程序启动完成。</li></ul><h4 id="1-2-dyld的工作流程"><a href="#1-2-dyld的工作流程" class="headerlink" title="1.2.dyld的工作流程"></a>1.2.dyld的工作流程</h4><p>dyld 加载成功后会接管后续的启动任务：</p><ol><li>Load dylibs image；</li><li>Rebase image；</li><li>Bind image；</li><li>ObjC Setup；</li><li>Initializers；</li></ol><h5 id="i-Load-dylibs-image"><a href="#i-Load-dylibs-image" class="headerlink" title="i.Load dylibs image"></a>i.Load dylibs image</h5><p>dyld将可执行文件以及依赖的库递归地加载进内存，生成对应的镜像对象：</p><ol><li>分析所依赖的动态库；</li><li>找到动态库的mach-o文件；</li><li>打开文件；</li><li>验证文件；</li><li>在系统核心注册文件签名；</li><li>对动态库的每一个segment调用mmap()；</li></ol><p>针对这一步骤的优化有：</p><ol><li>减少非系统库的依赖；</li><li>合并非系统库；</li><li>使用静态资源，比如把代码加入主程序；</li></ol><h5 id="ii-链接镜像"><a href="#ii-链接镜像" class="headerlink" title="ii.链接镜像"></a>ii.链接镜像</h5><p>对上面生成的镜像进行链接，主要是对镜像进行<code>rebase/bind</code>。</p><p>由于ASLR的存在，每次启动时，可执行文件和动态链接库在虚拟内存中的加载地址都不固定，所以需要这2步来修复镜像中资源的指针。</p><ul><li>rebase 修复的是指向当前镜像内部的资源指针；</li><li>bind 修复的是指向当前镜像外部的资源指针；</li></ul><p>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。</p><p>优化该阶段的关键在于减少<code>__DATA segment</code>中的指针数量：</p><ol><li>减少 Objc 类数量， 减少 selector 数量；</li><li>减少 C++ 虚函数数量；</li><li>使用 Swift stuct，减少符号的数量；</li></ol><h5 id="iii-ObjC-Setup"><a href="#iii-ObjC-Setup" class="headerlink" title="iii.ObjC Setup"></a>iii.ObjC Setup</h5><p>主要是调用各镜像的初始化方法：</p><ol><li>注册Objc类 (class registration)；</li><li>把category的定义插入方法列表 (category registration)；</li><li>保证每一个selector唯一 (selctor uniquing)；</li></ol><h5 id="iv-initializers"><a href="#iv-initializers" class="headerlink" title="iv.initializers"></a>iv.initializers</h5><p>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容：</p><ol><li>Objc的<code>+load()</code>函数；</li><li>C++的构造函数属性函数，形如 attribute((constructor)) void DoSomeInitializationWork()；</li><li>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) ，比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度；</li></ol><hr><p>至此，可执行文件和动态库中的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，由 runtime 管理。这之后 runtime 的那些方法(动态添加Class、swizzle等)才能生效。</p><p>整个事件由dyld主导，完成运行环境的初始化后，将二进制文件按格式加载到内存，动态链接依赖库，并由 runtime 加载成 objc 定义的结构，所有初始化工作结束后，dyld调用真正的<code>main</code>函数。</p><hr><p>冷启动与热启动：</p><ul><li>热启动：如果程序刚刚被运行过，则程序代码会被 dyld 缓存，即使杀掉进程再次重启，加载时间也会相对快一点；</li><li>冷启动：如果长时间没有启动或者当前 dyld 的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点；</li></ul><hr><p>怎么衡量<code>main()</code>之前的耗时呢？苹果官方提供了一种方法：在Xcode中，设置环境变量<code>DYLD_PRINT_STATISTICS</code>和<code>DYLD_PRINT_STATISTICS_DETAILS</code>后运行来查看耗时。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">E<span class="hljs-function"><span class="hljs-title">dit</span> Schemes-&gt;</span>R<span class="hljs-function"><span class="hljs-title">un</span>-&gt;</span>A<span class="hljs-function"><span class="hljs-title">rguments</span>-&gt;</span>E<span class="hljs-function"><span class="hljs-title">nvironment</span> Variables-&gt;</span>新增上述变量之一，value=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>设置后再次启动APP即可在控制台看到日志：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">Total</span> pre-main time: <span class="hljs-number">1</span>.<span class="hljs-number">3</span> seconds (<span class="hljs-number">100</span>.<span class="hljs-number">0</span>%)<br>  <span class="hljs-attribute">dylib</span> loading time: <span class="hljs-number">160</span>.<span class="hljs-number">66</span> milliseconds (<span class="hljs-number">11</span>.<span class="hljs-number">5</span>%)<br> <span class="hljs-attribute">rebase</span>/binding time: <span class="hljs-number">1</span>.<span class="hljs-number">1</span> seconds (<span class="hljs-number">81</span>.<span class="hljs-number">2</span>%)<br>     <span class="hljs-attribute">ObjC</span> setup time:  <span class="hljs-number">52</span>.<span class="hljs-number">53</span> milliseconds (<span class="hljs-number">3</span>.<span class="hljs-number">7</span>%)<br>    <span class="hljs-attribute">initializer</span> time:  <span class="hljs-number">47</span>.<span class="hljs-number">49</span> milliseconds (<span class="hljs-number">3</span>.<span class="hljs-number">4</span>%)<br><span class="hljs-attribute">slowest</span> intializers :<br>    <span class="hljs-attribute">libSystem</span>.dylib :   <span class="hljs-number">3</span>.<span class="hljs-number">80</span> milliseconds (<span class="hljs-number">0</span>.<span class="hljs-number">2</span>%)<br></code></pre></td></tr></table></figure><h3 id="2、main-函数之后"><a href="#2、main-函数之后" class="headerlink" title="2、main 函数之后"></a>2、main 函数之后</h3><p>1、执行main函数;</p><p>2、执行UIApplicationMain函数：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">创建UIApplication，启动主Runloop<span class="hljs-comment">;</span><br>创建AppDelegate对象，开始处理系统事件<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>3、检查Info.plist设置、创建显示主窗口：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">加载SB<span class="hljs-comment">;</span><br>创建Keywindow<span class="hljs-comment">;</span><br>创建rootViewController<span class="hljs-comment">;</span><br>显示主窗口<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="优化启动时间"><a href="#优化启动时间" class="headerlink" title="优化启动时间:"></a>优化启动时间:</h2><p><code>main()</code>之前可优化点：</p><ol><li>减少不必要的 framework；</li><li>合并或者删减一些OC类；</li><li>将不必须在+load方法中做的事情延迟到+initialize中；</li><li>删减一些无用的静态变量;</li><li>删减没有被调用到或者已经废弃的方法；</li><li>尽量不要用C++虚函数(创建虚函数表有开销)。</li></ol><p><code>main()</code>及之后可优化点：</p><ol><li>不使用xib，直接视用代码加载首页视图；</li><li>release版本不要使用 NSLog 打印日志；</li><li>NSUserDefaults中保存的内容不宜过多。</li><li>梳理应用启动时发送的所有网络请求，统一在异步线程请求；</li></ol><hr><p>相关参考：</p><p>#<a href="https://techblog.toutiao.com/2017/01/17/iosspeed/">©头条技术博客-今日头条iOS客户端启动速度优化</a></p><p>#<a href="https://www.jianshu.com/p/43db6b0aab8e">©DevilH-iOS程序启动</a></p><p>#<a href="https://mp.weixin.qq.com/s/I60p2M-IHDmeUanDUkFdVw">©MissionPeak-XNU、dyld源码分析Mach-O和动态库的加载过程(上)</a></p><p>#<a href="http://oncenote.com/2015/06/01/How-App-Launch/">©Jamin’s blog-由App的启动说起</a></p><p>#<a href="https://oleb.net/blog/2011/06/app-launch-sequence-ios/">©Ole Begemann-The App Launch Sequence on iOS</a></p><p>#<a href="https://www.jianshu.com/p/65901441903e">©alvin_wang-iOS编译与app启动</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译器</title>
    <link href="/2019/02/15/compile.html"/>
    <url>/2019/02/15/compile.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-编译-x2F-解释"><a href="#1-编译-x2F-解释" class="headerlink" title="1.编译&#x2F;解释"></a>1.编译&#x2F;解释</h3><ul><li>编译型语言</li></ul><p>代码须编译成机器码才能在CPU上执行的语言，如OC和Swift，其优点是代码执行效率高。</p><ul><li>解释型语言</li></ul><p>解释型语言，如 JavaScript 和 Python，代码不需要经过编译器，而是通过解释器直接将代码解释成CPU可以执行的代码。编写灵活，但执行效率低一些~</p><p>本篇主要关注编译型语言。编译过程可以划分为前端和后端两部分：</p><h3 id="2-Clang"><a href="#2-Clang" class="headerlink" title="2.Clang"></a>2.Clang</h3><p>编译器前端将不同的高级编程语言经过词法分析、语法分析转化为与前端语言无关的统一的中间表示。iOS 中的编译器前端使用的是 Clang，它是一个 C++ 编写的、基于LLVM 的 C&#x2F;C++&#x2F;Objective-C&#x2F;Objective-C++ 编译器。其主要任务是处理一些和具体机器无关的针对语言的分析操作：</p><p>预处理：</p><ul><li>符号化 (Tokenization)</li><li>宏定义的展开</li><li>#include 的展开。</li></ul><p>语法和语义分析：</p><ul><li>将符号化后的内容转化为一棵解析树 (parse tree)</li><li>解析树做语义分析（包含类型检查和其他检查）</li><li>输出一棵抽象语法树（Abstract Syntax Tree* (AST)）</li></ul><p>生成代码</p><ul><li>将 AST 转换为更低级的中间码 (LLVM IR)</li></ul><h3 id="3-LLVM"><a href="#3-LLVM" class="headerlink" title="3.LLVM"></a>3.LLVM</h3><p>编译器后端负责优化中间代码并生成对应平台的汇编代码。LLVM 属于编译器后端，其主要作用是：</p><p>代码优化</p><ul><li>对生成的中间码做优化</li><li>生成特定目标代码</li><li>输出汇编代码</li></ul><p>汇编器</p><ul><li>将汇编代码转换为以.o 结尾的目标对象文件（将可读的汇编代码转换为机器代码）。</li></ul><p>链接器</p><ul><li>读取目标文件和库并解决未知符号问题，将它们编码进一个可执行文件或动态库中。</li></ul><h3 id="4-Bitcode"><a href="#4-Bitcode" class="headerlink" title="4.Bitcode"></a>4.Bitcode</h3><p>一般的编译流程：OC -&gt; Clang AST -&gt; CIL IR -&gt; LLVM IR -&gt; MIR -&gt; Mach-O。</p><p>Bitcode 是 LLVM 中引入的一种中间代码，处在编译的LLVM IR这一阶段，尚未到 MIR 这一步。</p><p>Bitcode 提交到商店后，后续构建过程交给苹果完成。步骤之一就是剥离二进制符号(Binary symbol stripping)，即从二进制文件中删除非必要的元数据，以便优化二进制文件的大小。</p><p>发布新款设备后，苹果可以用 Bitcode 生成对应芯片的MIR，无需开发者重新打包上传。</p><p>更新：苹果曾强推 Bitcode，但 Xcode 14 后遭到弃用~</p><h3 id="5-Other-link"><a href="#5-Other-link" class="headerlink" title="5.Other link"></a>5.Other link</h3><p>在TARGET -&gt; Build Settings -&gt; Linking -&gt; Other linker Flags 中可配置链接参数。</p><ul><li>-all_load</li></ul><p>将静态库中所有文件都加载到IPA里，包括没用的一些文件、函数等。</p><ul><li>-noall_load</li></ul><p>链接器默认的配置，只加载用到的那部分代码，没用到的会被优化掉，减小包体。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">OC是动态语言，如果调用的方法没有被编译进来，运行时会闪退。<br>编译时，如果发现没有此方法，会报错”<span class="hljs-built_in">ref</span>erenced <span class="hljs-keyword">from</span>..”。<br></code></pre></td></tr></table></figure><ul><li>-force_load&lt;文件&gt;</li></ul><p>加载指定的某些文件。导入静态库后找不到文件或方法，推荐使用这个参数。</p><ul><li>-ObjC</li></ul><p>如果工程里有OC和C++等代码，只将所有ObjC文件(.m、分类等)编译到IPA里。</p><hr><p>题外话：</p><p>1、可以使用合适的链接参数，优化包体大小。</p><p>2、如果工程与静态库里定义了同名类或函数，但仅仅是将此静态库打包到了工程里，并没有 import 或使用它，此时是不会报错的。因为链接时默认使用 -noall_load 参数，不会链接没用到的类和函数，应用的二进制中只包含我们自己的那个类和函数。反之如果使用 -all_load 或 -ObjC 参数，即使没用到，也会报错。</p><h3 id="6-Xcode-Build"><a href="#6-Xcode-Build" class="headerlink" title="6.Xcode Build"></a>6.Xcode Build</h3><p>Xcode 是根据 target 分别编译的。每个 target 的具体的编译过程可以通过展开日志查看。</p><p>基本的格式是先简明一句说明要干什么，再缩进的几行说明具体的操作。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Build target CodeMix of project CodeMix with configuration <span class="hljs-built_in">Debug</span><br><br>CompileC /Users/<span class="hljs-built_in">..</span>/XXViewController.o CodeMix/XXViewController.m <br>normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler<br>    cd /Users/<span class="hljs-built_in">..</span>/CodeMix<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">LANG</span>=en_US.US-ASCII<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=“../XXViewController.o<br><br>Ld /Users/<span class="hljs-built_in">..</span>/Debug-iphonesimulator/CodeMix.app/CodeMix normal x86_64<br>    cd /Users/<span class="hljs-built_in">..</span>/CodeMix<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">IPHONES_DEPLOYMENT_TARGET</span>=11.2<br>    <span class="hljs-built_in">..</span><br><br>PhaseScriptExecution Run\<span class="hljs-built_in"> Script </span>/Users/<span class="hljs-built_in">..</span>/Script-0AC86E9E1FF6721A00098A24.sh<br>    cd /Users/Macmafia/Desktop/CodeMix<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">ACTION</span>=build<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">AD_HOC_CODE_SIGNING_ALLOWED</span>=<span class="hljs-literal">YES</span><br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">ALTERNATE_GROUP</span>=staff<br><br>    /bin/sh -c /Users/<span class="hljs-built_in">..</span>/Script-0AC86E9E1FF6721A00098A24.sh<br><br>PRAGMA <span class="hljs-attribute">foreign_keys</span>=OFF;<br>BEGIN TRANSACTION;<br>CREATE TABLE symbols(src text, des text);<br>COMMIT;<br><br>Touch /Users/<span class="hljs-built_in">..</span>/Build/Products/Debug-iphonesimulator/CodeMix.app<br>    cd /Users/<span class="hljs-built_in">..</span>/CodeMix<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;/Applications/Xcode.app/../Debug-iphonesimulator/CodeMix.app</span><br><span class="hljs-string"></span><br><span class="hljs-string">CodeSign /Users/../Debug-iphonesimulator/CodeMix.app</span><br><span class="hljs-string">    cd /Users/../CodeMix</span><br><span class="hljs-string">    export CODESIGN_ALLOCATE=/Applications/Xcode.app/../codesign_allocate</span><br><span class="hljs-string">    </span><br><span class="hljs-string">Signing Identity:     &quot;</span>-&quot;<br>    <span class="hljs-built_in">..</span><br>Build succeeded    2018/1/26 下午9:35<br></code></pre></td></tr></table></figure><p>从上面日志可以看到，大致的过程是：</p><ul><li>compile swift文件</li><li>compile各个.m文件（按名字升序）</li><li>compile xib</li><li>compile storyboard</li><li>link storyboards</li><li>copy静态资源，包括img，string，font</li><li>compile asset catalogs</li><li>run custom shell script</li><li>process info.plist</li><li>copy Swift standard libraries into xx.app（拷贝swift标准库）</li><li>sign app（代码签名）</li><li>touch app（生成.app文件）</li><li>validate app(真机build有)</li></ul><hr><p>参考文章：</p><p>#<a href="https://objccn.io/issue-6-2/">©编译器-objccn</a> </p><p>#<a href="http://wiki.jikexueyuan.com/project/objc/Build-tool/6-3.html">©极客学院-OC期刊</a></p><p>#<a href="https://blog.csdn.net/u012491514/article/details/24736041">©GCC编译器</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>派发机制</title>
    <link href="/2018/12/12/dispatch.html"/>
    <url>/2018/12/12/dispatch.html</url>
    
    <content type="html"><![CDATA[<p>函数&#x2F;方法把代码内聚到一处并对外暴露函数名，这提高了代码的复用性，也对外隐藏了具体的实现过程。根据函数名找到具体的函数实现，这就是函数派发的过程。函数派发的机制分两种：</p><ul><li>静态派发</li><li>动态派发</li></ul><hr><h3 id="一、静态派发"><a href="#一、静态派发" class="headerlink" title="一、静态派发"></a>一、静态派发</h3><blockquote><p>static dispatch is a form of polymorphism fully resolved during compile time. It is a form of method dispatch, which describes how a language or environment will select which implementation of a method or function to use.</p></blockquote><blockquote><p>Dynamic dispatch contrasts with static dispatch, in which the implementation of a polymorphic operation is selected at compile-time. </p></blockquote><p>静态派发机制下，“方法的实现在编译期就已确定”，即编译器在编译期就已经能确定函数具体实现的位置在哪。调用函数时，runtime 会直接跳转到函数的内存地址上执行具体的实现。</p><p><strong>优点</strong>：执行快、性能好、编译器能进行内联等优化。</p><p><strong>缺点</strong>：缺乏动态性，函数实现在运行期不能修改，无法满足某些特定的需求，比如在运行时替换某个方法。</p><h3 id="二、动态派发"><a href="#二、动态派发" class="headerlink" title="二、动态派发"></a>二、动态派发</h3><blockquote><p>Dynamic dispatch is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time. </p></blockquote><p>动态派发，是指“在运行时决定方法调用哪个实现”的过程。动态派发机制产生的原因是面向对象语言的多态性。动态派发机制下，编译器在编译期还不知道函数的具体实现是哪个；在执行函数时<code>runtime</code>才会根据函数名去函数表中查找并执行具体的实现。每种语言都有自己的机制来支持动态派发，例如swift支持函数表派发、消息派发~</p><p><strong>缺点</strong>：需要查表，执行效率相对低一些。</p><h4 id="2-1-函数表派发"><a href="#2-1-函数表派发" class="headerlink" title="2.1.函数表派发"></a>2.1.函数表派发</h4><p>这是<code>编译型语言</code>最常采用的函数派发机制。编译器在编译期为每个类创建一个与之相关联的函数表<code>virtual table</code>，即<code>vtable</code>。它是一个由函数指针组成的数组，指针指向的是函数的具体实现。</p><p>#示例1：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ParentClass</span> &#123;<br>    <span class="hljs-function">func <span class="hljs-title">method1</span>()</span> &#123;&#125;<br>    <span class="hljs-function">func <span class="hljs-title">method2</span>()</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">ChildClass</span>: <span class="hljs-title">ParentClass</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">override</span> func <span class="hljs-title">method2</span>()</span> &#123;&#125;<br>    <span class="hljs-function">func <span class="hljs-title">method3</span>()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会创建两个 dispatch table：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_virtual_dispatch.png" alt="table dispatch"></p><p>调用某个方法：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">let obj = ChildClass<span class="hljs-comment">()</span><br>obj.method<span class="hljs-number">2</span><span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>派发流程：</p><ol><li>runtime 会先去读取 <code>函数表</code> 0xB00；</li><li>根据函数的索引去读取函数指针：function2 索引值是 1，所以去读取 0xB00 + 1；</li><li>最后跳转到函数对应的内存地址 0x222 上执行具体的实现。</li></ol><h4 id="2-2-消息派发"><a href="#2-2-消息派发" class="headerlink" title="2.2.消息派发"></a>2.2.消息派发</h4><p>这是OC中的派发机制，OC中方法的调用会被转化为消息：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">id</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">op</span>, <span class="hljs-operator">...</span>)</span><br></code></pre></td></tr></table></figure><ul><li>参数1：调用者；</li><li>参数2：调用的方法；</li><li>省略号：方法的N个参数。</li></ul><p>派发流程：</p><ol><li>方法的调用者会通过<code>isa</code>指针找到其所属的类。</li><li>runtime 会先去<code>cache</code>中查找对应的方法；</li><li>若<code>cache</code>中没有找到则去<code>methodLists</code>中查找。</li><li>找到后通过函数指针跳转到对应的实现中执行，并将方法加入到<code>cache</code>中以便下次查找；</li><li>如果<code>methodLists</code>中也没找到，则继续顺着继承关系到父类中查找；</li><li>如果直到根类 NSObject 都还没找到则会尝试<code>动态方法决议</code>或<code>消息转发</code>机制；</li><li>如果没有实现这两种机制，则方法的调用会因找不到对应的实现而报运行时错误。</li></ol><p>消息派发机制是这三种派发机制中最具动态性的，你可以用<code>swizzling</code>黑魔法修改函数的实现；也可以用<code>isa-swizzling</code>修改对象本身，如KVO的<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html#//apple_ref/doc/uid/20002307-BAJEAIEE">底层实现</a>。</p><p>另外，Swift 作为静态语言天然支持静态派发，但它也用到了OC的<code>runtime library</code>，所以同样支持消息派发。</p><hr><h2 id="三、Swift的派发机制"><a href="#三、Swift的派发机制" class="headerlink" title="三、Swift的派发机制"></a>三、Swift的派发机制</h2><p>Swift 的函数派发机制因函数定义的位置、特别声明等而异：</p><table><thead><tr><th align="center">设定</th><th align="center">静态派发</th><th align="center">函数表派发</th><th align="center">消息派发</th></tr></thead><tbody><tr><td align="center">特别声明</td><td align="center">static &#x2F; final</td><td align="center">-</td><td align="center">dynamic</td></tr><tr><td align="center">class</td><td align="center">extensions</td><td align="center">initial declaration</td><td align="center">标注为@objc的extensions</td></tr><tr><td align="center">protocol</td><td align="center">extensions</td><td align="center">initial declaration</td><td align="center">-</td></tr><tr><td align="center">value type</td><td align="center">all func</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>#静态派发：</p><ol><li><code>static</code> 或 <code>final</code> 标注的函数不能被重写，所以不具有多态性，使用静态派发；</li><li><code>final</code> 标注的类会失去所有动态的能力，其中的函数也是使用静态派发；</li><li>Enum、Struct 是值类型，不能继承别的类型也就没有重写一说，其函数总是静态派发；</li><li>协议的扩展中定义的函数是静态派发；</li><li>类的扩展中定义的函数，除了标记为<code>@objc</code>的外，其他都是静态派发。</li></ol><p>#动态派发：</p><ol><li>类或协议中声明的原始函数，使用的是函数表派发；</li><li>继承自NSObject或其子类的Swift类中，被重写的OC函数使用的还是OC的消息派发；</li><li>由 <code>dynamic</code> 标记的函数使用的是消息派发；</li><li>Extensions 中标记为<code>@objc</code>的函数使用的是消息派发。</li></ol><p>#示例2：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Eat</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">eat</span>()  <span class="hljs-comment">//函数表派发</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Eat</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">eat</span>() &#123;<span class="hljs-comment">//函数表派发</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;eat()协议方法的默认实现，不是重写（swift分类中不能重写原类中已有的方法）~&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drink</span>() &#123;<span class="hljs-comment">//静态派发</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span>: <span class="hljs-title class_">Eat</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">eat</span>() &#123;<span class="hljs-comment">//函数表派发</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;eat的实现&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drink</span>() &#123;<span class="hljs-comment">//函数表派发</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;dink的实现&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>() &#123;&#125; <span class="hljs-comment">//消息派发</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Sheep</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">jump</span>() &#123;&#125; <span class="hljs-comment">//静态派发</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">sleep</span>() &#123;&#125; <span class="hljs-comment">//消息派发</span><br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">DiceNumber</span> : <span class="hljs-title class_">Int</span> &#123;<br>    <span class="hljs-keyword">case</span> one <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">case</span> two<br>    <span class="hljs-keyword">case</span> three<br>    <span class="hljs-keyword">case</span> four<br>    <span class="hljs-keyword">case</span> five<br>    <span class="hljs-keyword">case</span> six<br>    <br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateDirection</span>(<span class="hljs-params">num</span>:<span class="hljs-type">DiceNumber</span>) &#123;<span class="hljs-comment">//静态派发</span><br>        <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> num<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dice</span> &#123;<br>    <span class="hljs-keyword">var</span> slides <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">random</span>(<span class="hljs-params">dice</span>: <span class="hljs-type">DiceNumber</span>) -&gt; <span class="hljs-type">Int</span> &#123;<span class="hljs-comment">//静态派发</span><br>        <span class="hljs-keyword">return</span> dice.rawValue<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="四、动-x2F-静态语言"><a href="#四、动-x2F-静态语言" class="headerlink" title="四、动&#x2F;静态语言"></a>四、动&#x2F;静态语言</h2><p>动态&#x2F;静态语言一般是指动态&#x2F;静态编程语言，强调的是“程序在运行期是否可扩展”。</p><h4 id="4-1-动态语言"><a href="#4-1-动态语言" class="headerlink" title="4.1.动态语言"></a>4.1.动态语言</h4><blockquote><p>Dynamic programming language, in computer science, is a class of high-level programming languages which, at runtime, execute many common programming behaviors that static programming languages perform during compilation. These behaviors could include extension of the program, by adding new code, by extending objects and definitions, or by modifying the type system. </p></blockquote><p>动态语言是程序在运行期可以扩展的一类语言，包括：添加新代码、扩展对象或定义、修改类型系统。常见的动态语言有：<code>JavaScript</code>、<code>Python</code>、<code>Ruby</code>、<code>PHP</code>以及<code>OC</code>。</p><h4 id="4-2-静态语言"><a href="#4-2-静态语言" class="headerlink" title="4.2.静态语言"></a>4.2.静态语言</h4><p>静态语言是与动态语言相对应，运行期程序不可扩展。常见的静态语言有：<code>Java</code>、<code>C</code>、<code>C++</code>。</p><p>Swift 也是静态语言，Swift 中声明的方法、属性在编译期就已经确定。同时 Swift 也支持动态绑定和派发，只不过需要将类中的属性、方法标注为 <code>@objc</code>和<code>dynamic</code>，这样 Swift 的动态特性就可以使用 OC 的运行时机制来实现。</p><h2 id="五、动-x2F-静态类型语言"><a href="#五、动-x2F-静态类型语言" class="headerlink" title="五、动&#x2F;静态类型语言"></a>五、动&#x2F;静态类型语言</h2><p>静态&#x2F;动态类型语言强调的是“数据类型”在何时确定。</p><h4 id="5-1-静态类型语言"><a href="#5-1-静态类型语言" class="headerlink" title="5.1.静态类型语言"></a>5.1.静态类型语言</h4><p>数据类型在编译期就确定下来的语言，一般在使用变量之前要明确声明变量的类型。代表语言有：<code>C</code>、<code>C++</code>、<code>C#</code>、<code>Java</code>、<code>Delphi</code>以及<code>OC</code>。</p><h4 id="5-2-动态类型语言"><a href="#5-2-动态类型语言" class="headerlink" title="5.2.动态类型语言"></a>5.2.动态类型语言</h4><p>在运行期间才去做数据类型检查的语言。一般变量在使用之前不需要明确声明类型，被赋值时才知道数据具体的类型。代表语言有：<code>Python</code>、<code>Ruby</code>以及一些脚本语言如<code>JavaScript</code>。</p><hr><p>相关参考：</p><p>#<a href="https://en.wikipedia.org/wiki/Dynamic_programming_language">©维基百科-Dynamic programming language</a></p><p>#<a href="https://en.wikipedia.org/wiki/Type_system">©维基百科-Type_system</a></p><p>#<a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">©维基百科-Dynamic dispatch</a></p><p>#<a href="https://en.wikipedia.org/wiki/Static_dispatch">©维基百科-Static dispatch</a></p><p>#<a href="https://trinhngocthuyen.github.io/2017-09-25-method-dispatch-in-swift.html">©Method dispatch in Swift</a></p><p>#<a href="https://github.com/devedbox/SwiftWT/wiki/Dynamic-Swift">©devedbox-Dynamic Swift</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用排序算法</title>
    <link href="/2018/10/09/algorithm.html"/>
    <url>/2018/10/09/algorithm.html</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。</p></blockquote><p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p><p>#冒泡排序的Swift示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">bubbleSort</span>(_ nums: inout <span class="hljs-selector-attr">[Int]</span>) &#123;<br>    let n = nums<span class="hljs-selector-class">.count</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; n-<span class="hljs-number">1</span> &#123;<span class="hljs-comment">//循环n-1次</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; (n - <span class="hljs-number">1</span> - i) &#123;<br>            <span class="hljs-keyword">if</span> nums<span class="hljs-selector-attr">[j]</span> &gt; nums<span class="hljs-selector-attr">[j + 1]</span> &#123;<br>                nums<span class="hljs-selector-class">.swapAt</span>(j, j + <span class="hljs-number">1</span>)<span class="hljs-comment">//升序排列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(nums)<span class="hljs-comment">//打印结果</span><br>&#125;<br><span class="hljs-comment">//调用示例 </span><br><span class="hljs-selector-tag">var</span> nums = <span class="hljs-selector-attr">[5,8,1,4,2,7,6,3]</span><br><span class="hljs-function"><span class="hljs-title">bubbleSort</span><span class="hljs-params">(&amp;nums)</span></span><br></code></pre></td></tr></table></figure><h3 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h3><blockquote><p>鸡尾酒排序也就是定向冒泡排序，是冒泡排序的一种变形。此演算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</p></blockquote><ol><li>前半轮，从前往后比较相邻两个元素，将最大元素移到最后;</li><li>后半轮，从已排好序元素的前一位向前，比较相邻元素，将最小元素移到最前;</li><li>反复执行1.2两步，直到所有元素都排序完。</li></ol><p>#鸡尾酒排序的Swift语言示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">func cocktailSort(sourceArr <span class="hljs-built_in">array</span>: <span class="hljs-keyword">inout</span> [Int]) -&gt; Void<br>&#123;<br>    let n = <span class="hljs-built_in">array</span>.count<br>    var left = <span class="hljs-number">0</span><br>    var right = n - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">while</span> left &lt; right &#123;<br>        <br>        <span class="hljs-comment">//前半轮 将最大元素移到最后</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> left ..&lt; right &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">array</span>[i] &gt; <span class="hljs-built_in">array</span>[i+<span class="hljs-number">1</span>]&#123;<br>                <span class="hljs-built_in">array</span>.swapAt(i, i+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>        right -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment">//后半轮 将最小元素移到最前</span><br>        <span class="hljs-keyword">if</span> left &lt; right &#123;<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (left+<span class="hljs-number">1</span> ... right).reversed() &#123;<span class="hljs-comment">//从后向前遍历</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">array</span>[i<span class="hljs-number">-1</span>] &gt; <span class="hljs-built_in">array</span>[i]&#123;<br>                    <span class="hljs-built_in">array</span>.swapAt(i<span class="hljs-number">-1</span>, i)<br>                &#125;<br>            &#125;<br>            left += <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>选择排序也是一种简单直观的排序算法。它的工作原理是在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><p>#选择排序的Swift语言示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">func selectSort(sourceArr <span class="hljs-built_in">array</span>: <span class="hljs-keyword">inout</span> [Int]) -&gt; Void<br>&#123;<br>    let n = <span class="hljs-built_in">array</span>.count<br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; n<span class="hljs-number">-1</span> &#123;<span class="hljs-comment">// i为已排序序列的末尾</span><br>        var min = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i+<span class="hljs-number">1</span> ..&lt; n &#123;<span class="hljs-comment">// 未排序序列</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">array</span>[j] &lt; <span class="hljs-built_in">array</span>[min] &#123;<span class="hljs-comment">// 找出未排序序列中的最小值</span><br>                min = j<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> min != i &#123;<br>            <span class="hljs-built_in">array</span>.swapAt(min, i)<span class="hljs-comment">// 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><blockquote><p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于抓扑克牌，对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p></blockquote><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p>#插入排序的C语言示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertionSort</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> A[], <span class="hljs-built_in">int</span> n</span>)</span><br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> = A[i]; <span class="hljs-comment">// 右手抓到一张扑克牌</span><br>        <span class="hljs-built_in">int</span> j = i - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 拿在左手上的牌总是排序好的</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; <span class="hljs-keyword">get</span>) <span class="hljs-comment">//将右手抓到的牌与左手手牌从右向左进行比较</span><br>        &#123;<br>            A[j + <span class="hljs-number">1</span>] = A[j]; <span class="hljs-comment">//如果该左手手牌比右手抓到的牌大，就将其右移</span><br>            j--;<br>        &#125;<br>        A[j + <span class="hljs-number">1</span>] = <span class="hljs-keyword">get</span>; <span class="hljs-comment">//直到该手牌比右手抓到的牌小(或相等)，将右手抓到的牌插入到该手牌右边</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> A[] = &#123; <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span> &#125;;<span class="hljs-comment">// 从小到大插入排序</span><br>    <span class="hljs-built_in">int</span> n = <span class="hljs-keyword">sizeof</span>(A) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>);<br>    InsertionSort(A, n);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h3><blockquote><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。</p><p>一趟快速排序的算法是：</p><ol><li>设置两个变量i、j，排序开始的时候：i&#x3D;0，j&#x3D;N-1；</li><li>以第一个数组元素作为关键数据，赋值给key，即key&#x3D;A[0]；</li><li>从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</li><li>从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</li><li>重复第3、4步，直到i&#x3D;j； </li><li>然后，对key两边的数据，再分组分别进行上述的过程，直到不能再分组为止。</li></ol><p>#快速排序的C语言示例：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">void</span> <span class="hljs-built_in">sort</span>(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)<br>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)&#123; <span class="hljs-comment">//如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">int</span> i = left;<br>    <span class="hljs-type">int</span> j = right;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">key</span> = a[left];<span class="hljs-comment">//1\2.默认取最前边的值</span><br>     <br>    <span class="hljs-keyword">while</span>(i &lt; j) <span class="hljs-comment">//5.在当组内寻找</span><br>    &#123;<br>        <span class="hljs-comment">//3.从后向前找第一个小于key的数</span><br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt;= <span class="hljs-built_in">key</span>)<br>        &#123;<br>            j--;<span class="hljs-comment">//向前寻找</span><br>        &#125;<br>        a[i] = a[j];<span class="hljs-comment">//找到一个这样的数后就把它赋给前面的被拿走的i的值</span><br>        <br>        <span class="hljs-comment">//4.从前向后找第一个大于key的数 </span><br>        <span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt;= <span class="hljs-built_in">key</span>)<br>        &#123;<br>            i++;<span class="hljs-comment">//向后寻找</span><br>        &#125;<br>        a[j] = a[i];<br>    &#125;<br>    a[i] = <span class="hljs-built_in">key</span>;<span class="hljs-comment">//当在当组内找完一遍以后就把中间数key回归</span><br>    <br>    <span class="hljs-comment">//最后用同样的方式对分出来的左边的小组进行同上的做法</span><br>    <span class="hljs-built_in">sort</span>(a, left, i - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//用同样的方式对分出来的右边的小组进行同上的做法</span><br>    <span class="hljs-built_in">sort</span>(a, i + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-comment">//最后可能会出现很多分左右，直到每一组的 i = j 为止。</span><br></code></pre></td></tr></table></figure><p>按照上面的方法，对数组 {49，38，65，97，76，13，27} 进行快速排序：</p><ul><li>进行一次快速排序之后，数组被划分为 {27，38，13} 49 {76，97，65}前后两部分。49之前的所有数都比它小，49之后的所有数都比它大；</li><li>分别对前后两部分进行快速排序：{27，38，13} 经第三步和第四步交换后变成 {13，27，38} 完成排序。</li><li>{76，97，65} 经第三步和第四步交换后变成 {65，76，97} 完成排序。</li><li>最终排序结果为：{13，27，38，65，76，97}。</li></ul><hr><p>相关参考：</p><p>#<a href="http://www.cnblogs.com/eniac12/p/5329396.html">©SteveWang-常用排序算法总结(一)</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift中JSON转model</title>
    <link href="/2018/10/01/swift-json.html"/>
    <url>/2018/10/01/swift-json.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-Codeble"><a href="#1-Codeble" class="headerlink" title="1.Codeble"></a>1.Codeble</h3><p>Swift中，可以使用<code>Codable</code>协议来将JSON转换为model。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">public</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">Codable</span> <span class="hljs-operator">=</span> <span class="hljs-type">Decodable</span> &amp; <span class="hljs-type">Encodable</span><br></code></pre></td></tr></table></figure><p>Codable 是一个组合协议，由 Decodable 和 Encodable 两个协议组成。作用是将 JSON 转换为 model 对象，也可以反过来将 model 对象转换为 JSON 或其它格式。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> jsonString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">        &quot;name&quot;: &quot;davidlii&quot;,</span><br><span class="hljs-string">        &quot;email&quot;: &quot;davidlii@sina.com&quot;,</span><br><span class="hljs-string">        &quot;sex&quot;:true,</span><br><span class="hljs-string">        &quot;age&quot;: 18</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">// JSON中的字段可以比实体中的属性多</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> email: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> sex: <span class="hljs-type">Bool</span><br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//1.json转Model</span><br>    <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> jsonString.data(using: .utf8)<span class="hljs-operator">!</span><br>    <span class="hljs-keyword">let</span> usr <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">User</span>.<span class="hljs-keyword">self</span>, from: data)<br>    <span class="hljs-built_in">print</span>(usr)<br>    <br>    <span class="hljs-comment">//2.model转json</span><br>    <span class="hljs-keyword">let</span> encodeData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONEncoder</span>().encode(usr)<br>    <span class="hljs-keyword">let</span> json <span class="hljs-operator">=</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(data: encodeData, encoding: .utf8)<br>    <span class="hljs-built_in">print</span>(json<span class="hljs-operator">!</span>)<br>    <br>&#125;<span class="hljs-keyword">catch</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;~some error~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-映射"><a href="#2-映射" class="headerlink" title="2.映射"></a>2.映射</h3><p>如果Model中的属性名与 JSON 中的键不一致，可使用<code>CodingKeys</code>枚举来映射。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> jsonString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">        &quot;name&quot;: &quot;davidlii&quot;,</span><br><span class="hljs-string">        &quot;email&quot;: &quot;davidlii@sina.com&quot;,</span><br><span class="hljs-string">        &quot;sex&quot;:true,</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> emailBox: <span class="hljs-type">String</span> <span class="hljs-comment">//与JSON中不匹配</span><br>    <span class="hljs-keyword">let</span> sex: <span class="hljs-type">Bool</span><br>    <br>    <span class="hljs-comment">//映射键与属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CodingKeys</span> :<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CodingKey</span>&#123;<br>        <span class="hljs-keyword">case</span> name<br>        <span class="hljs-keyword">case</span> emailBox <span class="hljs-operator">=</span> <span class="hljs-string">&quot;email&quot;</span> <span class="hljs-comment">//匹配不规则的JSON字段</span><br>        <span class="hljs-keyword">case</span> sex<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//JSON转Model</span><br>    <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> jsonString.data(using: .utf8)<span class="hljs-operator">!</span><br>    <span class="hljs-keyword">let</span> usr <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">User</span>.<span class="hljs-keyword">self</span>, from: data)<br>    <span class="hljs-built_in">print</span>(usr)<br>    <br>&#125;<span class="hljs-keyword">catch</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;~some error~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-自定义编解码"><a href="#3-自定义编解码" class="headerlink" title="3.自定义编解码"></a>3.自定义编解码</h3><p>JSON中字段的类型可能会与model中的不同，需要我们自定义编解码，来达到二者的统一：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> jsonString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;name&quot;: &quot;davidlii&quot;,</span><br><span class="hljs-string">    &quot;sex&quot;: 0,</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> sex: <span class="hljs-type">Bool</span><br>    <br>    <span class="hljs-comment">//下面会用到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CodingKeys</span> :<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CodingKey</span>&#123;<br>        <span class="hljs-keyword">case</span> name<br>        <span class="hljs-keyword">case</span> sex<br>    &#125;<br>    <span class="hljs-comment">//解码</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">from</span> <span class="hljs-params">decoder</span>: <span class="hljs-type">Decoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">let</span> box <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> decoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> box.decode(<span class="hljs-type">String</span>.<span class="hljs-keyword">self</span>, forKey: .name) <span class="hljs-comment">//CodingKeys中定义的枚举</span><br>        <span class="hljs-comment">//先取出来Int值</span><br>        <span class="hljs-keyword">let</span> sexInt <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> box.decode(<span class="hljs-type">Int</span>.<span class="hljs-keyword">self</span>, forKey: .sex)<br>        <span class="hljs-comment">//再转换成Bool</span><br>        <span class="hljs-keyword">self</span>.sex <span class="hljs-operator">=</span> (sexInt <span class="hljs-operator">==</span> <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-comment">//编码    </span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params">to</span> <span class="hljs-params">encoder</span>: <span class="hljs-type">Encoder</span>) <span class="hljs-keyword">throws</span> &#123;<br>        <span class="hljs-keyword">var</span> box <span class="hljs-operator">=</span> encoder.container(keyedBy: <span class="hljs-type">CodingKeys</span>.<span class="hljs-keyword">self</span>)<br>        <span class="hljs-keyword">try</span> box.encode(<span class="hljs-keyword">self</span>.name, forKey: .name)<br>        <span class="hljs-comment">// 编码成Int</span><br>        <span class="hljs-keyword">try</span> box.encode(sex <span class="hljs-operator">?</span> <span class="hljs-number">1</span> : <span class="hljs-number">0</span>, forKey: .sex)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//1.json转Model</span><br>    <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> jsonString.data(using: .utf8)<span class="hljs-operator">!</span><br>    <span class="hljs-keyword">let</span> usr <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">User</span>.<span class="hljs-keyword">self</span>, from: data)<br>    <span class="hljs-built_in">print</span>(usr)<br>    <br>    <span class="hljs-comment">//2.model转json</span><br>    <span class="hljs-keyword">let</span> encodeData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONEncoder</span>().encode(usr)<br>    <span class="hljs-keyword">let</span> json <span class="hljs-operator">=</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(data: encodeData, encoding: .utf8)<br>    <span class="hljs-built_in">print</span>(json<span class="hljs-operator">!</span>)<br>    <br>&#125;<span class="hljs-keyword">catch</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;~some error~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-数组属性"><a href="#4-数组属性" class="headerlink" title="4.数组属性"></a>4.数组属性</h3><p>JSON中有数组类型时的处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> jsonString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;id&quot;: 1,</span><br><span class="hljs-string">    &quot;users&quot;: [</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">            &quot;name&quot;: &quot;davidlii&quot;,</span><br><span class="hljs-string">            &quot;email&quot;: &quot;davidlii@sina.com&quot;,</span><br><span class="hljs-string">            &quot;sex&quot;:true,</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">            &quot;name&quot;: &quot;Het&quot;,</span><br><span class="hljs-string">            &quot;email&quot;: &quot;Het@sina.com&quot;,</span><br><span class="hljs-string">            &quot;sex&quot;:false,</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment">//小组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Group</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">let</span> identifier: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">let</span> users:[<span class="hljs-type">User</span>] <span class="hljs-comment">// 数组</span><br>    <br>    <span class="hljs-comment">//映射键与属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CodingKeys</span> :<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CodingKey</span>&#123;<br>        <span class="hljs-keyword">case</span> identifier <span class="hljs-operator">=</span> <span class="hljs-string">&quot;id&quot;</span><br>        <span class="hljs-keyword">case</span> users<br>    &#125;<br>&#125;<br><span class="hljs-comment">//组员</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> ema1l: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> sex: <span class="hljs-type">Bool</span><br>    <br>    <span class="hljs-comment">//映射键与属性</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">CodingKeys</span> :<span class="hljs-title class_">String</span>, <span class="hljs-title class_">CodingKey</span>&#123;<br>        <span class="hljs-keyword">case</span> name<br>        <span class="hljs-keyword">case</span> ema1l <span class="hljs-operator">=</span> <span class="hljs-string">&quot;email&quot;</span> <span class="hljs-comment">//匹配不规则的JSON字段</span><br>        <span class="hljs-keyword">case</span> sex<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//1.json转Model</span><br>    <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> jsonString.data(using: .utf8)<span class="hljs-operator">!</span><br>    <span class="hljs-keyword">let</span> usrs <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Group</span>.<span class="hljs-keyword">self</span>, from: data)<br>    <span class="hljs-built_in">print</span>(usrs)<br>    <br>    <span class="hljs-comment">//2.model转json</span><br>    <span class="hljs-keyword">let</span> encodeData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONEncoder</span>().encode(usrs)<br>    <span class="hljs-keyword">let</span> json <span class="hljs-operator">=</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(data: encodeData, encoding: .utf8)<br>    <span class="hljs-built_in">print</span>(json<span class="hljs-operator">!</span>)<br>    <br>&#125;<span class="hljs-keyword">catch</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;~some error~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-可选属性"><a href="#5-可选属性" class="headerlink" title="5.可选属性"></a>5.可选属性</h3><p>model中可选属性为空时，编码后不会包含在 JSON 数据中。解码时，JSON字段中可不传此字段。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> jsonString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;users&quot;: [</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">            &quot;name&quot;: &quot;davidlii&quot;,</span><br><span class="hljs-string">            &quot;email&quot;: &quot;davidlii@sina.com&quot;,</span><br><span class="hljs-string">            &quot;sex&quot;:true,</span><br><span class="hljs-string">            &quot;age&quot;: 18</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">            &quot;name&quot;: &quot;Het&quot;,</span><br><span class="hljs-string">            &quot;email&quot;: &quot;Het@sina.com&quot;,</span><br><span class="hljs-string">            &quot;sex&quot;:false,</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment">//小组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Group</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">let</span> users:[<span class="hljs-type">User</span>]<br>&#125;<br><span class="hljs-comment">//组员</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">Codable</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> email: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> sex: <span class="hljs-type">Bool</span><br>    <span class="hljs-keyword">let</span> age: <span class="hljs-type">Int</span>?<br>&#125;<br><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-comment">//1.json转Model</span><br>    <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> jsonString.data(using: .utf8)<span class="hljs-operator">!</span><br>    <span class="hljs-keyword">let</span> usrs <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Group</span>.<span class="hljs-keyword">self</span>, from: data)<br>    <span class="hljs-built_in">print</span>(usrs)<br>    <br>    <span class="hljs-comment">//2.model转json</span><br>    <span class="hljs-keyword">let</span> encodeData <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONEncoder</span>().encode(usrs)<br>    <span class="hljs-keyword">let</span> json <span class="hljs-operator">=</span> <span class="hljs-type">String</span>.<span class="hljs-keyword">init</span>(data: encodeData, encoding: .utf8)<br>    <span class="hljs-built_in">print</span>(json<span class="hljs-operator">!</span>)<br>    <br>&#125;<span class="hljs-keyword">catch</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;~some error~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出的字符串：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;users&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;davidlii@sina.com&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sex&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;davidlii&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Het&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Het@sina.com&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;sex&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>编码后，不会包含为nil的<code>age</code>字段。</p><hr><p>相关参考：</p><p>#<a href="https://davidlii.cn/">©</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift中的GCD</title>
    <link href="/2018/09/25/swift-gcd.html"/>
    <url>/2018/09/25/swift-gcd.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-任务"><a href="#1-任务" class="headerlink" title="1.任务"></a>1.任务</h3><p>在 Swift 中往GCD队列里提交的任务，有两种常见封装方法。</p><h4 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// GCD</span><br><span class="hljs-keyword">let</span> q1 <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;serial&quot;</span>) <span class="hljs-comment">// 默认串行</span><br><span class="hljs-keyword">let</span> q2 <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;concurrent&quot;</span>, attributes: .concurrent) <span class="hljs-comment">// 指定为并发</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start&quot;</span>)<br>q2.async &#123; <span class="hljs-comment">// 使用闭包提交任务</span><br>    <span class="hljs-type">Thread</span>.sleep(forTimeInterval: <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++1 <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br>q2.async &#123;<br>    <span class="hljs-type">Thread</span>.sleep(forTimeInterval: <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++2 <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br>q2.async &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++3 <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="2-DispatchWorkItem"><a href="#2-DispatchWorkItem" class="headerlink" title="2.DispatchWorkItem"></a>2.DispatchWorkItem</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;concurrent&quot;</span>, attributes: .concurrent) <span class="hljs-comment">// 指定为并发</span><br><span class="hljs-comment">// 使用WorkItem提交任务</span><br><span class="hljs-keyword">let</span> work <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span>.<span class="hljs-keyword">init</span>(block:&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++1: item run on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>    <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++2: item run on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>    &#125;<br>&#125;)<br><span class="hljs-comment">//work.perform() //在当前线程执行任务</span><br><span class="hljs-comment">// 执行任务</span><br>q.async(execute: work)<br></code></pre></td></tr></table></figure><h5 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h5><p>在构造WorkItem时，可以设置优先级与执行策略。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">qos</span>: <span class="hljs-type">DispatchQoS</span> <span class="hljs-operator">=</span> .unspecified, <span class="hljs-params">flags</span>: <span class="hljs-type">DispatchWorkItemFlags</span> <span class="hljs-operator">=</span> [], <span class="hljs-params">block</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-keyword">@convention(block)</span> () -&gt; <span class="hljs-type">Void</span>)<br></code></pre></td></tr></table></figure><ul><li>qos</li></ul><p>与OC中类似，优先级从高到低包括了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">userInteractive <span class="hljs-comment">//用于涉及到UI交互的场景</span><br>userInitiated <span class="hljs-comment">//用于用户触发的、需要立刻返回结果的任务</span><br><span class="hljs-keyword">default</span> <span class="hljs-comment">//默认值</span><br>utility <span class="hljs-comment">//用于不需要立刻返回结果的任务</span><br>background <span class="hljs-comment">//用于非用户触发的、不可见的任务</span><br></code></pre></td></tr></table></figure><ul><li>flags</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">barrier <span class="hljs-comment">//栅栏，与OC中的一样</span><br>assignCurrentContext <span class="hljs-comment">//使用所在队列或者线程的属性设置，如优先级</span><br>detached <span class="hljs-comment">//不使用所在队列或者线程的属性设置</span><br>noQoS <span class="hljs-comment">//不指定优先级</span><br>inheritQoS <span class="hljs-comment">//设置本任务的优先级 &lt;= 当前队列或线程的优先级</span><br>enforceQoS <span class="hljs-comment">//设置本任务的优先级 &gt;= 当前队列或线程的优先级</span><br></code></pre></td></tr></table></figure><h5 id="2-API"><a href="#2-API" class="headerlink" title="2.API"></a>2.API</h5><h6 id="1-perform"><a href="#1-perform" class="headerlink" title="1.perform()"></a>1.perform()</h6><p>使任务直接在当前的线程中执行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> work <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span>.<span class="hljs-keyword">init</span>(block:&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++1: item run on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>    <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++2: item run on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>    &#125;<br>&#125;)<br>work.perform()<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++1: item run on &lt;NSThread: 0x600001cf41c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="hljs-comment">//++2: item run on &lt;NSThread: 0x600001cfa240&gt;&#123;number = 3, name = (null)&#125;</span><br></code></pre></td></tr></table></figure><h6 id="2-wait"><a href="#2-wait" class="headerlink" title="2.wait()"></a>2.wait()</h6><p>阻塞当前线程，待当前任务完成后，再继续执行后续代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> work <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span>.<span class="hljs-keyword">init</span> &#123;<br>    sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++working.. <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br><span class="hljs-type">DispatchQueue</span>.global().async(execute: work)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++before wait on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>work.wait()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++after wait on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++before wait on &lt;NSThread: 0x600001b08440&gt;&#123;number = 1, name = main&#125;</span><br><span class="hljs-comment">//++working.. &lt;NSThread: 0x600001b023c0&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//++after wait on &lt;NSThread: 0x600001b08440&gt;&#123;number = 1, name = main&#125;</span><br></code></pre></td></tr></table></figure><p>代码执行时，先输出before，等待1秒，再连续输出working与after。</p><p>这里涉及到了线程间的通信，wait会阻塞其所在的主线程，待异步线程中的任务完成后，才继续主线程的后续代码。</p><p>当然，执行到wait()时，如果任务已经完成，则会直接执行后续代码。比如上面的示例中改用<code>sync</code>同步提交任务时：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> work <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span>.<span class="hljs-keyword">init</span> &#123;<br>    sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++working.. <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br><span class="hljs-type">DispatchQueue</span>.global().sync(execute: work)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++before wait on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>work.wait()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++after wait on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++working.. &lt;NSThread: 0x6000019f40c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="hljs-comment">//++before wait on &lt;NSThread: 0x6000019f40c0&gt;&#123;number = 1, name = main&#125;</span><br><span class="hljs-comment">//++after wait on &lt;NSThread: 0x6000019f40c0&gt;&#123;number = 1, name = main&#125;</span><br></code></pre></td></tr></table></figure><p>再次执行时，到sync所在行时不会开启新线程，即在主线程执行work并等待1秒，随后连续输出before与after。看上去wait并没效果，是因为执行到wait时，work任务已经完成，所以直接跳过并执行after去了。</p><h6 id="3-notify"><a href="#3-notify" class="headerlink" title="3.notify()"></a>3.notify()</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q1 <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q1&quot;</span>)<br><span class="hljs-keyword">let</span> q2 <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q2&quot;</span>)<br><span class="hljs-keyword">let</span> work <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span>.<span class="hljs-keyword">init</span>(block: &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++work on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>    sleep(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-comment">// 监听通知</span><br>work.notify(queue: q2) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;notify on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br>q1.async(execute: work)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;finished on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++work on &lt;NSThread: 0x600000785f40&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="hljs-comment">//++finished on &lt;NSThread: 0x60000078c180&gt;&#123;number = 1, name = main&#125;</span><br><span class="hljs-comment">//++notify on &lt;NSThread: 0x6000007889c0&gt;&#123;number = 7, name = (null)&#125;</span><br></code></pre></td></tr></table></figure><p><code>notify</code>也涉及到线程间的通信，收到任务完成通知后，可以在另一队列中执行其他任务。</p><p>需要指出的是，notify中的任务会<code>异步</code>地执行，因此有机会开辟新线程：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q1 <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q1&quot;</span>)<br><span class="hljs-keyword">let</span> work <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span>.<span class="hljs-keyword">init</span>(block: &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++work on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>    sleep(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-comment">// 通知</span><br>work.notify(queue: q1) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++notify on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br>q1.sync(execute: work)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++finished on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++work on &lt;NSThread: 0x600003ee0200&gt;&#123;number = 1, name = main&#125;</span><br><span class="hljs-comment">//++notify on &lt;NSThread: 0x600003ee8ac0&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="hljs-comment">//++finished on &lt;NSThread: 0x600003ee0200&gt;&#123;number = 1, name = main&#125;</span><br></code></pre></td></tr></table></figure><p>从日志可以看到，通过<code>sync</code>方式提交的任务是在主线程上执行的，任务完成后 notify 却是在子线程中执行的，可以推断这里 notify 是异步执行的，开辟了新线程。</p><h3 id="2-任务组Group"><a href="#2-任务组Group" class="headerlink" title="2.任务组Group"></a>2.任务组Group</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">async</span>(<span class="hljs-params">group</span>: <span class="hljs-type">DispatchGroup</span>, <span class="hljs-params">execute</span> <span class="hljs-params">workItem</span>: <span class="hljs-type">DispatchWorkItem</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">async</span>(<span class="hljs-params">group</span>: <span class="hljs-type">DispatchGroup</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>, <span class="hljs-params">qos</span>: <span class="hljs-type">DispatchQoS</span> <span class="hljs-operator">=</span> .unspecified, <span class="hljs-params">flags</span>: <span class="hljs-type">DispatchWorkItemFlags</span> <span class="hljs-operator">=</span> [], <span class="hljs-params">execute</span> <span class="hljs-params">work</span>: <span class="hljs-keyword">@escaping</span> <span class="hljs-keyword">@convention(block)</span> () -&gt; <span class="hljs-type">Void</span>)<br></code></pre></td></tr></table></figure><p>DispatchGroup只支持异步的提交任务，任务可以是闭包或 WorkItem。</p><h4 id="1-notify"><a href="#1-notify" class="headerlink" title="1.notify()"></a>1.notify()</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// Group</span><br><span class="hljs-keyword">let</span> q <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q&quot;</span>, attributes: .concurrent)<br><span class="hljs-keyword">let</span> group <span class="hljs-operator">=</span> <span class="hljs-type">DispatchGroup</span>.<span class="hljs-keyword">init</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++start&quot;</span>)<br>q.async(group: group)&#123;<br>    sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++1&quot;</span>)<br>&#125;<br>q.async(group: group)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++2&quot;</span>)<br>&#125;<br>q.async(group: group)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++3&quot;</span>)<br>&#125;<br>group.notify(queue: <span class="hljs-type">DispatchQueue</span>.main) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++finished&quot;</span>)<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++end&quot;</span>)<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++start</span><br><span class="hljs-comment">//++2</span><br><span class="hljs-comment">//++3</span><br><span class="hljs-comment">//++end</span><br><span class="hljs-comment">//++1</span><br><span class="hljs-comment">//++finished</span><br></code></pre></td></tr></table></figure><h4 id="2-enter-x2F-leave"><a href="#2-enter-x2F-leave" class="headerlink" title="2.enter&#x2F;leave"></a>2.enter&#x2F;leave</h4><p>与OC中一样，当提交到Group中的是异步任务时，notify会先于异步任务执行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q&quot;</span>, attributes: .concurrent)<br><span class="hljs-keyword">let</span> group <span class="hljs-operator">=</span> <span class="hljs-type">DispatchGroup</span>.<span class="hljs-keyword">init</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++start&quot;</span>)<br>q.async(group: group)&#123;<br>    <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>        sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++1&quot;</span>)<br>    &#125;<br>&#125;<br>q.async(group: group)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++2&quot;</span>)<br>&#125;<br>q.async(group: group)&#123;<br>    <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++3&quot;</span>)<br>    &#125;<br>&#125;<br>group.notify(queue: <span class="hljs-type">DispatchQueue</span>.main) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++finished&quot;</span>)<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++end&quot;</span>)<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++start</span><br><span class="hljs-comment">//++end</span><br><span class="hljs-comment">//++2</span><br><span class="hljs-comment">//++3</span><br><span class="hljs-comment">//++finished</span><br><span class="hljs-comment">//++1</span><br></code></pre></td></tr></table></figure><p>日志显示，notify先于异步任务1执行了。</p><p>解决这种问题，依然可以像OC一样，使用<code>enter</code>与<code>leave</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q&quot;</span>, attributes: .concurrent)<br><span class="hljs-keyword">let</span> group <span class="hljs-operator">=</span> <span class="hljs-type">DispatchGroup</span>.<span class="hljs-keyword">init</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++start&quot;</span>)<br>q.async(group: group)&#123;<br>    group.enter() <span class="hljs-comment">//改了这里</span><br>    <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>        sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++1&quot;</span>)<br>        group.leave() <span class="hljs-comment">//改了这里</span><br>    &#125;<br>&#125;<br>q.async(group: group)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++2&quot;</span>)<br>&#125;<br>q.async(group: group)&#123;<br>    group.enter() <span class="hljs-comment">//改了这里</span><br>    <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++3&quot;</span>)<br>        group.leave() <span class="hljs-comment">//改了这里</span><br>    &#125;<br>&#125;<br>group.notify(queue: <span class="hljs-type">DispatchQueue</span>.main) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++finished&quot;</span>)<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++end&quot;</span>)<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++start</span><br><span class="hljs-comment">//++2</span><br><span class="hljs-comment">//++end</span><br><span class="hljs-comment">//++3</span><br><span class="hljs-comment">//++1</span><br><span class="hljs-comment">//++finished</span><br></code></pre></td></tr></table></figure><h4 id="3-wait"><a href="#3-wait" class="headerlink" title="3.wait()"></a>3.wait()</h4><p>wait会阻塞其所在线程，待Group中的任务都完成后，继续执行wait后面的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q&quot;</span>, attributes: .concurrent)<br><span class="hljs-keyword">let</span> group <span class="hljs-operator">=</span> <span class="hljs-type">DispatchGroup</span>.<span class="hljs-keyword">init</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++start&quot;</span>)<br>q.async(group: group)&#123;<br>    sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++1&quot;</span>)<br>&#125;<br>q.async(group: group)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++2&quot;</span>)<br>&#125;<br>q.async(group: group)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++3&quot;</span>)<br>&#125;<br>group.wait()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++end&quot;</span>)<br>group.notify(queue: <span class="hljs-type">DispatchQueue</span>.main) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++finished&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//++start</span><br><span class="hljs-comment">//++2</span><br><span class="hljs-comment">//++3</span><br><span class="hljs-comment">//++1</span><br><span class="hljs-comment">//++end</span><br><span class="hljs-comment">//++finished</span><br></code></pre></td></tr></table></figure><h3 id="3-栅栏barrier"><a href="#3-栅栏barrier" class="headerlink" title="3.栅栏barrier"></a>3.栅栏barrier</h3><ul><li>栅栏会分割队列中的任务，其前面的先执行，其后面的后执行。</li><li>栅栏中的任务会在同一线程中执行。</li><li>栅栏外的其他任务根据提交方式，可能会在不同线程中执行。</li></ul><h4 id="1-配合block"><a href="#1-配合block" class="headerlink" title="1.配合block"></a>1.配合block</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;q&quot;</span>, attributes: .concurrent)<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">10</span> &#123;<br>    <span class="hljs-keyword">if</span> index <span class="hljs-operator">&gt;=</span> <span class="hljs-number">5</span> <span class="hljs-operator">&amp;&amp;</span> index <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span> &#123;<br>        q.async(flags: .barrier) &#123; <span class="hljs-comment">// 栅栏</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;barrier <span class="hljs-subst">\(index)</span>, on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        q.async()&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(index)</span>, on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出日志：</span><br><span class="hljs-comment">//0, on &lt;NSThread: 0x600003e92280&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//2, on &lt;NSThread: 0x600003e9e300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="hljs-comment">//1, on &lt;NSThread: 0x600003e99a40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="hljs-comment">//4, on &lt;NSThread: 0x600003e99a40&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="hljs-comment">//3, on &lt;NSThread: 0x600003e92280&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//barrier 5, on &lt;NSThread: 0x600003e92280&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//barrier 6, on &lt;NSThread: 0x600003e92280&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//9, on &lt;NSThread: 0x600003e9e300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="hljs-comment">//8, on &lt;NSThread: 0x600003e92280&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//7, on &lt;NSThread: 0x600003e9ea40&gt;&#123;number = 3, name = (null)&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-配合workItem"><a href="#2-配合workItem" class="headerlink" title="2.配合workItem"></a>2.配合workItem</h4><p>DispatchWorkItem 中有个 flags 属性，<code>barrier</code>就是其枚举值之一。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> q <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;concurrent&quot;</span>, attributes: .concurrent)<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> <span class="hljs-operator">..&lt;</span> <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-keyword">if</span> index <span class="hljs-operator">&gt;=</span> <span class="hljs-number">5</span> <span class="hljs-operator">&amp;&amp;</span> index <span class="hljs-operator">&lt;</span> <span class="hljs-number">7</span> &#123;<br>        <span class="hljs-keyword">let</span> work <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span>.<span class="hljs-keyword">init</span>(flags: .barrier) &#123; <span class="hljs-comment">// 栅栏</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;barrier <span class="hljs-subst">\(index)</span>, on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>        &#125;<br>        q.async(execute: work)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        q.async &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(index)</span>, on <span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出的日志：</span><br><span class="hljs-comment">//0, on &lt;NSThread: 0x600001fe8600&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//1, on &lt;NSThread: 0x600001fe8680&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="hljs-comment">//2, on &lt;NSThread: 0x600001fe9200&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="hljs-comment">//4, on &lt;NSThread: 0x600001fe8600&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//3, on &lt;NSThread: 0x600001fe8640&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="hljs-comment">//barrier 5, on &lt;NSThread: 0x600001fe8640&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="hljs-comment">//barrier 6, on &lt;NSThread: 0x600001fe8640&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="hljs-comment">//8, on &lt;NSThread: 0x600001fe8680&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="hljs-comment">//9, on &lt;NSThread: 0x600001fe8600&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="hljs-comment">//7, on &lt;NSThread: 0x600001fe8640&gt;&#123;number = 8, name = (null)&#125;</span><br></code></pre></td></tr></table></figure><p>根据栅栏的特性，可以将其用作读写锁：</p><p>读的任务放在并发队列中，同一时刻允许多读；</p><p>写的任务放在栅栏里，同一时刻只允许一个线程执行写的操作，不允许其他读与写。</p><h3 id="4-timer"><a href="#4-timer" class="headerlink" title="4.timer"></a>4.timer</h3><p>GCD定时器不是由CFRunLoopTimer实现的，不需要加入到runloopMode中，不受滑动等模式切换的影响，甚至切换到后台时依然能正常运行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">//1默认主线程</span><br><span class="hljs-comment">//timer = DispatchSource.makeTimerSource()</span><br><span class="hljs-comment">//2指定线程</span><br>timer <span class="hljs-operator">=</span> <span class="hljs-type">DispatchSource</span>.makeTimerSource(flags: [], queue: <span class="hljs-type">DispatchQueue</span>.global())<br>timer<span class="hljs-operator">?</span>.schedule(deadline: <span class="hljs-type">DispatchTime</span>.now(), repeating: .seconds(<span class="hljs-number">1</span>), leeway: .milliseconds(<span class="hljs-number">10</span>))<br>timer<span class="hljs-operator">?</span>.setEventHandler(handler: &#123;<br>    <span class="hljs-type">DispatchQueue</span>.main.sync &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++&quot;</span>)<br>    &#125;<br>&#125;)<br>timer<span class="hljs-operator">?</span>.resume()<br></code></pre></td></tr></table></figure><h3 id="5-延迟"><a href="#5-延迟" class="headerlink" title="5.延迟"></a>5.延迟</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> workItem <span class="hljs-operator">=</span> <span class="hljs-type">DispatchWorkItem</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++延迟执行1<span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> queue <span class="hljs-operator">=</span> <span class="hljs-type">DispatchQueue</span>.<span class="hljs-keyword">init</span>(label: <span class="hljs-string">&quot;after&quot;</span>, attributes: .concurrent)<br>queue.asyncAfter(deadline: <span class="hljs-type">DispatchTime</span>.now()<span class="hljs-operator">+</span><span class="hljs-number">5</span>, execute: workItem)<br>queue.asyncAfter(deadline: <span class="hljs-type">DispatchTime</span>.now()<span class="hljs-operator">+</span><span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++延迟执行2<span class="hljs-subst">\(Thread.current)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-信号量"><a href="#6-信号量" class="headerlink" title="6.信号量"></a>6.信号量</h3><p>使用信号量控制线程的并发数量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> semaphore:<span class="hljs-type">DispatchSemaphore</span>?<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">semaphore</span> &#123;<br>    semaphore <span class="hljs-operator">=</span> <span class="hljs-type">DispatchSemaphore</span>(value: <span class="hljs-number">2</span>) <span class="hljs-comment">// 最大并发数=2</span><br>    <span class="hljs-keyword">for</span>  i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">...</span><span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> thread <span class="hljs-operator">=</span> <span class="hljs-type">Thread</span>(target: <span class="hljs-keyword">self</span>, selector: <span class="hljs-keyword">#selector</span>(test), object: i <span class="hljs-keyword">as</span> <span class="hljs-type">NSNumber</span>)<br>        thread.start()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">index</span>:<span class="hljs-type">NSNumber</span>)&#123;<br>    semaphore<span class="hljs-operator">?</span>.wait()<br>    sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++测试<span class="hljs-subst">\(index.intValue)</span>，<span class="hljs-subst">\(Date())</span>&quot;</span>)<br>    semaphore<span class="hljs-operator">?</span>.signal()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用信号量保证线程的同步与安全。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">semaphore <span class="hljs-operator">=</span> <span class="hljs-type">DispatchSemaphore</span>(value: <span class="hljs-number">1</span>)<br><span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>    <span class="hljs-keyword">self</span>.semaphore<span class="hljs-operator">?</span>.wait()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++访问共享资源1&quot;</span>)<br>    sleep(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">self</span>.semaphore<span class="hljs-operator">?</span>.signal()<br>&#125;<br><span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>    <span class="hljs-keyword">self</span>.semaphore<span class="hljs-operator">?</span>.wait()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++访问共享资源2&quot;</span>)<br>    sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">self</span>.semaphore<span class="hljs-operator">?</span>.signal()<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>相关参考：</p><p>#<a href="https://davidlii.cn/">©</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift-OC混编</title>
    <link href="/2018/09/20/swift-mix.html"/>
    <url>/2018/09/20/swift-mix.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-混编"><a href="#1-混编" class="headerlink" title="1.混编"></a>1.混编</h3><ul><li><p>Swift 工程中使用 Objective-C 文件；</p></li><li><p>Objective-C 工程中使用 Swift 文件。</p></li></ul><p>本文所用 Xcode 版本：9.4.1</p><h3 id="2-Swift中混编OC"><a href="#2-Swift中混编OC" class="headerlink" title="2.Swift中混编OC"></a>2.Swift中混编OC</h3><p>Swift 工程中使用 OC 文件时需要依赖 <code>桥接头文件</code> 将 OC 中的属性、接口等暴露给 Swift。默认情况下，在 Swift 工程中首次创建 OC 文件时，Xcode 会自动提示你是否创建桥接头文件：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_swift_OC_Header.png" alt="桥接头文件"></p><p>选择创建后，工程目录下会多出一个以 “工程名-Bridging-Header.h” 命名的头文件:</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_swift_OC_dir.png" alt="swift工程中OC文件目录"></p><p>可在 “Targets–&gt;Build Settings–&gt;Swift Compiler - General” 查看，一般不用做额外修改：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_swift_OC.png" alt="swift使用OC文件的设置"></p><p>如果你忽略了 Xcode 的提示，没创建桥接头文件，没关系后面还有机会。稍后你可以按照上面的命名规则自己新建一个头文件，在 “Targets–&gt;Build Settings–&gt;Swift Compiler - General” 中手动设置好 “Objective-C Bridging Header” 选项的路径即可。</p><p>接下来就可以在桥接头文件 “HelloSwift-Bridging-Header.h” 中导入你想暴露的 OC 头文件了：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;OCFile.h&quot;</span><br></code></pre></td></tr></table></figure><p>这样，就可以在 Swift 工程中使用刚刚创建的 OC 类<code>OCFile</code>了，完整示例如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//OCFile.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_ENUM</span>(<span class="hljs-built_in">NSInteger</span>, Direction) &#123;<br>    DirectionEast,<span class="hljs-comment">//Swift中会被编译为.east（OC中的枚举前缀在Swift中会被截断）</span><br>    DirectionWest,<br>    DirectionSouth,<br>    DirectionNorth,<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">OCFile</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-type">int</span> aInt;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonnull</span>) <span class="hljs-built_in">NSArray</span> *anArr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *str;<br><br>- (<span class="hljs-type">void</span>)instanceFunction:(Direction)direction;<br>+ (<span class="hljs-type">void</span>)classFunction;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//OCFile.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;OCFile.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">OCFile</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSDictionary</span> *aDic;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">OCFile</span></span><br><br>-(<span class="hljs-keyword">instancetype</span>)init<br>&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        aDouble = <span class="hljs-number">0.001</span>;<br>        aInte = <span class="hljs-number">1</span>;<br>        _aInt = <span class="hljs-number">2</span>;<br>        _anArr = @[@(<span class="hljs-number">123</span>)];<br>        _aDic = @&#123;<span class="hljs-string">@&quot;k1&quot;</span>:_anArr&#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)instanceFunction:(Direction)direction<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++call instance method&quot;</span>);<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)classFunction<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++call class method&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在<code>AppDelegate.swift</code>中直接使用OC类，不需要再导入其头文件：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit<br><br><span class="hljs-keyword">@UIApplicationMain</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AppDelegate</span>: <span class="hljs-title class_">UIResponder</span>, <span class="hljs-title class_">UIApplicationDelegate</span> &#123;<br><br>    <span class="hljs-keyword">var</span> window: <span class="hljs-type">UIWindow</span>?<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">application</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">application</span>: <span class="hljs-type">UIApplication</span>,<br>                     <span class="hljs-params">didFinishLaunchingWithOptions</span><br>        <span class="hljs-params">launchOptions</span>: [<span class="hljs-params">UIApplicationLaunchOptionsKey</span>: <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>) -&gt; <span class="hljs-type">Bool</span><br>    &#123;<br>        <span class="hljs-keyword">let</span> ocf <span class="hljs-operator">=</span> <span class="hljs-type">OCFile</span>()<br>        ocf.instanceFunction(<span class="hljs-type">Direction</span>.east)<br>        <span class="hljs-type">OCFile</span>.classFunction()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++<span class="hljs-subst">\(ocf.anArr)</span>&quot;</span>)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-OC中混编Swift"><a href="#3-OC中混编Swift" class="headerlink" title="3.OC中混编Swift"></a>3.OC中混编Swift</h3><p>OC 工程中使用 Swift 文件需要一个命名格式为 “工程名-Swift.h” 的头文件。它是一个 OC 头文件，包含了工程 Target 里所有 Swift 代码中定义的接口、属性等。有了它 Swift 文件中标记为 <code>open</code>、<code>public</code>、<code>internal</code> 的信息才能暴露给 OC 。在编译工程（command+B）后 Xcode 自动生成，不需要自己创建，也不会显示在工程目录中。下面是具体步骤：</p><p>在 OC 工程中新建 Swift 文件：“command+N -&gt; swift File”，目录如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_mix_match_dir.png" alt="OC工程中swift文件目录"></p><p>首次创建 Swift 文件时，Xcode 会提示新建桥接头文件，这里可以不创建。之后 Xcode 会自动设置好 “Objective-C Generated Interface Header Name” 选项，我们不用做什么修改：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_mix_match.png" alt="OC中使用swift文件"></p><p>自定义你的 Swift 类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 继承NSObject并用@objc标记需要暴露给OC的元素</span><br><span class="hljs-keyword">import</span> Foundation<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SwiftFile</span> : <span class="hljs-title class_">NSObject</span> &#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> name : <span class="hljs-type">String</span>?<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">let</span> nick : <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>:<span class="hljs-type">String</span>,<span class="hljs-params">nick</span>:<span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.nick <span class="hljs-operator">=</span> nick<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swiftInstanceMethod</span>(<span class="hljs-params">name</span>:<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name is:<span class="hljs-subst">\(name)</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">swiftClassMethod</span>(<span class="hljs-title class_">nick</span>:<span class="hljs-title class_">String</span>) -&gt; <span class="hljs-title class_">String</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nick is:<span class="hljs-subst">\(nick)</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> nick<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在用到此 Swift 文件的地方导入 “工程名-swift.h” 头文件即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;AppDelegate.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ASDF-Swift.h&quot;</span> <span class="hljs-comment">//导入 swift 文件对应的 OC 版头文件</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    SwiftFile *sf = [[SwiftFile alloc] initWithName:<span class="hljs-string">@&quot;swift&quot;</span> nick:<span class="hljs-string">@&quot;sf&quot;</span>];<br>    sf.name = <span class="hljs-string">@&quot;Swift4.1&quot;</span>;<br>    [sf swiftInstanceMethodWithName:<span class="hljs-string">@&quot;Hello&quot;</span>];<br>    [SwiftFile swiftClassMethodWithNick:<span class="hljs-string">@&quot;newNick&quot;</span>];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>command + B 编译之后，command + 点击这个<code>ASDF-Swift.h</code>就能看到其中的内容了。里面是 Xcode 帮我们生成的 <code>SwiftFile.swift</code> 的 OC 版头文件，内容很长，重要内容摘录如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SwiftFile</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> * _Nullable name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> * _Nonnull nick;<br>- (<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">instancetype</span>)initWithName:(<span class="hljs-built_in">NSString</span> * _Nonnull)name nick:(<span class="hljs-built_in">NSString</span> * _Nonnull)nick OBJC_DESIGNATED_INITIALIZER;<br>- (<span class="hljs-built_in">NSString</span> * _Nonnull)swiftInstanceMethodWithName:(<span class="hljs-built_in">NSString</span> * _Nonnull)name SWIFT_WARN_UNUSED_RESULT;<br>- (<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">instancetype</span>)init SWIFT_UNAVAILABLE;<br>+ (<span class="hljs-keyword">nonnull</span> <span class="hljs-keyword">instancetype</span>)new SWIFT_DEPRECATED_MSG(<span class="hljs-string">&quot;-init is unavailable&quot;</span>);<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>可访问性</li></ul><p>OC 中使用 Swift 文件时，Swift类需要继承<code>NSObject</code>并用<code>@objc</code>标记需要暴露给OC的元素；并且<code>工程名-Swift.h</code>文件中只能将 Swift文件中标注为<code>open</code>、<code>public</code>、<code>internal</code>的类、属性和接口等暴露给 OC，而<code>fileprivate</code>和<code>private</code>标记的信息对 OC 不可见。Swift 中默认的访问控制修饰符是<code>internal</code>。</p><ul><li>版本变更</li></ul><p>Swift 3.x 中类只要继承了 NSObject，编译器会隐式地为所有<code>public</code>的属性或方法添加<code>@objc</code>标注，这样就能把 Swift 的属性、函数等暴露给 OC；但 Swift 4.x 中继承自 NSObject 的类不再隐式添加<code>@objc</code>，需要手动标注。</p><ul><li>继承问题</li></ul><p>Swift类可以继承自 OC 类，但反过来 OC 类不能继承 Swift 类。</p><ul><li>宏定义</li></ul><p>Swift中使用 OC 中的<code>宏</code>时，可以将简单的宏定义成全局常量，复杂的宏可以将其定义成函数。</p><ul><li>Swift独有的特性</li></ul><p>将 Swift 代码导入 OC 后，你可以访问在 Swift 类或协议中使用<code>@objc</code>标记的任何对象，只要该对象与 OC 兼容。部分 Swift 独有的特性不能在 OC 中使用，包括：泛型、元组、非Int类型的枚举、可变参数、函数嵌套等。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/documentation/swift/migrating_your_objective_c_code_to_swift">©Apple</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift高阶函数</title>
    <link href="/2018/09/14/swift-map.html"/>
    <url>/2018/09/14/swift-map.html</url>
    
    <content type="html"><![CDATA[<h4 id="1-map"><a href="#1-map" class="headerlink" title="1.map"></a>1.map</h4><p>遍历集合并对每个元素执行相同的操作，从而将元素映射成新值并放在<code>数组</code>中返回，新值可以是原类型也可以是<code>新的类型</code>。</p><ul><li>对数组</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">//将元素映射成<span class="hljs-built_in">string</span>类型<br><span class="hljs-built_in">let</span> intArr = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-built_in">let</span> newArr = intArr.<span class="hljs-built_in">map</span> &#123; <span class="hljs-string">&quot;\($0)&quot;</span> &#125;<br><span class="hljs-built_in">print</span>(newArr)  //打印结果：[<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li>对set</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">//将元素+<span class="hljs-number">1</span>并映射成<span class="hljs-built_in">string</span>类型<br><span class="hljs-built_in">let</span> intSet = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br><span class="hljs-built_in">let</span> newSet = intSet.<span class="hljs-built_in">map</span> &#123; (e) -&gt; String <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;\(e+1)&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(newSet)  //打印结果：[<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li>对字典</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> dic = [<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">2</span>]<br>//<span class="hljs-number">1</span>.将value映射成<span class="hljs-built_in">string</span>类型<br><span class="hljs-built_in">let</span> arr1 = dic.<span class="hljs-built_in">map</span> &#123; (<span class="hljs-built_in">key</span>: String, value: Int) <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">return</span> [<span class="hljs-built_in">key</span>,<span class="hljs-string">&quot;\(value)&quot;</span>] <br>&#125;<br>//<span class="hljs-number">2</span>.取value并将其映射成<span class="hljs-built_in">string</span>类型<br><span class="hljs-built_in">let</span> arr2 = dic.<span class="hljs-built_in">map</span> &#123; (<span class="hljs-built_in">key</span>: String, value: Int) <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;\(value)&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(arr1)  //打印结果：[[<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>], [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>], [<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>]]<br><span class="hljs-built_in">print</span>(arr2)  //打印结果：[<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="2-flatMap"><a href="#2-flatMap" class="headerlink" title="2.flatMap"></a>2.flatMap</h4><p>功能1：与<code>map</code>类似，遍历集合中的元素将其映射为新值并以数组形式返回。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> intAra =<span class="hljs-meta"> [0,1,2,3,4,5]</span><br><span class="hljs-attribute">let</span> r0 = intAra.map &#123; $<span class="hljs-number">0</span>+<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">let</span> r1 = intAra.flatMap &#123; $<span class="hljs-number">0</span>+<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">print</span>(r0) //打印：[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-attribute">print</span>(r1) //打印：[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>功能2：flatMap能对多维数组进行降维，返回一维数组。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">let lv2Arr = <span class="hljs-string">[[1,2,3],[4,5,6]]</span>;<br>var result0 = lv2Arr.map &#123; $<span class="hljs-number">0.</span>map&#123; $<span class="hljs-number">0</span> + <span class="hljs-number">2</span> &#125; &#125;<br>var result1 = lv2Arr.flatMap &#123; $<span class="hljs-number">0.</span>map&#123; $<span class="hljs-number">0</span> + <span class="hljs-number">2</span> &#125; &#125;<br><span class="hljs-built_in">print</span>(result0) //<span class="hljs-string">[[3, 4, 5], [6, 7, 8]]</span>  -&gt;返回的还是二维数组<br><span class="hljs-built_in">print</span>(result1) //[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]      -&gt;返回的是一维数组<br></code></pre></td></tr></table></figure><p>功能3：对集合中的可选类型进行拆包，且只有拆包成功的元素才会在结果中返回。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">let a:String? = <span class="hljs-string">&quot;opt&quot;</span>     <span class="hljs-regexp">//</span>可选类型<br>let arr = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,nil,a] <span class="hljs-regexp">//</span>包含nil与可选<br>let map = arr.map&#123; <span class="hljs-variable">$0</span> &#125;<br>let flatMap = arr.flatMap&#123; <span class="hljs-variable">$0</span> &#125;<br>print(map)     <span class="hljs-regexp">//</span>[Optional(<span class="hljs-string">&quot;a&quot;</span>), Optional(<span class="hljs-string">&quot;b&quot;</span>), nil, Optional(<span class="hljs-string">&quot;opt&quot;</span>)]<br>print(flatMap) <span class="hljs-regexp">//</span>[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;opt&quot;</span>]  -&gt;可选拆包，且nil被过滤掉<br></code></pre></td></tr></table></figure><h4 id="3-filter"><a href="#3-filter" class="headerlink" title="3.filter"></a>3.filter</h4><p>遍历集合中的元素，将符合某个条件的元素组合成新的数组并返回。</p><ul><li>对数组</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//取集合中大于0的元素</span><br>let intArr = <span class="hljs-selector-attr">[0,1,2]</span><br>let aArr = intArr<span class="hljs-selector-class">.filter</span> &#123; value -&gt; Bool <span class="hljs-keyword">in</span><br>    return value &gt; <span class="hljs-number">0</span><br>&#125;<br>let bArr = intArr.<span class="hljs-attribute">filter</span>&#123; $<span class="hljs-number">0</span> &gt; <span class="hljs-number">0</span> &#125; //尾随闭包的写法<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(aArr)</span></span> <span class="hljs-comment">//打印结果：[1, 2]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bArr)</span></span> <span class="hljs-comment">//打印结果：[1, 2]</span><br></code></pre></td></tr></table></figure><ul><li>对字典</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//取集合中大于0的元素</span><br>let dic0 = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;a&quot;</span>:0,<span class="hljs-string">&quot;b&quot;</span>:1,<span class="hljs-string">&quot;c&quot;</span>:2]</span><br>let dic1 = dic0<span class="hljs-selector-class">.filter</span> &#123; (key: String, value: Int) <span class="hljs-keyword">in</span><br>    return value &gt; <span class="hljs-number">0</span><br>&#125;<br>let dic2 = dic0<span class="hljs-selector-class">.filter</span> &#123; $<span class="hljs-number">0</span><span class="hljs-selector-class">.value</span> &gt; <span class="hljs-number">0</span> &#125;  <span class="hljs-comment">//尾随闭包的写法</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dic1)</span></span> <span class="hljs-comment">//打印结果：[&quot;c&quot;: 2, &quot;b&quot;: 1]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dic2)</span></span> <span class="hljs-comment">//打印结果：[&quot;c&quot;: 2, &quot;b&quot;: 1]</span><br></code></pre></td></tr></table></figure><h4 id="4-reduce"><a href="#4-reduce" class="headerlink" title="4.reduce"></a>4.reduce</h4><p>遍历集合把所有元素组合起来，计算成一个新值并返回。<code>reduce</code>可接收一个初始值。</p><ul><li>对数组</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>计算所有元素的和<br>let numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>let sum0 = numbers.reduce(<span class="hljs-number">0</span>) &#123; (x,y) <span class="hljs-keyword">in</span><br>    <span class="hljs-regexp">//</span>print(<span class="hljs-string">&quot;\(x),\(y)&quot;</span>)<br>    return (x + y)<br>&#125;<br><span class="hljs-regexp">//</span>初始值为<span class="hljs-number">1</span>，计算元素的和<br>let sum1 = numbers.reduce(<span class="hljs-number">1</span>) &#123; <span class="hljs-variable">$0</span>+<span class="hljs-variable">$1</span> &#125; <span class="hljs-regexp">//</span>尾随闭包的写法<br>print(sum0) <span class="hljs-regexp">//</span>打印：<span class="hljs-number">10</span><br>print(sum1) <span class="hljs-regexp">//</span>打印：<span class="hljs-number">11</span><br><br><span class="hljs-regexp">//</span>对于sum0，其计算过程为：<br><span class="hljs-number">1</span>.初始值为<span class="hljs-number">0</span>，x为<span class="hljs-number">0</span>，y为<span class="hljs-number">1</span> -&gt; 返回 x + y 。所以初始值或者结果变为 <span class="hljs-number">1</span>。<br><span class="hljs-number">2</span>.初始值或者结果变为 <span class="hljs-number">1</span>，x为<span class="hljs-number">1</span>，y为<span class="hljs-number">2</span> -&gt; 返回 x + y 。所以初始值或者结果变为 <span class="hljs-number">3</span>。<br><span class="hljs-number">3</span>.初始值或者结果变为 <span class="hljs-number">3</span>，x为<span class="hljs-number">3</span>，y为<span class="hljs-number">3</span> -&gt; 返回 x + y 。所以初始值或者结果变为 <span class="hljs-number">6</span>。<br><span class="hljs-number">4</span>.初始值或者结果变为 <span class="hljs-number">6</span>，x为<span class="hljs-number">6</span>，y为<span class="hljs-number">4</span> -&gt; 返回 x + y 。所以初始值或者结果变为 <span class="hljs-number">10</span>。<br></code></pre></td></tr></table></figure><ul><li>对字典</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let dic0 = <span class="hljs-selector-attr">[<span class="hljs-string">&quot;a&quot;</span>:0,<span class="hljs-string">&quot;b&quot;</span>:1,<span class="hljs-string">&quot;c&quot;</span>:2,<span class="hljs-string">&quot;d&quot;</span>:4]</span><br>let reduce = dic0<span class="hljs-selector-class">.reduce</span>(<span class="hljs-number">0</span>) &#123; (result, dic) <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\(result),\(dic.key),\(dic.value)&quot;</span>)<br>    return result + dic<span class="hljs-selector-class">.value</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(reduce)</span></span> <span class="hljs-comment">//打印：7</span><br><br><span class="hljs-comment">//取消注释查看reduce的计算过程：</span><br><span class="hljs-number">0</span>,d,<span class="hljs-number">4</span><br><span class="hljs-number">4</span>,<span class="hljs-selector-tag">b</span>,<span class="hljs-number">1</span><br><span class="hljs-number">5</span>,<span class="hljs-selector-tag">a</span>,<span class="hljs-number">0</span><br><span class="hljs-number">5</span>,c,<span class="hljs-number">2</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift-@objc\@objcMember\dynamic</title>
    <link href="/2018/09/05/swift-dynamic.html"/>
    <url>/2018/09/05/swift-dynamic.html</url>
    
    <content type="html"><![CDATA[<h4 id="1-objc"><a href="#1-objc" class="headerlink" title="1.@objc"></a>1.@objc</h4><p>将Swift中的元素暴露给OC运行时，以便在OC中调用Swift代码。</p><p>常见的，如Swift中给按钮添加点击事件时，需要给selector添加@objc标记。因为SEL是OC运行时中的特性，runtime根据SEL查找函数的实现。要将按钮回调函数暴露给OC运行时，需要将其标记为<code>@objc</code>，从而让OC运行时进行消息派发。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>: <span class="hljs-title class_">UIViewController</span> &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        <span class="hljs-keyword">let</span> btn <span class="hljs-operator">=</span> <span class="hljs-type">UIButton</span>.<span class="hljs-keyword">init</span>(type: .custom)<br>        btn.addTarget(<span class="hljs-keyword">self</span>, action: <span class="hljs-keyword">#selector</span>(btnCallback), for: .touchUpInside)<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">btnCallback</span>()&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OC工程中调用Swift代码时，也需要将Swift代码标记为@objc：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// OC中定义SWift类 编译后会生成”工程名-Swift.h“头文件，里面包括了自动生成的OC版代码</span><br><span class="hljs-keyword">import</span> Foundation<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SwiftFile</span> : <span class="hljs-title class_">NSObject</span> &#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> name : <span class="hljs-type">String</span>?<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">let</span> nick : <span class="hljs-type">String</span><br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>:<span class="hljs-type">String</span>,<span class="hljs-params">nick</span>:<span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.nick <span class="hljs-operator">=</span> nick<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">swiftInstanceMethod</span>(<span class="hljs-params">name</span>:<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name is:<span class="hljs-subst">\(name)</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">swiftClassMethod</span>(<span class="hljs-title class_">nick</span>:<span class="hljs-title class_">String</span>) -&gt; <span class="hljs-title class_">String</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nick is:<span class="hljs-subst">\(nick)</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> nick<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// OC工程引用swift代码</span><br>#<span class="hljs-keyword">import</span> &quot;AppDelegate.h&quot;<br>#<span class="hljs-keyword">import</span> &quot;ASDF-Swift.h&quot; <span class="hljs-comment">//导入 swift 文件对应的 OC 版头文件</span><br><br><span class="hljs-meta">@implementation</span> <span class="hljs-type">AppDelegate</span><br><br><span class="hljs-operator">-</span> (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-type">UIApplication</span> <span class="hljs-operator">*</span>)application<br>didFinishLaunchingWithOptions:(<span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span>)launchOptions<br>&#123;<br>    <span class="hljs-type">SwiftFile</span> <span class="hljs-operator">*</span>sf <span class="hljs-operator">=</span> [[<span class="hljs-type">SwiftFile</span> alloc] initWithName:@<span class="hljs-string">&quot;swift&quot;</span> nick:@<span class="hljs-string">&quot;sf&quot;</span>];<br>    sf.name <span class="hljs-operator">=</span> @<span class="hljs-string">&quot;Swift4.1&quot;</span>;<br>    [sf swiftInstanceMethodWithName:@<span class="hljs-string">&quot;Hello&quot;</span>];<br>    [<span class="hljs-type">SwiftFile</span> swiftClassMethodWithNick:@<span class="hljs-string">&quot;newNick&quot;</span>];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">YES</span>;<br>&#125;<br><span class="hljs-meta">@end</span><br></code></pre></td></tr></table></figure><h4 id="2-objcMember"><a href="#2-objcMember" class="headerlink" title="2.@objcMember"></a>2.@objcMember</h4><p>标记Swift中的类，将其所有元素都暴露给OC，等同于为所有元素加上<code>@objc</code>。</p><p>注意：这些元素不包括Swift独有而OC中没有与之对应的元素类型，如Tuple。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@objc</span>Members<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> : <span class="hljs-title class_">NSObject</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">eat</span>() &#123; &#125; <span class="hljs-comment">// 隐式添加了 @objc</span><br>    <br>    <span class="hljs-comment">// 不会添加 @objc, 因为OC中没有元组</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drink</span>() -&gt; (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>)<span class="hljs-operator">?</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">call</span>() &#123; &#125;   <span class="hljs-comment">// 隐式添加了 @objc</span><br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">miao</span>() &#123; &#125;   <span class="hljs-comment">// 隐式添加了 @objc</span><br>&#125;<br> <br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Cat</span> &#123;<br>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">paw</span>() &#123; &#125;   <span class="hljs-comment">// 隐式添加了 @objc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为何有这个关键字呢？Swift3及其之前版本中继承自NSObject的类，编译器会给所有的非private类及其成员加上@objc。swift4之后苹果不再默认这么做，但提供了@objcMember关键字作为替代方案，给被其标记的类及其成员添加@objc关键字。</p><h4 id="3-dynamic"><a href="#3-dynamic" class="headerlink" title="3.dynamic"></a>3.dynamic</h4><p>标记类的成员，使其属性方法等进行动态派发。</p><p>被标记为@objc的元素不一定会变成动态派发，Swift依然可能会将其优化为静态调用。如果在Swift中确实需要用到动态派发机制，比如KVO或者方法交换等特性时，则需要将其标记为 dynamic。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>: <span class="hljs-title class_">NSObject</span> &#123;  <span class="hljs-comment">//需要继承自NSObject</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">//@objc在Swift4之后必须要添加</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> &#123;<br><br>    <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> <span class="hljs-type">People</span>.<span class="hljs-keyword">init</span>()<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        p.addObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-keyword">#keyPath</span>(<span class="hljs-type">People</span>.name), options: [.new], context: <span class="hljs-literal">nil</span>)<br>        p.addObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;age&quot;</span>, options: [.new], context: <span class="hljs-literal">nil</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewWillAppear</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">animated</span>: <span class="hljs-type">Bool</span>) &#123;<br>        p.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kitt&quot;</span><br>        p.age <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//监听回调</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">observeValue</span>(<span class="hljs-params">forKeyPath</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">String</span>?, <span class="hljs-params">of</span> <span class="hljs-params">object</span>: <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span>, <span class="hljs-params">change</span>: [<span class="hljs-params">NSKeyValueChangeKey</span> : <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>, <span class="hljs-params">context</span>: <span class="hljs-type">UnsafeMutableRawPointer</span>?) &#123;<br>        <span class="hljs-keyword">if</span> keyPath <span class="hljs-operator">==</span> <span class="hljs-string">&quot;name&quot;</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;new Name:<span class="hljs-subst">\(change<span class="hljs-operator">!</span>[NSKeyValueChangeKey.newKey] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;Default&quot;</span>)</span>&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> keyPath <span class="hljs-operator">==</span> <span class="hljs-string">&quot;age&quot;</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;new age:<span class="hljs-subst">\(change<span class="hljs-operator">!</span>[NSKeyValueChangeKey.newKey] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;Default&quot;</span>)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deinit&quot;</span>)<br>        p.removeObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;name&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果People类中去掉dynamic关键字，则给属性赋值时<code>p.age = 21</code>不会触发监听的回调。</p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift属性监听</title>
    <link href="/2018/08/31/swift-kvo.html"/>
    <url>/2018/08/31/swift-kvo.html</url>
    
    <content type="html"><![CDATA[<h2 id="1、属性观察器"><a href="#1、属性观察器" class="headerlink" title="1、属性观察器"></a>1、属性观察器</h2><p>Swift 提供了<code>属性观察器</code>来监听自身<code>存储属性</code>的变化。观察器只能用于监听非<code>lazy</code>存储属性。对于计算属性，它已经内含了<code>get&#123;&#125;</code>和<code>set&#123;&#125;</code>，闭包内已经知道属性的变化，不需要再提供观察器。对于从父类继承下来的存储属性或计算属性，我们可以在子类中重写属性的<code>getter</code>和<code>setter</code>来为它们添加属性观察器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <br>    <span class="hljs-keyword">var</span> nick : <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">willSet</span>&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++New value:<span class="hljs-subst">\(newValue)</span>&quot;</span>)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span>&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++Old value:<span class="hljs-subst">\(oldValue)</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>:<span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.nick <span class="hljs-operator">=</span> name<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用及输出结果：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> <span class="hljs-keyword">st</span> = Student(name: <span class="hljs-string">&quot;HALO&quot;</span>)<br><span class="hljs-keyword">st</span>.nick = <span class="hljs-string">&quot;james&quot;</span><br><span class="hljs-comment">//输出</span><br>++++New value:james<br>++++Old value:HALO<br></code></pre></td></tr></table></figure><p>观察器只能用来观察自身属性（包括从父类继承下来的属性）的变化。</p><h2 id="2、使用KVO观察属性"><a href="#2、使用KVO观察属性" class="headerlink" title="2、使用KVO观察属性"></a>2、使用KVO观察属性</h2><p>条件1：观察者和被观察者都要继承自<code>NSObject</code></p><p>KVO 是 OC 中的特性，在 OC 中它是基于 runtime 的动态分发机制和 KVC，通过<code>key</code>来监听<code>value</code>的变化。OC 中所有的类都直接或间接继承自 NSObject，而根类 NSObject 默认遵守了<code>NSKeyValueCoding</code>协议，所以这些类才能实现 KVO。Swift class 只有继承了 NSObject 才能拥有这些特性。对于没有父类或者不继承 NSObject 的情况，则可以使用上面提到的观察器来实现此功能。</p><p>条件2：需要将属性标记为<code>@objc</code>和<code>dynamic</code></p><p><code>@objc</code>标记用来将 Swift 类中的属性暴露给 OC；你也可以将类标注为<code>@objcMembers</code>，使用这种标注的类会隐式地为类中所有的属性和方法添加<code>@objc</code>标注。</p><p>另外，Swift 中默认关闭了动态派发机制，声明为<code>@objc</code>的属性或方法有可能会被 Swift 优化为静态调用，不一定会动态派发，所以还需将属性标记为<code>dynamic</code>才能开启运行时从而监听属性的变化。</p><h3 id="方案1（addObserver-）"><a href="#方案1（addObserver-）" class="headerlink" title="方案1（addObserver:）"></a>方案1（addObserver:）</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>: <span class="hljs-title class_">NSObject</span> &#123;<br>    <br>    <span class="hljs-comment">//定义待监听的属性</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;defaultName&quot;</span><br>    <span class="hljs-comment">//更新属性值</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params">pName</span>:<span class="hljs-type">String</span>) -&gt; () &#123;<br>        name <span class="hljs-operator">=</span> pName<br>    &#125;<br>    <br>    <span class="hljs-comment">//注册监听</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        addObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;name&quot;</span>, options: [.new,.old], context: <span class="hljs-literal">nil</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">//处理监听</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">observeValue</span>(<span class="hljs-params">forKeyPath</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">String</span>?,<br>                               <span class="hljs-params">of</span> <span class="hljs-params">object</span>: <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span>,<br>                               <span class="hljs-params">change</span>: [<span class="hljs-params">NSKeyValueChangeKey</span> : <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>,<br>                               <span class="hljs-params">context</span>: <span class="hljs-type">UnsafeMutableRawPointer</span>?) &#123;<br>        <span class="hljs-keyword">if</span> keyPath <span class="hljs-operator">==</span> <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-keyword">let</span> newName <span class="hljs-operator">=</span> change<span class="hljs-operator">?</span>[.newKey] &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++name updated to: <span class="hljs-subst">\(newName)</span>&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">super</span>.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//析构中移除监听</span><br>    <span class="hljs-keyword">deinit</span> &#123;<br>        removeObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;name&quot;</span>, context: <span class="hljs-literal">nil</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++已移除监听&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方法与输出结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//调用：</span><br><span class="hljs-keyword">let</span> people = <span class="hljs-constructor">People()</span><br>people.update<span class="hljs-constructor">Name(<span class="hljs-params">pName</span>: <span class="hljs-string">&quot;Dav&quot;</span>)</span><br>people.set<span class="hljs-constructor">Value(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-params">forKey</span>: <span class="hljs-string">&quot;name&quot;</span>)</span><br><span class="hljs-comment">//输出结果：</span><br>++++name updated <span class="hljs-keyword">to</span>: Dav<br>++++name updated <span class="hljs-keyword">to</span>: Hello<br>++++已移除监听<br></code></pre></td></tr></table></figure><h3 id="方案2（observe闭包）"><a href="#方案2（observe闭包）" class="headerlink" title="方案2（observe闭包）"></a>方案2（observe闭包）</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>: <span class="hljs-title class_">NSObject</span> &#123;<br>    <br>    <span class="hljs-comment">//定义待监听的属性</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;defaultName&quot;</span><br>    <span class="hljs-comment">//更新属性值</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateName</span>(<span class="hljs-params">pName</span>:<span class="hljs-type">String</span>) -&gt; () &#123;<br>        name <span class="hljs-operator">=</span> pName<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span>: <span class="hljs-title class_">NSObject</span> &#123;<br>    <br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">var</span> objToObserve : <span class="hljs-type">People</span> <span class="hljs-comment">//注意这里也要标记为@objc</span><br>    <br>    <span class="hljs-keyword">var</span> observation : <span class="hljs-type">NSKeyValueObservation</span>?<br>    <br>    <span class="hljs-comment">//注册监听</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">object</span> : <span class="hljs-type">People</span>) &#123;<br>        objToObserve <span class="hljs-operator">=</span> object<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        <br>        observation <span class="hljs-operator">=</span> observe(\.objToObserve.name,options: [.old, .new], changeHandler: &#123; (object, change) <span class="hljs-keyword">in</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name updated from: <span class="hljs-subst">\(change.oldValue<span class="hljs-operator">!</span>)</span>, updated to: <span class="hljs-subst">\(change.newValue<span class="hljs-operator">!</span>)</span>&quot;</span>)<br>        &#125;)<br>    &#125;<br>    <br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++Observer Deinited&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方法与输出结果如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//调用：</span><br><span class="hljs-keyword">let</span> people = <span class="hljs-constructor">People()</span><br><span class="hljs-keyword">let</span> observer = <span class="hljs-constructor">Observer(<span class="hljs-params">object</span>: <span class="hljs-params">people</span>)</span><br>people.update<span class="hljs-constructor">Name(<span class="hljs-params">pName</span>: <span class="hljs-string">&quot;Dav&quot;</span>)</span><br>people.set<span class="hljs-constructor">Value(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-params">forKey</span>: <span class="hljs-string">&quot;name&quot;</span>)</span><br><span class="hljs-comment">//输出结果：</span><br>++++name updated from: defaultName, updated <span class="hljs-keyword">to</span>: Dav<br>++++name updated from: Dav, updated <span class="hljs-keyword">to</span>: Hello<br>++++Observer Deinited<br></code></pre></td></tr></table></figure><hr><p>相关参考</p><p>#<a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns/using_key_value_observing_in_swift">©swift官方文档</a></p><p>#<a href="https://tech.glowing.com/cn/implement-kvo/">©自己实现KVO</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift错误处理</title>
    <link href="/2018/08/25/swift-error.html"/>
    <url>/2018/08/25/swift-error.html</url>
    
    <content type="html"><![CDATA[<h4 id="1-错误的表示"><a href="#1-错误的表示" class="headerlink" title="1.错误的表示"></a>1.错误的表示</h4><p>Swift中用实现了<code>Error</code>协议的类型表示错误，通常用枚举来表示一组错误信息。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">enum</span> VendingMachineError: Error &#123;<br>    <span class="hljs-keyword">case</span> invalidSelection<br>    <span class="hljs-keyword">case</span> insufficientFunds(coinsNeeded: <span class="hljs-built_in">Int</span>)<br>    <span class="hljs-keyword">case</span> outOfStock<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-抛出错误"><a href="#2-抛出错误" class="headerlink" title="2.抛出错误"></a>2.抛出错误</h4><p>在方法的参数后，返回值前使用<code>throws</code>标记可能方法可能抛出错误。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Item</span> &#123;<br>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VendingMachine</span> &#123;<br>    <span class="hljs-keyword">var</span> inventory <span class="hljs-operator">=</span> [<br>        <span class="hljs-string">&quot;Candy Bar&quot;</span>: <span class="hljs-type">Item</span>(price: <span class="hljs-number">12</span>, count: <span class="hljs-number">7</span>),<br>        <span class="hljs-string">&quot;Chips&quot;</span>: <span class="hljs-type">Item</span>(price: <span class="hljs-number">10</span>, count: <span class="hljs-number">4</span>),<br>        <span class="hljs-string">&quot;Pretzels&quot;</span>: <span class="hljs-type">Item</span>(price: <span class="hljs-number">7</span>, count: <span class="hljs-number">11</span>)<br>    ]<br>    <span class="hljs-keyword">var</span> coinsDeposited <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">vend</span>(<span class="hljs-params">itemNamed</span> <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) <span class="hljs-keyword">throws</span> &#123;   <span class="hljs-comment">//抛出错误</span><br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> item <span class="hljs-operator">=</span> inventory[name] <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-type">VendingMachineError</span>.invalidSelection<br>        &#125;<br><br>        <span class="hljs-keyword">guard</span> item.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-type">VendingMachineError</span>.outOfStock<br>        &#125;<br><br>        <span class="hljs-keyword">guard</span> item.price <span class="hljs-operator">&lt;=</span> coinsDeposited <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-type">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price <span class="hljs-operator">-</span> coinsDeposited)<br>        &#125;<br><br>        coinsDeposited <span class="hljs-operator">-=</span> item.price<br><br>        <span class="hljs-keyword">var</span> newItem <span class="hljs-operator">=</span> item<br>        newItem.count <span class="hljs-operator">-=</span> <span class="hljs-number">1</span><br>        inventory[name] <span class="hljs-operator">=</span> newItem<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dispensing <span class="hljs-subst">\(name)</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-错误的处理"><a href="#3-错误的处理" class="headerlink" title="3.错误的处理"></a>3.错误的处理</h4><p>错误被抛出后，必须要有相应的代码块处理这个错误。可分四种处理方法：</p><ul><li>将错误传递给调用此函数的代码；</li><li>使用do-catch语句处理错误；</li><li>将错误作为可选类型处理；</li><li>断言错误绝不会发生，万一真的发生则闪退；</li></ul><p>错误会改变代码的执行路径，使用<code>try</code>、<code>try?</code>或者<code>try!</code>标记可能抛出错误的地方。</p><ul><li>示例1：传递错误</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> favoriteSnacks <span class="hljs-operator">=</span> [<br>    <span class="hljs-string">&quot;Alice&quot;</span>: <span class="hljs-string">&quot;Chips&quot;</span>,<br>    <span class="hljs-string">&quot;Bob&quot;</span>: <span class="hljs-string">&quot;Licorice&quot;</span>,<br>    <span class="hljs-string">&quot;Eve&quot;</span>: <span class="hljs-string">&quot;Pretzels&quot;</span>,<br>]<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">buyFavoriteSnack</span>(<span class="hljs-params">person</span>: <span class="hljs-type">String</span>, <span class="hljs-params">vendingMachine</span>: <span class="hljs-type">VendingMachine</span>) <span class="hljs-keyword">throws</span> &#123; <span class="hljs-comment">//向上传递错误</span><br>    <span class="hljs-keyword">let</span> snackName <span class="hljs-operator">=</span> favoriteSnacks[person] <span class="hljs-operator">??</span> <span class="hljs-string">&quot;Candy Bar&quot;</span><br>    <span class="hljs-keyword">try</span> vendingMachine.vend(itemNamed: snackName)  <span class="hljs-comment">//将错误向上传递</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>示例2：do-catch</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">try</span> expression<br>    statements<br>&#125; <span class="hljs-keyword">catch</span> pattern <span class="hljs-number">1</span> &#123;<br>    statements<br>&#125; <span class="hljs-keyword">catch</span> pattern <span class="hljs-number">2</span> <span class="hljs-keyword">where</span> condition &#123;<br>    statements<br>&#125; <span class="hljs-keyword">catch</span> pattern <span class="hljs-number">3</span>, pattern <span class="hljs-number">4</span> <span class="hljs-keyword">where</span> condition &#123;<br>    statements<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    statements<br>&#125;<br><br><span class="hljs-comment">//具体案例</span><br><span class="hljs-keyword">var</span> vendingMachine <span class="hljs-operator">=</span> <span class="hljs-type">VendingMachine</span>()<br>vendingMachine.coinsDeposited <span class="hljs-operator">=</span> <span class="hljs-number">8</span><br><span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">try</span> buyFavoriteSnack(person: <span class="hljs-string">&quot;Alice&quot;</span>, vendingMachine: vendingMachine)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Success! Yum.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> <span class="hljs-type">VendingMachineError</span>.invalidSelection &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid Selection.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> <span class="hljs-type">VendingMachineError</span>.outOfStock &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Out of Stock.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> <span class="hljs-type">VendingMachineError</span>.insufficientFunds(<span class="hljs-keyword">let</span> coinsNeeded) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Insufficient funds. Please insert an additional <span class="hljs-subst">\(coinsNeeded)</span> coins.&quot;</span>)<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Unexpected error: <span class="hljs-subst">\(error)</span>.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;Insufficient funds. Please insert an additional 2 coins.&quot;</span><br></code></pre></td></tr></table></figure><ul><li>示例3：try?转为可选类型</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">func <span class="hljs-title">someThrowingFunction</span>() throws -&gt; Int</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">let</span> x = <span class="hljs-keyword">try</span>? someThrowingFunction()<br><br><span class="hljs-keyword">let</span> y: Int?<br><span class="hljs-keyword">do</span> &#123;<br>    y = <span class="hljs-function"><span class="hljs-keyword">try</span> <span class="hljs-title">someThrowingFunction</span>()</span><br><span class="hljs-function">&#125; <span class="hljs-keyword">catch</span></span> &#123;<br>    y = nil<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>try?</code>将可能抛出错误的方法的返回值转换成可选类型。如果未抛出错误，则try?表达式的值即为函数的值；如果抛出了错误则表达式的值为nil。</p><ul><li>示例4：try!</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> photo = <span class="hljs-keyword">try</span>! load<span class="hljs-constructor">Image(<span class="hljs-params">atPath</span>: <span class="hljs-string">&quot;./Resources/John Appleseed.jpg&quot;</span>)</span><br></code></pre></td></tr></table></figure><p><code>try!</code>断言此方法的调用不会出现错误，如果真的抛出错误则会报运行时错误。</p><h4 id="4-兼容NSError"><a href="#4-兼容NSError" class="headerlink" title="4.兼容NSError"></a>4.兼容NSError</h4><p>Swift中<code>Error</code>可直接转换成OC中的<code>NSError</code>, 如<code>SomeError.error0 as NSError</code>，只是没有errorCode, domain等信息。如果想和NSError一样, 则需要实现<code>LocalizedError</code>与<code>CustomNSError</code>协议:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SwiftError</span>: <span class="hljs-title class_">Error</span>, <span class="hljs-title class_">LocalizedError</span>, <span class="hljs-title class_">CustomNSError</span> &#123;<br>    <span class="hljs-keyword">case</span> error0, error1<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> errorDescription: <span class="hljs-type">String</span>? &#123;<br>        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> &#123;<br>        <span class="hljs-keyword">case</span> .error0:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error description error0&quot;</span><br>        <span class="hljs-keyword">case</span> .error1:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error description error1&quot;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> errorCode: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> &#123;<br>        <span class="hljs-keyword">case</span> .error0:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">case</span> .error1:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> errorDomain: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error domain SwiftError&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> errorUserInfo: [<span class="hljs-type">String</span> : <span class="hljs-keyword">Any</span>] &#123;<br>        <span class="hljs-keyword">switch</span> <span class="hljs-keyword">self</span> &#123;<br>        <span class="hljs-keyword">case</span> .error0:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;This is Error0&quot;</span>]<br>        <span class="hljs-keyword">case</span> .error1:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;info&quot;</span>: <span class="hljs-string">&quot;This is error1&quot;</span>]<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-type">SwiftError</span>.error0 <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>) <span class="hljs-comment">//__lldb_expr_7.SwiftError.error0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-type">SwiftError</span>.error0.errorCode)  <span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift类型检查</title>
    <link href="/2018/08/20/swift-isa.html"/>
    <url>/2018/08/20/swift-isa.html</url>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>作为面向对象的语言，OC 与 Swift 都具有多态性，有时会大量使用类簇，因此描述对象的信息成为了常见需求。</p><ul><li>判断对象在继承树上的位置；</li><li>判断对象是否遵守了某个协议；</li></ul><p>这些都是对象<code>内省</code>能力的一部分，本文将尝试对 OC 和 Swift 中这些场景的实现做一次整理。</p><h3 id="二、OC版"><a href="#二、OC版" class="headerlink" title="二、OC版"></a>二、OC版</h3><p>NSObject<code>协议</code>中提供了诸多内省方法，本文主要讨论以下三个：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs erlang">//NSObject.h<br>@protocol NSObject<br>...<br>- <span class="hljs-params">(BOOL)</span>isKindOfClass:<span class="hljs-params">(Class)</span>aClass; // 描述对象的完整继承树（包括直属类、父类、基类）<br>- <span class="hljs-params">(BOOL)</span>isMemberOfClass:<span class="hljs-params">(Class)</span>aClass; // 描述对象本身直属的类<br>- <span class="hljs-params">(BOOL)</span>conformsToProtocol:<span class="hljs-params">(Protocol *)</span>aProtocol;<br>...<br>@<span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>我们先定义两个类，以方便接下来的讨论：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// protocol</span><br><span class="hljs-variable">@protocol</span> MakeNoise &lt;NSObject&gt;<br>- (void)scream;<br><span class="hljs-variable">@end</span><br><br><span class="hljs-comment">// Animal</span><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">Animal </span>: NSObject&lt;MakeNoise&gt;<br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@implementation</span> Animal<br>- (void)scream&#123;<br>    <span class="hljs-selector-tag">NSLog</span>(@<span class="hljs-string">&quot;++++Animal scream~&quot;</span>);<br>&#125;<br>@<span class="hljs-selector-tag">end</span><br><br><span class="hljs-comment">// Cat</span><br>@<span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">Cat</span> : <span class="hljs-selector-tag">Animal</span><br>@<span class="hljs-selector-tag">property</span> (nonatomic, copy) <span class="hljs-selector-tag">NSString</span> *<span class="hljs-selector-tag">name</span>; <span class="hljs-comment">//子类独有的属性</span><br>@<span class="hljs-selector-tag">end</span><br><br>@<span class="hljs-selector-tag">implementation</span> <span class="hljs-selector-tag">Cat</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">scream</span>&#123;<br>    <span class="hljs-selector-tag">NSLog</span>(@<span class="hljs-string">&quot;+++Cat miao~&quot;</span>);<br>&#125;<br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure><p>接下来进入正题~</p><h4 id="1-isMemberOfClass"><a href="#1-isMemberOfClass" class="headerlink" title="1.isMemberOfClass"></a>1.isMemberOfClass</h4><p><strong>定义：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>isMemberOfClass:<span class="hljs-params">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><p><strong>作用：</strong></p><blockquote><p>Returns a Boolean value that indicates whether the receiver is an instance of a given class.</p></blockquote><p>检查对象是否是某个类的<code>直属对象</code>。</p><p>#示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- (void)classCast&#123;<br>    Animal *animal = <span class="hljs-literal">[A<span class="hljs-identifier">nimal</span> <span class="hljs-identifier">new</span>]</span>;<br>    Cat *cat = <span class="hljs-literal">[C<span class="hljs-identifier">at</span> <span class="hljs-identifier">new</span>]</span>;<br>    Animal *aniCat = <span class="hljs-literal">[C<span class="hljs-identifier">at</span> <span class="hljs-identifier">new</span>]</span>; <span class="hljs-comment">// 父类指针指向子类，即把子类转成父类，向上转型</span><br>    Cat *catAni = <span class="hljs-literal">[A<span class="hljs-identifier">nimal</span> <span class="hljs-identifier">new</span>]</span>; <span class="hljs-comment">// 子类指针指向父类，即把父类转化成子类，向下转型，OC中不能这么做</span><br>    <span class="hljs-comment">// catAni.name; 这里编译器不会报错，但运行时会闪退，因为catAni实际上指向的是父类Animal，而Animal显然没有name属性。</span><br>    <br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[animal isMemberOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">animal</span> <span class="hljs-params">isMemberOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[cat isMemberOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">cat</span> <span class="hljs-params">isMemberOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[cat isMemberOfClass:[Cat class]]:%d&quot;</span>,[<span class="hljs-params">cat</span> <span class="hljs-params">isMemberOfClass</span>:[Cat <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[aniCat isMemberOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">aniCat</span> <span class="hljs-params">isMemberOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[aniCat isMemberOfClass:[Cat class]]:%d&quot;</span>,[<span class="hljs-params">aniCat</span> <span class="hljs-params">isMemberOfClass</span>:[Cat <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[catAni isMemberOfClass:[Cat class]]:%d&quot;</span>,[<span class="hljs-params">catAni</span> <span class="hljs-params">isMemberOfClass</span>:[Cat <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[catAni isMemberOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">catAni</span> <span class="hljs-params">isMemberOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">+++[animal isMemberOfClass:[Animal <span class="hljs-keyword">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">cat</span> <span class="hljs-symbol">isMemberOfClass:</span>[<span class="hljs-symbol">Animal</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">0</span><br>+++[<span class="hljs-symbol">cat</span> <span class="hljs-symbol">isMemberOfClass:</span>[<span class="hljs-symbol">Cat</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">aniCat</span> <span class="hljs-symbol">isMemberOfClass:</span>[<span class="hljs-symbol">Animal</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">0</span><br>+++[<span class="hljs-symbol">aniCat</span> <span class="hljs-symbol">isMemberOfClass:</span>[<span class="hljs-symbol">Cat</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">catAni</span> <span class="hljs-symbol">isMemberOfClass:</span>[<span class="hljs-symbol">Cat</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">0</span><br>+++[<span class="hljs-symbol">catAni</span> <span class="hljs-symbol">isMemberOfClass:</span>[<span class="hljs-symbol">Animal</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>animal 直属于 Animal 类;</li><li>cat 直属于 Cat 类，不直属于 Animal 类；</li><li>aniCat和catAni都直属于它实际指向的类，不直属于声明它的类；</li></ul><p><strong>结论：</strong></p><ul><li>isMemberOfClass 适合用来判断对象是否<code>直属于</code>某个类。</li><li>父类指针指向子类时，此对象实质上是子类的实例；</li><li>子类指针指向父类时，此对象实质上是父类的实例。</li></ul><p>额外信息：</p><blockquote><p>OC中不允许向下转型，不能将父类转化成子类，即子类指针指向父类。</p></blockquote><p>这是因为父类中没有子类的属性和方法，这样转换出来的子类对象实际上还是指向父类，它不能使用子类中的属性和方法。这么做虽然编译期不会报错，但运行时会闪退。</p><h4 id="2-isKindOfClass"><a href="#2-isKindOfClass" class="headerlink" title="2.isKindOfClass"></a>2.isKindOfClass</h4><p><strong>定义：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>isKindOfClass:<span class="hljs-params">(Class)</span>aClass;<br></code></pre></td></tr></table></figure><p><strong>作用：</strong></p><blockquote><p>Returns a Boolean value that indicates whether the receiver is an instance of given class or an instance of any class that inherits from that class.</p></blockquote><p>检查对象是否在某个继承树上，包括对象直属的类、对象的父类、基类。</p><p>#示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- (void)classCast&#123;<br>    Animal *animal = <span class="hljs-literal">[A<span class="hljs-identifier">nimal</span> <span class="hljs-identifier">new</span>]</span>;<br>    Cat *cat = <span class="hljs-literal">[C<span class="hljs-identifier">at</span> <span class="hljs-identifier">new</span>]</span>;<br>    Animal *aniCat = <span class="hljs-literal">[C<span class="hljs-identifier">at</span> <span class="hljs-identifier">new</span>]</span>; <span class="hljs-comment">// 父类指针指向子类，即将子类转成父类，向上转型</span><br>    Cat *catAni = <span class="hljs-literal">[A<span class="hljs-identifier">nimal</span> <span class="hljs-identifier">new</span>]</span>; <span class="hljs-comment">// 子类指针指向父类，即把父类转化成子类，向下转型，OC中不能这么做</span><br>    <br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[animal isKindOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">animal</span> <span class="hljs-params">isKindOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[cat isKindOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">cat</span> <span class="hljs-params">isKindOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[cat isKindOfClass:[Cat class]]:%d&quot;</span>,[<span class="hljs-params">cat</span> <span class="hljs-params">isKindOfClass</span>:[Cat <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[aniCat isKindOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">aniCat</span> <span class="hljs-params">isKindOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[aniCat isKindOfClass:[Cat class]]:%d&quot;</span>,[<span class="hljs-params">aniCat</span> <span class="hljs-params">isKindOfClass</span>:[Cat <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[catAni isKindOfClass:[Cat class]]:%d&quot;</span>,[<span class="hljs-params">catAni</span> <span class="hljs-params">isKindOfClass</span>:[Cat <span class="hljs-params">class</span>]])</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++[catAni isKindOfClass:[Animal class]]:%d&quot;</span>,[<span class="hljs-params">catAni</span> <span class="hljs-params">isKindOfClass</span>:[Animal <span class="hljs-params">class</span>]])</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">+++[animal isKindOfClass:[Animal <span class="hljs-keyword">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">cat</span> <span class="hljs-symbol">isKindOfClass:</span>[<span class="hljs-symbol">Animal</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">cat</span> <span class="hljs-symbol">isKindOfClass:</span>[<span class="hljs-symbol">Cat</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">aniCat</span> <span class="hljs-symbol">isKindOfClass:</span>[<span class="hljs-symbol">Animal</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">aniCat</span> <span class="hljs-symbol">isKindOfClass:</span>[<span class="hljs-symbol">Cat</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br>+++[<span class="hljs-symbol">catAni</span> <span class="hljs-symbol">isKindOfClass:</span>[<span class="hljs-symbol">Cat</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">0</span><br>+++[<span class="hljs-symbol">catAni</span> <span class="hljs-symbol">isKindOfClass:</span>[<span class="hljs-symbol">Animal</span> <span class="hljs-symbol">class</span>]]:<span class="hljs-symbol">1</span><br></code></pre></td></tr></table></figure><p>分析：animal、cat、aniCat、catAni 是其直属类、父类、基类的所属类。</p><p><strong>结论：</strong>只要在对象直属类及其之上的继承树上，isKindOfClass都会返回 YES。</p><h4 id="3-conformsToProtocol"><a href="#3-conformsToProtocol" class="headerlink" title="3.conformsToProtocol"></a>3.conformsToProtocol</h4><p><strong>定义：</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>conformsToProtocol:<span class="hljs-params">(Protocol *)</span>aProtocol;<br></code></pre></td></tr></table></figure><p><strong>作用：</strong></p><blockquote><p>Returns a Boolean value that indicates whether the receiver conforms to a given protocol.</p></blockquote><p>检测对象是否遵守了某个协议。</p><p>#示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">- (<span class="hljs-keyword">void</span>)protocolCast&#123;<br>    Animal *animal = [Animal <span class="hljs-keyword">new</span>];<br>    Cat *cat = [Cat <span class="hljs-keyword">new</span>];<br>    Animal *aniCat = [Cat <span class="hljs-keyword">new</span>]; <span class="hljs-comment">// 父类指针指向子类，即将子类转成父类，向上转型</span><br>    <br>    NSLog(@<span class="hljs-string">&quot;+++[animal conformsToProtocol:@protocol(MakeNoise)]:%d&quot;</span>,<br>    [animal conformsToProtocol:<span class="hljs-meta">@protocol(MakeNoise)</span>]);<br>    <br>    NSLog(@<span class="hljs-string">&quot;+++[cat conformsToProtocol:@protocol(MakeNoise)]:%d&quot;</span>,<br>    [cat conformsToProtocol:<span class="hljs-meta">@protocol(MakeNoise)</span>]);<br>    <br>    NSLog(@<span class="hljs-string">&quot;+++[aniCat conformsToProtocol:@protocol(MakeNoise)]:%d&quot;</span>,<br>    [aniCat conformsToProtocol:<span class="hljs-meta">@protocol(MakeNoise)</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">+++[animal conformsToProtocol:<span class="hljs-meta">@protocol(MakeNoise)</span>]:<span class="hljs-number">1</span><br>+++[cat conformsToProtocol:<span class="hljs-meta">@protocol(MakeNoise)</span>]:<span class="hljs-number">1</span><br>+++[aniCat conformsToProtocol:<span class="hljs-meta">@protocol(MakeNoise)</span>]:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>animal 对象所属类显式声明并遵守了 MakeNoise 协议；</li><li>cat 直属类虽未直接声明遵守 MakeNoise 协议，但它会继承其父类的特点，默认也遵守了父类的协议；</li><li>aniCat 实质上是 Cat 类型，所以跟 cat 一样，默认继承父类的特点，也遵守了父类中的协议。</li></ul><p><strong>结论：</strong>若父类遵守了某协议，而子类未直接遵守此协议，则子类依然会从父类中继承此协议。</p><h3 id="三、Swift版"><a href="#三、Swift版" class="headerlink" title="三、Swift版"></a>三、Swift版</h3><blockquote><p>Type casting is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.<br>Type casting in Swift is implemented with the is and as operators. These two operators provide a simple and expressive way to check the type of a value or cast a value to a different type.<br>You can also use type casting to check whether a type conforms to a protocol, as described in Checking for Protocol Conformance.</p></blockquote><p><code>is</code>和<code>as</code>操作符的作用：</p><ul><li>描述实例的类型；</li><li>检查类型是否遵守了某个协议。</li></ul><p>先定义两个类，方便接下来的讨论：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MakeNoise</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">scream</span>()<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>: <span class="hljs-title class_">MakeNoise</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">scream</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++<span class="hljs-subst">\(<span class="hljs-keyword">self</span>)</span>++xxxxx~&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">scream</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++<span class="hljs-subst">\(<span class="hljs-keyword">self</span>)</span>:++Miao~&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-is类型检查"><a href="#1-is类型检查" class="headerlink" title="1.is类型检查"></a>1.is类型检查</h4><blockquote><p>Use the type check operator (is) to check whether an instance is of a certain subclass type. The type check operator returns true if the instance is of that subclass type and false if it is not.</p></blockquote><p><code>is</code>用来检查实例是否属于某个类或子类。</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">checkType</span>() &#123;<br>    <span class="hljs-keyword">let</span> animal <span class="hljs-operator">=</span> <span class="hljs-type">Animal</span>()<br>    <span class="hljs-keyword">let</span> cat <span class="hljs-operator">=</span> <span class="hljs-type">Cat</span>()<br>    <span class="hljs-keyword">let</span> aniCat : <span class="hljs-type">Animal</span> <span class="hljs-operator">=</span> <span class="hljs-type">Cat</span>() <span class="hljs-comment">//父类指针指向子类，向上转型</span><br>        <br>    <span class="hljs-comment">// is 类型检查</span><br>    <span class="hljs-keyword">if</span> animal <span class="hljs-keyword">is</span> <span class="hljs-type">Cat</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++animal is Cat~&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> cat <span class="hljs-keyword">is</span> <span class="hljs-type">Animal</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++cat is Animal~&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> aniCat <span class="hljs-keyword">is</span> <span class="hljs-type">Animal</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++aniCat is Animal~&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> aniCat <span class="hljs-keyword">is</span> <span class="hljs-type">Cat</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++aniCat is Cat~&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">+++cat <span class="hljs-keyword">is</span> <span class="hljs-keyword">Animal</span>~<br>+++aniCat <span class="hljs-keyword">is</span> <span class="hljs-keyword">Animal</span>~<br>+++aniCat <span class="hljs-keyword">is</span> Cat~<br></code></pre></td></tr></table></figure><p>日志信息显示：<code>is</code>不仅可检测出实例直属的类，也可以检测其所属的父类~</p><p><strong>结论：</strong><code>is</code>的作用与OC中<code>isKindOfClass</code>类似，用于检测实例所在的继承树。</p><h4 id="2-as向上转型"><a href="#2-as向上转型" class="headerlink" title="2.as向上转型"></a>2.as向上转型</h4><p>转型分为两种：向上转型和向下转型，<code>as</code>主要用于向上转型，Swift不支持向下转型。</p><p><strong>作用：</strong>检查实例A是否可以向上转型成目标类及其子类的实例，如果可以则返回实例A，否则报错。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func up<span class="hljs-constructor">Cast()</span> &#123;<br>    <span class="hljs-keyword">let</span> animal = <span class="hljs-constructor">Animal()</span><br>    <span class="hljs-keyword">let</span> cat = <span class="hljs-constructor">Cat()</span><br>    <span class="hljs-keyword">let</span> aniCat : Animal = <span class="hljs-constructor">Cat()</span> <span class="hljs-comment">//父类指针指向子类</span><br>    <span class="hljs-comment">// as 向上转型</span><br>    <span class="hljs-keyword">let</span> catAsAnimal = (cat <span class="hljs-keyword">as</span> Animal)<br>    <br>    <span class="hljs-comment">// 获取地址</span><br>    print(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Unmanaged</span>.</span></span>pass<span class="hljs-constructor">Unretained(<span class="hljs-params">cat</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Opaque()</span>)<br>    print(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Unmanaged</span>.</span></span>pass<span class="hljs-constructor">Unretained(<span class="hljs-params">catAsAnimal</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Opaque()</span>)<br>    <br>    <span class="hljs-comment">//检查父类继承树</span><br>    <span class="hljs-keyword">if</span> catAsAnimal is Animal &#123;<br>        print(<span class="hljs-string">&quot;++++catAsAnimal is Animal~&quot;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        print(<span class="hljs-string">&quot;++++catAsAnimal is NOT Animal~&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">//检查子类继承树</span><br>    <span class="hljs-keyword">if</span> catAsAnimal is Cat &#123;<br>        print(<span class="hljs-string">&quot;++++catAsAnimal is Cat~&quot;</span>)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        print(<span class="hljs-string">&quot;++++catAsAnimal is NOT Cat~&quot;</span>)<br>    &#125;<br>        <br>    <span class="hljs-comment">// animal as Cat // 这里会报错</span><br>    aniCat <span class="hljs-keyword">as</span> Animal<br>    <span class="hljs-comment">// aniCat as Cat // 这里会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">0x00006000030dc660<br>0x00006000030dc660<br>++++catAsAnimal <span class="hljs-keyword">is</span> <span class="hljs-keyword">Animal</span>~<br>++++catAsAnimal <span class="hljs-keyword">is</span> Cat~<br></code></pre></td></tr></table></figure><p><code>catAsAnimal</code>与<code>cat</code>实例的内存地址相同，说明实例as转型成功后得到的返回值与其本身是同一个对象。</p><p><code>as</code>可以代替<code>is</code>的功能，可以用于检查实例对象是否在某个类的继承树中；</p><p><code>as</code>不能用于向下转型，即父类转子类，会直接报错，原因在上面OC版中已经分析过~</p><h4 id="3-as-as-转型"><a href="#3-as-as-转型" class="headerlink" title="3.as?\as!转型"></a>3.as?\as!转型</h4><p><strong>作用：</strong>与<code>as</code>类似，只不过它强调的是你是否确定转型一定成功。</p><ul><li>as?，用于转型未必成功时，返回可选类型，用可选绑定查看是否转型成功；</li><li>as!，用于转型一定成功时，如果转型失败则会抛出运行时异常。</li></ul><p><code>as?</code>返回的是目标类的可选类型，如果转型失败则可选值为nil，通过可选绑定即可判断。</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">downCast</span>() &#123;<br>    <span class="hljs-keyword">let</span> animal <span class="hljs-operator">=</span> <span class="hljs-type">Animal</span>()<br>    <span class="hljs-keyword">let</span> cat <span class="hljs-operator">=</span> <span class="hljs-type">Cat</span>()<br>    <span class="hljs-keyword">let</span> aniCat : <span class="hljs-type">Animal</span> <span class="hljs-operator">=</span> <span class="hljs-type">Cat</span>() <span class="hljs-comment">//父类指针指向子类，向上转型</span><br>        <br>    <span class="hljs-comment">// as?\as! 转型</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> aniCat <span class="hljs-keyword">as?</span> <span class="hljs-type">Animal</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++aniCat as? Animal~&quot;</span>) <span class="hljs-comment">// 成立</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> aniCat <span class="hljs-keyword">as?</span> <span class="hljs-type">Cat</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++aniCat as? Cat~&quot;</span>) <span class="hljs-comment">// 成立</span><br>    &#125;<br>        <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> animal <span class="hljs-keyword">as?</span> <span class="hljs-type">Animal</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++animal as? Animal~&quot;</span>) <span class="hljs-comment">// 成立</span><br>    &#125;<br><br>    <span class="hljs-comment">// 强制向下转型</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> animal <span class="hljs-keyword">as?</span> <span class="hljs-type">Cat</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++animal as? Cat~&quot;</span>) <span class="hljs-comment">// 不成立</span><br>    &#125;<br>        <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> cat <span class="hljs-keyword">as?</span> <span class="hljs-type">Animal</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++cat as? Animal~&quot;</span>) <span class="hljs-comment">// 成立</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> cat <span class="hljs-keyword">as?</span> <span class="hljs-type">Cat</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++cat as? Cat~&quot;</span>) <span class="hljs-comment">// 成立</span><br>    &#125;<br><br>    cat <span class="hljs-keyword">as!</span> <span class="hljs-type">Animal</span> <span class="hljs-comment">// 运行正常</span><br>    animal <span class="hljs-keyword">as!</span> <span class="hljs-type">Cat</span> <span class="hljs-comment">// 运行时错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata">+++aniCat <span class="hljs-keyword">as</span>? Animal~<br>+++aniCat <span class="hljs-keyword">as</span>? <span class="hljs-keyword">Cat</span>~<br>+++animal <span class="hljs-keyword">as</span>? Animal~<br>+++<span class="hljs-keyword">cat</span> <span class="hljs-keyword">as</span>? Animal~<br>+++<span class="hljs-keyword">cat</span> <span class="hljs-keyword">as</span>? <span class="hljs-keyword">Cat</span>~<br></code></pre></td></tr></table></figure><p><strong>结论：</strong><code>as?</code>和<code>as!</code>更多的是用来检测异常情况，转型失败则可选值为nil。</p><h4 id="4-检测协议"><a href="#4-检测协议" class="headerlink" title="4.检测协议"></a>4.检测协议</h4><p><code>is</code>和<code>as</code>操作符除了可以检测继承关系，还可以用来检测是否遵守了某种协议：</p><blockquote><p>You can use the is and as operators described in Type Casting to check for protocol conformance, and to cast to a specific protocol. Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:</p></blockquote><blockquote><p>The is operator returns true if an instance conforms to a protocol and returns false if it doesn’t.</p></blockquote><blockquote><p>The as? version of the downcast operator returns an optional value of the protocol’s type, and this value is nil if the instance doesn’t conform to that protocol.</p></blockquote><blockquote><p>The as! version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.</p></blockquote><ul><li>变量遵守了协议时<code>is</code>会返回真；否则返回假；</li><li>as?返回一个遵守了指定协议的可选值，如果实例未遵守协议则可选值为nil；</li><li>as!将实例强制转型成遵守指定协议的对象，如果转型失败则抛出运行时异常。</li></ul><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">conformsTo</span>() &#123;<br>    <span class="hljs-keyword">let</span> animal <span class="hljs-operator">=</span> <span class="hljs-type">Animal</span>()<br>    <span class="hljs-keyword">let</span> cat <span class="hljs-operator">=</span> <span class="hljs-type">Cat</span>()<br>    <span class="hljs-keyword">let</span> aniCat : <span class="hljs-type">Animal</span> <span class="hljs-operator">=</span> <span class="hljs-type">Cat</span>() <span class="hljs-comment">//父类指针指向子类，向上转型</span><br>        <br>    <span class="hljs-keyword">if</span> animal <span class="hljs-keyword">is</span> <span class="hljs-type">MakeNoise</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++animal conforms to MakeNoise~&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> cat <span class="hljs-keyword">is</span> <span class="hljs-type">MakeNoise</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++cat conforms to MakeNoise~&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> aniCat <span class="hljs-keyword">is</span> <span class="hljs-type">MakeNoise</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++aniCat conforms to MakeNoise~&quot;</span>)<br>    &#125;<br>        <br>    animal <span class="hljs-keyword">as?</span> <span class="hljs-type">MakeNoise</span> <span class="hljs-comment">// 运行正常</span><br>    cat <span class="hljs-keyword">as!</span> <span class="hljs-type">MakeNoise</span> <span class="hljs-comment">// 运行正常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">+++animal conforms <span class="hljs-keyword">to</span> MakeNoise~<br>+++<span class="hljs-keyword">cat</span> conforms <span class="hljs-keyword">to</span> MakeNoise~<br>+++aniCat conforms <span class="hljs-keyword">to</span> MakeNoise~<br></code></pre></td></tr></table></figure><h3 id="四、结尾"><a href="#四、结尾" class="headerlink" title="四、结尾"></a>四、结尾</h3><p>从上面的示例和分析来看，OC中的三个内省方法各司其职：</p><ul><li>isMemberOfClass 只能用来判断对象的直属类；</li><li>isKindOfClass 不仅能判断对象的直属类，也能判断其间接父类和基类；</li><li>conformsToProtocol 用来判断对象是否直接或间接实现了某协议；</li></ul><p>而 Swift 则对 OC 中的内省进行了抽象，is和as都能胜任以上三种任务，只是：</p><ul><li>is 更偏向单纯的检查功能，类似于 isKindOfClass 的作用；</li><li>as 除了检查功能外，还多了尝试去转型的功能，作用更丰富一些。</li></ul><p>所以，在实际开发中，我们可以结合语言和功能需要，选择合适的内省方法来描述对象的类型和协议信息~</p><hr><p>相关参考：</p><p>#<a href="https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html">©doc.swift</a></p><p>#<a href="https://developer.apple.com/documentation/objectivec/1418956-nsobject/1418511-iskindofclass?language=occ">©Dev.apple</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift可选拆包</title>
    <link href="/2018/08/18/swift-unwrap.html"/>
    <url>/2018/08/18/swift-unwrap.html</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>You use optionals in situations where a value may be absent. An optional represents two possibilities: Either there is a value, and you can unwrap the optional to access that value, or there isn’t a value at all.</p></blockquote><p>可选用来表示值的或缺，当可选没有值时相当于OC中的nil，而当有值时我们需要对可选进行拆包才能取出和访问这个值。本篇将对可选的拆包方式做一次汇总~</p><h3 id="1-强制拆包"><a href="#1-强制拆包" class="headerlink" title="1.强制拆包"></a>1.强制拆包</h3><blockquote><p>Once you’re sure that the optional does contain a value, you can access its underlying value by adding an exclamation mark (!) to the end of the optional’s name. The exclamation mark effectively says, “I know that this optional definitely has a value; please use it.” This is known as forced unwrapping of the optional’s value:</p></blockquote><p>强制拆包是指当确定可选有值时，在可选后标注一个<code>!</code>，表明“我确定可选有值，请给我值”。</p><p>#示例：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">let</span> possibleNumber = <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-keyword">let</span> convertedNumber = Int(possibleNumber)<br>// convertedNumber <span class="hljs-keyword">is</span> inferred <span class="hljs-keyword">to</span> <span class="hljs-keyword">be</span> of <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;Int?&quot;</span>, <span class="hljs-built_in">or</span> <span class="hljs-string">&quot;optional Int&quot;</span><br><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;</span>) // 这个convertedNumber!即为强制拆包<br><br>// Prints <span class="hljs-string">&quot;convertedNumber has an integer value of 123.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-可选绑定"><a href="#2-可选绑定" class="headerlink" title="2.可选绑定"></a>2.可选绑定</h3><blockquote><p>You use optional binding to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable. Optional binding can be used with if and while statements to check for a value inside an optional, and to extract that value into a constant or variable, as part of a single action.</p></blockquote><p>可选绑定是当可选有值时将值绑定到一个临时变量或常量中，多用在<code>if</code>和<code>while</code>语句中。</p><p>#示例1：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> actualNumber <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(possibleNumber) &#123; <span class="hljs-comment">// 有值时绑定到临时常量actualNumber中</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The string <span class="hljs-subst">\&quot;</span><span class="hljs-subst">\(possibleNumber)</span><span class="hljs-subst">\&quot;</span> has an integer value of <span class="hljs-subst">\(actualNumber)</span>&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The string <span class="hljs-subst">\&quot;</span><span class="hljs-subst">\(possibleNumber)</span><span class="hljs-subst">\&quot;</span> could not be converted to an integer&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;The string &quot;123&quot; has an integer value of 123&quot;</span><br></code></pre></td></tr></table></figure><p>精简版用法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> nickname: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> nickname &#123; <span class="hljs-comment">// 省略了赋值：if let x = nickName</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hey, <span class="hljs-subst">\(nickname)</span>&quot;</span>) <span class="hljs-comment">// 使用同名变量代替拆包后的值</span><br>&#125;<br><span class="hljs-comment">// Doesn&#x27;t print anything, because nickname is nil.</span><br></code></pre></td></tr></table></figure><p>#示例2：if中多个可选绑定组合</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> firstNumber <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(<span class="hljs-string">&quot;4&quot;</span>), <span class="hljs-keyword">let</span> secondNumber <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(<span class="hljs-string">&quot;42&quot;</span>), firstNumber <span class="hljs-operator">&lt;</span> secondNumber <span class="hljs-operator">&amp;&amp;</span> secondNumber <span class="hljs-operator">&lt;</span> <span class="hljs-number">100</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(firstNumber)</span> &lt; <span class="hljs-subst">\(secondNumber)</span> &lt; 100&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-隐式拆包变量声明"><a href="#3-隐式拆包变量声明" class="headerlink" title="3.隐式拆包变量声明"></a>3.隐式拆包变量声明</h3><blockquote><p>Sometimes it’s clear from a program’s structure that an optional will always have a value, after that value is first set. In these cases, it’s useful to remove the need to check and unwrap the optional’s value every time it’s accessed, because it can be safely assumed to have a value all of the time.<br>These kinds of optionals are defined as implicitly unwrapped optionals. You write an implicitly unwrapped optional by placing an exclamation mark (String!) rather than a question mark (String?) after the type that you want to make optional.</p></blockquote><p>有时当可选被首次赋值之后，能确定此可选后续必定有值，且不会再被设置为nil。这时为了不必每次访问可选变量时都进行拆包或检查，可在声明可选时往其后面标注一个<code>!</code>，这种可选就是隐式拆包的可选。</p><p>使用隐式拆包时，可以像普通可选一样进行可选绑定，也可以像非可选变量一样不必在其后加<code>!</code>：</p><p>#示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">possibleString</span>: <span class="hljs-title class_">String</span>? = <span class="hljs-string">&quot;An optional string.&quot;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">forcedString</span>: <span class="hljs-title class_">String</span> = possibleString! <span class="hljs-comment">// requires an exclamation mark</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">assumedString</span>: <span class="hljs-title class_">String</span>! = <span class="hljs-string">&quot;An implicitly unwrapped optional string.&quot;</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">implicitString</span>: <span class="hljs-title class_">String</span> = assumedString <span class="hljs-comment">// no need for an exclamation mark</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> definiteString = assumedString &#123;<br>    <span class="hljs-title function_">print</span>(definiteString)<br>&#125;<br><span class="hljs-comment">// Prints &quot;An implicitly unwrapped optional string.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-可选链"><a href="#4-可选链" class="headerlink" title="4.可选链"></a>4.可选链</h3><blockquote><p>Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil. If the optional contains a value, the property, method, or subscript call succeeds; if the optional is nil, the property, method, or subscript call returns nil. Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is nil.</p></blockquote><p>当可选对象调用属性、方法或下标时，可选本身可能为nil。如果为nil，则调用失败；如果不为nil，则调用成功。</p><p>多个调用可以链接到一起并返回一个可选值，一旦其中某个调用返回nil时，整个调用链就会失败。</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> residence: <span class="hljs-type">Residence</span>?<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Residence</span> &#123;<br>    <span class="hljs-keyword">var</span> numberOfRooms: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++numberOfRooms is 1)&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> john <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br><span class="hljs-keyword">let</span> opt <span class="hljs-operator">=</span> john.residence<span class="hljs-operator">?</span>.numberOfRooms <span class="hljs-comment">// opt is a Int? type</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> roomCount <span class="hljs-operator">=</span> opt &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;John&#x27;s residence has <span class="hljs-subst">\(roomCount)</span> room(s).&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Unable to retrieve the number of rooms.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;Unable to retrieve the number of rooms.&quot;</span><br></code></pre></td></tr></table></figure><p>这里的”john.residence?.numberOfRooms”就是一个可选链，此可选链返回一个<code>Int?</code>类型的可选<code>opt</code>，将其拆包即可。</p><p>变量<code>john</code>初始化时其<code>residence</code>对象并未赋值，即为nil，所以整个可选链调用失败，也不会再访问后续的<code>numberOfRooms</code>属性。因为可选链失败了，所以对<code>opt</code>进行可选绑定时取不到值，因此输出最后一行~</p><h3 id="5-空合运算符"><a href="#5-空合运算符" class="headerlink" title="5.空合运算符??"></a>5.空合运算符??</h3><blockquote><p>The nil-coalescing operator (a ?? b) unwraps an optional a if it contains a value, or returns a default value b if a is nil. The expression a is always of an optional type. The expression b must match the type that is stored inside a.</p></blockquote><p>空合运算符在可选<code>a</code>有值时会对<code>a</code>进行拆包并返回拆包后的值<code>a!</code>；如果可选<code>a</code>没有值则返回默认值<code>b</code>。</p><p><code>b</code>的值必须与<code>a</code>的类型一致。</p><p>空合运算符是下面代码的缩写:</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">a != nil ? a! : b<br></code></pre></td></tr></table></figure><h3 id="6-guard模式匹配"><a href="#6-guard模式匹配" class="headerlink" title="6.guard模式匹配"></a>6.guard模式匹配</h3><blockquote><p>A guard statement, like an if statement, executes statements depending on the Boolean value of an expression. You use a guard statement to require that a condition must be true in order for the code after the guard statement to be executed. Unlike an if statement, a guard statement always has an else clause—the code inside the else clause is executed if the condition is not true.</p></blockquote><p><code>guard</code>和<code>if</code>语句一样，都是根据紧随其后的 Boolean 型表达式而决定后续行为，不同的是<code>guard</code>的声明中一定要有一个<code>else</code>代码块。在<code>guard</code>语句中，如果表达式为真才会继续执行<code>guard</code>声明之后的代码，否则就执行其<code>else</code>代码块中的代码。</p><p>基于这些，我们可以像在<code>if</code>语句中一样，在<code>guard</code>中使用可选绑定进行拆包。</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person</span>: [<span class="hljs-params">String</span>: <span class="hljs-type">String</span>]) &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> person[<span class="hljs-string">&quot;name&quot;</span>] <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 可选绑定</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello <span class="hljs-subst">\(name)</span>!&quot;</span>)<br><br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> location <span class="hljs-operator">=</span> person[<span class="hljs-string">&quot;location&quot;</span>] <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 可选绑定</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I hope the weather is nice near you.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I hope the weather is nice in <span class="hljs-subst">\(location)</span>.&quot;</span>)<br>&#125;<br><br>greet(person: [<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>])<br><span class="hljs-comment">// Prints &quot;Hello John!&quot;</span><br><span class="hljs-comment">// Prints &quot;I hope the weather is nice near you.&quot;</span><br>greet(person: [<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-string">&quot;location&quot;</span>: <span class="hljs-string">&quot;Cupertino&quot;</span>])<br><span class="hljs-comment">// Prints &quot;Hello Jane!&quot;</span><br><span class="hljs-comment">// Prints &quot;I hope the weather is nice in Cupertino.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>以上几种就是常见的拆包方法，1和3是强制拆包，有可能出错所以不安全，建议使用其他几种方法进行拆包~</p><hr><p>相关参考：</p><p>#<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html">©Swift.org</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift闭包</title>
    <link href="/2018/08/15/swift-block.html"/>
    <url>/2018/08/15/swift-block.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><p>闭包(Closures)是自包含的功能代码块，可以在代码中使用或者用来作为参数传值。</p><h4 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1.语法"></a>1.1.语法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">&#123;(parameters) -&gt; <span class="hljs-keyword">return</span> type <span class="hljs-keyword">in</span><br>   statements<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> divide <span class="hljs-operator">=</span> &#123;(param1: <span class="hljs-type">Int</span>, param2: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> <span class="hljs-keyword">in</span> <br>   <span class="hljs-keyword">return</span> param1 <span class="hljs-operator">/</span> param2 <br>&#125;<br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> divide(<span class="hljs-number">200</span>, <span class="hljs-number">20</span>)<br>print (result) <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><h4 id="1-2-优化"><a href="#1-2-优化" class="headerlink" title="1.2.优化"></a>1.2.优化</h4><p>Swift对闭包做了很多优化:</p><ul><li>根据上下文推断参数和返回值类型；</li><li>从单行表达式闭包中隐式返回（闭包体只有一行代码，可以省略return）；</li><li>可以使用简化参数名，如$0, $1(从0开始，表示第i个参数)；</li><li>提供了尾随闭包语法(Trailing closure syntax)；</li></ul><p>示例：</p><p>版本1：对数组内元素做排序</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">backward</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">s1</span>: <span class="hljs-type">String</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">s2</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>    <span class="hljs-keyword">return</span> s1 <span class="hljs-operator">&gt;</span> s2<br>&#125;<br><span class="hljs-keyword">var</span> reversedNames <span class="hljs-operator">=</span> names.sorted(by: backward)<br><span class="hljs-comment">// reversedNames is equal to [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span><br></code></pre></td></tr></table></figure><p>版本2：使用闭包</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">reversedNames <span class="hljs-operator">=</span> names.sorted(by: &#123; (s1: <span class="hljs-type">String</span>, s2: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-keyword">return</span> s1 <span class="hljs-operator">&gt;</span> s2<br>&#125;)<br></code></pre></td></tr></table></figure><p>版本3：写在一行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">reversedNames <span class="hljs-operator">=</span> names.sorted(by: &#123; (s1: <span class="hljs-type">String</span>, s2: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Bool</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> s1 <span class="hljs-operator">&gt;</span> s2 &#125; )<br></code></pre></td></tr></table></figure><p>版本4：根据上下文推断参数和返回值类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">reversedNames <span class="hljs-operator">=</span> names.sorted(by: &#123; s1, s2 <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> s1 <span class="hljs-operator">&gt;</span> s2 &#125; )<br></code></pre></td></tr></table></figure><p>版本5：闭包体只有一行代码，可以省略<code>return</code>关键字</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">reversedNames <span class="hljs-operator">=</span> names.sorted(by: &#123; s1, s2 <span class="hljs-keyword">in</span> s1 <span class="hljs-operator">&gt;</span> s2 &#125; )<br></code></pre></td></tr></table></figure><p>版本6：使用简化参数名</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">reversedNames <span class="hljs-operator">=</span> names.sorted(by: &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;</span> <span class="hljs-variable">$1</span> &#125; )<br></code></pre></td></tr></table></figure><p>甚至还可以继续简化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">reversedNames <span class="hljs-operator">=</span> names.sorted(by: <span class="hljs-operator">&gt;</span>)<br></code></pre></td></tr></table></figure><p>版本7：使用尾随闭包语法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">reversedNames <span class="hljs-operator">=</span> names.sorted() &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">&gt;</span> <span class="hljs-variable">$1</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-escaping"><a href="#2-escaping" class="headerlink" title="2.@escaping"></a>2.@escaping</h3><blockquote><p>A closure is said to escape a function when the closure is passed as an argument to the function, but is called after the function returns. When you declare a function that takes a closure as one of its parameters, you can write @escaping before the parameter’s type to indicate that the closure is allowed to escape.</p></blockquote><p>当闭包作为函数的参数，在函数<code>return</code>之后被调用时，我们就说这个闭包从函数中逃离，即<code>逃逸闭包</code>，使用<code>@escaping</code>来标示。</p><p>这种情况常见于函数中发起了一个异步请求并把闭包作为异步操作的回调。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 逃逸闭包示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetHelper</span> &#123; <span class="hljs-comment">//网络工具类</span><br>    <br>    <span class="hljs-keyword">var</span> statusOK <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">httpRequest</span>(<span class="hljs-params">withUrl</span> <span class="hljs-params">url</span>:<span class="hljs-type">String</span>,<br>                     <span class="hljs-params">succeesCallback</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Data</span>?,<span class="hljs-type">URLResponse</span>?)-&gt;(),<br>                     <span class="hljs-params">failCallback</span>: <span class="hljs-keyword">@escaping</span> (<span class="hljs-type">Error</span>?)-&gt;()) &#123;<br>        <span class="hljs-comment">//逃逸闭包必须用@escaping声明;</span><br>        <span class="hljs-comment">//否则编译时报错 Escaping closure captures non-escaping parameter &#x27;succeesCallback&#x27;</span><br>        <span class="hljs-keyword">guard</span> <span class="hljs-operator">!</span>url.isEmpty <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++URL is nil~&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++task start&quot;</span>)<br>        <span class="hljs-keyword">let</span> urlT:<span class="hljs-type">URL</span>? <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>(string: url)<br>        <span class="hljs-keyword">let</span> task <span class="hljs-operator">=</span> <span class="hljs-type">URLSession</span>.shared.dataTask(with: urlT<span class="hljs-operator">!</span>) &#123;(data:<span class="hljs-type">Data</span>?, response:<span class="hljs-type">URLResponse</span>?, error:<span class="hljs-type">Error</span>?) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">if</span> error <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">self</span>.statusOK <span class="hljs-operator">=</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// 逃逸闭包中使用到闭包所在类型时 需要显式的调用self 以便提醒自己捕获了self, 不写编译器会报错!</span><br>                failCallback(error) <span class="hljs-comment">//调用逃逸闭包</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">self</span>.statusOK <span class="hljs-operator">=</span> <span class="hljs-literal">true</span><br>                succeesCallback(data,response) <span class="hljs-comment">//调用逃逸闭包</span><br>            &#125;<br>        &#125;<br>        task.resume() <span class="hljs-comment">// 开始任务</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 发起网络请求</span><br><span class="hljs-keyword">var</span> netHelper <span class="hljs-operator">=</span> <span class="hljs-type">NetHelper</span>()<br>netHelper.httpRequest(withUrl: <span class="hljs-string">&quot;https://www.baidu.com&quot;</span>, succeesCallback: &#123; (data, response) <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++Network finished successfully~<span class="hljs-subst">\n</span> response:<span class="hljs-subst">\(response<span class="hljs-operator">!</span>)</span>&quot;</span>)<br>&#125;) &#123; (error) <span class="hljs-keyword">in</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++++error:<span class="hljs-subst">\(error<span class="hljs-operator">!</span>)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-autoclosure"><a href="#3-autoclosure" class="headerlink" title="3.autoclosure"></a>3.autoclosure</h3><blockquote><p>An autoclosure is a closure that’s automatically created to wrap an expression that’s being passed as an argument to a function. It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it. This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure.</p></blockquote><p>自动闭包，一种自动创建的闭包，用来把作为函数参数的<code>表达式</code>自动封装成<code>闭包</code>。</p><p>示例1：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">logIfTrue</span>(<span class="hljs-params">predicate</span>: ()-&gt;<span class="hljs-type">Bool</span>)&#123;<br>    <span class="hljs-keyword">if</span> predicate() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;TRUE&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例分析：</p><ol><li>函数接受一个闭包作为参数；</li><li>闭包不接受任何参数；</li><li>闭包被调用时，返回一个值；</li><li>值为true时，执行打印；</li></ol><p>示例调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">logIfTrue(predicate: &#123; () <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>优化闭包的调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">logIfTrue(predicate: &#123;<span class="hljs-number">2</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">//写成一行并省略return关键字</span><br></code></pre></td></tr></table></figure><p>继续优化，使用尾随闭包写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">logIfTrue&#123; <span class="hljs-number">2</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>但调用时不管怎么优化，要么书写起来十分麻烦，要么表达上不太清晰，于是自动闭包登场了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">logIfTrue</span>(<span class="hljs-params">predicate</span>: <span class="hljs-keyword">@autoclosure</span> ()-&gt;<span class="hljs-type">Bool</span>)&#123;<br>    <span class="hljs-keyword">if</span> predicate() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;TRUE&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里改换了原方法的参数，在闭包的类型前加上<code>@autoclosure</code>关键字，再次调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT">logIfTrue( predicate: <span class="hljs-number">2</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>Swift 会把<code>2 &gt; 1</code>这个表达式自动转换为<code>()-&gt;Bool</code>类型的闭包。</p><p>自动闭包的好处是：</p><ol><li>调用时写法简单，表意清楚；</li><li>允许延迟处理，对于闭包内有副作用或占用资源的代码，直到你调用闭包时才会运行。</li></ol><p>示例2：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> customersInLine <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Chris&quot;</span>,<span class="hljs-string">&quot;Alex&quot;</span>,<span class="hljs-string">&quot;Ewa&quot;</span>,<span class="hljs-string">&quot;Barry&quot;</span>,<span class="hljs-string">&quot;Daniella&quot;</span>]<br> <br><span class="hljs-comment">//定义block，其类型为()-&gt;String，此时尚未执行</span><br><span class="hljs-keyword">let</span> customProvider <span class="hljs-operator">=</span> &#123;customersInLine.remove(at: <span class="hljs-number">0</span>)&#125;<br> <br><span class="hljs-comment">//定义函数，接受一个()-&gt;String类型的block作为参数，使用非自动闭包的写法</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">serve</span>(<span class="hljs-params">custom</span> <span class="hljs-params">customerProvider</span>:() -&gt;<span class="hljs-type">String</span>)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Now serving<span class="hljs-subst">\(customerProvider())</span>!&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 调用</span><br>serve(custom: &#123;customersInLine.remove(at: <span class="hljs-number">0</span>)&#125;)<br><span class="hljs-comment">// 打印结果 &quot;Now serving Chris!&quot;</span><br></code></pre></td></tr></table></figure><p>自动闭包的写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">//将闭包参数标记为@autoclosure</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">serve</span>(<span class="hljs-params">custom</span> <span class="hljs-params">customerProvider</span>: <span class="hljs-keyword">@autoclosure</span> () -&gt;<span class="hljs-type">String</span> )&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Now serving <span class="hljs-subst">\(customerProvider())</span>!&quot;</span>)<br>&#125;<br><span class="hljs-comment">//调用函数时，不需要再写花括号&#123;&#125;，@autoclosure会根据上面的定义，自动将其转换为闭包</span><br>serve(custom: customersInLine.remove(at: <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>注意：自动闭包不接受任何参数，只有形如<code>()-&gt;T</code>的参数才能使用这个特性进行简化。</p><h3 id="4-捕获变量"><a href="#4-捕获变量" class="headerlink" title="4.捕获变量"></a>4.捕获变量</h3><h4 id="4-1-捕获引用"><a href="#4-1-捕获引用" class="headerlink" title="4.1.捕获引用"></a>4.1.捕获引用</h4><p>A closure can capture constants and variables from the surrounding context in which it is defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.</p><p>As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.</p><p>Swift also handles all memory management involved in disposing of variables when they are no longer needed.</p><p>OC 中 block 会捕获变量，且捕获的是变量的值。</p><p>Swift 的闭包也会自动捕获其上下文中定义的变量，但默认捕获的是<code>变量的引用</code>，这样就可以在闭包内修改它们的值。换句话说，Swift 闭包中变量的默认行为与 OC 中<code>__block</code> 变量一致。</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// Block 引用变量</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">blockRetain</span>() &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> block1 <span class="hljs-operator">=</span> &#123; <span class="hljs-comment">// 最简单的闭包 内部引用了变量</span><br>        num <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(num)</span>&quot;</span>)<br>    &#125;<br>    num <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>    block1()<br>&#125;<br>blockRetain() <span class="hljs-comment">// 打印 &quot;3&quot;</span><br></code></pre></td></tr></table></figure><p><code>num</code>是局部变量，它在<code>block1</code>中和之后都被修改了，而这两处改变也都影响了最终打印的信息。这说明<code>block1</code>中是对<code>num</code>变量进行了引用，而非值的复制，这与OC中 block 对变量的捕获有很大的不同。</p><h4 id="4-2-强制捕获值"><a href="#4-2-强制捕获值" class="headerlink" title="4.2.强制捕获值"></a>4.2.强制捕获值</h4><p>如果不想被引用而是被复制，则可以使用<code>捕获列表</code>：</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// Block 捕获变量</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">blockCapture</span>() &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> block2 <span class="hljs-operator">=</span> &#123; [num] <span class="hljs-keyword">in</span> <span class="hljs-comment">//声明捕获列表 捕获变量的值 而非引用</span><br>        <span class="hljs-comment">//num += 1 // 此处会报错:Left side of mutating operator isn&#x27;t mutable: &#x27;num&#x27; is an immutable capture</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(num)</span>&quot;</span>)<br>    &#125;<br>    num <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>    block2()<br>&#125;<br>blockCapture() <span class="hljs-comment">// 打印 &quot;1&quot;</span><br></code></pre></td></tr></table></figure><p>定义捕获列表之后，<code>num</code>在闭包中被捕获，但这次是被复制且成为了一个常量，不能在闭包内被修改。闭包之后的修改也并未影响到闭包内的打印结果，这才有点像OC中的 block。</p><p>Swift 出于性能考虑会对闭包做一些优化，比如它会自动判断你是否在闭包内或闭包外修改了变量，如果没有则会直接持有一份该变量的拷贝。</p><h3 id="5-循环引用"><a href="#5-循环引用" class="headerlink" title="5.循环引用"></a>5.循环引用</h3><h4 id="5-1-原因"><a href="#5-1-原因" class="headerlink" title="5.1.原因"></a>5.1.原因</h4><p>A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as self.someProperty, or because the closure calls a method on the instance, such as self.someMethod(). In either case, these accesses cause the closure to “capture” self, creating a strong reference cycle.</p><p>与 OC 中的 block 类似，Swift 闭包也会强引用被它捕获的对象，从而引发可能的循环引用问题。</p><p>比如对象持有一个闭包属性，而闭包体中通过<code>self.</code>调用了对象的属性或方法，从而捕获了self 本身，造成循环引用。</p><p>#示例1：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> &#123;<br><br>    <span class="hljs-keyword">var</span> name :<span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span><br>    <span class="hljs-keyword">var</span> sBlock:(()-&gt;())<span class="hljs-operator">?</span> <span class="hljs-comment">//定义闭包属性，VC强引用闭包</span><br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        sBlock <span class="hljs-operator">=</span> &#123;<br>            <span class="hljs-comment">//闭包访问VC的其他成员，闭包捕获并强引用self对象</span><br>            <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;x&quot;</span> <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">deinit</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++ deinited !&quot;</span>)<span class="hljs-comment">//因为闭包的循环引用，这里析构并不会执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-解决方案1-捕获列表"><a href="#5-2-解决方案1-捕获列表" class="headerlink" title="5.2.解决方案1:捕获列表"></a>5.2.解决方案1:捕获列表</h4><p>You resolve a strong reference cycle between a closure and a class instance by defining a capture list as part of the closure’s definition.Each item in a capture list is a pairing of the weak or unowned keyword with a reference to a class instance (such as self) or a variable initialized with some value (such as delegate &#x3D; self.delegate!). </p><p><code>捕获列表</code>也可以解决闭包的循环引用问题，把被捕获的变量标记为<code>weak</code> 或 <code>unowned</code>即可。</p><ul><li>给带参数的闭包定义捕获列表：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> aClosure: (<span class="hljs-type">Int</span>, <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> <span class="hljs-operator">=</span> &#123;<br>    [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">weak</span> delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.delegate<span class="hljs-operator">!</span>] (index: <span class="hljs-type">Int</span>, stringToProcess: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">in</span><br>    <span class="hljs-comment">//闭包具体内容</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>给不带参数的闭包定义捕获列表：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> aClosure: () -&gt; <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> &#123;<br>    [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>, <span class="hljs-keyword">weak</span> delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.delegate<span class="hljs-operator">!</span>] <span class="hljs-keyword">in</span><br>    <span class="hljs-comment">//闭包具体内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以，上面#示例1中的问题可以这样解决：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_">UIViewController</span> &#123;<br><br>    <span class="hljs-keyword">var</span> name :<span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span><br>    <span class="hljs-keyword">var</span> sBlock:(()-&gt;())<span class="hljs-operator">?</span><br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        sBlock <span class="hljs-operator">=</span> &#123;<br>            [<span class="hljs-keyword">unowned</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span> <span class="hljs-comment">//定义捕获列表</span><br>            <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;x&quot;</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">deinit</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++ deinited !&quot;</span>) <span class="hljs-comment">//能正常析构</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>VC虽然强引用了闭包，但是闭包对VC的引用变成了弱引用，不增加VC的引用计数，当指向VC的其他强引用都被移除后，其引用计数为0，即可正常销毁。</p><p>区分<code>weak</code>与<code>unowned</code>：</p><ul><li>weak</li></ul><p>A weak reference is a reference that does not keep a strong hold on the instance it refers to, and so does not stop ARC from disposing of the referenced instance. </p><p>Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first. </p><ul><li>unowned</li></ul><p>Like a weak reference, an unowned reference does not keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime.</p><p>Use an unowned reference only when you are sure that the reference always refers to an instance that has not been deallocated.</p><p>If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.</p><p><code>weak</code>与<code>unowned</code>的作用类似，都是用来解决循环引用问题。区别在于：</p><p><strong>1.生命周期：</strong></p><p><strong>weak</strong> 对象的生命周期一般 &lt; weak 对象所在的类的实例的生命周期，当访问该 weak 对象时它可能已经被释放了，比如 delegate、房子中的租客。因此，weak 修饰的属性一定是<code>optional</code>值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123; <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name &#125;<br>    <span class="hljs-keyword">var</span> apartment: <span class="hljs-type">Apartment</span>?<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apartment</span> &#123;<br>    <span class="hljs-keyword">let</span> unit: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">unit</span>: <span class="hljs-type">String</span>) &#123; <span class="hljs-keyword">self</span>.unit <span class="hljs-operator">=</span> unit &#125;<br>    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> tenant: <span class="hljs-type">Person</span>?<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Apartment <span class="hljs-subst">\(unit)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> john: <span class="hljs-type">Person</span>?<br><span class="hljs-keyword">var</span> unit4A: <span class="hljs-type">Apartment</span>?<br>john <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(name: <span class="hljs-string">&quot;John Appleseed&quot;</span>)<br>unit4A <span class="hljs-operator">=</span> <span class="hljs-type">Apartment</span>(unit: <span class="hljs-string">&quot;4A&quot;</span>)<br><br><span class="hljs-comment">// 相互持有</span><br>john<span class="hljs-operator">!</span>.apartment <span class="hljs-operator">=</span> unit4A<br>unit4A<span class="hljs-operator">!</span>.tenant <span class="hljs-operator">=</span> john<br><br><span class="hljs-comment">// 看看是否能调用各自的析构函数</span><br>john <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>unit4A <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mizar">John Appleseed <span class="hljs-keyword">is</span> <span class="hljs-keyword">being</span> deinitialized<br>Apartment 4A <span class="hljs-keyword">is</span> <span class="hljs-keyword">being</span> deinitialized<br></code></pre></td></tr></table></figure><p>说明两个对象都已经顺利释放了~</p><p><strong>unowned</strong> 对象的生命周期一般 &gt;&#x3D; unowned 对象所在的类的实例的生命周期。比如 Customer 与 CreditCard，人可能没有信用卡，但信用卡一定得有个主人，Customer的生命周期比 CreditCard 长。因此，unowned 修饰的属性不能是<code>optional</code>值，也不能指向 nil。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> card: <span class="hljs-type">CreditCard</span>?<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>    &#125;<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(name)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreditCard</span> &#123;<br>    <span class="hljs-keyword">let</span> number: <span class="hljs-type">UInt64</span><br>    <span class="hljs-keyword">unowned</span> <span class="hljs-keyword">let</span> customer: <span class="hljs-type">Customer</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">number</span>: <span class="hljs-type">UInt64</span>, <span class="hljs-params">customer</span>: <span class="hljs-type">Customer</span>) &#123;<br>        <span class="hljs-keyword">self</span>.number <span class="hljs-operator">=</span> number<br>        <span class="hljs-keyword">self</span>.customer <span class="hljs-operator">=</span> customer<br>    &#125;<br>    <span class="hljs-keyword">deinit</span> &#123; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Card #<span class="hljs-subst">\(number)</span> is being deinitialized&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-comment">// 相互持有</span><br><span class="hljs-keyword">var</span> john: <span class="hljs-type">Customer</span>? <span class="hljs-operator">=</span> <span class="hljs-type">Customer</span>(name: <span class="hljs-string">&quot;John Appleseed&quot;</span>)<br>john<span class="hljs-operator">!</span>.card <span class="hljs-operator">=</span> <span class="hljs-type">CreditCard</span>(number: <span class="hljs-number">1234_5678_9012_3456</span>, customer: john<span class="hljs-operator">!</span>)<br><span class="hljs-comment">// 尝试看Customer和CreditCard对象是否能顺利析构</span><br>john <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mizar">John Appleseed <span class="hljs-keyword">is</span> <span class="hljs-keyword">being</span> deinitialized<br>Card #1234567890123456 <span class="hljs-keyword">is</span> <span class="hljs-keyword">being</span> deinitialized<br></code></pre></td></tr></table></figure><p>两个实例都顺利析构并释放内存~</p><p><strong>2.野指针问题</strong></p><p><strong>weak</strong> 修饰可选对象，当引用的对象被释放时，可选对象自动变成nil，继续访问该对象时不会闪退。</p><p><strong>unowned</strong> 相当于OC中的<code>unsafe_unretained</code>，也不会增加引用计数，其引用的对象被释放后，它依然会保持对已被释放对象的一个无效引用，继续访问该对象会闪退。</p><h4 id="5-3-解决方案2-用结构体"><a href="#5-3-解决方案2-用结构体" class="headerlink" title="5.3.解决方案2:用结构体"></a>5.3.解决方案2:用结构体</h4><p>循环引用，从其命名来看实际上是两个问题：</p><ul><li>循环</li><li>引用</li></ul><p>即对象之间出现了相互引用的怪圈。在解决此类问题时，我们的第一反应往往是使用<code>weak</code>或<code>unowned</code>来弱引用对象，从而打破这个环，这解决了第一个问题；</p><p>其实我们也可以从第二个问题来入手：仔细回想一下，我们所见到的循环引用一般都是出现在两个或多个<code>引用</code>类型之间，比如<code>闭包</code>和<code>类</code>之间。所以换个角度来想，如果将引用类型改成值类型，那么也就不存在相互<code>引用</code>的情况了，比如可能的话，将某些<code>类</code>改成值类型的<code>结构体</code>来实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Customer</span> &#123; <span class="hljs-comment">// 将此类改成由结构体来实现</span><br>    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> card: <span class="hljs-type">CreditCard</span>?<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CreditCard</span> &#123;<br>    <span class="hljs-keyword">let</span> number: <span class="hljs-type">UInt64</span><br>    <span class="hljs-keyword">let</span> customer: <span class="hljs-type">Customer</span> <span class="hljs-comment">// 这里也不再需要 unowned 修饰了</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">number</span>: <span class="hljs-type">UInt64</span>, <span class="hljs-params">customer</span>: <span class="hljs-type">Customer</span>) &#123;<br>        <span class="hljs-keyword">self</span>.number <span class="hljs-operator">=</span> number<br>        <span class="hljs-keyword">self</span>.customer <span class="hljs-operator">=</span> customer<br>    &#125;<br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Card #<span class="hljs-subst">\(number)</span> is being deinitialized&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// playground中定义的方法</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">tryStruct</span>()&#123;<br>    <span class="hljs-keyword">var</span> customer <span class="hljs-operator">=</span> <span class="hljs-type">Customer</span>(name: <span class="hljs-string">&quot;XXX&quot;</span>)<br>    <span class="hljs-keyword">let</span> card <span class="hljs-operator">=</span> <span class="hljs-type">CreditCard</span>(number: <span class="hljs-number">10</span>, customer: customer)<br>    customer.card <span class="hljs-operator">=</span> card;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">tryStruct</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Card <span class="hljs-string">#10</span> <span class="hljs-keyword">is</span> being deinitialized<br></code></pre></td></tr></table></figure><p>分析：</p><ul><li>客户对象是结构体，作为信用卡的参数时是值的拷贝而非引用，因此不存在相互引用一说；</li><li>作为值类型的客户对象，在出了方法体之后被自动释放。</li></ul><p>综上，解决循环引用问题时，可以从弱化引用和替换成值类型两处入手~</p><hr><p>相关参考：</p><p>#<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID52">©Swift:ARC</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>循环引用</tag>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift一览</title>
    <link href="/2018/08/12/swift-basic.html"/>
    <url>/2018/08/12/swift-basic.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://davidlii.nos-eastchina1.126.net/pic_swift5_outline.png" alt="Swift5一览"></p><h3 id="1-运算符"><a href="#1-运算符" class="headerlink" title="1.运算符"></a>1.运算符</h3><p>Swift的Int类型不在支持自增减运算符,比如 <code>++</code>a, <code>-—</code>a,a<code>-—</code>,a<code>++</code>。</p><p>要支持这种方法，须重载运算符:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span> &#123;<br>    <span class="hljs-comment">//前缀++</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">prefix</span>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">++</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>  &#123;<br>        num <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> num<br>    &#125;<br>    <span class="hljs-comment">//后缀++</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">postfix</span>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">++</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>  &#123;<br>        <span class="hljs-keyword">let</span> temp <span class="hljs-operator">=</span> num<br>        num <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> temp<br>    &#125;<br>    <span class="hljs-comment">//前缀--</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">prefix</span>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">--</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>  &#123;<br>        num <span class="hljs-operator">-=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> num<br>    &#125;<br>    <span class="hljs-comment">//后缀--</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">postfix</span>  <span class="hljs-keyword">func</span> <span class="hljs-title function_">--</span>(<span class="hljs-params">num</span>:<span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>  &#123;<br>        <span class="hljs-keyword">let</span> temp <span class="hljs-operator">=</span> num<br>        num <span class="hljs-operator">-=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> temp<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> aInt <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> b <span class="hljs-operator">=</span> aInt<span class="hljs-operator">++</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;aInt:<span class="hljs-subst">\(aInt)</span>,b:<span class="hljs-subst">\(b)</span>&quot;</span>) <span class="hljs-comment">//输出：aInt:1,b:0</span><br><br><span class="hljs-keyword">var</span> c <span class="hljs-operator">=</span> <span class="hljs-operator">++</span>aInt<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;aInt:<span class="hljs-subst">\(aInt)</span>,c:<span class="hljs-subst">\(c)</span>&quot;</span>) <span class="hljs-comment">//输出：aInt:2,c:2</span><br></code></pre></td></tr></table></figure><p>使用自增运算符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>a <span class="hljs-operator">+=</span> <span class="hljs-number">2</span><br><span class="hljs-comment">// a is now equal to 3</span><br></code></pre></td></tr></table></figure><p>这里<code>a += 2</code>是<code>a = a + 2</code>的简写形式。</p><h3 id="2-String"><a href="#2-String" class="headerlink" title="2.String"></a>2.String</h3><ul><li><code>String.Index</code></li></ul><p>表示字符在字符串中的位置：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> greeting <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Guten Tag!&quot;</span><br>greeting[greeting.startIndex]<br><span class="hljs-comment">// G</span><br>greeting[greeting.index(before: greeting.endIndex)]<br><span class="hljs-comment">// !</span><br>greeting[greeting.index(after: greeting.startIndex)]<br><span class="hljs-comment">// u</span><br><span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> greeting.index(greeting.startIndex, offsetBy: <span class="hljs-number">7</span>)<br>greeting[index]<br><span class="hljs-comment">// a</span><br>greeting[greeting.endIndex] <span class="hljs-comment">// 报错：越界</span><br>greeting.index(after: greeting.endIndex) <span class="hljs-comment">// 报错：越界</span><br><br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> greeting.indices &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(greeting[index])</span> &quot;</span>, terminator: <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;G u t e n   T a g ! &quot;</span><br></code></pre></td></tr></table></figure><ul><li>增删字符</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">//增</span><br><span class="hljs-keyword">var</span> welcome <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span><br>welcome.insert(<span class="hljs-string">&quot;!&quot;</span>, at: welcome.endIndex)<br><span class="hljs-comment">// welcome now equals &quot;hello!&quot;</span><br>welcome.insert(contentsOf: <span class="hljs-string">&quot; there&quot;</span>, at: welcome.index(before: welcome.endIndex))<br><span class="hljs-comment">// welcome now equals &quot;hello there!&quot;</span><br><br><span class="hljs-comment">//删</span><br>welcome.remove(at: welcome.index(before: welcome.endIndex))<br><span class="hljs-comment">// welcome now equals &quot;hello there&quot;</span><br><span class="hljs-keyword">let</span> range <span class="hljs-operator">=</span> welcome.index(welcome.endIndex, offsetBy: <span class="hljs-operator">-</span><span class="hljs-number">6</span>)<span class="hljs-operator">..&lt;</span>welcome.endIndex<br>welcome.removeSubrange(range)<br><span class="hljs-comment">// welcome now equals &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><ul><li>截取</li></ul><p>截取字符串时返回的是<code>Substring</code>类型：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> greeting <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, world!&quot;</span><br><span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> greeting.firstIndex(of: <span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-operator">??</span> greeting.endIndex<br><span class="hljs-keyword">let</span> beginning <span class="hljs-operator">=</span> greeting[<span class="hljs-operator">..&lt;</span>index]<br><span class="hljs-comment">// beginning is &quot;Hello&quot;</span><br><br><span class="hljs-comment">// Convert the result to a String for long-term storage.</span><br><span class="hljs-keyword">let</span> newString <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(beginning)<br></code></pre></td></tr></table></figure><h3 id="3-集合"><a href="#3-集合" class="headerlink" title="3.集合"></a>3.集合</h3><h4 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h4><p><code>Array&lt;Element&gt;</code>表示数组的类型，简写作：<code>[Element]</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> someInts: [<span class="hljs-type">Int</span>] <span class="hljs-operator">=</span> []<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;someInts is of type [Int] with <span class="hljs-subst">\(someInts.count)</span> items.&quot;</span>)<br><span class="hljs-comment">// Prints &quot;someInts is of type [Int] with 0 items.&quot;</span><br>someInts.append(<span class="hljs-number">3</span>)<br><span class="hljs-comment">// someInts now contains 1 value of type Int</span><br></code></pre></td></tr></table></figure><p>数组的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> shoppingList <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Eggs&quot;</span>, <span class="hljs-string">&quot;Milk&quot;</span>]<br><span class="hljs-keyword">if</span> shoppingList.isEmpty &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The shopping list is empty.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The shopping list isn&#x27;t empty.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;The shopping list isn&#x27;t empty.&quot;</span><br><br><span class="hljs-comment">// 增</span><br>shoppingList.append(<span class="hljs-string">&quot;Flour&quot;</span>)<br><span class="hljs-comment">// shoppingList now contains 3 items, and someone is making pancakes</span><br>shoppingList <span class="hljs-operator">+=</span> [<span class="hljs-string">&quot;Baking Powder&quot;</span>]<br><span class="hljs-comment">// shoppingList now contains 4 items</span><br>shoppingList <span class="hljs-operator">+=</span> [<span class="hljs-string">&quot;Chocolate Spread&quot;</span>, <span class="hljs-string">&quot;Cheese&quot;</span>, <span class="hljs-string">&quot;Butter&quot;</span>]<br><span class="hljs-comment">// shoppingList now contains 7 items</span><br><br><span class="hljs-comment">// 读</span><br><span class="hljs-keyword">var</span> firstItem <span class="hljs-operator">=</span> shoppingList[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// firstItem is equal to &quot;Eggs&quot;</span><br><span class="hljs-comment">// 修改指定索引处的元素</span><br>shoppingList[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Six eggs&quot;</span><br><span class="hljs-comment">// the first item in the list is now equal to &quot;Six eggs&quot; rather than &quot;Eggs&quot;</span><br>shoppingList[<span class="hljs-number">4</span><span class="hljs-operator">...</span><span class="hljs-number">6</span>] <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Bananas&quot;</span>, <span class="hljs-string">&quot;Apples&quot;</span>]<br><span class="hljs-comment">// shoppingList now contains 6 items</span><br><br><span class="hljs-comment">// 插入</span><br>shoppingList.insert(<span class="hljs-string">&quot;Maple Syrup&quot;</span>, at: <span class="hljs-number">0</span>)<br><span class="hljs-comment">// shoppingList now contains 7 items</span><br><span class="hljs-comment">// &quot;Maple Syrup&quot; is now the first item in the list</span><br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">let</span> mapleSyrup <span class="hljs-operator">=</span> shoppingList.remove(at: <span class="hljs-number">0</span>)<br><span class="hljs-comment">// the item that was at index 0 has just been removed</span><br><span class="hljs-comment">// shoppingList now contains 6 items, and no Maple Syrup</span><br><span class="hljs-comment">// the mapleSyrup constant is now equal to the removed &quot;Maple Syrup&quot; string</span><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoppingList &#123;<br>    <span class="hljs-built_in">print</span>(item)<br>&#125;<br><span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> shoppingList.enumerated() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Item <span class="hljs-subst">\(index <span class="hljs-operator">+</span> <span class="hljs-number">1</span>)</span>: <span class="hljs-subst">\(value)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-Set"><a href="#2-Set" class="headerlink" title="2.Set"></a>2.Set</h4><p><code>Set</code>是无序集合。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> letters <span class="hljs-operator">=</span> <span class="hljs-type">Set</span>&lt;<span class="hljs-type">Character</span>&gt;()<br><br><span class="hljs-comment">// 增</span><br>letters.insert(<span class="hljs-string">&quot;a&quot;</span>)<br><span class="hljs-comment">// letters now contains 1 value of type Character</span><br><span class="hljs-comment">// 置空</span><br>letters <span class="hljs-operator">=</span> []<br><span class="hljs-comment">// letters is now an empty set, but is still of type Set&lt;Character&gt;</span><br><br><span class="hljs-comment">// 字面量赋值</span><br><span class="hljs-keyword">var</span> favoriteGenres: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Rock&quot;</span>, <span class="hljs-string">&quot;Classical&quot;</span>, <span class="hljs-string">&quot;Hip hop&quot;</span>]<br><span class="hljs-comment">// 简写</span><br>favoriteGenres: <span class="hljs-type">Set</span> <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Rock&quot;</span>, <span class="hljs-string">&quot;Classical&quot;</span>, <span class="hljs-string">&quot;Hip hop&quot;</span>]<br></code></pre></td></tr></table></figure><p><code>Set</code>的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> favoriteGenres: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Rock&quot;</span>, <span class="hljs-string">&quot;Classical&quot;</span>, <span class="hljs-string">&quot;Hip hop&quot;</span>]<br>favoriteGenres.insert(<span class="hljs-string">&quot;Jazz&quot;</span>)<br><span class="hljs-comment">// favoriteGenres now contains 4 items</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> removedGenre <span class="hljs-operator">=</span> favoriteGenres.remove(<span class="hljs-string">&quot;Rock&quot;</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(removedGenre)</span>? I&#x27;m over it.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I never much cared for that.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;Rock? I&#x27;m over it.&quot;</span><br><span class="hljs-keyword">if</span> favoriteGenres.contains(<span class="hljs-string">&quot;Funk&quot;</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I get up on the good foot.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;It&#x27;s too funky in here.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;It&#x27;s too funky in here.&quot;</span><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> genre <span class="hljs-keyword">in</span> favoriteGenres &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(genre)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Dictionary"><a href="#3-Dictionary" class="headerlink" title="3.Dictionary"></a>3.Dictionary</h4><p><code>Dictionary&lt;Key, Value&gt;</code>表示字典的类型，简写作：<code>[Key: Value]</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 创建空字典</span><br><span class="hljs-keyword">var</span> namesOfIntegers: [<span class="hljs-type">Int</span>: <span class="hljs-type">String</span>] <span class="hljs-operator">=</span> [:]<br>namesOfIntegers[<span class="hljs-number">16</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sixteen&quot;</span><br>namesOfIntegers <span class="hljs-operator">=</span> [:]<br><br><span class="hljs-comment">// 创建字典并赋值</span><br><span class="hljs-keyword">var</span> airports: [<span class="hljs-type">String</span>: <span class="hljs-type">String</span>] <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;YYZ&quot;</span>: <span class="hljs-string">&quot;Toronto Pearson&quot;</span>, <span class="hljs-string">&quot;DUB&quot;</span>: <span class="hljs-string">&quot;Dublin&quot;</span>]<br><span class="hljs-comment">// 简写形式</span><br><span class="hljs-keyword">var</span> airports <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;YYZ&quot;</span>: <span class="hljs-string">&quot;Toronto Pearson&quot;</span>, <span class="hljs-string">&quot;DUB&quot;</span>: <span class="hljs-string">&quot;Dublin&quot;</span>]<br></code></pre></td></tr></table></figure><p>字典的操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 更新</span><br>airports[<span class="hljs-string">&quot;LHR&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-string">&quot;London Heathrow&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> oldValue <span class="hljs-operator">=</span> airports.updateValue(<span class="hljs-string">&quot;Dublin Airport&quot;</span>, forKey: <span class="hljs-string">&quot;DUB&quot;</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The old value for DUB was <span class="hljs-subst">\(oldValue)</span>.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;The old value for DUB was Dublin.&quot;</span><br><br><span class="hljs-comment">// 取值</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> airportName <span class="hljs-operator">=</span> airports[<span class="hljs-string">&quot;DUB&quot;</span>] &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The name of the airport is <span class="hljs-subst">\(airportName)</span>.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;That airport isn&#x27;t in the airports dictionary.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;The name of the airport is Dublin Airport.&quot;</span><br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> removedValue <span class="hljs-operator">=</span> airports.removeValue(forKey: <span class="hljs-string">&quot;DUB&quot;</span>) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The removed airport&#x27;s name is <span class="hljs-subst">\(removedValue)</span>.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The airports dictionary doesn&#x27;t contain a value for DUB.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;The removed airport&#x27;s name is Dublin Airport.&quot;</span><br><br><span class="hljs-comment">// 遍历字典</span><br><span class="hljs-keyword">for</span> (airportCode, airportName) <span class="hljs-keyword">in</span> airports &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(airportCode)</span>: <span class="hljs-subst">\(airportName)</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 遍历键</span><br><span class="hljs-keyword">for</span> airportCode <span class="hljs-keyword">in</span> airports.keys &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Airport code: <span class="hljs-subst">\(airportCode)</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 遍历值</span><br><span class="hljs-keyword">for</span> airportName <span class="hljs-keyword">in</span> airports.values &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Airport name: <span class="hljs-subst">\(airportName)</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 取所有键</span><br><span class="hljs-keyword">let</span> airportCodes <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>](airports.keys)<br><span class="hljs-comment">// 取所有值</span><br><span class="hljs-keyword">let</span> airportNames <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>](airports.values)<br></code></pre></td></tr></table></figure><h3 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4.枚举"></a>4.枚举</h3><p>定义和使用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CompassPoint</span> &#123;<br>    <span class="hljs-keyword">case</span> north<br>    <span class="hljs-keyword">case</span> south<br>    <span class="hljs-keyword">case</span> east<br>    <span class="hljs-keyword">case</span> west<br>&#125;<br><br><span class="hljs-keyword">var</span> directionToHead <span class="hljs-operator">=</span> <span class="hljs-type">CompassPoint</span>.west<br>directionToHead <span class="hljs-operator">=</span> .east<br><br>directionToHead <span class="hljs-operator">=</span> .south<br><span class="hljs-keyword">switch</span> directionToHead &#123;<br><span class="hljs-keyword">case</span> .north:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Lots of planets have a north&quot;</span>)<br><span class="hljs-keyword">case</span> .south:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Watch out for penguins&quot;</span>)<br><span class="hljs-keyword">case</span> .east:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Where the sun rises&quot;</span>)<br><span class="hljs-keyword">case</span> .west:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Where the skies are blue&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;Watch out for penguins&quot;</span><br></code></pre></td></tr></table></figure><ul><li>遍历枚举</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Beverage</span>: <span class="hljs-title class_">CaseIterable</span> &#123;<br>    <span class="hljs-keyword">case</span> coffee, tea, juice<br>&#125;<br><span class="hljs-keyword">let</span> numberOfChoices <span class="hljs-operator">=</span> <span class="hljs-type">Beverage</span>.allCases.count<br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> beverage <span class="hljs-keyword">in</span> <span class="hljs-type">Beverage</span>.allCases &#123;<br>    <span class="hljs-built_in">print</span>(beverage)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>原始值</li></ul><p>原始值可以是字符串、字符、或者任何整型值或浮点型值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Rank</span>: <span class="hljs-title class_">Int</span> &#123; <span class="hljs-comment">// 默认从0开始，往后递增。</span><br>    <span class="hljs-keyword">case</span> ace <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">// 自定义case对应的值</span><br>    <span class="hljs-keyword">case</span> two, three, four, five, six, seven, eight, nine, ten<br>    <span class="hljs-keyword">case</span> jack, queen, king<br>&#125;<br><span class="hljs-keyword">let</span> ace <span class="hljs-operator">=</span> <span class="hljs-type">Rank</span>.ace<br><span class="hljs-keyword">let</span> aceRawValue <span class="hljs-operator">=</span> ace.rawValue<br></code></pre></td></tr></table></figure><p><code>Int</code>类型的枚举默认从0开始，往后递增。手动指定某个case的值后，其后面的枚举值也是递增。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CompassPoint</span>: <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">case</span> north, south, east, west<br>&#125;<br><span class="hljs-keyword">let</span> direction <span class="hljs-operator">=</span> <span class="hljs-type">CompassPoint</span>.north.rawValue <span class="hljs-comment">// &quot;north&quot;</span><br><span class="hljs-keyword">let</span> south <span class="hljs-operator">=</span> <span class="hljs-type">CompassPoint</span>(rawValue: <span class="hljs-string">&quot;south&quot;</span>) <span class="hljs-comment">// &quot;south&quot;</span><br></code></pre></td></tr></table></figure><p><code>CompassPoint.south</code>隐式的原始值是字符串”south”。</p><ul><li>相关值</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">ServerResponse</span> &#123;<br>    <span class="hljs-keyword">case</span> result(<span class="hljs-type">String</span>, <span class="hljs-type">String</span>)<br>    <span class="hljs-keyword">case</span> failure(<span class="hljs-type">String</span>)<br>&#125;<br><span class="hljs-keyword">let</span> success <span class="hljs-operator">=</span> <span class="hljs-type">ServerResponse</span>.result(<span class="hljs-string">&quot;6:00 am&quot;</span>, <span class="hljs-string">&quot;8:09 pm&quot;</span>)<br><span class="hljs-keyword">let</span> failure <span class="hljs-operator">=</span> <span class="hljs-type">ServerResponse</span>.failure(<span class="hljs-string">&quot;Out of cheese.&quot;</span>)<br><br><span class="hljs-keyword">switch</span> success &#123;<br><span class="hljs-keyword">case</span> .result(<span class="hljs-keyword">let</span> sunrise, <span class="hljs-keyword">let</span> sunset):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Sunrise is at <span class="hljs-subst">\(sunrise)</span> and sunset is at <span class="hljs-subst">\(sunset)</span>.&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .failure(message):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failure...  <span class="hljs-subst">\(message)</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;Sunrise is at 6:00 am and sunset is at 8:09 pm.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="5-属性"><a href="#5-属性" class="headerlink" title="5.属性"></a>5.属性</h3><h4 id="1-存储属性"><a href="#1-存储属性" class="headerlink" title="1.存储属性"></a>1.存储属性</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span><br>&#123;<br>   <span class="hljs-keyword">var</span> digits: <span class="hljs-type">Int</span><br>   <span class="hljs-keyword">let</span> pi <span class="hljs-operator">=</span> <span class="hljs-number">3.1415</span><br>&#125;<br><br><span class="hljs-keyword">var</span> n <span class="hljs-operator">=</span> <span class="hljs-type">Number</span>(digits: <span class="hljs-number">12345</span>)<br>n.digits <span class="hljs-operator">=</span> <span class="hljs-number">67</span><br>n.pi <span class="hljs-operator">=</span> <span class="hljs-number">3.1</span> <span class="hljs-comment">// 报错，pi是常量，不能修改</span><br></code></pre></td></tr></table></figure><h4 id="2-计算属性"><a href="#2-计算属性" class="headerlink" title="2.计算属性"></a>2.计算属性</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TextBool</span> &#123;<br>    <span class="hljs-comment">// 1.存储属性</span><br>    <span class="hljs-keyword">var</span> aInt:<span class="hljs-type">Int</span><br>    <span class="hljs-comment">// 2.计算属性</span><br>    <span class="hljs-keyword">var</span> text:<span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> aInt <span class="hljs-operator">==</span> <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;true&quot;</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;false&quot;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            <span class="hljs-keyword">if</span> newValue <span class="hljs-operator">==</span> <span class="hljs-string">&quot;true&quot;</span> &#123;<br>                aInt <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                aInt <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 3.只读属性</span><br>    <span class="hljs-keyword">var</span> readOnlyText:<span class="hljs-type">String</span> &#123;<br>        <span class="hljs-comment">// 只有一个表达式时，可隐式返回表达式的值</span><br>        <span class="hljs-keyword">get</span>&#123;<br>            aInt <span class="hljs-operator">==</span> <span class="hljs-number">1</span> <span class="hljs-operator">?</span> <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> aBool <span class="hljs-operator">=</span> <span class="hljs-type">TextBool</span>(aInt: <span class="hljs-number">0</span>)<br>aBool.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-built_in">print</span>(aBool.aInt) <span class="hljs-comment">// 打印：&quot;1&quot;</span><br><span class="hljs-built_in">print</span>(aBool.readOnlyText) <span class="hljs-comment">// 打印：“true”</span><br></code></pre></td></tr></table></figure><p>只有<code>get</code>没有<code>set</code>的计算属性就是只读属性。</p><p><code>get</code>函数中只有一个表达式时，会隐式返回它的值(即省略<code>return</code>关键字)。</p><h4 id="3-延迟存储属性"><a href="#3-延迟存储属性" class="headerlink" title="3.延迟存储属性"></a>3.延迟存储属性</h4><p>第一次被调用时才会计算其初始值的属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TextBool</span> &#123;<br>    <span class="hljs-keyword">init</span>()&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Init TextBool&quot;</span>)<br>        aInt <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 存储属性</span><br>    <span class="hljs-keyword">var</span> aInt:<span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span><br>&#123;<br>    <span class="hljs-keyword">var</span> digits: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">let</span> pi <span class="hljs-operator">=</span> <span class="hljs-number">3.1415</span><br>    <span class="hljs-comment">// 1.延迟属性</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> aBool <span class="hljs-operator">=</span> <span class="hljs-type">TextBool</span>()<br>    <span class="hljs-comment">// 2.首次赋值使用默认语句</span><br>    <span class="hljs-keyword">var</span> onceInt:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init Int at first call&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-comment">// 3.延迟+默认赋值语句</span><br>    <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> onceDouble:<span class="hljs-type">Double</span> <span class="hljs-operator">=</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init lazy Double at first call&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>(pi<span class="hljs-operator">+</span><span class="hljs-number">1</span>)<br>    &#125;()<br>&#125;<br><br><span class="hljs-keyword">var</span> n <span class="hljs-operator">=</span> <span class="hljs-type">Number</span>(digits: <span class="hljs-number">1</span>)<br>n.digits <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(n.digits)</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is <span class="hljs-subst">\(n.aBool)</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(n.onceInt)<br><span class="hljs-built_in">print</span>(n.onceDouble)<br></code></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">init <span class="hljs-type">Int</span> <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span> <span class="hljs-keyword">call</span><br><span class="hljs-number">2</span><br>Init TextBool<br>This <span class="hljs-keyword">is</span> TextBool(aInt: <span class="hljs-number">0</span>)<br><span class="hljs-number">3</span><br>init lazy <span class="hljs-keyword">Double</span> <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span> <span class="hljs-keyword">call</span><br><span class="hljs-number">4.141500000000001</span><br></code></pre></td></tr></table></figure><p>创建<code>aBool</code>实例实会先执行其<code>init()</code>函数并打印日志，而日志中<code>2</code>先于<code>Init TextBool</code>打印，说明创建<code>n</code>实例后并未立即创建<code>aBool</code>实例。只有调用<code>print(n.aBool)</code>时第一次访问了<code>aBool</code>实例，此时<code>aBool</code>才真正被初始化。</p><p><code>=&#123;&#125;()</code>用来在第一次访问属性时使用括号内的默认语句给其赋值。</p><h4 id="4-观察器"><a href="#4-观察器" class="headerlink" title="4.观察器"></a>4.观察器</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TextBool</span> &#123;<br>    <span class="hljs-comment">// 存储属性</span><br>    <span class="hljs-keyword">var</span> aInt:<span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-comment">// 属性观察器</span><br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;willSet:<span class="hljs-subst">\(newValue)</span>&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">didSet</span>&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;didSet:<span class="hljs-subst">\(oldValue)</span>&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> aBool <span class="hljs-operator">=</span> <span class="hljs-type">TextBool</span>(aInt: <span class="hljs-number">0</span>)<br>aBool.aInt <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>打印日志：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">willSet</span>:<span class="hljs-number">1</span><br><span class="hljs-attribute">didSet</span>:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>初始化方法中设置属性，以及在 willSet 和 didSet 中再次设置属性，都不会再次触发属性观察器。</p><h4 id="5-包装器"><a href="#5-包装器" class="headerlink" title="5.包装器"></a>5.包装器</h4><p>作用：将属性的定义和管理代码封装在一起。它可以让我们抽象出属性的某些行为，比如线程安全性、延迟初始化等。当需要给多个属性定义同样的行为时，使用包装器可以省去大量重复代码，让我们的代码更加简洁和易于理解。</p><p>示例1：属性值不能 &gt; 12</p><ul><li>定义包装器</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">@propertyWrapper</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwelveOrLess</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> number <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> number &#125;<br>        <span class="hljs-keyword">set</span> &#123; number <span class="hljs-operator">=</span> <span class="hljs-built_in">min</span>(newValue, <span class="hljs-number">12</span>) &#125; <span class="hljs-comment">// 属性值不能&gt;12</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>属性封装器中必须声明一个<code>wrappedvalue</code>属性，用来表示真正待封装属性。待封装属性可能是height，也可能是width，但在封装器中均用<code>wrappedvalue</code>来表示。</p><ul><li>使用包装器</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SmallRectangle</span> &#123;<br>    <span class="hljs-meta">@TwelveOrLess</span> <span class="hljs-keyword">var</span> height: <span class="hljs-type">Int</span><br>    <span class="hljs-meta">@TwelveOrLess</span> <span class="hljs-keyword">var</span> width: <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> rectangle <span class="hljs-operator">=</span> <span class="hljs-type">SmallRectangle</span>()<br><span class="hljs-built_in">print</span>(rectangle.height)<br><span class="hljs-comment">// Prints &quot;0&quot;</span><br><br>rectangle.height <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(rectangle.height)<br><span class="hljs-comment">// Prints &quot;10&quot;</span><br><br>rectangle.height <span class="hljs-operator">=</span> <span class="hljs-number">24</span><br><span class="hljs-built_in">print</span>(rectangle.height)<br><span class="hljs-comment">// Prints &quot;12&quot; // 24大于12，所以取二者中的最小值12</span><br></code></pre></td></tr></table></figure><p>使用时以@+封装器的名字修饰变量；编译器会按照上面的定义，自动合成此属性的setter 和 getter，因此我们省去了这部分任务，这正是属性封装器的精髓，尤其是类似的属性很多时，这个语法糖的优势很明显。</p><p>示例2：属性值发生变化时页面同步更新</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>   <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>   <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>   <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> user: <span class="hljs-type">User</span><br>​<br>   <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>       <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Hello, <span class="hljs-subst">\(user.name)</span>!&quot;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是SwiftUI中的<code>@Published</code>与<code>@ObservedObject</code>，它们也都是属性包装器。</p><p>当<code>user.name</code>的值发生变化时，ContentView 会自动更新，显示新的名字。</p><h4 id="6-修饰符"><a href="#6-修饰符" class="headerlink" title="6.修饰符"></a>6.修饰符</h4><h5 id="1-强弱"><a href="#1-强弱" class="headerlink" title="1.强弱"></a>1.强弱</h5><p>Swift 里属性默认是强类型的，OC 中<code>strong</code>属性在 Swift 中会转换为<code>存储属性</code>。</p><p>Swift 中<code>weak</code>对应 OC 中的<code>weak</code>，仅能修饰引用类型，不能修饰<code>String</code>、<code>Int</code>等值类型属性；</p><p><code>weak</code>修饰的属性必须是 optional 对象类型，否则会报错“’weak’ variable should have optional type ‘xxClass?’”。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> ani:Animal?<br></code></pre></td></tr></table></figure><p>weak 一般用来解决对象间或闭包属性与其所属对象之间的循环引用问题。</p><h5 id="2-读写"><a href="#2-读写" class="headerlink" title="2.读写"></a>2.读写</h5><p>Swift 没有 OC 中的<code>readwrite</code>和<code>readonly</code>关键字。</p><p>对于<code>存储属性</code>，使用<code>let</code>表明只读；使用<code>var</code>表明可读／可写。</p><p>对于<code>计算属性</code>，提供一个 getter 使其可读，提供 setter 使其可写；只有 getter 没有 setter，则属性只读；计算属性不能只提供 setter 不提供 getter，否则会报错。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">var</span> aInt: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-原子性"><a href="#3-原子性" class="headerlink" title="3.原子性"></a>3.原子性</h5><p>OC 中的<code>atomic</code>和<code>nonatomic</code>在 Swift 中没有对应的修饰符，Swift 中属性默认是<code>nonatomic</code>的，可以通过 OC 中类似的锁机制来保证属性对象的线程安全。</p><h5 id="4-拷贝"><a href="#4-拷贝" class="headerlink" title="4.拷贝"></a>4.拷贝</h5><p>在Swift中，OC的<code>copy</code>被转换为<code>@NSCopying</code>属性。这一类属性须遵守 <code>NSCopying</code>协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>: <span class="hljs-title class_">NSCopying</span> &#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>?<br>    <span class="hljs-comment">// 实现copy协议方法</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">with</span> <span class="hljs-params">zone</span>: <span class="hljs-type">NSZone</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) -&gt; <span class="hljs-keyword">Any</span> &#123;<br>        <span class="hljs-keyword">let</span> copy <span class="hljs-operator">=</span> <span class="hljs-type">Book</span>()<br>        copy.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">return</span> copy<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BooksShelf</span> &#123;<br>    <span class="hljs-keyword">@NSCopying</span> <span class="hljs-keyword">var</span> book: <span class="hljs-type">Book</span>?<br>&#125;<br><br><span class="hljs-comment">//调用及日志</span><br><span class="hljs-keyword">let</span> book1 <span class="hljs-operator">=</span> <span class="hljs-type">Book</span>()<br>book1.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;swift&quot;</span><br><span class="hljs-keyword">let</span> bookShelf <span class="hljs-operator">=</span> <span class="hljs-type">BooksShelf</span>()<br>bookShelf.book <span class="hljs-operator">=</span> book1<br><span class="hljs-built_in">print</span>(bookShelf.book <span class="hljs-operator">===</span> book1)<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h3 id="6-控制流"><a href="#6-控制流" class="headerlink" title="6.控制流"></a>6.控制流</h3><h4 id="1-if-else"><a href="#1-if-else" class="headerlink" title="1.if else"></a>1.if else</h4><ul><li>1.一般用法：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> individualScores <span class="hljs-operator">=</span> [<span class="hljs-number">75</span>, <span class="hljs-number">43</span>, <span class="hljs-number">103</span>, <span class="hljs-number">87</span>, <span class="hljs-number">12</span>]<br><span class="hljs-keyword">var</span> teamScore <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> score <span class="hljs-keyword">in</span> individualScores &#123;<br>    <span class="hljs-keyword">if</span> score <span class="hljs-operator">&gt;</span> <span class="hljs-number">50</span> &#123;<br>        teamScore <span class="hljs-operator">+=</span> <span class="hljs-number">3</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        teamScore <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(teamScore)<br><span class="hljs-comment">// Prints &quot;11&quot;</span><br></code></pre></td></tr></table></figure><ul><li>2.变量赋值：</li></ul><p>可以在<code>=</code>号之后使用<code>if</code>或<code>switch</code>语句根据条件取变量的值：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> scoreDecoration <span class="hljs-operator">=</span> <span class="hljs-keyword">if</span> teamScore <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span> &#123;<br>    <span class="hljs-string">&quot;🎉&quot;</span> <span class="hljs-comment">//省略了return</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Score:&quot;</span>, teamScore, scoreDecoration)<br><span class="hljs-comment">// Prints &quot;Score: 11 🎉&quot;</span><br></code></pre></td></tr></table></figure><ul><li>3.可选绑定</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> optionalString: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-built_in">print</span>(optionalString <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// Prints &quot;false&quot;</span><br><br><span class="hljs-keyword">var</span> optionalName: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">&quot;John Appleseed&quot;</span><br><span class="hljs-keyword">var</span> greeting <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello!&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> optionalName &#123; <span class="hljs-comment">//不为nil时 值绑定到常量name上</span><br>    greeting <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, <span class="hljs-subst">\(name)</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可选绑定的简写用法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> nickname: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> nickname &#123; <span class="hljs-comment">// 省略了赋值：if let x = nickName</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hey, <span class="hljs-subst">\(nickname)</span>&quot;</span>) <span class="hljs-comment">// 使用同名变量代替拆包后的值</span><br>&#125;<br><span class="hljs-comment">// Doesn&#x27;t print anything, because nickname is nil.</span><br></code></pre></td></tr></table></figure><h4 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h4><p><code>case</code>中支持任何数据类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> someCharacter: <span class="hljs-type">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;z&quot;</span><br><span class="hljs-keyword">switch</span> someCharacter &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The first letter of the Latin alphabet&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;z&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The last letter of the Latin alphabet&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Some other character&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;The last letter of the Latin alphabet&quot;</span><br></code></pre></td></tr></table></figure><ul><li>fallthrough</li></ul><p>switch匹配成功后默认不需要手动书写<code>break</code>，会自动退出当前控制流。</p><p><code>fallthrough</code>可以让<code>case</code>之后的语句按顺序继续运行，且不论条件是否满足都会执行：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> index <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br><br><span class="hljs-keyword">switch</span> index &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>  :<br>      <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;index 的值为 100&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>,<span class="hljs-number">15</span>  :<br>      <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;index 的值为 10 或 15&quot;</span>)<br>      <span class="hljs-keyword">fallthrough</span><br>   <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>  :<br>      <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;index 的值为 5&quot;</span>)<br>   <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>  :<br>      <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;index 的值为 0&quot;</span>)<br>   <span class="hljs-keyword">default</span> :<br>      <span class="hljs-built_in">print</span>( <span class="hljs-string">&quot;默认 case&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 输出日志：</span><br><span class="hljs-comment">// index 的值为 10 或 15</span><br><span class="hljs-comment">// index 的值为 5</span><br></code></pre></td></tr></table></figure><ul><li>合并case的写法</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> anotherCharacter: <span class="hljs-type">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">switch</span> anotherCharacter &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-comment">// 写在同一行，逗号隔开</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The letter A&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Not the letter A&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;The letter A&quot;</span><br></code></pre></td></tr></table></figure><ul><li>变量赋值</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> aCharacter: <span class="hljs-type">Character</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">let</span> message <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> aCharacter &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br>    <span class="hljs-string">&quot;The first letter of the Latin alphabet&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;z&quot;</span>:<br>    <span class="hljs-string">&quot;The last letter of the Latin alphabet&quot;</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-string">&quot;Some other character&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(message)<br><span class="hljs-comment">// Prints &quot;The first letter of the Latin alphabet&quot;</span><br></code></pre></td></tr></table></figure><ul><li>间隔匹配</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> approximateCount <span class="hljs-operator">=</span> <span class="hljs-number">62</span><br><span class="hljs-keyword">let</span> countedThings <span class="hljs-operator">=</span> <span class="hljs-string">&quot;moons orbiting Saturn&quot;</span><br><span class="hljs-keyword">let</span> naturalCount: <span class="hljs-type">String</span><br><span class="hljs-keyword">switch</span> approximateCount &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    naturalCount <span class="hljs-operator">=</span> <span class="hljs-string">&quot;no&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">5</span>:<br>    naturalCount <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a few&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">12</span>:<br>    naturalCount <span class="hljs-operator">=</span> <span class="hljs-string">&quot;several&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">12</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">100</span>:<br>    naturalCount <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dozens of&quot;</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">100</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">1000</span>:<br>    naturalCount <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hundreds of&quot;</span><br><span class="hljs-keyword">default</span>:<br>    naturalCount <span class="hljs-operator">=</span> <span class="hljs-string">&quot;many&quot;</span><br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;There are <span class="hljs-subst">\(naturalCount)</span> <span class="hljs-subst">\(countedThings)</span>.&quot;</span>)<br><span class="hljs-comment">// Prints &quot;There are dozens of moons orbiting Saturn.&quot;</span><br></code></pre></td></tr></table></figure><ul><li>支持<code>where</code>语句：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> vegetable <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red pepper&quot;</span><br><span class="hljs-keyword">switch</span> vegetable &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;celery&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Add some raisins and make ants on a log.&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;cucumber&quot;</span>, <span class="hljs-string">&quot;watercress&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;That would make a good tea sandwich.&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> x <span class="hljs-keyword">where</span> x.hasSuffix(<span class="hljs-string">&quot;pepper&quot;</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Is it a spicy <span class="hljs-subst">\(x)</span>?&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Everything tastes good in soup.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// Prints &quot;Is it a spicy red pepper?&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h4><p><code>for-in</code>遍历集合：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">let</span> interestingNumbers <span class="hljs-operator">=</span> [<br>    <span class="hljs-string">&quot;Prime&quot;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>],<br>    <span class="hljs-string">&quot;Fibonacci&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>],<br>    <span class="hljs-string">&quot;Square&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>],<br>]<br><span class="hljs-keyword">var</span> largest <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">_</span>, numbers) <span class="hljs-keyword">in</span> interestingNumbers &#123;<br>    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers &#123;<br>        <span class="hljs-keyword">if</span> number <span class="hljs-operator">&gt;</span> largest &#123;<br>            largest <span class="hljs-operator">=</span> number<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">print</span>(largest)<br><span class="hljs-comment">// Prints &quot;25&quot;</span><br></code></pre></td></tr></table></figure><p>支持<code>..&lt;</code>右不包含、<code>...</code>左右都包含的区间遍历：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> total <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">4</span> &#123;<br>    total <span class="hljs-operator">+=</span> i<br>&#125;<br><span class="hljs-built_in">print</span>(total)<br><span class="hljs-comment">// Prints &quot;6&quot;</span><br></code></pre></td></tr></table></figure><h4 id="4-while"><a href="#4-while" class="headerlink" title="4.while"></a>4.while</h4><ul><li>1.一般用法：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> n <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">while</span> n <span class="hljs-operator">&lt;</span> <span class="hljs-number">100</span> &#123;<br>    n <span class="hljs-operator">*=</span> <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-built_in">print</span>(n)<br><span class="hljs-comment">// Prints &quot;128&quot;</span><br></code></pre></td></tr></table></figure><ul><li>2.repeat用法：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">var</span> m <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">repeat</span> &#123;<br>    m <span class="hljs-operator">*=</span> <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">while</span> m <span class="hljs-operator">&lt;</span> <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(m)<br><span class="hljs-comment">// Prints &quot;128&quot;</span><br></code></pre></td></tr></table></figure><p>保证循环至少执行一次。</p><h3 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h3><ul><li>1.局部参数名</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person</span>: <span class="hljs-type">String</span>, <span class="hljs-params">day</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello <span class="hljs-subst">\(person)</span>, today is <span class="hljs-subst">\(day)</span>.&quot;</span><br>&#125;<br>greet(person: <span class="hljs-string">&quot;Bob&quot;</span>, day: <span class="hljs-string">&quot;Tuesday&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>person</code>、<code>day</code>都是局部参数，在函数体内使用。</p><ul><li>2.外部参数名</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">person</span>: <span class="hljs-type">String</span>, <span class="hljs-params">on</span> <span class="hljs-params">day</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello <span class="hljs-subst">\(person)</span>, today is <span class="hljs-subst">\(day)</span>.&quot;</span><br>&#125;<br>greet(<span class="hljs-string">&quot;John&quot;</span>, on: <span class="hljs-string">&quot;Wednesday&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>_</code>、<code>on</code>即为外部参数名，其中<code>_</code>表示外部参数名可省略，调用时无需书写。</p><ul><li>3.inout参数</li></ul><p>在函数中定义的参数默认都是常量参数，函数体内不可以修改它的值；</p><p>如果想声明一个变量参数，可以在参数定义前加上<code>inout</code>关键字：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">swapTwoInts</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Int</span>) &#123;<br>    <span class="hljs-keyword">let</span> temporaryA <span class="hljs-operator">=</span> a<br>    a <span class="hljs-operator">=</span> b<br>    b <span class="hljs-operator">=</span> temporaryA<br>&#125;<br><span class="hljs-keyword">var</span> someInt <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> anotherInt <span class="hljs-operator">=</span> <span class="hljs-number">107</span><br>swapTwoInts(<span class="hljs-operator">&amp;</span>someInt, <span class="hljs-operator">&amp;</span>anotherInt)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;someInt is now <span class="hljs-subst">\(someInt)</span>, and anotherInt is now <span class="hljs-subst">\(anotherInt)</span>&quot;</span>)<br><span class="hljs-comment">// Prints &quot;someInt is now 107, and anotherInt is now 3&quot;</span><br></code></pre></td></tr></table></figure><ul><li>4.参数默认值</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">someFunction</span>(<span class="hljs-params">a</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">b</span>: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>) &#123;<br>    <span class="hljs-comment">// If you omit the second argument when calling this function, then</span><br>    <span class="hljs-comment">// the value of b is 12 inside the function body.</span><br>&#125;<br>someFunction(a: <span class="hljs-number">3</span>, b: <span class="hljs-number">6</span>) <span class="hljs-comment">// b is 6</span><br>someFunction(a: <span class="hljs-number">4</span>) <span class="hljs-comment">// b is 12</span><br></code></pre></td></tr></table></figure><ul><li>5.函数重载</li></ul><p>Swift允许函数重载，需保证：函数名相同、参数标签不同、参数类型不同、参数个数不同。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 1.原函数</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">samefunc</span>(<span class="hljs-params">a</span>:<span class="hljs-type">Int</span>)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++a:<span class="hljs-subst">\(a)</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 2.参数标签不同</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">samefunc</span>(<span class="hljs-params">b</span>:<span class="hljs-type">Int</span>)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++Int b:<span class="hljs-subst">\(b)</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 3.参数类型不同</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">samefunc</span>(<span class="hljs-params">b</span>:<span class="hljs-type">Double</span>)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++Double b:<span class="hljs-subst">\(b)</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 4.参数个数不同</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">samefunc</span>(<span class="hljs-params">a</span>:<span class="hljs-type">Int</span> ,<span class="hljs-params">b</span>:<span class="hljs-type">Double</span>)&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++a:<span class="hljs-subst">\(a)</span>, b:<span class="hljs-subst">\(b)</span>&quot;</span>)<br>&#125;<br>samefunc(a: <span class="hljs-number">0</span>)<br>samefunc(b: <span class="hljs-number">0</span>)<br>samefunc(b: <span class="hljs-number">0.0</span>)<br>samefunc(a: <span class="hljs-number">0</span>, b: <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>注意：返回值类型与函数重载无关。函数名、参数个数&amp;类型&amp;标签都相同时，无论返回值类型是否相同，调用时都会报错。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 5.返回值类型无关重载</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">samefunc</span>(<span class="hljs-params">a</span>:<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++a from (Int)-&gt;Int:<span class="hljs-subst">\(a)</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br>samefunc(a: <span class="hljs-number">0</span>) <span class="hljs-comment">//报错：Ambiguous use of &#x27;samefunc(a:)&#x27;</span><br></code></pre></td></tr></table></figure><p>虽然可以同时定义<code>(a:Int)-&gt;void</code>与<code>(a:Int)-&gt;Int</code>，但调用时会报错。</p><h3 id="8-结构体与类"><a href="#8-结构体与类" class="headerlink" title="8.结构体与类"></a>8.结构体与类</h3><p>相同点：</p><ul><li>定义属性和方法；</li><li>使用下标语法<code>subscript syntax</code>；</li><li>定义初始化器设置初始状态；</li><li>添加扩展、实现协议；</li></ul><p>class 独有的特性：</p><ul><li>继承</li><li>类型转换<code>Type casting</code></li><li>析构</li><li>class 的实例可被多个对象引用</li></ul><p>最大的不同：struct 是值类型，class 是引用类型。</p><p>值类型在赋值给变量、常量，或者作为函数参数传递时，是<code>值拷贝</code>，对拷贝的修改不影响原对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 枚举</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>    <span class="hljs-keyword">case</span> north, south, east, west<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">goNorth</span>() &#123;<br>        <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> .north<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> d1 <span class="hljs-operator">=</span> <span class="hljs-type">Direction</span>.south<br><span class="hljs-keyword">var</span> d2 <span class="hljs-operator">=</span> d1 <span class="hljs-comment">// 值拷贝</span><br>d2.goNorth()<br><span class="hljs-built_in">print</span>(d1)   <span class="hljs-comment">// 输出 south，拷贝的修改不影响原对象</span><br><span class="hljs-built_in">print</span>(d2)   <span class="hljs-comment">// 输出 north</span><br><br><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">var</span> num:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>() &#123;<br>        num <span class="hljs-operator">+=</span> <span class="hljs-number">10</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> aCal <span class="hljs-operator">=</span> <span class="hljs-type">Calculator</span>()<br><span class="hljs-keyword">var</span> cal2 <span class="hljs-operator">=</span> aCal <span class="hljs-comment">// 值拷贝</span><br>cal2.num <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(aCal.num) <span class="hljs-comment">// 输出0，拷贝的修改不影响原对象</span><br><span class="hljs-built_in">print</span>(cal2.num) <span class="hljs-comment">// 输出1</span><br><br><span class="hljs-comment">//  结构体作为函数的参数</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">meth</span>(<span class="hljs-params">calculator</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">Calculator</span>) &#123;<br>    calculator.num <span class="hljs-operator">+=</span> <span class="hljs-number">10</span>  <span class="hljs-comment">//传入的是指针，修改会影响外部</span><br>    <span class="hljs-comment">//或者调用 calculator.add()</span><br>&#125;<br><br>meth(calculator: <span class="hljs-operator">&amp;</span>aCal) <span class="hljs-comment">//传递指针</span><br><span class="hljs-built_in">print</span>(aCal.num) <span class="hljs-comment">// 输出10</span><br></code></pre></td></tr></table></figure><p>结构体单纯的作为参数传入函数体时，是值拷贝；</p><p>函数体内修改结构体时，需要使用inout并传入结构体的指针。</p><p><mark>注意：函数体内修改结构体时</mark>，会影响外部对应的结构体对象。</p><h3 id="9-单例"><a href="#9-单例" class="headerlink" title="9.单例"></a>9.单例</h3><ul><li>方式1: 静态常量</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass</span> &#123;<br>    <span class="hljs-comment">// 声明类变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">SingletonClass</span>()<br>    <span class="hljs-comment">// 声明成私有 防止外界通过SingletonClass()创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">instanceFunc</span>()&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++call static func~&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用单例及其方法</span><br><span class="hljs-type">SingletonClass</span>.shared.instanceFunc()<br></code></pre></td></tr></table></figure><ul><li>方式2: 静态变量+闭包</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass2</span> &#123;<br>    <span class="hljs-comment">// 声明类变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> shared: <span class="hljs-type">SingletonClass2</span> <span class="hljs-operator">=</span> &#123;<br>        <span class="hljs-keyword">let</span> instance <span class="hljs-operator">=</span> <span class="hljs-type">SingletonClass2</span>()<br>        <span class="hljs-comment">// 进行额外的配置和初始化</span><br>        <span class="hljs-keyword">return</span> instance<br>    &#125;() <span class="hljs-comment">// 这里的闭包会在第一次访问 shared 属性时执行，从而保证只有一个实例被创建。</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-comment">// 私有化初始化方法，防止其他地方创建实例</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">instanceFunc</span>()&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++call static func2~&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用单例及其方法</span><br><span class="hljs-type">SingletonClass2</span>.shared.instanceFunc()<br></code></pre></td></tr></table></figure><ul><li>方式3：内部结构体</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass3</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> shared: <span class="hljs-type">SingletonClass3</span> &#123;<br>        <span class="hljs-comment">//结构体</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SingletonStruct</span> &#123;<br>            <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">SingletonClass3</span>()<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">SingletonStruct</span>.shared<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">instanceFunc</span>()&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++call static func3~&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用单例及其方法</span><br><span class="hljs-type">SingletonClass3</span>.shared.instanceFunc()<br></code></pre></td></tr></table></figure><ul><li>方法4：全局常量</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">//全局常量，只对当前.swift文件可见，别的文件中创建此单例时看不到此常量</span><br><span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">let</span> globalVar <span class="hljs-operator">=</span> <span class="hljs-type">SingletonClass4</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonClass4</span> &#123;<br>    <span class="hljs-comment">//静态变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> shared: <span class="hljs-type">SingletonClass4</span> &#123;<br>        <span class="hljs-keyword">return</span> globalVar<br>    &#125;<br><br>    <span class="hljs-keyword">fileprivate</span> <span class="hljs-keyword">init</span>() &#123; &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">instanceFunc</span>()&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++call static func4~&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用单例及其方法</span><br><span class="hljs-type">SingletonClass4</span>.shared.instanceFunc()<br></code></pre></td></tr></table></figure><p>四种方式从本质上来说，都是利用了类的静态类属性。</p><h3 id="10-构造器"><a href="#10-构造器" class="headerlink" title="10.构造器"></a>10.构造器</h3><p>Swift 中类的初始化顺序如下：</p><ol><li>初始化自己的存储属性，必须；</li><li>调用父类初始化方法，如无需第3步，则这一步也可省略；</li><li>修改父类成员变量，可选。</li></ol><p>构造器结束前，需要完成本类中所有存储属性的初始化；</p><p>子类构造器中，存储属性必须全部初始化，才能调用super构造器，否则会报错；</p><p>子类构造器中，需要先完成父类的初始化，才能给从父类中继承的属性赋值，否则会报错；</p><p>便利构造器中，不能直接调用super构造器，可调用本类中默认构造器，或者其他便利构造器；</p><p>便利构造器中，可以将初始化任务代理给其他构造器，但最终需要调用本类的默认构造器。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-keyword">var</span> corners:<span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(corners)</span> 边&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">corners</span>:<span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">self</span>.corners <span class="hljs-operator">=</span> corners <span class="hljs-comment">// 构造函数结束前 需要完成所有存储属性的初始化</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> rectangle <span class="hljs-operator">=</span> <span class="hljs-type">Graph</span>(corners: <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;矩形: <span class="hljs-subst">\(rectangle.description)</span>&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubGraph</span>: <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-keyword">var</span> aInt:<span class="hljs-type">Int</span><br>    <span class="hljs-comment">// 子类初始化函数</span><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">aInt</span>:<span class="hljs-type">Int</span> ,<span class="hljs-params">corners</span>:<span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">self</span>.aInt <span class="hljs-operator">=</span> aInt <span class="hljs-comment">// 注意：子类存储属性须全部初始化完成，才能调用super构造器，否则会报错：Property &#x27;self.xxx&#x27; not initialized at super.init call</span><br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(corners: corners)<br>        <span class="hljs-keyword">self</span>.corners <span class="hljs-operator">=</span> <span class="hljs-number">5</span> <span class="hljs-comment">// 注意：需要先完成父类的初始化，才能在子类中给父类中继承的属性赋值，否则会报错：self&#x27; used in property access &#x27;corners&#x27; before &#x27;super.init&#x27; call</span><br>    &#125;<br>    <span class="hljs-comment">// 便利构造函数</span><br>    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>()&#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(aInt:<span class="hljs-number">1</span>, corners: <span class="hljs-number">5</span>) <span class="hljs-comment">// 调用本类中默认构造器</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> subGraph <span class="hljs-operator">=</span> <span class="hljs-type">SubGraph</span>() <span class="hljs-comment">//调用便利函数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;五角形: <span class="hljs-subst">\(subGraph.description)</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="11-Extension"><a href="#11-Extension" class="headerlink" title="11.Extension"></a>11.Extension</h3><p>Swift 的扩展能向一个已有的类、结构体或枚举类型添加新功能：</p><ul><li>添加计算型属性和计算型静态属性；</li><li>定义实例方法和类型方法；</li><li>提供新的构造器；</li><li>定义下标；</li><li>定义和使用新的嵌套类型；</li><li>使一个已有类型符合某个协议；</li></ul><h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SomeType</span> &#123;<br>    <span class="hljs-comment">// 这里添加新功能</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-增加计算属性"><a href="#2-增加计算属性" class="headerlink" title="2.增加计算属性"></a>2.增加计算属性</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span> &#123;<br>   <span class="hljs-keyword">var</span> add: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span> &#125;<br>   <span class="hljs-keyword">var</span> sub: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span> &#125;<br>   <span class="hljs-keyword">var</span> mul: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">*</span> <span class="hljs-number">1</span> &#125;<br>   <span class="hljs-keyword">var</span> div: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">/</span> <span class="hljs-number">1</span> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> addition <span class="hljs-operator">=</span> <span class="hljs-number">1</span>.add<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;加法运算：<span class="hljs-subst">\(addition)</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="3-增加新的方法"><a href="#3-增加新的方法" class="headerlink" title="3.增加新的方法"></a>3.增加新的方法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">repetitions</span>(<span class="hljs-params">task</span>: () -&gt; <span class="hljs-type">Void</span>) &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-keyword">self</span> &#123;<br>            task()<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用</span><br><span class="hljs-number">3</span>.repetitions &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：扩展可以添加新功能，但不能重写已有的功能：</p><ul><li>不能增加父类；</li><li>不能覆盖原有的方法；</li><li>不能增加存储属性；</li><li>不能为已有属性添加观察器；</li></ul><p>Swift 的<code>Extension</code>与 OC 的<code>Category</code>都不能改变原类型的内存结构，而增加存储属性会改变内存结构。OC 中可使用<code>关联对象</code>达到给分类增加属性实现存取的效果，Swift 也可以参考这种做法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AssociatedKey</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> textKey: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;textKey&quot;</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span>? &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span><span class="hljs-type">AssociatedKey</span>.textKey) <span class="hljs-keyword">as?</span> <span class="hljs-type">String</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            objc_setAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-operator">&amp;</span><span class="hljs-type">AssociatedKey</span>.textKey, newValue, .<span class="hljs-type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>a.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>    <span class="hljs-comment">//存值</span><br><span class="hljs-built_in">print</span>(a.text<span class="hljs-operator">!</span>)  <span class="hljs-comment">//取值</span><br></code></pre></td></tr></table></figure><h4 id="4-现有类适配协议"><a href="#4-现有类适配协议" class="headerlink" title="4.现有类适配协议"></a>4.现有类适配协议</h4><p>扩展已有类型，使其能够适配一个或多个协议：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 注意，冒号`:`后面只能使用`协议`，不能是某个`类`。</span><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SomeType</span>: <span class="hljs-title class_">SomeProtocol</span>, <span class="hljs-title class_">AnotherProtocol</span> &#123;<br>    <span class="hljs-comment">// 协议的实现写到这里</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">var</span> add: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">var</span> sub: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">var</span> mul: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">var</span> div: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <br>&#125;<br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>   <span class="hljs-keyword">var</span> add: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">+</span> <span class="hljs-number">100</span> &#125;<br>   <span class="hljs-keyword">var</span> sub: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">-</span> <span class="hljs-number">10</span> &#125;<br>   <span class="hljs-keyword">var</span> mul: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">*</span> <span class="hljs-number">10</span> &#125;<br>   <span class="hljs-keyword">var</span> div: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">/</span> <span class="hljs-number">5</span> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> addition <span class="hljs-operator">=</span> <span class="hljs-number">3</span>.add<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;加法运算后的值：<span class="hljs-subst">\(addition)</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="5-协议方法默认实现"><a href="#5-协议方法默认实现" class="headerlink" title="5.协议方法默认实现"></a>5.协议方法默认实现</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>()<br>&#125;<br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>()&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;run on <span class="hljs-subst">\(<span class="hljs-keyword">self</span>)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iPhone</span>: <span class="hljs-title class_">IOS</span>&#123;<br><span class="hljs-comment">// 给协议方法提供默认实现后，这里就可以不重写协议方法了</span><br><span class="hljs-comment">//    func run() &#123;</span><br><span class="hljs-comment">//        print(&quot;run on \(self)&quot;)</span><br><span class="hljs-comment">//    &#125;</span><br>&#125;<br><span class="hljs-keyword">let</span> iphoneX <span class="hljs-operator">=</span> iPhone()<br>iphoneX.run()<br></code></pre></td></tr></table></figure><p>默认情况下，<code>iPhone</code>类中需要重写<code>run()</code>协议方法并提供自己的实现，否则编译时会报错。通过<code>extension</code>给<code>IOS</code>协议中的<code>run()</code>提供默认实现后，<code>iPhone</code>类中可以不再重写此协议方法，调用时会使用协议扩展中的默认实现。</p><h3 id="12-Protocols"><a href="#12-Protocols" class="headerlink" title="12.Protocols"></a>12.Protocols</h3><p>协议规定了实现特定功能所必需的方法和属性。类、结构体、枚举均可遵循协议并提供具体实现。</p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">// 定义协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-comment">// protocol definition goes here</span><br>&#125;<br><br><span class="hljs-comment">// 实现超类与协议</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>: <span class="hljs-title class_">SomeSuperclass</span>, <span class="hljs-title class_">FirstProtocol</span>, <span class="hljs-title class_">AnotherProtocol</span> &#123;<br>    <span class="hljs-comment">// 这里提供协议的具体实现</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h4><p>协议中可指定实例属性或类属性，不用指定是存储型属性还是计算型属性。</p><p>协议中必须指明属性是只读的还是可读可写的：</p><p>协议中指定为可读可写的属性，实现中必须也是可读可写；</p><p>协议中指定为只读的属性，实现中可以保持只读也可以可读可写，只要满足协议中的要求即可。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">var</span> mustBeSettable: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;          <span class="hljs-comment">// 可读可写</span><br>    <span class="hljs-keyword">var</span> doesNotNeedToBeSettable: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;     <span class="hljs-comment">// 只读</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125; <span class="hljs-comment">// 类型属性</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h4><p>协议中可以定义实例方法或类型方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someInstanceMethod</span>()<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">someTypeMethod</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-构造器"><a href="#4-构造器" class="headerlink" title="4.构造器"></a>4.构造器</h4><p>协议可以要求它的遵循者实现指定的构造器。</p><p>在遵循该协议的类中实现构造器时，可以指定其为类的指定构造器或者便利构造器。两种情况下，都必须给构造器的实现标上<code>required</code>修饰符：</p><p>示例1：实现中声明为指定构造器</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>   <span class="hljs-keyword">init</span>(<span class="hljs-params">someParameter</span>: <span class="hljs-type">Int</span>)<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>: <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">someParameter</span>: <span class="hljs-type">Int</span>) &#123; <span class="hljs-comment">// 指定构造器</span><br>        <span class="hljs-comment">// 这里是构造器的具体实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例2：实现中声明为便利构造器</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>   <span class="hljs-keyword">init</span>(<span class="hljs-params">someParameter</span>: <span class="hljs-type">Int</span>)<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>: <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;designed init&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">someParameter</span>: <span class="hljs-type">Int</span>) &#123; <span class="hljs-comment">// 便利构造器</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;convenience init&quot;</span>)<br>        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> inst <span class="hljs-operator">=</span> <span class="hljs-type">SomeClass</span>(someParameter: <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>如果一个子类重写了父类的指定构造器，并且该构造器遵循了某个协议的规定，那么该构造器的实现需要被同时标示<code>required</code>和<code>override</code>修饰符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">init</span>()<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeSuperClass</span> &#123;<br>    <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-comment">// initializer implementation goes here</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeSubClass</span>: <span class="hljs-title class_">SomeSuperClass</span>, <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123; <span class="hljs-comment">// 这里 同时提供两个标注</span><br>        <span class="hljs-comment">// initializer implementation goes here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-用作代理"><a href="#5-用作代理" class="headerlink" title="5.用作代理"></a>5.用作代理</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeController</span>: <span class="hljs-title class_">UIViewController</span>, <span class="hljs-title class_">UITableViewDelegate</span> &#123;<br>    <br>    <span class="hljs-keyword">var</span> tableview: <span class="hljs-type">UITableView</span><br><br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span>: <span class="hljs-type">NSCoder</span>) &#123;<br>        tableview <span class="hljs-operator">=</span> <span class="hljs-type">UITableView</span>.<span class="hljs-keyword">init</span>()<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(coder: coder)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        tableview.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-comment">// 设置代理</span><br>    &#125;<br><br>    <span class="hljs-comment">// 实现代理方法</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">tableView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">tableView</span>: <span class="hljs-type">UITableView</span>, <span class="hljs-params">numberOfRowsInSection</span> <span class="hljs-params">section</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-类的扩展"><a href="#6-类的扩展" class="headerlink" title="6.类的扩展"></a>6.类的扩展</h4><p>扩展现有类，使其遵循某个协议，即使你无法访问该类的源码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">var</span> add: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">var</span> sub: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">var</span> mul: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">var</span> div: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <br>&#125;<br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Int</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>   <span class="hljs-keyword">var</span> add: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">+</span> <span class="hljs-number">100</span> &#125;<br>   <span class="hljs-keyword">var</span> sub: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">-</span> <span class="hljs-number">10</span> &#125;<br>   <span class="hljs-keyword">var</span> mul: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">*</span> <span class="hljs-number">10</span> &#125;<br>   <span class="hljs-keyword">var</span> div: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">/</span> <span class="hljs-number">5</span> &#125;<br>&#125;<br><span class="hljs-keyword">let</span> addition <span class="hljs-operator">=</span> <span class="hljs-number">3</span>.add<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;加法运算后的值：<span class="hljs-subst">\(addition)</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="7-where与协议"><a href="#7-where与协议" class="headerlink" title="7.where与协议"></a>7.where与协议</h4><p>示例：数组中元素须遵循<code>TextRepresentable</code>协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Textable</span> &#123;<br>    <span class="hljs-keyword">var</span> inText: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dice</span> &#123;<br>    <span class="hljs-keyword">var</span> sides: <span class="hljs-type">Int</span><br>&#125;<br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Dice</span>: <span class="hljs-title class_">Textable</span> &#123;<br>    <span class="hljs-keyword">var</span> inText: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A <span class="hljs-subst">\(sides)</span>-sided dice&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span>: <span class="hljs-title class_">Textable</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>: <span class="hljs-title class_">Textable</span> &#123;<br>    <span class="hljs-keyword">var</span> inText: <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">let</span> itemsAsText <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.map &#123; <span class="hljs-variable">$0</span>.inText &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span> <span class="hljs-operator">+</span> itemsAsText.joined(separator: <span class="hljs-string">&quot;, &quot;</span>) <span class="hljs-operator">+</span> <span class="hljs-string">&quot;]&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> d6 <span class="hljs-operator">=</span> <span class="hljs-type">Dice</span>(sides: <span class="hljs-number">6</span>)<br><span class="hljs-keyword">let</span> d12 <span class="hljs-operator">=</span> <span class="hljs-type">Dice</span>(sides: <span class="hljs-number">12</span>)<br><span class="hljs-keyword">let</span> myDice <span class="hljs-operator">=</span> [d6, d12]<br><span class="hljs-built_in">print</span>(myDice.inText)<br></code></pre></td></tr></table></figure><h4 id="8-协议的继承"><a href="#8-协议的继承" class="headerlink" title="8.协议的继承"></a>8.协议的继承</h4><p>协议能够继承一个或多个其他协议，可以在继承的协议基础上增加新的要求。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">InheritingProtocol</span>: <span class="hljs-title class_">SomeProtocol</span>, <span class="hljs-title class_">AnotherProtocol</span> &#123;<br>    <span class="hljs-comment">// 协议定义</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-类专属协议"><a href="#9-类专属协议" class="headerlink" title="9.类专属协议"></a>9.类专属协议</h4><p>定义一个只有<code>类</code>可以实现的协议，需要在协议的继承列表中加入<code>AnyObject</code>协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeClassOnlyProtocol</span>: <span class="hljs-title class_">AnyObject</span>, <span class="hljs-title class_">SomeInheritedProtocol</span> &#123;<br>    <span class="hljs-comment">// class-only protocol definition goes here</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样枚举、结构体就不能实现此协议了。</p><h4 id="10-合成协议"><a href="#10-合成协议" class="headerlink" title="10.合成协议"></a>10.合成协议</h4><p>一个类型可以同时遵循多个协议，通过<code>协议1 &amp; 协议2 &amp; 协议3</code>的形式将多个协议合成一个。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Named</span> &#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Aged</span> &#123;<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>: <span class="hljs-title class_">Named</span>, <span class="hljs-title class_">Aged</span> &#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span><br>&#125;<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">wishHappyBirthday</span>(<span class="hljs-params">to</span> <span class="hljs-params">celebrator</span>: <span class="hljs-type">Named</span> &amp; <span class="hljs-type">Aged</span>) &#123; <span class="hljs-comment">// 合成协议</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Happy birthday, <span class="hljs-subst">\(celebrator.name)</span>, you&#x27;re <span class="hljs-subst">\(celebrator.age)</span>!&quot;</span>)<br>&#125;<br><span class="hljs-keyword">let</span> birthdayPerson <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(name: <span class="hljs-string">&quot;Malcolm&quot;</span>, age: <span class="hljs-number">21</span>)<br>wishHappyBirthday(to: birthdayPerson)<br><span class="hljs-comment">// Prints &quot;Happy birthday, Malcolm, you&#x27;re 21!&quot;</span><br></code></pre></td></tr></table></figure><h4 id="11-可选协议"><a href="#11-可选协议" class="headerlink" title="11.可选协议"></a>11.可选协议</h4><p>Swift可以像OC一样，在协议中定义一些不需要实现类必须满足的属性或方法，这些属性或方法须标记为<code>optional</code>，同时这些可选属性或方法以及协议本身，都需要标记为<code>@objc</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someFunction</span>() <span class="hljs-comment">// 必选方法</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">optional</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">someOptionalFunction</span>() <span class="hljs-comment">// 可选方法</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">optional</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">someOptionalFunctionWithParm</span>(<span class="hljs-params">p</span>:<span class="hljs-type">Int</span>) <span class="hljs-comment">// 可选带参方法</span><br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">optional</span> <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125; <span class="hljs-comment">// 可选属性</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> : <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">// 实现可选属性</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someFunction</span>() &#123;         <span class="hljs-comment">// 实现必选方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;someFunction()&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> delegate: <span class="hljs-type">SomeProtocol</span>? <span class="hljs-operator">=</span> <span class="hljs-type">SomeClass</span>()<br>delegate<span class="hljs-operator">?</span>.someFunction()<br>delegate<span class="hljs-operator">?</span>.someOptionalFunction<span class="hljs-operator">?</span>()<br>delegate<span class="hljs-operator">?</span>.someOptionalFunctionWithParm<span class="hljs-operator">?</span>(p: <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(delegate<span class="hljs-operator">?</span>.someTypeProperty <span class="hljs-operator">??</span> <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><p>与OC不同的是，Swift中每个非必须实现的协议属性或方法前，必须分别标注上<code>optional</code>；</p><p>因为<code>@objc</code>只能用于<code>Class</code>类型，所以只有<code>Class</code>才能实现这种协议，结构体和枚举都不行；</p><p>在协议中使用<code>optional</code>属性或方法时，它们的类型会自动变成可选类型。例如<code>(Int) -&gt; String</code>函数类型会变成<code>((Int) -&gt; String)?</code>可选类型。</p><h4 id="12-扩展协议"><a href="#12-扩展协议" class="headerlink" title="12.扩展协议"></a>12.扩展协议</h4><p>通过<code>extension</code>可以给协议增加方法、计算属性、下标、构造器，并且可以给方法、计算属性添加默认实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someFunction</span>()<br>    <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>&#125;<br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#123; <span class="hljs-number">1</span> &#125; &#125; <span class="hljs-comment">// 扩展已有属性，默认返回1</span><br>    <span class="hljs-keyword">var</span> someTypeProperty2: <span class="hljs-type">Int</span> &#123; <span class="hljs-number">2</span> &#125; <span class="hljs-comment">// 新增计算属性，默认返回2</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someFunction</span>()&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;default implementation&quot;</span>) <span class="hljs-comment">// 给协议方法添加默认实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span> : <span class="hljs-title class_">SomeProtocol</span> &#123;<br>    <span class="hljs-keyword">var</span> someTypeProperty: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 实现协议属性并赋值</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someFunction</span>() &#123;         <span class="hljs-comment">// 实现协议方法并重写具体实现</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;this is new imp for someFunction()&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> delegate: <span class="hljs-type">SomeProtocol</span>? <span class="hljs-operator">=</span> <span class="hljs-type">SomeClass</span>()<br>delegate<span class="hljs-operator">?</span>.someFunction()<br><span class="hljs-built_in">print</span>(delegate<span class="hljs-operator">?</span>.someTypeProperty <span class="hljs-operator">??</span> <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(delegate<span class="hljs-operator">?</span>.someTypeProperty2 <span class="hljs-operator">??</span> <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h3 id="13-相等"><a href="#13-相等" class="headerlink" title="13.相等"></a>13.相等</h3><blockquote><p>Note that identical to (represented by three equals signs, or &#x3D;&#x3D;&#x3D;) doesn’t mean the same thing as equal to (represented by two equals signs, or &#x3D;&#x3D;). Identical to means that two constants or variables of class type refer to exactly the same class instance. Equal to means that two instances are considered equal or equivalent in value, for some appropriate meaning of equal, as defined by the type’s designer.</p></blockquote><blockquote><p>When you define your own custom structures and classes, it’s your responsibility to decide what qualifies as two instances being equal. </p></blockquote><ul><li><code>===</code>表示两个实例引用了相同的对象，强调“引用”相同；</li><li><code>==</code> 表示两个实例中的值“相等”，至于哪些值相等，需要自己在类中定义；</li></ul><p>自定义类时，实现<code>Equatable</code>协议并重写全局操作符<code>==</code>来决定两个操作数是否相等。</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>:<span class="hljs-title class_">Equatable</span> &#123;<br>    <br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>?<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">==</span>(<span class="hljs-params">lhs</span>:<span class="hljs-type">Cat</span>, <span class="hljs-params">rhs</span>:<span class="hljs-type">Cat</span>) -&gt; <span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">if</span> lhs.name <span class="hljs-operator">==</span> rhs.name&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用并打印结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let cat1 = <span class="hljs-built_in">Cat</span>()<br>let cat2 = <span class="hljs-built_in">Cat</span>()<br>cat1<span class="hljs-selector-class">.name</span> = <span class="hljs-string">&quot;Miao&quot;</span><br>cat2<span class="hljs-selector-class">.name</span> = <span class="hljs-string">&quot;Miao&quot;</span><br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(cat1 == cat2)</span></span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>注意，<code>===</code>的左右两个操作数必须是类的实例，对枚举或结构体及其变种（String、Array、Dictionary）等使用时会报错。</p><h3 id="14-final、static、class"><a href="#14-final、static、class" class="headerlink" title="14.final、static、class"></a>14.final、static、class</h3><h4 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h4><p>修饰类及其元素，强调不能被继承和重写。</p><ul><li>final 只能修饰类和类中的元素，不能修饰值类型的结构体和枚举，它们本身就不能被继承；</li><li>final 修饰的方法、属性、下标不能被重写；</li><li>final 修饰整个类时此类不能被继承，其中的元素也将被标记为 final，因此不能重写；</li></ul><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">var</span> aInt: <span class="hljs-type">Int</span>&#123;<br>        <span class="hljs-keyword">get</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">callFunction</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-title class_">A</span> &#123; <span class="hljs-comment">// 报错“Inheritance from a final class &#x27;A&#x27;”</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> aInt: <span class="hljs-type">Int</span> &#123; <span class="hljs-comment">// 报错“Property overrides a &#x27;final&#x27; property”</span><br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">callFunction</span>() &#123; <span class="hljs-comment">//报错“Instance method overrides a &#x27;final&#x27; instance method”</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>final</code>修饰类的属性、方法时只是将其标记为不能重写，并不会将其变成类属性或类方法。</p><h4 id="2-static"><a href="#2-static" class="headerlink" title="2.static"></a>2.static</h4><p>修饰类中元素，强调属于类、不可重写。</p><ul><li>static 可以修饰类中的元素，但不能修饰类本身;</li><li>static 可以修饰结构体中的元素，但不能修饰结构体本身；</li><li>static 不能修饰枚举及其元素；</li><li>static 可以修饰存储属性；</li><li>static 修饰的属性为静态属性，修饰的方法为静态方法，不能重写，需通过类型名来调用；</li></ul><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> aInt: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">callFunction</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A.aInt:<span class="hljs-subst">\(aInt)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">var</span> aInt: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-comment">// 属性前不能加override 否则会报错“Property does not override any property from its superclass”</span><br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">callFunction</span>() &#123; <span class="hljs-comment">// 方法前不能加override 否则会报错“Method does not override any method from its superclass”</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B.aInt:<span class="hljs-subst">\(aInt)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-type">A</span>.aInt <span class="hljs-comment">// 1</span><br><span class="hljs-type">B</span>.aInt <span class="hljs-comment">// 1</span><br><span class="hljs-type">A</span>.callFunction() <span class="hljs-comment">// A.aInt:1</span><br><span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-type">B</span>()<br>b.aInt <span class="hljs-comment">// 2</span><br>b.callFunction()  <span class="hljs-comment">// 打印 B.aInt:2</span><br></code></pre></td></tr></table></figure><h4 id="3-class"><a href="#3-class" class="headerlink" title="3.class"></a>3.class</h4><p>修饰类中元素，强调属于类、可重写。</p><ul><li>class 只能用在类中，不能修饰结构体或枚举及它们的元素；</li><li>class 修饰的属性和方法，可以被重写；</li><li>class 不能修饰存储属性；</li><li>class 修饰的属性是类属性，修饰的方法是类方法，可以通过“类名.xx”直接调用；</li><li>class 可以修饰计算属性，不能修饰存储属性，因为存储属性属于类的实例；</li></ul><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">var</span> <span class="hljs-title class_">aInt</span>: <span class="hljs-title class_">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">callFunction</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;A&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">var</span> <span class="hljs-title class_">aInt</span>: <span class="hljs-title class_">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">func</span> <span class="hljs-title class_">callFunction</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;B&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-type">A</span>.aInt <span class="hljs-comment">// 打印：1</span><br><span class="hljs-type">B</span>.aInt <span class="hljs-comment">// 打印：2</span><br><span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-type">B</span>()<br><span class="hljs-type">B</span>.callFunction() <span class="hljs-comment">// 打印：B</span><br></code></pre></td></tr></table></figure><h3 id="15-访问控制符"><a href="#15-访问控制符" class="headerlink" title="15.访问控制符"></a>15.访问控制符</h3><p>五种访问修饰符，按从高到低排序是：open &gt; public &gt; interal &gt; fileprivate &gt; private。</p><ul><li>open：可以被任何模块的代码访问，可以被继承和重写。</li><li>public: 可以被任何模块的代码访问，模块外不可继承和重写。</li><li>internal：默认访问级别，源代码所在的整个模块都可以访问。</li><li>fileprivate：只能在当前文件中访问，当前类的扩展中也可以。</li><li>private：只能在当前类与其扩展中访问，子类中无法访问。</li></ul><h3 id="16-API可用性"><a href="#16-API可用性" class="headerlink" title="16.API可用性"></a>16.API可用性</h3><p><code>#available</code>+<code>if</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">10</span>, <span class="hljs-keyword">macOS</span> <span class="hljs-number">10.12</span>, <span class="hljs-operator">*</span>) &#123;<br>    <span class="hljs-comment">// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Fall back to earlier iOS and macOS APIs</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>#available</code>+<code>guard</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">@available</span>(<span class="hljs-keyword">macOS</span> <span class="hljs-number">10.12</span>, <span class="hljs-operator">*</span>)<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ColorPreference</span> &#123;<br>    <span class="hljs-keyword">var</span> bestColor <span class="hljs-operator">=</span> <span class="hljs-string">&quot;blue&quot;</span><br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">chooseBestColor</span>() -&gt; <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">macOS</span> <span class="hljs-number">10.12</span>, <span class="hljs-operator">*</span>) <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gray&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> colors <span class="hljs-operator">=</span> <span class="hljs-type">ColorPreference</span>()<br>    <span class="hljs-keyword">return</span> colors.bestColor<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unavailable</code>反向检查：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">10</span>, <span class="hljs-operator">*</span>) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Fallback code</span><br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">#unavailable</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">10</span>) &#123;<br>    <span class="hljs-comment">// Fallback code</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第一个 else 语句与第二个的<code>unavailable</code>是等效的。</p><h3 id="17-guard"><a href="#17-guard" class="headerlink" title="17.guard"></a>17.guard</h3><p><code>guard</code>是一种早退出机制，其布尔值须为<code>true</code>才能继续执行后续的代码。</p><p><code>guard</code>搭配<code>else</code>语句，如果<code>guard</code>条件为 false，则执行<code>else</code>内的代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">person</span>: [<span class="hljs-params">String</span>: <span class="hljs-type">String</span>]) &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> name <span class="hljs-operator">=</span> person[<span class="hljs-string">&quot;name&quot;</span>] <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello <span class="hljs-subst">\(name)</span>!&quot;</span>)<br><br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> location <span class="hljs-operator">=</span> person[<span class="hljs-string">&quot;location&quot;</span>] <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I hope the weather is nice near you.&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I hope the weather is nice in <span class="hljs-subst">\(location)</span>.&quot;</span>)<br>&#125;<br><br>greet(person: [<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>])<br><span class="hljs-comment">// Prints &quot;Hello John!&quot;</span><br><span class="hljs-comment">// Prints &quot;I hope the weather is nice near you.&quot;</span><br>greet(person: [<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-string">&quot;location&quot;</span>: <span class="hljs-string">&quot;Cupertino&quot;</span>])<br><span class="hljs-comment">// Prints &quot;Hello Jane!&quot;</span><br><span class="hljs-comment">// Prints &quot;I hope the weather is nice in Cupertino.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="18-defer"><a href="#18-defer" class="headerlink" title="18.defer"></a>18.defer</h3><p><code>defer</code>用于在离开当前代码块<code>前</code>执行一系列语句，如关闭数据库、清理对象等。</p><p>当前代码块存在多个<code>defer</code>语句时，defer语句会按照定义时的顺序从后往前执行。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">aDefer</span>() &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++第一行&quot;</span>)<br>    <span class="hljs-keyword">defer</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++defer 1&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++defer 2&quot;</span>)<br>    &#125;<br><span class="hljs-comment">//    print(&quot;++测试defer是否中断&quot;)</span><br><span class="hljs-comment">//    if true &#123;</span><br><span class="hljs-comment">//        return</span><br><span class="hljs-comment">//    &#125;</span><br>    <span class="hljs-keyword">defer</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++defer 3&quot;</span>)<br>    &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;++要结束咯&quot;</span>)<br>&#125;<br><span class="hljs-comment">//调用</span><br>aDefer()<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印结果：</span><br><span class="hljs-comment">++第一行</span><br><span class="hljs-comment">++要结束咯</span><br><span class="hljs-comment">++defer 3</span><br><span class="hljs-comment">++defer 2</span><br><span class="hljs-comment">++defer 1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>defer语句可以被return，error等打断，即执行到defer语句前如果代码已经返回，那么defer将不会被执行。可将上面例子中的注释语句打开并重新运行看看结果：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">打印日志：</span><br><span class="hljs-literal">++</span><span class="hljs-comment">第一行</span><br><span class="hljs-literal">++</span><span class="hljs-comment">测试defer是否中断</span><br><span class="hljs-literal">++</span><span class="hljs-comment">defer 2</span><br><span class="hljs-literal">++</span><span class="hljs-comment">defer 1</span><br></code></pre></td></tr></table></figure><p>即第三个defer前代码块被return，则后续defer及”print(“++要结束咯”)“均未执行。</p><h3 id="19-typealias"><a href="#19-typealias" class="headerlink" title="19.typealias"></a>19.typealias</h3><p>作用：给已有类型重新定义名称，方便代码阅读。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-comment">//eg:1.已有类型的重新命名</span><br><span class="hljs-keyword">typealias</span>  <span class="hljs-type">Address</span> <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span><br><br><span class="hljs-keyword">let</span> point: <span class="hljs-type">CGPoint</span> <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>,y: <span class="hljs-number">0</span>)<br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">let</span> point: <span class="hljs-type">Address</span> <span class="hljs-operator">=</span> <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>,y: <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>常见应用场景：定义闭包，类似oc的 block 定义。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">typealias</span> successBlock <span class="hljs-operator">=</span> (<span class="hljs-keyword">_</span> code: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> message: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Void</span><br><span class="hljs-keyword">var</span> callBack: successBlock<span class="hljs-operator">?</span><br><span class="hljs-keyword">self</span>.callBack<span class="hljs-operator">!</span>(code: <span class="hljs-number">200</span>, message: <span class="hljs-string">&quot;ok&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="20-泛型"><a href="#20-泛型" class="headerlink" title="20.泛型"></a>20.泛型</h3><p>泛型是一种类型参数，是指定并命名一个参数的类型的占位符。在定义类、结构体中的元素或函数中的参数、返回值时，对于类型暂时不确定的，只在调用时才能确定具体类型的，可以引入泛型。</p><h4 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1.语法"></a>1.语法</h4><p>以<code>&lt;T&gt;</code>形式声明泛型，尖括号中可以有多个泛型命名，以逗号隔开。</p><ul><li>用在函数参数中：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">swapTwoValues</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">a</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">T</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">b</span>: <span class="hljs-keyword">inout</span> <span class="hljs-type">T</span>) &#123;<br>    <span class="hljs-keyword">let</span> temporaryA <span class="hljs-operator">=</span> a<br>    a <span class="hljs-operator">=</span> b<br>    b <span class="hljs-operator">=</span> temporaryA<br>&#125;<br><span class="hljs-keyword">var</span> someInt <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">var</span> anotherInt <span class="hljs-operator">=</span> <span class="hljs-number">107</span><br>swapTwoValues(<span class="hljs-operator">&amp;</span>someInt, <span class="hljs-operator">&amp;</span>anotherInt)<br><span class="hljs-comment">// someInt is now 107, and anotherInt is now 3</span><br><br><br><span class="hljs-keyword">var</span> someString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-keyword">var</span> anotherString <span class="hljs-operator">=</span> <span class="hljs-string">&quot;world&quot;</span><br>swapTwoValues(<span class="hljs-operator">&amp;</span>someString, <span class="hljs-operator">&amp;</span>anotherString)<br><span class="hljs-comment">// someString is now &quot;world&quot;, and anotherString is now &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><ul><li>用在自定义的类型中：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Element</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> items: [<span class="hljs-type">Element</span>] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Element</span>) &#123;<br>        items.append(item)<br>    &#125;<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-type">Element</span> &#123;<br>        <span class="hljs-keyword">return</span> items.removeLast()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">var</span> aStack <span class="hljs-operator">=</span> <span class="hljs-type">Stack</span>&lt;<span class="hljs-type">String</span>&gt;() <span class="hljs-comment">// 指定具体类型</span><br>aStack.push(<span class="hljs-string">&quot;uno&quot;</span>)<br><span class="hljs-keyword">let</span> fromTheTop <span class="hljs-operator">=</span> aStack.pop()<br></code></pre></td></tr></table></figure><p>数组、字典也都是泛型集合，是泛型的典型应用：</p><ul><li>Array&lt;Element&gt;</li><li>Dictionary&lt;Key, Value&gt;</li></ul><p>这里的<code>Element</code>、<code>Key</code>、<code>Value</code>都用来表示某种数据类型。</p><h4 id="2-扩展泛型"><a href="#2-扩展泛型" class="headerlink" title="2.扩展泛型"></a>2.扩展泛型</h4><p>可以通过<code>extension</code>给现有泛型增加新的功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Element</span>&gt; &#123;<br>    <span class="hljs-keyword">var</span> items <span class="hljs-operator">=</span> [<span class="hljs-type">Element</span>]()<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Element</span>) &#123;<br>        items.append(item)<br>    &#125;<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-type">Element</span> &#123;<br>        <span class="hljs-keyword">return</span> items.removeLast()<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Stack</span> &#123;<br>    <span class="hljs-keyword">var</span> topItem: <span class="hljs-type">Element</span>? &#123; <span class="hljs-comment">// 新增的计算属性</span><br>       <span class="hljs-keyword">return</span> items.isEmpty <span class="hljs-operator">?</span> <span class="hljs-literal">nil</span> : items[items.count <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> aStack <span class="hljs-operator">=</span> <span class="hljs-type">Stack</span>&lt;<span class="hljs-type">String</span>&gt;()<br>aStack.push(<span class="hljs-string">&quot;google&quot;</span>)<br>aStack.push(<span class="hljs-string">&quot;runoob&quot;</span>)<br> <br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> topItem <span class="hljs-operator">=</span> aStack.topItem &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;栈顶元素：<span class="hljs-subst">\(topItem)</span>.&quot;</span>)<br>&#125;<br> <br><span class="hljs-built_in">print</span>(aStack.items)<br></code></pre></td></tr></table></figure><h4 id="3-类型约束"><a href="#3-类型约束" class="headerlink" title="3.类型约束"></a>3.类型约束</h4><p>给泛型设置约束，限制其可使用的类型，如必须继承自某个类或遵循某个协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">findIndex</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">Equatable</span>&gt;(<span class="hljs-params">of</span> <span class="hljs-params">valueToFind</span>: <span class="hljs-type">T</span>, <span class="hljs-params">in</span> <span class="hljs-params">array</span>:[<span class="hljs-type">T</span>]) -&gt; <span class="hljs-type">Int</span>? &#123;<br>    <span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> array.enumerated() &#123;<br>        <span class="hljs-keyword">if</span> value <span class="hljs-operator">==</span> valueToFind &#123;<br>            <span class="hljs-keyword">return</span> index<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">let</span> doubleIndex <span class="hljs-operator">=</span> findIndex(of: <span class="hljs-number">9.3</span>, in: [<span class="hljs-number">3.14159</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.25</span>])<br><span class="hljs-comment">// doubleIndex is an optional Int with no value, because 9.3 isn&#x27;t in the array</span><br><span class="hljs-keyword">let</span> stringIndex <span class="hljs-operator">=</span> findIndex(of: <span class="hljs-string">&quot;Andrea&quot;</span>, in: [<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-string">&quot;Malcolm&quot;</span>, <span class="hljs-string">&quot;Andrea&quot;</span>])<br><span class="hljs-comment">// stringIndex is an optional Int containing a value of 2</span><br></code></pre></td></tr></table></figure><h4 id="4-associatedtype"><a href="#4-associatedtype" class="headerlink" title="4.associatedtype"></a>4.associatedtype</h4><ul><li>语法</li></ul><p>协议中不支持<code>&lt;T&gt;</code>这种方式定义泛型，使用<code>associatedtype</code>关键字定义某种泛型，在协议的实现类中才指明此泛型具体是何类型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Item</span>  <span class="hljs-comment">//这个Item就是泛型，可现在协议中用着</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">append</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Item</span>)<br>    <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Item</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IntStack</span>: <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-comment">// IntStack 类的自有部分</span><br>    <span class="hljs-keyword">var</span> items: [<span class="hljs-type">Int</span>] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Int</span>) &#123;<br>        items.append(item)<br>    &#125;<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> items.removeLast()<br>    &#125;<br>    <span class="hljs-comment">// 实现 Container 协议的部分</span><br>    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Item</span> <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>  <span class="hljs-comment">//这里指明Item是Int类型</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">append</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">self</span>.push(item)<br>    &#125;<br>    <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> items.count<br>    &#125;<br>    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> items[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>约束关联类型</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Item</span>: <span class="hljs-type">Equatable</span>    <span class="hljs-comment">// 这里约束泛型须遵循Equatable协议</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">append</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Item</span>)<br>    <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Item</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-where语句"><a href="#5-where语句" class="headerlink" title="5.where语句"></a>5.where语句</h4><ul><li>泛型类型定义中的<code>where</code>：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Element</span>&gt; <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>:<span class="hljs-title class_">Equatable</span> &#123;&#125;<br></code></pre></td></tr></table></figure><ul><li>extension中的<code>where</code>：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Stack</span> <span class="hljs-title class_">where</span> <span class="hljs-title class_">Element</span>:<span class="hljs-title class_">Equatable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">isItemInStack</span>(<span class="hljs-params">item</span>:<span class="hljs-type">Element</span>)-&gt;<span class="hljs-type">Bool</span> &#123;<br>        <span class="hljs-keyword">for</span> stackItem <span class="hljs-keyword">in</span> items &#123;<br>            <span class="hljs-keyword">if</span> stackItem <span class="hljs-operator">==</span> item &#123; <span class="hljs-comment">//比较大小须遵守Equatable协议</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>参数列表中的<code>where</code>：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">ItemType</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">append</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">ItemType</span>)<br>    <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">ItemType</span> &#123; <span class="hljs-keyword">get</span> &#125;<br>&#125;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span>&lt;<span class="hljs-title class_">Element</span>&gt;: <span class="hljs-title class_">Container</span> &#123;<br>    <span class="hljs-comment">// Stack&lt;Element&gt; 的原始实现部分</span><br>    <span class="hljs-keyword">var</span> items <span class="hljs-operator">=</span> [<span class="hljs-type">Element</span>]()<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">push</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Element</span>) &#123;<br>        items.append(item)<br>    &#125;<br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pop</span>() -&gt; <span class="hljs-type">Element</span> &#123;<br>        <span class="hljs-keyword">return</span> items.removeLast()<br>    &#125;<br>    <span class="hljs-comment">// Container 协议的实现部分</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">append</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">item</span>: <span class="hljs-type">Element</span>) &#123;<br>        <span class="hljs-keyword">self</span>.push(item)<br>    &#125;<br>    <span class="hljs-keyword">var</span> count: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> items.count<br>    &#125;<br>    <span class="hljs-keyword">subscript</span>(<span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Element</span> &#123;<br>        <span class="hljs-keyword">return</span> items[i]<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Array</span>: <span class="hljs-title class_">Container</span> &#123;&#125;<br> <br><span class="hljs-keyword">func</span> <span class="hljs-title function_">allItemsMatch</span>&lt;<span class="hljs-type">C1</span>: <span class="hljs-type">Container</span>, <span class="hljs-type">C2</span>: <span class="hljs-type">Container</span>&gt;<br>    (<span class="hljs-keyword">_</span> <span class="hljs-params">someContainer</span>: <span class="hljs-type">C1</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">anotherContainer</span>: <span class="hljs-type">C2</span>) -&gt; <span class="hljs-type">Bool</span><br>    <span class="hljs-keyword">where</span> <span class="hljs-type">C1</span>.<span class="hljs-type">ItemType</span> <span class="hljs-operator">==</span> <span class="hljs-type">C2</span>.<span class="hljs-type">ItemType</span>, <span class="hljs-type">C1</span>.<span class="hljs-type">ItemType</span>: <span class="hljs-type">Equatable</span> &#123;<br>        <span class="hljs-keyword">if</span> someContainer.count <span class="hljs-operator">!=</span> anotherContainer.count &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>someContainer.count &#123;<br>            <span class="hljs-keyword">if</span> someContainer[i] <span class="hljs-operator">!=</span> anotherContainer[i] &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">var</span> tos <span class="hljs-operator">=</span> <span class="hljs-type">Stack</span>&lt;<span class="hljs-type">String</span>&gt;()<br>tos.push(<span class="hljs-string">&quot;google&quot;</span>)<br>tos.push(<span class="hljs-string">&quot;baidu&quot;</span>)<br>tos.push(<span class="hljs-string">&quot;microsoft&quot;</span>)<br> <br><span class="hljs-keyword">var</span> aos <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;google&quot;</span>, <span class="hljs-string">&quot;baidu&quot;</span>, <span class="hljs-string">&quot;microsoft&quot;</span>]<br> <br><span class="hljs-keyword">if</span> allItemsMatch(tos, aos) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;匹配所有元素&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;元素不匹配&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="21-some"><a href="#21-some" class="headerlink" title="21.some"></a>21.some</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>在标注属性、下标、函数返回值的类型时，对内保存返回值的类型信息，对外隐藏类型信息。</p><p>示例1：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>()<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iPhone</span>: <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;run on iPhone&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iPad</span>: <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;run on iPad&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">func</span> <span class="hljs-title function_">whoCalls</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">IOS</span> &#123; <span class="hljs-comment">// 这里 some 关键字标注的就是不透明类型</span><br>    <span class="hljs-keyword">return</span> iPad()<br>&#125;<br></code></pre></td></tr></table></figure><p>不透明类型，以<code>some+协议</code>配合使用，通常用作函数的返回值类型：当函数返回不透明类型时，其返回值类型不使用具体的类型，而是用它支持的协议来描述。</p><p>上面的示例中，<code>whoCalls()</code>返回的就是不透明类型<code>some IOS</code>。调用者并不关心函数返回值的真实类型是啥，也不关心函数内部的具体实现，只需知道返回值是个遵循<code>IOS</code>协议的类型。</p><h4 id="2-对比泛型"><a href="#2-对比泛型" class="headerlink" title="2.对比泛型"></a>2.对比泛型</h4><p>作为函数返回值类型时：</p><p><code>泛型</code>：让函数的调用者来选择一种返回值的具体类型；</p><p><code>不透明类型</code>：让函数体来选择一种返回值的具体类型；</p><p>示例2：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">max</span>&lt;<span class="hljs-type">T</span>&gt;(<span class="hljs-keyword">_</span> <span class="hljs-params">x</span>: <span class="hljs-type">T</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">y</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">T</span> <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">Comparable</span> &#123; <span class="hljs-operator">...</span> &#125;<br></code></pre></td></tr></table></figure><p>这个泛型场景中，<code>max()</code>函数的返回值类型是根据调用者传进来的类型而定的。调用者传入<code>x</code>，<code>y</code>的值，它们的类型决定了<code>T</code>的具体类型，函数内部仅仅使用了<code>Comparable</code>协议定义的通用功能。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">func</span> <span class="hljs-title function_">whoCalls</span>() -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">IOS</span> &#123;<br>    <span class="hljs-keyword">return</span> iPad()<br>&#125;<br></code></pre></td></tr></table></figure><p>示例1中，函数体内通过<code>return iPad()</code>指定了返回值的具体类型是<code>iPad</code>，而且通过<code>some IOS</code>不透明类型，对外隐藏了返回值的具体类型，调用者只知道该返回值遵循了<code>IOS</code>协议。</p><p>所以，作为函数返回值时，不透明类型与泛型的作用正好相反~</p><h4 id="3-对比协议"><a href="#3-对比协议" class="headerlink" title="3.对比协议"></a>3.对比协议</h4><p>作为函数返回值类型时：</p><p><code>协议</code>：可以是所有遵循了此协议的对象；</p><p><code>不透明类型</code>：只能是某一种遵循了此协议的对象；</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>()<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iPhone</span>: <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;run on iPhone&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">iPad</span>: <span class="hljs-title class_">IOS</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">run</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;run on iPad&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Device</span> &#123;<br>    <span class="hljs-keyword">case</span> iPhone<br>    <span class="hljs-keyword">case</span> iPad<br>&#125;<br><span class="hljs-comment">//报错：Function declares an opaque return type, but the return statements in its body do</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">opaqueCalls</span>(<span class="hljs-params">type</span> <span class="hljs-params">device</span>: <span class="hljs-type">Device</span>) -&gt; <span class="hljs-keyword">some</span> <span class="hljs-type">IOS</span> &#123;<br>    <span class="hljs-keyword">if</span> device <span class="hljs-operator">==</span> .iPhone &#123; <span class="hljs-comment">// if else 分支返回的类型不同 会导致报错</span><br>        <span class="hljs-keyword">return</span> iPhone()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> iPad()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用协议</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">protoCalls</span>(<span class="hljs-params">type</span> <span class="hljs-params">device</span>: <span class="hljs-type">Device</span>) -&gt; <span class="hljs-type">IOS</span> &#123;<br>    <span class="hljs-keyword">if</span> device <span class="hljs-operator">==</span> .iPhone &#123;<br>        <span class="hljs-keyword">return</span> iPhone()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> iPad()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 使用泛型</span><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">geneticCalls</span>&lt;<span class="hljs-type">T</span>: <span class="hljs-type">IOS</span>&gt;(<span class="hljs-params">type</span> <span class="hljs-params">device</span>: <span class="hljs-type">T</span>) -&gt; <span class="hljs-type">T</span> &#123;<br>    <span class="hljs-keyword">return</span> device<br>&#125;<br><br><span class="hljs-comment">// 协议类型返回值</span><br><span class="hljs-keyword">let</span> iphone1 <span class="hljs-operator">=</span> protoCalls(type: .iPhone)<br><span class="hljs-keyword">let</span> iphone2 <span class="hljs-operator">=</span> protoCalls(type: .iPhone)<br>iphone1 <span class="hljs-operator">==</span> iphone2 <span class="hljs-comment">// 报错</span><br><span class="hljs-comment">// 泛型返回值</span><br><span class="hljs-keyword">let</span> ipad1 <span class="hljs-operator">=</span> geneticCalls(type: iPad())<br><span class="hljs-keyword">let</span> ipad2 <span class="hljs-operator">=</span> geneticCalls(type: iPad())<br>ipad1 <span class="hljs-operator">==</span> ipad2     <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p><code>some</code>返回值的函数<code>opaqueCalls</code>中，使用类似<code>if</code>这样的分支语句返回多种不同类型时会报错。</p><p>协议类型返回值的函数<code>protoCalls</code>中，可以返回不同类型的对象，只要遵循<code>IOS</code>协议即可。</p><p>所以，不透明类型实际是对内保存了明确类型信息的，比协议的要求更为严格~</p><p>另外，对于泛型或协议类型的返回值，不能使用<code>==</code>比较类型。一是因为<code>IOS</code>协议中并未定义<code>==</code>操作符；二是<code>==</code>左右两边的返回值的类型不确定！</p><h4 id="4-any"><a href="#4-any" class="headerlink" title="4.any"></a>4.any</h4><p>boxed protocol type，用于定义一个类型，该类型须遵循指定的协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs SWIFT"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() -&gt; <span class="hljs-type">String</span><br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">VerticalShapes</span>: <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">var</span> shapes: [<span class="hljs-keyword">any</span> <span class="hljs-type">Shape</span>] <span class="hljs-comment">// 看这里</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() -&gt; <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> shapes.map &#123; <span class="hljs-variable">$0</span>.draw() &#125;.joined(separator: <span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Triangle</span>: <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() -&gt; <span class="hljs-type">String</span> &#123;<br>       <span class="hljs-keyword">var</span> result: [<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> []<br>       <span class="hljs-keyword">for</span> length <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">...</span>size &#123;<br>           result.append(<span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;*&quot;</span>, count: length))<br>       &#125;<br>       <span class="hljs-keyword">return</span> result.joined(separator: <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Square</span>: <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() -&gt; <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">let</span> line <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;*&quot;</span>, count: size)<br>        <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;(repeating: line, count: size)<br>        <span class="hljs-keyword">return</span> result.joined(separator: <span class="hljs-string">&quot;<span class="hljs-subst">\n</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> largeTriangle <span class="hljs-operator">=</span> <span class="hljs-type">Triangle</span>(size: <span class="hljs-number">5</span>)<br><span class="hljs-keyword">let</span> largeSquare <span class="hljs-operator">=</span> <span class="hljs-type">Square</span>(size: <span class="hljs-number">5</span>)<br><span class="hljs-keyword">let</span> vertical <span class="hljs-operator">=</span> <span class="hljs-type">VerticalShapes</span>(shapes: [largeTriangle, largeSquare])<br><span class="hljs-built_in">print</span>(vertical.draw())<br></code></pre></td></tr></table></figure><p>数组<code>shapes</code>中的元素可以是不同类型，但都必须遵循<code>Shape</code>协议。</p><p><code>some</code>与<code>any</code>的区别在于是否保存明确的类型信息。</p><ul><li><code>some</code>必须指定某一个具体类型；</li><li><code>any</code>可以是任何类型，只要遵循某个协议即可；</li></ul><hr><p>相关参考：</p><p>#<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/UsingSwiftwithCocoaandObjective-C%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C.md">©Swift翻译组</a></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存分配</title>
    <link href="/2018/07/30/memory.html"/>
    <url>/2018/07/30/memory.html</url>
    
    <content type="html"><![CDATA[<h3 id="分区及职责"><a href="#分区及职责" class="headerlink" title="分区及职责"></a>分区及职责</h3><ol><li><p>栈区(stack)：存放局部变量和方法实参。</p></li><li><p>堆区(heap)：存放OC中使用new等方法创建的对象。</p></li><li><p>全局（静态）区：包括以下两个分区：</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">1</span>. 数据段（Data segment）：初始化的全局变量和静态变量。<br><span class="hljs-attribute">3</span>.<span class="hljs-number">2</span>. BSS段：未初始化的全局变量和静态变量。<br></code></pre></td></tr></table></figure><ol start="4"><li><p>常量区(数据段)：const、@”x”常量字符串</p></li><li><p>代码段(Text segment)：程序的代码（ELF）。</p></li></ol><h3 id="分配-amp-释放？"><a href="#分配-amp-释放？" class="headerlink" title="分配&amp;释放？"></a>分配&amp;释放？</h3><ul><li>栈区：由编译器自动分配和释放。</li><li>堆区：由程序员申请和释放，不释放会泄漏。</li><li>BSS段\数据段\常量区\代码段：程序结束后由系统释放。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">int</span> age = <span class="hljs-number">24</span>;  <span class="hljs-comment">//全局初始化区（数据段）</span><br><span class="hljs-built_in">NSString</span> *name;<span class="hljs-comment">//全局未初始化区（BSS段）</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *sName = <span class="hljs-string">@&quot;Dav&quot;</span>;<span class="hljs-comment">//全局（静态初始化）区</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>-(<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>willFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-type">int</span> aInt;<span class="hljs-comment">//栈</span><br>    <span class="hljs-built_in">NSString</span> *aName = <span class="hljs-string">@&quot;Dav&quot;</span>; <span class="hljs-comment">//Dav在常量区，对象aName的指针存储在栈区。</span><br>    <span class="hljs-comment">//对象aArr的指针在栈区，分配而来的8字节的区域在堆区，aArr的指针指向堆区的地址。</span><br>    <span class="hljs-built_in">NSMutableArray</span> *aArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithCapacity:<span class="hljs-number">1</span>]; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSInteger</span>)mathAddParam1:(<span class="hljs-built_in">NSInteger</span>)num1 Param2:(<span class="hljs-built_in">NSInteger</span>)num2<br>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2; <span class="hljs-comment">//num1和num2 在栈区</span><br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存错误</title>
    <link href="/2018/07/25/memory-error.html"/>
    <url>/2018/07/25/memory-error.html</url>
    
    <content type="html"><![CDATA[<h3 id="1、内存错误是啥"><a href="#1、内存错误是啥" class="headerlink" title="1、内存错误是啥"></a>1、内存错误是啥</h3><p>在C和OC中，你一直在处理指针。指针是存储另一个变量的内存地址的变量。当向一个对象发送消息时，指向该对象的指针将会被引用。这意味着，你获取了指针所指的内存地址，并访问该存储区域的值。</p><p>当该存储器区域不再映射到你的应用时，或者换句话说，该内存区域在你认为使用的时候却没有使用，该内存区域是无法访问的。 这时内核会抛出一个异常（ EXC ），表明你的应用程序不能访问该存储器区域（BAD ACCESS） 。</p><p>总之，当你碰到 EXC_BAD_ACCESS ，这意味着你试图发送消息到的内存块，但内存块无法执行该消息。但是，在某些情况下， EXC_BAD_ACCESS 是由被损坏的指针引起的。每当你的应用程序尝试引用损坏的指针，一个异常就会被内核抛出。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs smali">static NSMutableArray *array;<br> <br>- (void)viewDidLoad<br>&#123;<br>    [super viewDid<span class="hljs-class">Load];</span><br>   <span class="hljs-built_in"> array </span>= [[NSMutableArray alloc] initWithCapacity:5];<br>    [array release];<br>&#125;<br> <br>- (void) viewWillAppear:(BOOL)animated <br>&#123;<br>    [array addObject:@<span class="hljs-string">&quot;Hello&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码就会出现 EXC_BAD_ACCESS 错误，错误日志为：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">-[CALayerArray addObject:]: unrecognized selector sent to<span class="hljs-built_in"> instance </span>0x604000443480<br></code></pre></td></tr></table></figure><p>其中 0x604000443480 就是 array 变量的地址。</p><p><strong>ps：</strong> Xcode7.0 之后的版本在编译上面的代码时，会在“[array release];”处报错：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">release <span class="hljs-keyword">is</span> unavailable <span class="hljs-keyword">in</span> <span class="hljs-built_in">auto</span>matic <span class="hljs-built_in">ref</span>erence counting mode<br></code></pre></td></tr></table></figure><p>所以，为了模拟上面的 EXC_BAD_ACCESS 错误，需要对编译环境进行设置：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">B<span class="hljs-function"><span class="hljs-title">uild</span> Settings -&gt;</span> O<span class="hljs-function"><span class="hljs-title">bjective</span>-C Automatic Reference Counting -&gt;</span> NO。<br></code></pre></td></tr></table></figure><hr><h3 id="2、咋调试？（Zombie-模式）"><a href="#2、咋调试？（Zombie-模式）" class="headerlink" title="2、咋调试？（Zombie 模式）"></a>2、咋调试？（Zombie 模式）</h3><p>EXC_BAD_ACCESS 难以调试的原因是，你不知道你的应用程序试图访问哪个对象时出了问题。在 Xcode 中，启用僵尸对象意味着被释放的对象将会以僵尸的形式被保留。如果向僵尸对象发送消息，应用程序将会由于 EXC_BAD_ACCESS 而崩溃，此时 Xcode 就可以告诉你你试图访问的是哪个僵尸对象。</p><p>下面是在 Xcode9.2 中开启僵尸调试模式的步骤：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">左上角E<span class="hljs-function"><span class="hljs-title">dit</span> Scheme -&gt;</span> R<span class="hljs-function"><span class="hljs-title">un</span> -&gt;</span> D<span class="hljs-function"><span class="hljs-title">iagnostics</span> -&gt;</span> 勾选Zombie Objects<br></code></pre></td></tr></table></figure><p>设置完之后还是上面的代码，再次运行之后，会打印如下报错信息：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)<br>*** -[__NSArrayM addObject:]: message sent to deallocated<span class="hljs-built_in"> instance </span>0x60400045d1c0<br></code></pre></td></tr></table></figure><p>找到问题后记得还原 scheme中的 Zombie 设置。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常捕获</title>
    <link href="/2018/07/20/crash.html"/>
    <url>/2018/07/20/crash.html</url>
    
    <content type="html"><![CDATA[<h3 id="线上APP获取崩溃信息的方式："><a href="#线上APP获取崩溃信息的方式：" class="headerlink" title="线上APP获取崩溃信息的方式："></a>线上APP获取崩溃信息的方式：</h3><ul><li>使用系统 API 收集崩溃信息并上传到服务器。</li><li>使用友盟、Bugly 等第三方收集分析SDK。</li><li>使用 iTunes Connect 上的崩溃收集服务。</li></ul><p>这里暂时只讲第一种。iOS提供了异常发生时的处理API，在程序启动的时候可以添加这样的Handler，这样程序发生异常的时候就可以对异常进行必要的处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">void</span> <span class="hljs-built_in">NSSetUncaughtExceptionHandler</span>(<span class="hljs-built_in">NSUncaughtExceptionHandler</span> * _Nullable);<br></code></pre></td></tr></table></figure><p>下面的类就利用了系统提供的API来捕获出现的崩溃，并将异常信息存储到固定目录下的文件中，</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//.h文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ExceptionHandler</span> : <span class="hljs-title">NSObject</span></span><br><br>+ (<span class="hljs-type">void</span>)setDefaultHandler;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//.m文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ExceptionHandler.h&quot;</span></span><br><br><span class="hljs-keyword">volatile</span> int32_t UncaughtExceptionCount = <span class="hljs-number">0</span>;   <span class="hljs-comment">//当前处理的异常个数</span><br><span class="hljs-keyword">volatile</span> int32_t UncaughtExceptionMaximum = <span class="hljs-number">10</span>;<span class="hljs-comment">//最大能够处理的异常个数</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -文件目录</span><br><span class="hljs-built_in">NSString</span> *exceptionFilePath()<br>&#123;<br><span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSDocumentDirectory</span>,<span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) lastObject];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -收到异常通知时的回调函数</span><br><span class="hljs-type">void</span> UncaughtExceptionHandler(<span class="hljs-built_in">NSException</span> *exception)<br>&#123;<br><span class="hljs-built_in">NSArray</span> *arr = [exception callStackSymbols];<br><span class="hljs-built_in">NSString</span> *reason = [exception reason];<br><span class="hljs-built_in">NSString</span> *name = [exception name];<br><br><span class="hljs-built_in">NSString</span> *info = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;+异常崩溃报告+\nname:\n%@\nreason:\n%@\ncallStackSymbols:\n%@&quot;</span>,name,reason,[arr componentsJoinedByString:<span class="hljs-string">@&quot;\n&quot;</span>]];<br><br><span class="hljs-built_in">NSString</span> *path = [exceptionFilePath() stringByAppendingPathComponent:<span class="hljs-string">@&quot;Exception.txt&quot;</span>];<br><br>[info writeToFile:path atomically:<span class="hljs-literal">YES</span> encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span> error:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ExceptionHandler</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -开始监听异常</span><br>+ (<span class="hljs-type">void</span>)setDefaultHandler<br>&#123;<br><span class="hljs-built_in">NSSetUncaughtExceptionHandler</span> (&amp;UncaughtExceptionHandler);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>[ExceptionHandler setDefaultHandler];<br><span class="hljs-built_in">NSArray</span> *anArr = @[@(<span class="hljs-number">0</span>)];<br>anArr[<span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>崩溃后得到日志信息如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">+异常崩溃报告+<br><span class="hljs-symbol">name:</span><br>NSRangeException<br><span class="hljs-symbol">reason:</span><br>*** -[__NSSingleObjectArrayI objectAtIndex:]: index <span class="hljs-number">5</span> beyond bounds [<span class="hljs-number">0</span> .. <span class="hljs-number">0</span>]<br><span class="hljs-symbol">callStackSymbols:</span><br><span class="hljs-number">0</span>   CoreFoundation      <span class="hljs-number">0x00000001070dd1ab</span> __exceptionPreprocess + <span class="hljs-number">171</span><br><span class="hljs-number">1</span>   libobjc<span class="hljs-number">.</span>A<span class="hljs-number">.</span>dylib     <span class="hljs-number">0x0000000106772f41</span> objc_exception_throw + <span class="hljs-number">48</span><br><span class="hljs-number">2</span>   CoreFoundation      <span class="hljs-number">0x000000010711d2df</span> -[__NSSingleObjectArrayI objectAtIndex:] + <span class="hljs-number">111</span><br><span class="hljs-number">3</span>   ASDF                <span class="hljs-number">0x0000000105e5a8b2</span> -[AppDelegate application:didFinishLaunchingWithOptions:] + <span class="hljs-number">242</span><br>...<br><span class="hljs-number">28</span>  CoreFoundation      <span class="hljs-number">0x0000000107064b49</span> __CFRunLoopDoSources0 + <span class="hljs-number">185</span><br><span class="hljs-number">29</span>  CoreFoundation      <span class="hljs-number">0x000000010706412f</span> __CFRunLoopRun + <span class="hljs-number">1279</span><br><span class="hljs-number">30</span>  CoreFoundation      <span class="hljs-number">0x00000001070639b9</span> CFRunLoopRunSpecific + <span class="hljs-number">409</span><br><span class="hljs-number">31</span>  GraphicsServices    <span class="hljs-number">0x000000010c0ad9c6</span> GSEventRunModal + <span class="hljs-number">62</span><br><span class="hljs-number">32</span>  UIKit               <span class="hljs-number">0x00000001075585e8</span> UIApplicationMain + <span class="hljs-number">159</span><br><span class="hljs-number">33</span>  ASDF                <span class="hljs-number">0x0000000105e5bf4f</span> main + <span class="hljs-number">111</span><br><span class="hljs-number">34</span>  libdyld<span class="hljs-number">.</span>dylib       <span class="hljs-number">0x000000010aa71d81</span> start + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>但是，并不是所有的程序崩溃都是由于发生可以捕捉的异常的，有些时候引起崩溃的原因可能是：内存访问错误、重复释放等。上面的API对这些错误就无能为力了，因为这种错误它抛出的是Signal，所以必须要专门做Signal处理。</p><p>此时，可以使用下面的函数来注册signal异常时的回调函数：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">signal</span><span class="hljs-string"></span>(SIGABRT, signalExceptionHandler);<br></code></pre></td></tr></table></figure><p>这样，当应用发生错误而产生上述signal后，就会进入我们自定义的回调函数signalExceptionHandler中。为了得到崩溃时的现场信息，还可以加入一些获取CallTrace的方法，完整代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ExceptionHandler</span> : <span class="hljs-title">NSObject</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance;<br>+ (<span class="hljs-built_in">NSArray</span> *)backtrace;<br>+ (<span class="hljs-type">void</span>)installExceptionHandler;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;ExceptionHandler.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libkern/OSAtomic.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execinfo.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/signal.h&gt;</span></span><br><br><span class="hljs-comment">//当前处理的异常个数</span><br><span class="hljs-keyword">volatile</span> int32_t UncaughtExceptionCount = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//最大能够处理的异常个数</span><br><span class="hljs-keyword">volatile</span> int32_t UncaughtExceptionMaximum = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">NSInteger</span> ExceptionHandlerSkipAddressCount = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">NSInteger</span> ExceptionHandlerReportAddressCount = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">static</span> ExceptionHandler *mExceptionHandler =  <span class="hljs-literal">nil</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -捕获信号后的回调函数</span><br><span class="hljs-type">void</span> signalExceptionHandler(<span class="hljs-type">int</span> signo)<br>&#123;<br>int32_t exceptionCount = OSAtomicIncrement32(&amp;UncaughtExceptionCount);<br><span class="hljs-keyword">if</span> (exceptionCount &gt; UncaughtExceptionMaximum)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">NSArray</span> *callStack = [ExceptionHandler backtrace];<br><br><span class="hljs-built_in">NSMutableDictionary</span> *userInfo = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithObject:<br>[<span class="hljs-built_in">NSNumber</span> numberWithInt:signo] forKey:<span class="hljs-string">@&quot;signal&quot;</span>];<br>[userInfo setValue:callStack forKey:<span class="hljs-string">@&quot;callStack&quot;</span>];<br><br><span class="hljs-comment">//创建一个OC异常对象</span><br><span class="hljs-built_in">NSException</span> *ex = [<span class="hljs-built_in">NSException</span> exceptionWithName:<span class="hljs-string">@&quot;Name&quot;</span> reason:<span class="hljs-literal">nil</span> userInfo:userInfo];<br><br><span class="hljs-comment">//处理异常消息</span><br>[[ExceptionHandler shareInstance] performSelectorOnMainThread:<span class="hljs-keyword">@selector</span>(onHandleSignalException:) withObject:ex waitUntilDone:<span class="hljs-literal">YES</span>];<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ExceptionHandler</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance<br>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br><span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br><span class="hljs-keyword">if</span> (mExceptionHandler == <span class="hljs-literal">nil</span>) &#123;<br>mExceptionHandler  =  [[ExceptionHandler alloc] init];<br>&#125;<br>&#125;);<br><span class="hljs-keyword">return</span> mExceptionHandler;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -注册异常处理回调</span><br>+ (<span class="hljs-type">void</span>)installExceptionHandler<br>&#123;<br><span class="hljs-comment">//注册程序由于abort()函数调用发生的程序中止信号</span><br>signal(SIGABRT, signalExceptionHandler);<br><br><span class="hljs-comment">//注册程序由于非法指令产生的程序中止信号</span><br>signal(SIGILL, signalExceptionHandler);<br><br><span class="hljs-comment">//注册程序由于无效内存的引用导致的程序中止信号</span><br>signal(SIGSEGV, signalExceptionHandler);<br><br><span class="hljs-comment">//注册程序由于浮点数异常导致的程序中止信号</span><br>signal(SIGFPE, signalExceptionHandler);<br><br><span class="hljs-comment">//注册程序由于内存地址未对齐导致的程序中止信号</span><br>signal(SIGBUS, signalExceptionHandler);<br><br><span class="hljs-comment">//程序通过端口发送消息失败导致的程序中止信号</span><br>signal(SIGPIPE, signalExceptionHandler);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -处理异常用到的方法</span><br>- (<span class="hljs-type">void</span>)onHandleSignalException:(<span class="hljs-built_in">NSException</span> *)exception<br>&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++出现崩溃:\n%@&quot;</span>,exception.userInfo);<br><br><span class="hljs-built_in">NSSetUncaughtExceptionHandler</span>(<span class="hljs-literal">NULL</span>);<br><br>signal(SIGABRT, SIG_DFL);<br>signal(SIGILL, SIG_DFL);<br>signal(SIGSEGV, SIG_DFL);<br>signal(SIGFPE, SIG_DFL);<br>signal(SIGBUS, SIG_DFL);<br>signal(SIGPIPE, SIG_DFL);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -获取调用堆栈</span><br>+ (<span class="hljs-built_in">NSArray</span> *)backtrace<br>&#123;<br><span class="hljs-type">void</span>* callstack[<span class="hljs-number">128</span>];<br><br><span class="hljs-comment">//该函数用于获取当前线程的调用堆栈</span><br><span class="hljs-type">int</span> frames = backtrace(callstack, <span class="hljs-number">128</span>);<br><br><span class="hljs-comment">//将从backtrace函数获取的信息转化为一个字符串数组</span><br><span class="hljs-type">char</span> **strs = backtrace_symbols(callstack, frames);<br><br><span class="hljs-type">int</span> i;<br><br><span class="hljs-built_in">NSMutableArray</span> *backtrace = [<span class="hljs-built_in">NSMutableArray</span> arrayWithCapacity:frames];<br><br><span class="hljs-keyword">for</span> (i = ExceptionHandlerSkipAddressCount;<br>i &lt; ExceptionHandlerSkipAddressCount + ExceptionHandlerReportAddressCount; i++)<br>&#123;<br>[backtrace addObject:[<span class="hljs-built_in">NSString</span> stringWithUTF8String:strs[i]]];<br>&#125;<br>free(strs);<br><span class="hljs-keyword">return</span> backtrace;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>[ExceptionHandler installExceptionHandler];<br><span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，基本上所有崩溃都能捕获了。</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设备唯一标识符</title>
    <link href="/2018/07/15/idfa.html"/>
    <url>/2018/07/15/idfa.html</url>
    
    <content type="html"><![CDATA[<h4 id="1、UDID"><a href="#1、UDID" class="headerlink" title="1、UDID"></a>1、UDID</h4><p>UDID（Unique Device Identifier），iOS 设备的唯一识别码，是一个40位十六进制序列。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[UIDevice cuurrent]</span> uniqueIdenfier]</span>;<br></code></pre></td></tr></table></figure><p>移动广告商等往往需要通过UDID用来识别玩家用户，并对用户活动进行跟踪。这会泄露用户的隐私信息，所以iOS5.0之后，苹果已被废除此方法，并且禁止使用UDID信息的APP上架。</p><h4 id="2、UUID"><a href="#2、UUID" class="headerlink" title="2、UUID"></a>2、UUID</h4><p>UUID（Universally Unique Identifier），通用唯一标识符，是一个32位的十六进制序列。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%@&quot;</span>,[<span class="hljs-built_in">NSUUID</span> UUID]);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">++CA34E048-C879<span class="hljs-string">-4</span>BCA<span class="hljs-string">-8105</span><span class="hljs-string">-8</span>E6F3DA137C4<br>+<span class="hljs-string">+4</span>C808BD6-C7EE<span class="hljs-string">-4</span>E35-BEB5-B319F37BEA30<br>++C9B7AA3E<span class="hljs-string">-71</span>AD<span class="hljs-string">-462</span>B-BAC1<span class="hljs-string">-36</span>B9433B987F<br>++A8847816<span class="hljs-string">-7194</span><span class="hljs-string">-4</span>ECF<span class="hljs-string">-8</span>FA4<span class="hljs-string">-75</span>C566D68B21<br>+<span class="hljs-string">+6</span>C9FCC03-BCF7<span class="hljs-string">-4</span>B68<span class="hljs-string">-9</span>A98<span class="hljs-string">-8209</span>BF83690E<br></code></pre></td></tr></table></figure><p>循环5次，每次取到的值都不一样。所以当用户重新启动了应用或者删除应用重装后，UUID都会被重置。因此你需要在应用第一次启动时就将其UUID保存到钥匙串中，之后从钥匙串中取值。<br><br/></p><p>因为每次使用系统方法获取到的UUID都是不一样的，所以每个应用都会产生与之对应的UUID。像淘宝和支付宝账号互通的这种系列应用，如果从淘宝切到支付宝，因为UUID不一样了就提示换了设备，显然不符合实际情况。</p><h4 id="3、IDFV"><a href="#3、IDFV" class="headerlink" title="3、IDFV"></a>3、IDFV</h4><p>iOS6.0之后，苹果提供的新方法。它是通过 bundleID 的反转的前两部分进行匹配，如果内容相同则认为是同一个Vendor（供应商），例如对于<code>com.example.app1</code>和<code>com.example.app2</code>这两个 bundleID，它们就属于同一个 Vendor，共享同一个<code>IDFV</code>。这样就解决了上面提到的账号互通类应用切换登录时的问题。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">UIDevice *device <span class="hljs-operator">=</span> [UIDevice currentDevice]<span class="hljs-comment">;</span><br>NSUUID * uuid <span class="hljs-operator">=</span> [device identifierForVendor]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>vendor</strong>（运营商）的值是根据已经上架到 Appstore 的 App 来决定的。如果应用不是通过 Appstore 安装的（如企业版或开发调试阶段），那么会根据<code>bundle ID</code>判断。<br><br/></p><p>iOS6.x中，会取 bundleID 的前两个部分生成 <code>vendor ID</code>（##com.example##.app.app1）。<br><br/></p><p>iOS7.x之后，除了最后一部分外，其他部分的 bundleID 都会用来生成<code>vendor ID</code>（##com.example.app##.app1）。<br><br/></p><p>需要注意的是，用户删除了某 APP 重装后，APP 里再获取 <code>IDFV</code> 时，值和之前的就不同了。</p><h4 id="4、IDFA"><a href="#4、IDFA" class="headerlink" title="4、IDFA"></a>4、IDFA</h4><p>IDFA - identifierForIdentifier（广告标示符），每个设备只有一个IDFA，在同一个设备上的所有 APP 都会取到相同的值，是iOS6 苹果专门给各广告提供商用来追踪用户而设定的。虽然 iPhone 默认是允许追踪的，而且一般用户都不知道有这么个设置，但是用户可以在 设置 - 隐私 - 广告追踪 里重置此 ID 的值，或者限制此 ID 的使用，所以有可能会取不到值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//依赖库：AdSupport.framework</span><br>#<span class="hljs-keyword">import</span> &lt;AdSupport/AdSupport.h&gt;<br><span class="hljs-string">[[[ASIdentifierManager sharedManager]</span> advertisingIdentifier] UUIDString];<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：App Store 禁止不使用广告而只采集 IDFA 的 APP 上架。</p><h4 id="5、OpenUDID"><a href="#5、OpenUDID" class="headerlink" title="5、OpenUDID"></a>5、OpenUDID</h4><p>UDID 被弃用后，广大开发者需要寻找一个可以替代的 UDID，并且不受苹果控制的方案，由此，OpenUDID 成为了当时使用最广泛的开源 UDID 代替方案。OpenUDID 利用一个非常巧妙的方法在不同程序间存储标示符：在粘贴板中用了一个特殊的名称来存储标示符，通过这种方法，其他应用程序也可以获取。<br><br/></p><p>每台iOS设备的 OpenUDID 是通过第一个带有 OpenUDID SDK包的 App 生成，如果你完全删除全部带有 OpenUDID SDK包的App（比如恢复系统等），那么OpenUDID会重新生成，而且和之前的值会不同，相当于新设备。<br><br/></p><p>另外，苹果在 iOS 7 之后对粘贴板做了限制，导致同一个设备上的应用间，无法再共享一个 OpenUDID。</p><h4 id="6、MAC"><a href="#6、MAC" class="headerlink" title="6、MAC"></a>6、MAC</h4><p>MAC 地址在网络上用来区分设备的唯一性，接入网络的设备都有一个MAC地址，他们肯定都是唯一的。一部 iPhone 上可能有多个 MAC 地址，包括 WIFI 的、SIM 的等，但是 iTouch 和 iPad 上就有一个 WIFI 的，因此只需获取 WIFI 的 MAC 地址就好了。一般会采取 MD5（MAC 地址 + bundleID）获取唯一标识。<br><br/></p><p>但是 MAC 地址和 UDID 一样，存在隐私问题， iOS 7 之后，所有设备请求 MAC 地址会返回一个固定值，这个方法也不攻自破了。</p><h4 id="7、IDFV-keychain"><a href="#7、IDFV-keychain" class="headerlink" title="7、IDFV + keychain"></a>7、IDFV + keychain</h4><p>通过以上几种储存唯一标识的方法的分析，总结一下各有优劣。很多方法被苹果禁止或者漏洞太多，越来越不被开发者使用，现在苹果主推 IDFA 和 IDFV 这两种方法，但是 IDFV 在 APP 重新安装时会变化，所以可以将IDFV存储到钥匙串中，以后每次想获取标识符时都从钥匙串中取。</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拷贝</title>
    <link href="/2018/06/20/copy.html"/>
    <url>/2018/06/20/copy.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-拷贝"><a href="#1-拷贝" class="headerlink" title="1.拷贝"></a>1.拷贝</h3><blockquote><p>The exact meaning of “copy” can vary from class to class, but a copy must be a functionally independent object with values identical to the original at the time the copy was made.</p></blockquote><p>上面的摘要描述了<code>拷贝</code>的三个基本特征：</p><ul><li>在不同的类中有不同的的具体含义；</li></ul><p>拷贝可以作用于不同的对象上，比如值类型和指针类型、字符串和集合、可变对象和不可变对象等。对于不同的对象，拷贝有着不同的意义和效果，后面会继续介绍。</p><ul><li>每一份拷贝都是一个独立的对象；</li></ul><p>一个值类型对象被作为方法的参数传递或者作为返回值时，我们通常使用的是它的拷贝，而不是它本身。比如下面的方法中，我们将一个字符串赋值给对象的<code>name</code>实例变量：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)setName:(NSString *)aName<br>&#123;<br>    [<span class="hljs-type">name</span> autorelease];<br>    <span class="hljs-type">name</span> = [aName <span class="hljs-keyword">copy</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>保存<code>aName</code>的拷贝产生的效果就是：产生了一个独立的对象，对象的值与原对象一致。后续对原对象的操作不会影响到新对象，对新对象的操作也不会影响到原对象。再比如，我们通常会在一个方法中返回某个对象的拷贝，而不是对象本身：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (NSString *)<span class="hljs-type">name</span><br>&#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-type">name</span> <span class="hljs-keyword">copy</span>] autorelease];<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>name</code>的 getter 返回的就是<code>name</code>的一份拷贝~</p><ul><li>拷贝的值与发生拷贝时的原对象的值保持一致。</li></ul><p>上面说了，拷贝之后，原对象与新对象相互独立，互不影响。新对象的值与发生拷贝时原对象的值保持一致，后续原对象的值怎么变化，并不影响新对象的值。</p><h3 id="2-协议"><a href="#2-协议" class="headerlink" title="2.协议"></a>2.协议</h3><h4 id="1-拷贝协议"><a href="#1-拷贝协议" class="headerlink" title="1.拷贝协议"></a>1.拷贝协议</h4><p><code>NSObject.h</code>中定义了两个关于拷贝的实例方法：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">- (<span class="hljs-built_in">id</span>)<span class="hljs-keyword">copy</span>;<br></code></pre></td></tr></table></figure><blockquote><p>The copy method is defined for all NSObjects and simply invokes copyWithZone: with the default zone.</p></blockquote><p><code>copy</code>方法是一个便利方法，用来调用<code>copyWithZone:</code>方法，返回一个不可变对象。后者是<code>NSCopying</code>协议的协议方法。如果一个继承自 NSObject 的类的实例对象要调用<code>copy</code>时，那么该类就必须实现此协议，否则会报异常。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (id)mutableCopy<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>Convenience method for classes that adopt the NSMutableCopying protocol. This method just calls the NSMutableCopying protocol method mutableCopyWithZone: with the zone as NULL. An exception is raised if there is no implementation for mutableCopyWithZone:.</p></blockquote><p>与<code>copy</code>一样，<code>mutableCopy</code>也是一个便利方法，用来调用<code>NSMutableCopying</code>协议的协议方法<code>mutableCopyWithZone:</code>。此方法主要用来返回一个可变对象。同样的，对象需要调用<code>mutableCopy</code>时，其所属类必须实现此协议，并在协议方法中返回一个可变对象。只有那些有可变和不可变之分的类才需要实现此协议，否则应该实现<code>NSCopying</code>协议。如果某个类既有可变版本又有不可变版本，那就需要同时实现这两个协议。</p><h4 id="2-拷贝与继承"><a href="#2-拷贝与继承" class="headerlink" title="2.拷贝与继承"></a>2.拷贝与继承</h4><p><code>A</code>、<code>B</code>两个类，B继承自A，如果A中没有实现<code>NSCopying</code>或<code>NSMutableCopying</code>协议，而B实现了，则 B 类的协议方法中既需要拷贝自己声明的属性，又需要拷贝从父类继承而来的属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//父类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Model</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Model</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SubModel</span> : <span class="hljs-title">Model</span>&lt;<span class="hljs-title">NSCopying</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *subName;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SubModel</span></span><br><br>-(<span class="hljs-type">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    SubModel *newSubModel = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] alloc] init];<br>    newSubModel.name = [<span class="hljs-keyword">self</span>.name <span class="hljs-keyword">copy</span>];<span class="hljs-comment">//拷贝父类属性</span><br>    newSubModel.subName = [<span class="hljs-keyword">self</span>.subName <span class="hljs-keyword">copy</span>];<span class="hljs-comment">//拷贝子类属性</span><br>    <br>    <span class="hljs-keyword">return</span> newSubModel;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>如果A类中实现了拷贝协议，则B会继承此协议，B只需在自己的类中重写协议方法，调用<code>super</code>实现父类属性的拷贝，并拷贝自己类中声明的属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//父类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Model</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">NSCopying</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Model</span></span><br><br>-(<span class="hljs-type">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    Model *newModel = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] allocWithZone:zone] init];<br>    newModel.name = [<span class="hljs-keyword">self</span>.name <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-keyword">return</span> newModel;<br>&#125;<br><br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SubModel</span> : <span class="hljs-title">Model</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *subName;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SubModel</span></span><br><br>-(<span class="hljs-type">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    SubModel *newSubModel = [<span class="hljs-variable language_">super</span> copyWithZone:zone];<span class="hljs-comment">//调用super</span><br>    newSubModel.subName = [<span class="hljs-keyword">self</span>.subName <span class="hljs-keyword">copy</span>];<span class="hljs-comment">//拷贝子类属性</span><br>    <br>    <span class="hljs-keyword">return</span> newSubModel;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-可-x2F-不可变对象"><a href="#3-可-x2F-不可变对象" class="headerlink" title="3.可&#x2F;不可变对象"></a>3.可&#x2F;不可变对象</h4><p><code>copy</code>返回的是不可变对象，<code>mutableCopy</code>返回的是可变对象。按照 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ObjectMutability/ObjectMutability.html">Apple文档</a> 的说法，对象默认是可变的。这很好理解，比如你自定义的<code>客户</code>实体，当客户的信息发生变化时，对应的实体对象应该能更新相关字段。大多数的对象都允许你通过 setter 函数修改它内部封装的数据，Foundation 框架也为我们提供了一些可变类型，如：</p><ul><li>NSMutableArray</li><li>NSMutableDictionary</li><li>NSMutableSet</li><li>NSMutableIndexSet</li><li>NSMutableCharacterSet</li><li>NSMutableData</li><li>NSMutableString</li><li>NSMutableAttributedString</li><li>NSMutableURLRequest</li></ul><p>既然对象默认是可变的，为什么还要有不可变对象呢？这是因为，不可变对象可以防止被多处引用时因一方的修改导致其他所有引用的地方都意外地发生变化的情况，比如你持有的 tableview 数据源数组是可变的，如果在别的地方被引用且其中的数据被清空了，那么你的列表就会出问题。另外，不可变对象在性能上更有优势，因为它们不需要像可变对象那样始终维持一份可变存储。</p><p>我们通常会上面提到的集合类或者 NSString 和 block 等对象发送这两个消息，从而获得一个新的拷贝对象，这些操作的背后是框架帮我们处理了协议方法的实现及其返回值。</p><p>对于我们自定义的类的实例，也可以调用这俩方法，但是，需要我们自己实现对应的协议方法，自己定义返回值。协议方法内的返回值可以是 self，也可以是一个属性值与 self 属性值一致的新对象，根据你的需求而定。</p><p><strong>小结：</strong> 结合以上分析可以看出，这两个方法只是一种<code>便利方法</code>。当向对象发送这两个消息时，它们只是会在对象所属的类中查找并调用对应的协议方法，返回可变或不可变的新对象。这点类似于我们常用的<code>便利初始化函数</code>，最终调用指定初始化函数。从另一个角度来说，<code>copy</code>并不等价于浅拷贝，<code>mutableCopy</code>也并等价于深拷贝，尤其是当你在自定义的类中实现拷贝的协议方法时，深拷贝还是浅拷贝可根据你的需求而定。具体什么是深拷贝和浅拷贝，接下来继续介绍。</p><h3 id="3-深-x2F-浅拷贝"><a href="#3-深-x2F-浅拷贝" class="headerlink" title="3.深&#x2F;浅拷贝"></a>3.深&#x2F;浅拷贝</h3><p>二者在处理简单的纯量属性（Int,float等）时，都是直接拷贝属性的值到新对象；不同点在于对指针类型的处理上：</p><ul><li><strong>浅拷贝</strong>：指针拷贝，将原对象的指针复制到副本中，原对象和副本共享指针指向的数据。</li><li><strong>深拷贝</strong>：对象拷贝，复制原指针指向的数据给副本，副本与原对象的地址不同，互不影响。</li></ul><h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h3><h4 id="1-不可变字符串"><a href="#1-不可变字符串" class="headerlink" title="1.不可变字符串"></a>1.不可变字符串</h4><p>结论：对不可变字符串的copy是浅拷贝，mutableCopy是深拷贝。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *str1 = <span class="hljs-string">@&quot;hello&quot;</span>;<br><span class="hljs-built_in">NSString</span> *str2 = [str1 <span class="hljs-keyword">copy</span>]; <span class="hljs-comment">// 浅拷贝</span><br><span class="hljs-built_in">NSString</span> *str3 = [str1 mutableCopy]; <span class="hljs-comment">// 深拷贝</span><br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str1 = %p&quot;</span>,str1);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str2 = %p&quot;</span>,str2);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str3 = %p&quot;</span>,str3);<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">str1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x10ae55810<br><span class="hljs-attribute">str2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x10ae55810<br><span class="hljs-attribute">str3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x600000258ea0<br></code></pre></td></tr></table></figure><p>str1 与 str2 指向同一片内存区域，就是说对不可变字符串的 copy 只是指针拷贝；而 str3 与 str1 指向不同内存区域，说明对不可变字符串的 mutableCopy 产生了新的对象，此对象的内存地址与 str1 指向的地址完全不同。</p><h4 id="2-可变字符串"><a href="#2-可变字符串" class="headerlink" title="2.可变字符串"></a>2.可变字符串</h4><p>结论：对可变字符串的copy与mutableCopy都是深拷贝。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSMutableString</span> *str1 = [<span class="hljs-built_in">NSMutableString</span> stringWithString:<span class="hljs-string">@&quot;hello&quot;</span>];<br><span class="hljs-built_in">NSString</span> *str2 = [str1 <span class="hljs-keyword">copy</span>]; <span class="hljs-comment">// 深拷贝</span><br><span class="hljs-built_in">NSString</span> *str3 = [str1 mutableCopy]; <span class="hljs-comment">// 深拷贝</span><br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str1 = %p&quot;</span>,str1);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str2 = %p&quot;</span>,str2);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;str3 = %p&quot;</span>,str3);<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">str1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x604000451040<br><span class="hljs-attribute">str2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>xa00006f6c6c65685<br><span class="hljs-attribute">str3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x604000450fe0<br></code></pre></td></tr></table></figure><p>对可变字符串的两种复制都产生了新的对象，三个对象的地址完全不同。</p><h4 id="3-可变性"><a href="#3-可变性" class="headerlink" title="3.可变性"></a>3.可变性</h4><p>结论：字符串，不论可不可变，copy 后返回不可变对象；mutableCopy 后返回可变对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *str1 = <span class="hljs-string">@&quot;hi&quot;</span>;<br><span class="hljs-built_in">NSMutableString</span> *str2 = [str1 mutableCopy];<br>[str2 appendString:<span class="hljs-string">@&quot;xx&quot;</span>];<br><br><span class="hljs-built_in">NSMutableString</span> *str3 = [<span class="hljs-built_in">NSMutableString</span> stringWithString:<span class="hljs-string">@&quot;hello&quot;</span>];<br><span class="hljs-built_in">NSMutableString</span> *str4 = [str3 <span class="hljs-keyword">copy</span>]; <span class="hljs-comment">// 不可变</span><br><span class="hljs-built_in">NSMutableString</span> *str5 = [str3 mutableCopy]; <span class="hljs-comment">// 可变</span><br><br>[str4 appendString:<span class="hljs-string">@&quot;world&quot;</span>]; <span class="hljs-comment">//报错</span><br>[str5 appendString:<span class="hljs-string">@&quot;Kitty&quot;</span>]; <span class="hljs-comment">//正常</span><br></code></pre></td></tr></table></figure><p>示例在运行到 [str4 appendString:@”world”] 这一行时会报错“unrecognized selector sent to instance”，这就是说可变字符串在执行 copy 操作后返回的对象不再是可变字符串，因此对其执行 appendString 方法时出现了崩溃。注释掉这一行后，程序正常执行。</p><h3 id="5-自定义类"><a href="#5-自定义类" class="headerlink" title="5.自定义类"></a>5.自定义类</h3><p>结论：对于我们自定义的类，其 copy 与 mutableCopy 是深&#x2F;浅拷贝因我们的实现而定。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Model</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">NSCopying</span>, <span class="hljs-title">NSMutableCopying</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Model.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Model</span></span><br><br>- (<span class="hljs-type">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    <span class="hljs-comment">/*可返回一份值拷贝，也可以返回一份指针拷贝，这里我返回的是值拷贝；</span><br><span class="hljs-comment">     *当然，你也可以‘return self’，返回一份self实例的指针，这么做也不会报错，因你的需求而定。</span><br><span class="hljs-comment">     */</span> <br>    Model *newModel = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] allocWithZone:zone] init];<br>    newModel.name = [<span class="hljs-keyword">self</span>.name <span class="hljs-keyword">copy</span>]; <span class="hljs-comment">// 使用copy</span><br>    <br>    <span class="hljs-keyword">return</span> newModel;<br>&#125;<br><br>- (<span class="hljs-type">id</span>)mutableCopyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    Model *newModel = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] allocWithZone:zone] init];<br>    newModel.name = [<span class="hljs-keyword">self</span>.name mutableCopy]; <span class="hljs-comment">// 使用mutableCopy</span><br><br>    <span class="hljs-keyword">return</span> newModel;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Model</span> *<span class="hljs-keyword">model</span> = [<span class="hljs-keyword">Model</span> new];<br><span class="hljs-keyword">model</span>.name = @<span class="hljs-string">&quot;sakura&quot;</span>;<br>NSLog(@<span class="hljs-string">&quot;++++model = %p;&quot;</span>,<span class="hljs-keyword">model</span>);<br><br><span class="hljs-keyword">Model</span> *copymodel = [<span class="hljs-keyword">model</span> copy]; <span class="hljs-comment">// 深拷贝</span><br>NSLog(@<span class="hljs-string">&quot;++++copymodel = %p&quot;</span>,copymodel);<br><br><span class="hljs-keyword">Model</span> *mutableCopymodel = [<span class="hljs-keyword">model</span> mutableCopy]; <span class="hljs-comment">// 深拷贝</span><br>NSLog(@<span class="hljs-string">&quot;++++mutableCopymodel = %p&quot;</span>,mutableCopymodel);<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">model = 0x600002748bb0;</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">copymodel = 0x6000027585d0</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">mutableCopymodel = 0x600002748bc0</span><br></code></pre></td></tr></table></figure><h3 id="6-集合类"><a href="#6-集合类" class="headerlink" title="6.集合类"></a>6.集合类</h3><h4 id="1-浅拷贝"><a href="#1-浅拷贝" class="headerlink" title="1.浅拷贝"></a>1.浅拷贝</h4><p>对OC中集合类对象的拷贝，默认是浅拷贝。集合的浅拷贝会产生新的集合对象，新旧集合内的元素指针相同。原集合中的每个元素会收到一条 retain 消息，引用计数+1，它们的指针会被拷贝到新建的集合中。系统为我们提供了一些方法，以实现集合对象的浅拷贝：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">-copyWithZone:（如 [anArr copyWithZone:<span class="hljs-literal">nil</span>];）<br>-mutableCopyWithZone:<br>-initWithArray:copyItems:<span class="hljs-literal">NO</span>（第二个参数为<span class="hljs-literal">NO</span>）<br>-initWithDictionary:copyItems:<span class="hljs-literal">NO</span>（第二个参数为<span class="hljs-literal">NO</span>）<br></code></pre></td></tr></table></figure><h4 id="2-深拷贝"><a href="#2-深拷贝" class="headerlink" title="2.深拷贝"></a>2.深拷贝</h4><p>集合的深拷贝会产生新的集合对象，新旧集合内的元素指针不相同，新集合中的元素是从原集合中的元素拷贝而来。</p><p>方案1：通过集合类对象的实例方法</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">- initWithArray:copyItems:<span class="hljs-keyword">YES</span>（第二个参数为<span class="hljs-keyword">YES</span>）<br>- initWithDictionary:copyItems:<span class="hljs-keyword">YES</span>（第二个参数为<span class="hljs-keyword">YES</span>）<br></code></pre></td></tr></table></figure><p>copyItems 的参数 &#x3D; YES，这种方式下集合中的每个对象都会调用一次 copyWithZone: 方法，如果这些对象实现了 NSCopying 协议，那么这些对象会被深拷贝到新集合中。如果没有实现 NSCopying 协议，则运行时会报错。</p><p>方案2：通过归档解档</p><blockquote><p>If you need a true deep copy, such as when you have an array of arrays, you can archive and then unarchive the collection, provided the contents all conform to the NSCoding protocol. </p></blockquote><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">NSArray* trueDeepCopyArray = [NSKeyedUn<span class="hljs-params">archive</span>r un<span class="hljs-params">archive</span>ObjectWithData:<br>                                [NSKeyed<span class="hljs-params">Archive</span>r <span class="hljs-params">archive</span>dDataWithRootObject:oldArray]]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这是集合真正意义上的深拷贝，这种方式下集合中的所有对象都要实现 NSCoding 协议，不然也会出现崩溃。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Model</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">NSCopying</span>,<span class="hljs-title">NSMutableCopying</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Model</span></span><br><br>- (<span class="hljs-type">id</span>)copyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++call Model copyWithZone~&quot;</span>);<br>    <br>    Model *newModel = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] allocWithZone:zone] init];<br>    newModel.name = [<span class="hljs-keyword">self</span>.name <span class="hljs-keyword">copy</span>];<br>    <br>    <span class="hljs-keyword">return</span> newModel;<br>&#125;<br><br>- (<span class="hljs-type">id</span>)mutableCopyWithZone:(<span class="hljs-built_in">NSZone</span> *)zone<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++call Model mutableCopyWithZone~&quot;</span>);<br>    <br>    Model *newModel = [[[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>] allocWithZone:zone] init];<br>    newModel.name = [<span class="hljs-keyword">self</span>.name mutableCopy];<br><br>    <span class="hljs-keyword">return</span> newModel;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Model *model = <span class="hljs-literal">[[M<span class="hljs-identifier">odel</span> <span class="hljs-identifier">alloc</span>]</span> init];<br>NSArray *<span class="hljs-built_in">array</span> = <span class="hljs-literal">[NSA<span class="hljs-identifier">rray</span> <span class="hljs-identifier">arrayWithObject</span>:<span class="hljs-identifier">model</span>]</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++model:%p&quot;</span>,<span class="hljs-params">model</span>)</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++array:%p,+++array[0]:%p&quot;</span>,<span class="hljs-params">array</span>,<span class="hljs-params">array</span>[0])</span>;<br>    <br>NSArray *zoneArray = <span class="hljs-literal">[<span class="hljs-identifier">array</span> <span class="hljs-identifier">copyWithZone</span>:<span class="hljs-identifier">nil</span>]</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++zoneArray:%p,+++zoneArray[0]:%p&quot;</span>,<span class="hljs-params">zoneArray</span>,<span class="hljs-params">zoneArray</span>[0])</span>;<br>    <br>NSArray *noCopyArr = <span class="hljs-literal">[[NSA<span class="hljs-identifier">rray</span> <span class="hljs-identifier">alloc</span>]</span> initWithArray:<span class="hljs-built_in">array</span> copyItems:NO];<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++noCopyArr:%p,+++noCopyArr[0]:%p&quot;</span>,<span class="hljs-params">noCopyArr</span>,<span class="hljs-params">noCopyArr</span>[0])</span>;<br>    <br>NSArray *copyArray = <span class="hljs-literal">[[NSA<span class="hljs-identifier">rray</span> <span class="hljs-identifier">alloc</span>]</span> initWithArray:<span class="hljs-built_in">array</span> copyItems:YES];<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++copyArray:%p,+++copyArray[0]:%p&quot;</span>,<span class="hljs-params">copyArray</span>,<span class="hljs-params">copyArray</span>[0])</span>;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">model:0x600003124780</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">array:0x6000031246f0</span><span class="hljs-string">,</span><span class="hljs-literal">+++</span><span class="hljs-comment">array</span><span class="hljs-title">[</span><span class="hljs-comment">0</span><span class="hljs-title">]</span><span class="hljs-comment">:0x600003124780</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">zoneArray:0x6000031246f0</span><span class="hljs-string">,</span><span class="hljs-literal">+++</span><span class="hljs-comment">zoneArray</span><span class="hljs-title">[</span><span class="hljs-comment">0</span><span class="hljs-title">]</span><span class="hljs-comment">:0x600003124780</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">noCopyArr:0x6000031246e0</span><span class="hljs-string">,</span><span class="hljs-literal">+++</span><span class="hljs-comment">noCopyArr</span><span class="hljs-title">[</span><span class="hljs-comment">0</span><span class="hljs-title">]</span><span class="hljs-comment">:0x600003124780</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">call Model copyWithZone~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">copyArray:0x60000313f550</span><span class="hljs-string">,</span><span class="hljs-literal">+++</span><span class="hljs-comment">copyArray</span><span class="hljs-title">[</span><span class="hljs-comment">0</span><span class="hljs-title">]</span><span class="hljs-comment">:0x600003124440</span><br></code></pre></td></tr></table></figure><p>日志信息显示：</p><ul><li>copyWithZone:返回的的数组对象与原数组对象的指针相同，内部元素的指针也相同；</li><li>copyItems:NO返回的数组对象与原数组对象的指针不同，内部元素的指针相同；</li><li>copyItems:YES返回的数组对象与原数组对象的指针不同，内部元素的指针也不相同，且自动调用了元素的拷贝协议方法；</li></ul><p>这些都印证了上面关于集合对象深浅拷贝时内部元素的不同。</p><h4 id="3-可变性-1"><a href="#3-可变性-1" class="headerlink" title="3.可变性"></a>3.可变性</h4><ul><li>1.copyWithZone</li></ul><p>上层不可变，其他更深层对象的可变性与原对象相同。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSMutableArray</span> * array;<br></code></pre></td></tr></table></figure><p>对<code>array</code>属性执行<code>add</code>操作会发生什么?</p><p><code>copy</code>方法返回的集合是不可变集合，故而这里<code>array</code>属性实际上是不可变的，对其执行增删对象操作时会闪退。</p><ul><li>2.copyItems:NO</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>initWithArray:copyItems:NO:<br></code></pre></td></tr></table></figure><p>上层可变性与其初始化时的类型保持一致，其他更深层的可变性与原对象相同。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)testWithNoCopy<br>&#123;<br>    <span class="hljs-built_in">NSMutableArray</span> *element = [[<span class="hljs-built_in">NSMutableArray</span> alloc] initWithObjects:@(<span class="hljs-number">1</span>), <span class="hljs-literal">nil</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++element:%p,elementClass:%@&quot;</span>,element,[element <span class="hljs-keyword">class</span>]);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *mutArr1 = [[<span class="hljs-built_in">NSMutableArray</span> alloc] initWithObjects:element, <span class="hljs-literal">nil</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++mutArr1:%p&quot;</span>,mutArr1);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *mutArr2 = [[<span class="hljs-built_in">NSMutableArray</span> alloc] initWithArray:mutArr1 copyItems:<span class="hljs-literal">NO</span>];<br>    [mutArr2 addObject:@(<span class="hljs-number">2</span>)];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++mutArr2:%p, mutArr2Class:%@, mutArr2.count:%lu&quot;</span>,mutArr2,[mutArr2 <span class="hljs-keyword">class</span>],mutArr2.count);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *arrAt0 = mutArr2[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++arrAt0:%p, arrAt0Class:%@&quot;</span>,arrAt0,[arrAt0 <span class="hljs-keyword">class</span>]);<br>    <br>    [arrAt0 addObject:@(<span class="hljs-number">3</span>)];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++arrAt0.count:%lu&quot;</span>,(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)arrAt0.count);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++element.count:%lu&quot;</span>,(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)element.count);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">++++elemen<span class="hljs-variable">t:0x60000229de00</span>,elementClas<span class="hljs-variable">s:__NSArrayM</span><br>++++mutArr1:<span class="hljs-number">0</span>x600002283810<br>++++mutArr2:<span class="hljs-number">0</span>x6000022838d0, mutArr2Clas<span class="hljs-variable">s:__NSArrayM</span>, mutArr2.coun<span class="hljs-variable">t:2</span><br>++++arrAt0:<span class="hljs-number">0</span>x60000229de00, arrAt0Clas<span class="hljs-variable">s:__NSArrayM</span><br>++++arrAt0.coun<span class="hljs-variable">t:2</span><br>++++element.coun<span class="hljs-variable">t:2</span><br></code></pre></td></tr></table></figure><p>mutArr2 是通过copyItems:NO产生的新数组，内部元素从可变数组 mutArr1 中拷贝而来。示例中 [mutArr2 addObject:@(2)] 可以正常执行，说明copyItems:NO产生的 mutArr2 正如其创建时声明的那样，是一个可变数组，即：上层可变性与其初始化时的类型保持一致~</p><p>arrAt0 作为 mutArr2 的子元素，指针与 element 相同，也就是说在创建 mutArr2 时只是拷贝了 mutArr1 中元素 element 的指针。因此，arrAt0 也是一个可变数组，能正常执行 [arrAt0 addObject:@(3)]，即：其他更深层的可变性与原对象相同。</p><ul><li>3.copyItems:YES</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>initWithArray:copyItems:YES:<br></code></pre></td></tr></table></figure><p>上层可变性与初始化时的类型一致，接下来的一层不可变，其他更深层的可变性与原对象相同。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)testWithCopy<br>&#123;<br>    <span class="hljs-built_in">NSMutableArray</span> *inArr = [[<span class="hljs-built_in">NSMutableArray</span> alloc] initWithObjects:@(<span class="hljs-number">1</span>), <span class="hljs-literal">nil</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++inArr:%p, inArrClass:%@&quot;</span>,inArr,[inArr <span class="hljs-keyword">class</span>]);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *element = [[<span class="hljs-built_in">NSMutableArray</span> alloc] initWithObjects:inArr, <span class="hljs-literal">nil</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++element:%p,elementClass:%@&quot;</span>,element,[element <span class="hljs-keyword">class</span>]);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *mutArr1 = [[<span class="hljs-built_in">NSMutableArray</span> alloc] initWithObjects:element, <span class="hljs-literal">nil</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++mutArr1:%p&quot;</span>,mutArr1);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *mutArr2 = [[<span class="hljs-built_in">NSMutableArray</span> alloc] initWithArray:mutArr1 copyItems:<span class="hljs-literal">YES</span>];<br>    [mutArr2 addObject:@(<span class="hljs-number">2</span>)];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++mutArr2:%p, mutArr2Class:%@, mutArr2.count:%lu&quot;</span>,mutArr2,[mutArr2 <span class="hljs-keyword">class</span>],mutArr2.count);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *arrAt0 = mutArr2[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++arrAt0:%p, arrAt0Class:%@&quot;</span>,arrAt0,[arrAt0 <span class="hljs-keyword">class</span>]);<br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *inArrAt0 = arrAt0[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++inArrAt0:%p, inArrAt0Class:%@&quot;</span>,inArrAt0,[inArrAt0 <span class="hljs-keyword">class</span>]);<br>    <br>    [inArrAt0 addObject:@(<span class="hljs-number">3</span>)];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++inArrAt0.count:%lu&quot;</span>,(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)inArrAt0.count);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++inArr.count:%lu&quot;</span>,(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)inArr.count);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">++++inArr:<span class="hljs-number">0</span>x6000028a4150, inArrClas<span class="hljs-variable">s:__NSArrayM</span><br>++++elemen<span class="hljs-variable">t:0x6000028bd0b0</span>,elementClas<span class="hljs-variable">s:__NSArrayM</span><br>++++mutArr1:<span class="hljs-number">0</span>x6000028bd3e0<br>++++mutArr2:<span class="hljs-number">0</span>x6000028bd470, mutArr2Clas<span class="hljs-variable">s:__NSArrayM</span>, mutArr2.coun<span class="hljs-variable">t:2</span><br>++++arrAt0:<span class="hljs-number">0</span>x6000024e19d0, arrAt0Clas<span class="hljs-variable">s:__NSSingleObjectArrayI</span><br>++++inArrAt0:<span class="hljs-number">0</span>x6000028a4150, inArrAt0Clas<span class="hljs-variable">s:__NSArrayM</span><br>++++inArrAt0.coun<span class="hljs-variable">t:2</span><br>++++inArr.coun<span class="hljs-variable">t:2</span><br></code></pre></td></tr></table></figure><p>可以看到，mutArr2Class:__NSArrayM，说明 mutArr2 仍然是一个可变数组，即：上层可变性与其初始化时的类型保持一致~</p><p>arrAt0Class:__NSSingleObjectArrayI，且 arrAt0 与 element 的指针不再相同，说明 arrAt0 是内容拷贝而非指针拷贝，且不可变，即：接下来的一层不可变~</p><p>inArrAt0Class:__NSArrayM，inArrAt0 为 arrAt0 中的第一个元素，对应着 inArr，且二者的指针相同，即：其他更深层的可变性与原对象相同。</p><p>另外，mutArr2 是一个集合，算是最上层。arrAt0 作为 mutArr2 集合的第一层，对应着 mutArr1 中的 element，但 arrAt0 与 element 的指针不同，也就是说 initWithArray:copyItems:YES 产生的集合中，最上层是深拷贝；inArrAt0 作为 arrAt0 的元素，是 mutArr2 的第二层，它的指针与 inArr 的指针相同，且 [inArrAt0 addObject:@(3)] 之后 inArr.count 也随着变化，这说明从第二层开始就已经是指针拷贝，即浅拷贝了~</p><blockquote><p>结论：集合的深拷贝，只是单层深拷贝，更深层开始元素就只是指针拷贝了~</p></blockquote><ul><li>4.归解档</li></ul><p>所有层的可变性与原对象完全相同。</p><h4 id="4-copy与mutableCopy"><a href="#4-copy与mutableCopy" class="headerlink" title="4.copy与mutableCopy"></a>4.copy与mutableCopy</h4><h5 id="1-不可变集合"><a href="#1-不可变集合" class="headerlink" title="1.不可变集合"></a>1.不可变集合</h5><p>结论：对于不可变集合对象的 copy 是指针拷贝，不产生新对象；mutableCopy 是内容拷贝，会产生新对象；两种情况下集合内元素都是指针拷贝。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Model *m = <span class="hljs-literal">[[M<span class="hljs-identifier">odel</span> <span class="hljs-identifier">alloc</span>]</span> init];<br>NSArray *element = @<span class="hljs-literal">[<span class="hljs-identifier">m</span>]</span>;<br>NSArray *oriArray = @<span class="hljs-literal">[<span class="hljs-identifier">element</span>]</span>;<br>NSMutableArray *copyArray = <span class="hljs-literal">[<span class="hljs-identifier">oriArray</span> <span class="hljs-identifier">copy</span>]</span>;<br>NSMutableArray *mutableCopyArray = <span class="hljs-literal">[<span class="hljs-identifier">oriArray</span> <span class="hljs-identifier">mutableCopy</span>]</span>;<br>    <br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++oriArr:%p,element:%p&quot;</span>,<span class="hljs-params">oriArray</span>,<span class="hljs-params">element</span>)</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++copyArr:%p,indexAt0:%p&quot;</span>,<span class="hljs-params">copyArray</span>,<span class="hljs-params">copyArray</span>[0])</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++mutableCopyArr:%p,indexAt0:%p&quot;</span>,<span class="hljs-params">mutableCopyArray</span>,<span class="hljs-params">mutableCopyArray</span>[0])</span>;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">+++oriArr:<span class="hljs-number">0</span>x60<span class="hljs-number">00039f0760</span>,element:<span class="hljs-number">0</span>x60<span class="hljs-number">00039f06b0</span><br>++++copyArr:<span class="hljs-number">0</span>x60<span class="hljs-number">00039f0760</span>,indexAt0:<span class="hljs-number">0</span>x60<span class="hljs-number">00039f06b0</span><br>++++mutableCopyArr:<span class="hljs-number">0</span>x60<span class="hljs-number">00035a59b0</span>,indexAt0:<span class="hljs-number">0</span>x60<span class="hljs-number">00039f06b0</span><br></code></pre></td></tr></table></figure><p>不可变数组 oriArray 中包含了一个数组对象 element 。从日志可以看出，oriArray 与从其 copy 出来的数组 copyArray 指向同一片内存，而与从其 mutableCopy 出来的数组 mutableCopyArray 的内存不同。这与不可变非集合类对象类似，对不可变数组的 copy 只是指针拷贝，不会产生新的集合对象；mutableCopy 是内容拷贝，会产生新的集合对象。</p><h5 id="2-可变集合"><a href="#2-可变集合" class="headerlink" title="2.可变集合"></a>2.可变集合</h5><p>结论：对于可变集合对象的 copy 和 mutableCopy 都是内容拷贝，会产生新的集合对象；两种情况下集合内元素都是指针拷贝。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Model *m = [[Model alloc] init];<br><span class="hljs-built_in">NSArray</span> *element = @[m];<br><span class="hljs-built_in">NSMutableArray</span> *oriArray = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObject:element];<br><span class="hljs-built_in">NSMutableArray</span> *copyArray = [oriArray <span class="hljs-keyword">copy</span>];<br><span class="hljs-built_in">NSMutableArray</span> *mutableCopyArray = [oriArray mutableCopy];<br>    <br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++oriArr:%p,element:%p&quot;</span>,oriArray,element);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++copyArr:%p,indexAt0:%p&quot;</span>,copyArray,copyArray[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++mutableCopyArr:%p,indexAt0:%p&quot;</span>,mutableCopyArray,mutableCopyArray[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">+++oriArr:<span class="hljs-number">0</span>x60000102dd10,element:<span class="hljs-number">0</span>x6<span class="hljs-number">00001c64c40</span><br>++++copyArr:<span class="hljs-number">0</span>x6<span class="hljs-number">00001c73360</span>,indexAt0:<span class="hljs-number">0</span>x6<span class="hljs-number">00001c64c40</span><br>++++mutableCopyArr:<span class="hljs-number">0</span>x6<span class="hljs-number">00001033900</span>,indexAt0:<span class="hljs-number">0</span>x6<span class="hljs-number">00001c64c40</span><br></code></pre></td></tr></table></figure><p>对可变数组 oriArray 的两种拷贝都是内容拷贝，都产生了新的集合对象。</p><p>上面两个示例中，元素 element 与 copyArray[0] 和 mutableCopyArray[0] 都是指向同一片内存。也就是说两种拷贝下，新旧集合内容部的元素都只是指针拷贝。</p><blockquote><p>结论：对于可变和不可变集合对象的copy 和 mutableCopy，其内部元素始终都是指针拷贝。</p></blockquote><h5 id="3-集合元素的指针拷贝"><a href="#3-集合元素的指针拷贝" class="headerlink" title="3.集合元素的指针拷贝"></a>3.集合元素的指针拷贝</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *elementArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObject:@<span class="hljs-number">1</span>];<br><span class="hljs-built_in">NSMutableArray</span> *oriArray = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObject:elementArr];<br><span class="hljs-built_in">NSMutableArray</span> *mutableCopyArray = [oriArray mutableCopy];<br>[mutableCopyArray[<span class="hljs-number">0</span>] addObject:@<span class="hljs-number">2</span>];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++objects in element:%p++++&quot;</span>,elementArr);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSNumber</span> *num <span class="hljs-keyword">in</span> elementArr) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++%d&quot;</span>,[num intValue]);<br>&#125;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++objects in mutableCopyArray[0]:%p++++&quot;</span>,mutableCopyArray[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSNumber</span> *num <span class="hljs-keyword">in</span> mutableCopyArray[<span class="hljs-number">0</span>]) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++%d&quot;</span>,[num intValue]);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">objects in element:0x600000249450</span><span class="hljs-literal">++++</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">objects in mutableCopyArray</span><span class="hljs-title">[</span><span class="hljs-comment">0</span><span class="hljs-title">]</span><span class="hljs-comment">:0x600000249450</span><span class="hljs-literal">++++</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">2</span><br></code></pre></td></tr></table></figure><p>示例显示，mutableCopyArray 内的元素与 oriArray 内的元素，都是指向同一片地址，也就是 element 的地址。后续对 mutableCopyArray[0] 执行添加数据的操作时，element 数组也受到影响，跟着增加了相同的对象。因此实际开发过程中，需要留意这一点！</p><h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><ul><li>可变对象的<code>copy</code>和<code>mutableCopy</code>都是深拷贝；</li><li>不可变对象的<code>copy</code>是浅拷贝，<code>mutableCopy</code>是深拷贝；</li><li><code>copy</code>方法返回的都是不可变对象；</li></ul><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Protocols/NSCopying/Description.html#//apple_ref/occ/intf/NSCopying">©Apple-Documentation-nscopying</a></p><p>#<a href="https://developer.apple.com/documentation/foundation/nscopying?language=objc">©Apple-Documentation-nscopying新</a></p><p>#<a href="https://developer.apple.com/documentation/foundation/nsmutablecopying?language=objc">©Apple-Documentation-nsmutablecopying</a></p><p>#<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ObjectMutability/ObjectMutability.html">©Apple-Documentation-Object Mutability</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串属性</title>
    <link href="/2018/06/15/string-prop.html"/>
    <url>/2018/06/15/string-prop.html</url>
    
    <content type="html"><![CDATA[<p>日常实践中，我们经常要声明一些字符串属性，包括<code>NSString</code>和<code>NSMutableString</code>，而字符串最常用的修饰符就要数<code>strong</code>和<code>copy</code>了。这两个修饰符对字符串有什么影响呢？</p><h4 id="1-不可变源字符串"><a href="#1-不可变源字符串" class="headerlink" title="1.不可变源字符串"></a>1.不可变源字符串</h4><p>#示例1：用 NSString 赋值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *aStrongStr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *aCopyStr;<br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//用 NSString 赋值</span><br>    <span class="hljs-built_in">NSString</span> *oriStr = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;A&quot;</span>];<br>    <br>    <span class="hljs-keyword">self</span>.aStrongStr = oriStr;<br>    <span class="hljs-keyword">self</span>.aCopyStr = oriStr;<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++oriStr:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,oriStr,&amp;oriStr,oriStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Strong:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aStrongStr,&amp;_aStrongStr,_aStrongStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Copy:    值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aCopyStr,&amp;_aCopyStr,_aCopyStr);<br><br>    <span class="hljs-comment">//改变 oriStr 的指针</span><br>    oriStr = <span class="hljs-string">@&quot;B&quot;</span>;<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++oriStr1:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,oriStr,&amp;oriStr,oriStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Strong1:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aStrongStr,&amp;_aStrongStr,_aStrongStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Copy1:    值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aCopyStr,&amp;_aCopyStr,_aCopyStr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">++oriStr:  值地址:<span class="hljs-number">0xcee763de400efcf2</span>,  对象地址:<span class="hljs-number">0x7ffeea6357e8</span>,  值:A<br>++Strong:  值地址:<span class="hljs-number">0xcee763de400efcf2</span>,  对象地址:<span class="hljs-number">0x600003c7ff28</span>,  值:A<br>++Copy:    值地址:<span class="hljs-number">0xcee763de400efcf2</span>,  对象地址:<span class="hljs-number">0x600003c7ff30</span>,  值:A<br>++oriStr1:  值地址:<span class="hljs-number">0x1055d67d0</span>,  对象地址:<span class="hljs-number">0x7ffeea6357e8</span>,  值:B<br>++Strong1:  值地址:<span class="hljs-number">0xcee763de400efcf2</span>,  对象地址:<span class="hljs-number">0x600003c7ff28</span>,  值:A<br>++Copy1:    值地址:<span class="hljs-number">0xcee763de400efcf2</span>,  对象地址:<span class="hljs-number">0x600003c7ff30</span>,  值:A<br></code></pre></td></tr></table></figure><p>当使用 NSString 类型的<code>oriStr</code>给<code>strong</code>和<code>copy</code>修饰的字符串对象赋值时，两个对象内保存的是字符串<code>oriStr</code>值对象<code>A</code>的地址指针。因为<code>oriStr</code>是不可变字符串，所以只能修改<code>oriStr</code>的指针，使其指向新的值<code>B</code>时，此时<code>strong</code>与<code>copy</code>的对象内保存的指针并没变，还是指向值原值对象<code>A</code>的地址。所以<code>oriStr</code>指针的新变化不会影响前两者内的指针。</p><h4 id="2-可变源字符串"><a href="#2-可变源字符串" class="headerlink" title="2.可变源字符串"></a>2.可变源字符串</h4><p>#示例2：用 NSMutableString 赋值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *aStrongStr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *aCopyStr;<br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//用 NSMutableString 赋值</span><br>    <span class="hljs-built_in">NSMutableString</span> *oriStr = [<span class="hljs-built_in">NSMutableString</span> stringWithFormat:<span class="hljs-string">@&quot;A&quot;</span>];<br>    <br>    <span class="hljs-keyword">self</span>.aStrongStr = oriStr;<br>    <span class="hljs-keyword">self</span>.aCopyStr = oriStr;<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++oriStr:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,oriStr,&amp;oriStr,oriStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Strong:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aStrongStr,&amp;_aStrongStr,_aStrongStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Copy:    值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aCopyStr,&amp;_aCopyStr,_aCopyStr);<br>    <br>    <span class="hljs-comment">//改变 oriStr 的值(注意，不是改变指针)</span><br>    [oriStr setString:<span class="hljs-string">@&quot;B&quot;</span>];<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++oriStr1:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,oriStr,&amp;oriStr,oriStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Strong1:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aStrongStr,&amp;_aStrongStr,_aStrongStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Copy1:    值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aCopyStr,&amp;_aCopyStr,_aCopyStr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">++oriStr:  值地址:<span class="hljs-number">0</span>x6000<span class="hljs-number">02b960a0</span>,  对象地址:<span class="hljs-number">0</span>x7ffee<span class="hljs-number">292d7e8</span>,  值:<span class="hljs-keyword">A</span><br>++Strong:  值地址:<span class="hljs-number">0</span>x6000<span class="hljs-number">02b960a0</span>,  对象地址:<span class="hljs-number">0</span>x60<span class="hljs-number">00025f6c08</span>,  值:<span class="hljs-keyword">A</span><br>++Copy:    值地址:<span class="hljs-number">0</span>xfac5ab<span class="hljs-number">7f38f70e39</span>,  对象地址:<span class="hljs-number">0</span>x60<span class="hljs-number">00025f6c10</span>,  值:<span class="hljs-keyword">A</span><br>++oriStr1:  值地址:<span class="hljs-number">0</span>x6000<span class="hljs-number">02b960a0</span>,  对象地址:<span class="hljs-number">0</span>x7ffee<span class="hljs-number">292d7e8</span>,  值:B<br>++Strong1:  值地址:<span class="hljs-number">0</span>x6000<span class="hljs-number">02b960a0</span>,  对象地址:<span class="hljs-number">0</span>x60<span class="hljs-number">00025f6c08</span>,  值:B<br>++Copy1:    值地址:<span class="hljs-number">0</span>xfac5ab<span class="hljs-number">7f38f70e39</span>,  对象地址:<span class="hljs-number">0</span>x60<span class="hljs-number">00025f6c10</span>,  值:<span class="hljs-keyword">A</span><br></code></pre></td></tr></table></figure><p>当使用 NSMutableString 类型的<code>oriStr</code>给<code>strong</code>类型的字符串赋值时，<code>_aStrongStr</code>对<code>oriStr</code>的值对象<code>A</code>的地址进行了指针拷贝，二者值相等。当<code>oriStr</code>值对象的指针未变但值变成<code>B</code>时，<code>_aStrongStr</code>中值对象指针跟<code>oriStr</code>一样也没变，所以其值也会变成<code>B</code>。</p><p>当使用 NSMutableString 类型的<code>oriStr</code>给<code>copy</code>类型的字符串赋值时，<code>_aCopyStr</code>对<code>oriStr</code>的值对象进行了深拷贝，二者指向了不同的对象。当<code>oriStr</code>的值变化时，<code>_aCopyStr</code>的值并未跟着变化而是保持不变。</p><h4 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h4><p>1、当源字符串为<code>NSString</code>类型，给<code>strong</code>和<code>copy</code>修饰的属性赋值时，效果一样，都是浅拷贝，得到的两个对象都与源字符串的值相同。同时，由于源字符串不可变，如果想修改这两个对象的值，可以将二者指向新的字符串对象，或直接用字符串字面量赋值。</p><p>2、当源字符串为<code>NSMutableString</code>类型，给<code>strong</code>修饰的属性赋值时，也是浅拷贝，但要注意，由于源字符串是可变的，所以源字符串的变化会影响到<code>strong</code>修饰的属性及其对应的成员变量。</p><p>3、当源字符串为<code>NSMutableString</code>类型，使用<code>copy</code>修饰的属性赋值时，是深拷贝，新对象的值与源字符串的值相同，但二者的指针不同，不会相互影响。</p><hr><p>通常情况下，我们声明一个字符串类型的属性并给其赋值时，并不希望源字符串后续的修改会影响到我们的字符串属性，所以，<strong>综合起来还是使用<code>copy</code>稳妥</strong>。这样，如果源字符串为<code>NSString</code>类型，其内容不可变，所以不存在后续影响；如果源字符串为<code>NSMutableString</code>类型，因为<code>copy</code>会做深拷贝，所以也不存在后续影响的问题。</p><h4 id="4-给属性成员变量的赋值"><a href="#4-给属性成员变量的赋值" class="headerlink" title="4.给属性成员变量的赋值"></a>4.给属性成员变量的赋值</h4><p>上面的示例中，在给属性赋值时，使用的都是<code>self.属性 = xx</code>格式，而直接给属性的成员变量赋值时，即<code>_属性名 = xx</code>，需要特别注意：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *aStrongStr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *aCopyStr;<br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//用 NSMutableString 赋值</span><br>    <span class="hljs-built_in">NSMutableString</span> *oriStr = [<span class="hljs-built_in">NSMutableString</span> stringWithFormat:<span class="hljs-string">@&quot;A&quot;</span>];<br>    <br>    <span class="hljs-comment">//注意这里是给属性对应的成员变量赋值</span><br>    _aStrongStr = oriStr;<br>    _aCopyStr = oriStr;<br>    [oriStr setString:<span class="hljs-string">@&quot;B&quot;</span>];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++oriStr:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,oriStr,&amp;oriStr,oriStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Strong:  值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aStrongStr,&amp;_aStrongStr,_aStrongStr);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Copy:    值地址:%p,  对象地址:%p,  值:%@&quot;</span>,_aCopyStr,&amp;_aCopyStr,_aCopyStr);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">++oriStr:  值地址:<span class="hljs-number">0x60000101a760</span>,  对象地址:<span class="hljs-number">0x7ffee854ed68</span>,  值:B<br>++Strong:  值地址:<span class="hljs-number">0x60000101a760</span>,  对象地址:<span class="hljs-number">0x60000101e148</span>,  值:B<br>++Copy:    值地址:<span class="hljs-number">0x60000101a760</span>,  对象地址:<span class="hljs-number">0x60000101e150</span>,  值:B<br></code></pre></td></tr></table></figure><p>示例中是给属性对应的<code>成员变量</code>赋值的！虽然源字符串还是<code>NSMutableString</code>类型，但从打印的日志来看，<code>copy</code>修饰的属性并未做深拷贝，且它的值始终受到源字符串变化的影响。这是因为，以下划线开头的成员变量是ARC环境下，编译器自动帮我们添加的，给其赋值时，并不会触发属性的 setter，也就没有默认的<code>copy</code>操作，因此也就不会有<code>copy</code>效果~</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>属性修饰符</title>
    <link href="/2018/06/12/property.html"/>
    <url>/2018/06/12/property.html</url>
    
    <content type="html"><![CDATA[<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="1-retain："><a href="#1-retain：" class="headerlink" title="1.retain："></a>1.retain：</h4><p>类似于ARC下的 <code>strong</code>，表示强引用和持有的关系：将属性成员变量的指针指向源对象，同时持有源对象（此对象的引用计数会加1）。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//retain</span><br>-(void)setName:<span class="hljs-type"></span>(NSString *)<span class="hljs-keyword">new</span><span class="hljs-type">Name</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (_name != <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>) &#123;<br>        [<span class="hljs-keyword">new</span><span class="hljs-type">Name</span> retain];<br>        [_name release];<br>        _name = <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-assign："><a href="#2-assign：" class="headerlink" title="2.assign："></a>2.assign：</h4><p>类似于ARC下的 <code>weak</code>，表示弱引用和不持有的关系：将属性成员变量的指针指向源对象，但不持有源对象，不更改其引用计数，一般用于基本数据类型(<code>NSInteger</code>，<code>CGFloat</code>)和C类型、<code>int,float,double,bool</code>等，这些数值主要存在于栈上)。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//assign</span><br>-(void)setName:<span class="hljs-type"></span>(NSString *)<span class="hljs-keyword">new</span><span class="hljs-type">Name</span><br>&#123;<br>    _name = <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>weak 与 assign 的区别：</strong></p><p>1、修饰的对象</p><p><strong>assign</strong> 可修饰对象类型和基本类型，一般用于修饰基本类型。<strong>weak</strong> 只可以修饰对象类型，修饰基本数据类型时编译器会报错。</p><p>2、修饰对象类型时是否产生野指针</p><p><strong>weak</strong> 不会产生野指针问题：weak 修饰的对象释放后指针会自动被置nil，之后再向该对象发消息也不会崩溃。<strong>assign</strong> 修饰对象类型时可能会产生野指针问题：assign 修饰的象被释放后指针不会自动被置空，此时向对象发消息会崩溃。另外，如果assign只是修饰基本数据类型，则是安全的。</p><p>3、小结：<br>值类型会被放入栈中，遵循先进后出原则，由系统负责管理栈内存。而引用类型会被放入堆中，需要我们手动管理内存或通过ARC管理。<strong>weak</strong> 适用于 delegate 和 block 等引用类型，不会导致野指针问题，是安全的，可用于解决循环引用问题。<strong>assign</strong> 适用于基本数据类型，不适用于引用类型。</p><h4 id="3-copy："><a href="#3-copy：" class="headerlink" title="3.copy："></a>3.copy：</h4><p>表示拷贝和持有：会在内存中拷贝一份源对象，并将属性对应的成员变量的指针指向此拷贝出的新对象，新对象的引用计数 &#x3D; 1。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe">-(void)setName:<span class="hljs-type"></span>(NSString *)<span class="hljs-keyword">new</span><span class="hljs-type">Name</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (_name != <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>) &#123;<br>        [_name release];<br>        _name = [<span class="hljs-keyword">new</span><span class="hljs-type">Name</span> copy];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与 strong 的区别在于：<code>strong</code> 修饰的变量与原对象指向同一片内存空间，对变量的修改会影响到源对象。而<code>copy</code> 修饰的对象与源对象指向两片不同的内存空间，变量与原对象两者互不影响。</p><h4 id="4-readwrite："><a href="#4-readwrite：" class="headerlink" title="4.readwrite："></a>4.readwrite：</h4><p>编译器自动为属性创建 setter&#x2F;getter 方法。</p><h4 id="5-readonly："><a href="#5-readonly：" class="headerlink" title="5.readonly："></a>5.readonly：</h4><p>编译器只为属性创建 getter 方法。</p><p>属性被声明为只读时，可以同时重写属性的<code>getter</code>与<code>setter</code> 使其变为 readwrite。</p><h4 id="6-nonatomic："><a href="#6-nonatomic：" class="headerlink" title="6.nonatomic："></a>6.nonatomic：</h4><p>nonatomic 修饰的对象不保证<code>setter</code>和<code>getter</code>的完整性，多线程中访问它时可能会返回未初始化的对象。它比<code>atomic</code>快，但它不是线程安全的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// @property(nonatomic, <span class="hljs-keyword">copy</span>) NSString *<span class="hljs-type">name</span>;<br>- (NSString *)<span class="hljs-type">name</span> <br>&#123;<br>    <span class="hljs-keyword">return</span> _name;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)setName:(NSString *)newName <br>&#123;<br>    [_name <span class="hljs-keyword">release</span>];<br>    _name = [newName <span class="hljs-keyword">copy</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-atomic："><a href="#7-atomic：" class="headerlink" title="7.atomic："></a>7.atomic：</h4><p>atomic 修饰的对象会保证<code>setter</code>和<code>getter</code>的完整性，任何线程对其访问都可以得到一个完整的初始化后的对象。例如有多个线程同时调用<code>setter</code>，不会出现某个线程执行完<code>setter</code>全部语句之前，另一个线程开始执行<code>setter</code>情况，相当于函数头尾加了锁一样。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// @property(atomic, copy) NSString *name;</span><br>- (<span class="hljs-built_in">NSString</span> *)name <br>&#123;<br>    <span class="hljs-keyword">@synchronized</span>(<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">return</span> _name;<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)newName <br>&#123;<br>    <span class="hljs-keyword">@synchronized</span>(<span class="hljs-keyword">self</span>) &#123;<br>      [_name release];<br>      _name = [newName <span class="hljs-keyword">copy</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为要保证操作完成，所以速度慢。它比<code>nonatomic</code>安全，但也并不是绝对的线程安全，例如多个线程同时调用<code>set</code>和<code>get</code>就会导致获得的对象值不一样甚至发生崩溃。绝对的线程安全就要用到线程的同步机制，比如使用<code>NSLock</code>、<code>@synchronized</code>等加锁。</p><h4 id="8-默认值"><a href="#8-默认值" class="headerlink" title="8.默认值"></a>8.默认值</h4><p>基本数据类型的默认关键字是：<code>atomic</code>、<code>readwrite</code>、<code>assign</code>；</p><p>属性的默认关键字是：<code>atomic</code>、<code>readwrite</code>、<code>strong</code>。</p><h3 id="Getter与Setter"><a href="#Getter与Setter" class="headerlink" title="Getter与Setter"></a>Getter与Setter</h3><h4 id="dynamic"><a href="#dynamic" class="headerlink" title="@dynamic"></a>@dynamic</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">@<span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span>;<br></code></pre></td></tr></table></figure><p>@dynamic：告诉编译器，属性的<code>getter</code>和<code>setter</code>由我们自己实现，不需要编译器自动生成。如果我们将属性标记为<code>@dynamic var;</code>而又没有提供对应的<code>getter</code>与<code>setter</code>时，编译期是不会报错，但在运行期如果访问属性或者给属性赋值时则会报错并崩溃，因为运行时找不到对应的<code>getter</code>和<code>setter</code>去完成这两个操作。</p><h4 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a>@synthesize</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@syntheszie</span> <span class="hljs-keyword">var</span>;<br></code></pre></td></tr></table></figure><p>@synthesize：告诉编译器，在编译期用我指定的成员变量实现属性的<code>getter</code>和<code>setter</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSArray</span> *anArr;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><span class="hljs-comment">//@dynamic anArr;</span><br><span class="hljs-keyword">@synthesize</span> anArr;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">self</span>.anArr = @[<span class="hljs-string">@&quot;Hello&quot;</span>];<br>    <span class="hljs-built_in">NSString</span> *str = <span class="hljs-keyword">self</span>.anArr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上面访问属性时使用的都是<code>self.anArr</code>，这时如果使用<code>_anArr</code>会报错，因为<code>@synthesize anArr;</code>只创建了成员变量<code>anArr</code>并绑定到属性<code>anArr</code>上。所以需要我们使用<code>@synthesize anArr = _anArr</code>来让编译器帮我们创建成员变量<code>_anArr</code>并将其绑定到属性上。</p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>iOS5之后，如果<code>@synthesize</code>和<code>@dynamic</code>都没写，那么属性默认是<code>@syntheszie var = _var</code>;</p><hr><p>相关参考：</p><p>#<a href="https://xiaozhuanlan.com/topic/3908156472">©故胤道长</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理：AutoreleasePool</title>
    <link href="/2018/05/21/autoreleasepool.html"/>
    <url>/2018/05/21/autoreleasepool.html</url>
    
    <content type="html"><![CDATA[<h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><h4 id="1-retain-x2F-release"><a href="#1-retain-x2F-release" class="headerlink" title="1.retain&#x2F;release"></a>1.retain&#x2F;release</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NSObject</span></span><br><span class="hljs-comment">//...</span><br>- (<span class="hljs-keyword">instancetype</span>)<span class="hljs-keyword">retain</span> OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-keyword">oneway</span> <span class="hljs-type">void</span>)release OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-keyword">instancetype</span>)autorelease OBJC_ARC_UNAVAILABLE;<br>- (<span class="hljs-built_in">NSUInteger</span>)retainCount OBJC_ARC_UNAVAILABLE;<br><br>- (<span class="hljs-keyword">struct</span> _NSZone *)zone OBJC_ARC_UNAVAILABLE;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在MRC时代，对象的生命周期是通过引用计数来管理的，我们需要通过频繁地手动添加<code>retain</code>来使引用计数 +1，通过<code>release</code>来使引用计数 -1，当对象的引用计数为 0 时，对象会被销毁。</p><p>#示例1：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe">- (void)setName:<span class="hljs-type"></span>(NSString *)<span class="hljs-keyword">new</span><span class="hljs-type">Name</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (_name != <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>) &#123;<br>        [<span class="hljs-keyword">new</span><span class="hljs-type">Name</span> retain]<span class="hljs-comment">//引用计数+1，强引用新值</span><br>        [_name release];<span class="hljs-comment">//引用计数-1，释放旧值</span><br>        _name = <span class="hljs-keyword">new</span><span class="hljs-type">Name</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的管理方式不仅比较繁琐，而且可能会因为疏忽大意而导致内存泄露或过度释放情况的发生。比如示例1中，我们是先通过<code>retain</code>使<code>newName</code>引用计数 +1，再通过<code>release</code>使引用计数 -1。如果这两者顺序颠倒，则就可能出问题。假设<code>newName</code>和_name 的旧值是同一个对象，那么先<code>release</code>旧值就会使旧值的引用计数为0，从而导致对象被提前释放，后面再赋值给_name 就无效。</p><h4 id="2-自动释放池"><a href="#2-自动释放池" class="headerlink" title="2.自动释放池"></a>2.自动释放池</h4><p>与 release 相比，<code>autorelease</code>算是一种延迟对象释放时间的方式。它需要配合 autorelease pool(自动释放池)使用，我们只需要将对象标记为<code>autorelease</code>，这样对象就会被自动加入到自动释放池中；自动释放池会在合适的时机自动或手动执行<code>drain</code>方法进行销毁；销毁前会向其内部的这些对象发送<code>release</code>消息，从而使对象的引用计数-1；当引用计数为 0 时，对象的内存空间就会被释放。一个对象可以被多次放入到同一个自动释放池内，并且每次放入池内时都会调用一次<code>release</code>方法。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">NSDictionary *dic = <span class="hljs-comment">[<span class="hljs-comment">[<span class="hljs-comment">[NSDictionary alloc]</span> init]</span> autorelease]</span>;<br></code></pre></td></tr></table></figure><p>自动释放池在 MRC 和 ARC 中有不同的形式和使用方法：</p><ul><li>MRC 中的 NSAutoreleasePool</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NSAutoreleasePool</span> <span class="hljs-operator">*</span>pool <span class="hljs-operator">=</span> [[<span class="hljs-type">NSAutoreleasePool</span> alloc] <span class="hljs-keyword">init</span>];<br><span class="hljs-comment">// Code benefitting from a local autorelease pool.</span><br>[pool release];<br></code></pre></td></tr></table></figure><ul><li>ARC 中的 @autoreleasepool{}</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@autoreleasepool</span> &#123;<br>    // <span class="hljs-selector-tag">Code</span> benefitting <span class="hljs-selector-tag">from</span> <span class="hljs-selector-tag">a</span> local autorelease pool.<br>&#125;<br></code></pre></td></tr></table></figure><p>在ARC环境下，我们不能直接使用 NSAutoreleasePool 对象，而要使用后者。根据 <a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=objc">开发文档</a> 的描述，后者的效率更高。</p><h4 id="3-pool的创建"><a href="#3-pool的创建" class="headerlink" title="3.pool的创建"></a>3.pool的创建</h4><h5 id="3-1-自动"><a href="#3-1-自动" class="headerlink" title="3.1.自动"></a>3.1.自动</h5><p>大部分情况下，系统已经为我们创建了自动释放池，并不需要我们自己创建。那么系统是什么时候帮我们创建的自动释放池呢。。。？这就要结合 runloop 来分析，下面这段内容是应用执行到didFinishLaunchingWithOptions时，通过 po [NSRunLoop currentRunLoop] 打印的当前runloop的信息：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs xquery">po [NSRunLoop currentRunLoop]<br>&lt;CFRunLoop <span class="hljs-number">0x600001cb0100</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;wakeup port = <span class="hljs-number">0x1f07</span>, stopped =<span class="hljs-built_in"> false</span>, ignoreWakeUps =<span class="hljs-built_in"> false</span>, <br>current mode = kCFRunLoopDefaultMode,<br>common modes = &lt;CFBasicHash <span class="hljs-number">0x600002ef2910</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">2</span>,<br>entries =&gt;<br>    <span class="hljs-number">0</span> : &lt;CFString <span class="hljs-number">0x116ab9be0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;contents = <span class="hljs-string">&quot;UITrackingRunLoopMode&quot;</span>&#125;<br>    <span class="hljs-number">2</span> : &lt;CFString <span class="hljs-number">0x10bef8168</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;contents = <span class="hljs-string">&quot;kCFRunLoopDefaultMode&quot;</span>&#125;<br>&#125;<br>,<br>common mode items = &lt;CFBasicHash <span class="hljs-number">0x600002e81da0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">13</span>,<br>entries =&gt;<br>    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;&#125;<br>    <span class="hljs-number">1</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0540</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000015b5080</span>, callout = __handleEventQueue (<span class="hljs-number">0x116270912</span>)&#125;&#125;<br>    <span class="hljs-number">2</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b1f80</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = Yes, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000004b1680</span>, callout = FBSSerialQueueRunLoopSourceHandler (<span class="hljs-number">0x118c99f0b</span>)&#125;&#125;<br>    <span class="hljs-number">3</span> : &lt;CFRunLoopObserver <span class="hljs-number">0x6000011b0c80</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0x1161aedfc</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;<br>    <span class="hljs-number">4</span> : &lt;CFRunLoopObserver <span class="hljs-number">0x6000011b0be0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0x1</span>, repeats = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (<br>    <span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;</span><br><span class="language-xml">)&#125;&#125;</span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0b40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0x1161aee75</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span><span class="language-xml"></span><br><span class="language-xml">    6 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0aa0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (</span><br><span class="language-xquery">    <span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;</span></span><br><span class="language-xml"><span class="language-xquery">)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    7 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0cc0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    13 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0e40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">13583</span>, subsystem = <span class="hljs-number">0x116a53448</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x0</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    14 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x600002e81830</span>, callout = __handleHIDEventFetcherDrain (<span class="hljs-number">0x11627091e</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    15 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b05a0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0x1117046ae</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x0</span>&gt;&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">    18 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b4480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">42499</span>, subsystem = <span class="hljs-number">0x116a654b0</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x6000020acb80</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    21 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b4640</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x20</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x600000bb5a40</span>&gt;&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">modes = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002ef2850</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">4</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">2</span> : &lt;CFRunLoopMode <span class="hljs-number">0x600001bb4270</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;<span class="hljs-built_in">&#123;name</span> = UITrackingRunLoopMode, port set = <span class="hljs-number">0x5103</span>, queue = <span class="hljs-number">0x600000eb5500</span>, source = <span class="hljs-number">0x600000eb5600</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0x5003</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = &lt;CFBasicHash <span class="hljs-number">0x600002e81e30</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">4</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    4 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0540</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000015b5080</span>, callout = __handleEventQueue (<span class="hljs-number">0x116270912</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b1f80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = Yes, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000004b1680</span>, callout = FBSSerialQueueRunLoopSourceHandler (<span class="hljs-number">0x118c99f0b</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    6 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x600002e81830</span>, callout = __handleHIDEventFetcherDrain (<span class="hljs-number">0x11627091e</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    sources1 = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002e81e60</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">3</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0e40</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">13583</span>, subsystem = <span class="hljs-number">0x116a53448</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x0</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    1 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b4480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">42499</span>, subsystem = <span class="hljs-number">0x116a654b0</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x6000020acb80</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    2 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0cc0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    observers = (</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0be0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x1</span>, repeats = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b4640</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x20</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x600000bb5a40</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0c80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0x1161aedfc</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b05a0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0x1117046ae</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0b40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0x1161aee75</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0aa0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;</span><br><span class="language-xml">),</span><br><span class="language-xml">    timers = (null),</span><br><span class="language-xml">    currently 563029792 (7903325957143) / soft deadline in: 1.84467362e+10 sec (@ -1) / hard deadline in: 1.84467362e+10 sec (@ -1)</span><br><span class="language-xml">&#125;,</span><br><span class="language-xml"></span><br><span class="language-xml">    3 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopMode</span> <span class="hljs-attr">0x600001bb4340</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> = GSEventReceiveRunLoopMode, port set = <span class="hljs-number">0x2e03</span>, queue = <span class="hljs-number">0x600000eb5680</span>, source = <span class="hljs-number">0x600000eb5780</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0x4e03</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = &lt;CFBasicHash <span class="hljs-number">0x600002e81ef0</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    sources1 = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002e81f20</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">2</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0f00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    observers = (null),</span><br><span class="language-xml">    timers = (null),</span><br><span class="language-xml">    currently 563029792 (7903327601583) / soft deadline in: 1.84467362e+10 sec (@ -1) / hard deadline in: 1.84467362e+10 sec (@ -1)</span><br><span class="language-xml">&#125;,</span><br><span class="language-xml"></span><br><span class="language-xml">    4 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopMode</span> <span class="hljs-attr">0x600001bb04e0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> = kCFRunLoopDefaultMode, port set = <span class="hljs-number">0x210b</span>, queue = <span class="hljs-number">0x600000eb1500</span>, source = <span class="hljs-number">0x600000eb1600</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0x1d07</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = &lt;CFBasicHash <span class="hljs-number">0x600002e81e90</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">4</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b5e00</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x0</span>, callout = PurpleEventSignalCallback (<span class="hljs-number">0x110820188</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    4 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0540</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000015b5080</span>, callout = __handleEventQueue (<span class="hljs-number">0x116270912</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b1f80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = Yes, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x6000004b1680</span>, callout = FBSSerialQueueRunLoopSourceHandler (<span class="hljs-number">0x118c99f0b</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    6 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">0</span>, info = <span class="hljs-number">0x600002e81830</span>, callout = __handleHIDEventFetcherDrain (<span class="hljs-number">0x11627091e</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    sources1 = <span class="hljs-tag">&lt;<span class="hljs-name">CFBasicHash</span> <span class="hljs-attr">0x600002e81ec0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable set,<span class="hljs-built_in"> count</span> = <span class="hljs-number">3</span>,</span></span><br><span class="language-xquery"><span class="language-xquery">entries =&gt;</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopSource <span class="hljs-number">0x6000015b0e40</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">13583</span>, subsystem = <span class="hljs-number">0x116a53448</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x0</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    1 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b4480</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource MIG Server&gt; &#123;port = <span class="hljs-number">42499</span>, subsystem = <span class="hljs-number">0x116a654b0</span>, <span class="hljs-keyword">context</span> = <span class="hljs-number">0x6000020acb80</span>&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">    2 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopSource</span> <span class="hljs-attr">0x6000015b0cc0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;signalled = No, valid = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">1</span>, <span class="hljs-keyword">context</span> = &lt;CFRunLoopSource <span class="hljs-keyword">context</span>&gt;&#123;version = <span class="hljs-number">1</span>, info = <span class="hljs-number">0x2f03</span>, callout = PurpleEventCallback (<span class="hljs-number">0x110820194</span>)&#125;</span></span><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">,</span><br><span class="language-xml">    observers = (</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0be0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x1</span>, repeats = Yes, <span class="hljs-keyword">order</span> = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b4640</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0x20</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x600000bb5a40</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0c80</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0x1161aedfc</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b05a0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0x1117046ae</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0b40</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0x1161aee75</span>), <span class="hljs-keyword">context</span> = &lt;CFRunLoopObserver <span class="hljs-keyword">context</span> <span class="hljs-number">0x7ffe6b7018e0</span>&gt;&#125;</span></span><span class="language-xml">&quot;,</span><br><span class="language-xml">    &quot;<span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopObserver</span> <span class="hljs-attr">0x6000011b0aa0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;valid = Yes, activities = <span class="hljs-number">0xa0</span>, repeats = Yes, <span class="hljs-keyword">order</span> = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0x11617f1b1</span>), <span class="hljs-keyword">context</span> = &lt;CFArray <span class="hljs-number">0x600002efc360</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (\n\t<span class="hljs-number">0</span> : <span class="language-xml">&lt;0x7ffe6c009058&gt;\n)&#125;</span></span></span><span class="language-xml">&#125;&quot;</span><br><span class="language-xml">),</span><br><span class="language-xml">    timers = <span class="hljs-tag">&lt;<span class="hljs-name">CFArray</span> <span class="hljs-attr">0x6000004b7360</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery">&#123;type = mutable-small,<span class="hljs-built_in"> count</span> = <span class="hljs-number">1</span>, values = (</span></span><br><span class="language-xquery"><span class="language-xquery">    <span class="hljs-number">0</span> : &lt;CFRunLoopTimer <span class="hljs-number">0x6000015b5440</span> [<span class="hljs-number">0x10bee2b68</span>]&gt;&#123;valid = Yes, firing = No, interval = <span class="hljs-number">0</span>, tolerance = <span class="hljs-number">0</span>, <span class="hljs-keyword">next</span> fire date = <span class="hljs-number">563029756</span> (-<span class="hljs-number">36.444778</span> @ <span class="hljs-number">7866885955998</span>), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (<span class="hljs-number">0x10ac9327d</span> / <span class="hljs-number">0x115810fb9</span>) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore), <span class="hljs-keyword">context</span> = &lt;CFRunLoopTimer <span class="hljs-keyword">context</span> <span class="hljs-number">0x6000035f3a40</span>&gt;&#125;</span></span><span class="language-xml"></span><br><span class="language-xml">)&#125;,</span><br><span class="language-xml">    currently 563029792 (7903327672130) / soft deadline in: 1.8446744e+10 sec (@ 7866885955998) / hard deadline in: 1.8446744e+10 sec (@ 7866885955998)</span><br><span class="language-xml">&#125;,</span><br><span class="language-xml"></span><br><span class="language-xml">    5 : <span class="hljs-tag">&lt;<span class="hljs-name">CFRunLoopMode</span> <span class="hljs-attr">0x600001bb08f0</span> [<span class="hljs-attr">0x10bee2b68</span>]&gt;</span></span><span class="language-xquery"><span class="language-xquery"><span class="hljs-built_in">&#123;name</span> = kCFRunLoopCommonModes, port set = <span class="hljs-number">0x3e0f</span>, queue = <span class="hljs-number">0x600000ebc400</span>, source = <span class="hljs-number">0x600000ebc500</span> <span class="hljs-built_in">(not</span> fired), timer port = <span class="hljs-number">0xa803</span>, </span></span><br><span class="language-xquery"><span class="language-xquery">    sources<span class="hljs-number">0</span> = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    sources1 = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    observers = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    timers = (null),</span></span><br><span class="language-xquery"><span class="language-xquery">    currently <span class="hljs-number">563029792</span> (<span class="hljs-number">7903329641921</span>) / soft deadline in: <span class="hljs-number">1.84467362</span>e+<span class="hljs-number">10</span> sec (@ -<span class="hljs-number">1</span>) / hard deadline in: <span class="hljs-number">1.84467362</span>e+<span class="hljs-number">10</span> sec (@ -<span class="hljs-number">1</span>)</span></span><br><span class="language-xquery"><span class="language-xquery">&#125;</span></span><span class="language-xml">,</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>以下是摘要，显示的是启动后系统在主线程的 Runloop 中自动添加的观察者：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">observers = (<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x6000011b0be0 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>x1, repeats = Yes, order = -<span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0</span>x<span class="hljs-number">11617f1b1</span>), context = &lt;CFArray <span class="hljs-number">0</span>x600002efc360 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;type = mutable-small, count = <span class="hljs-number">1</span>, values = (\n\t0 : &lt;<span class="hljs-number">0</span>x7ffe<span class="hljs-number">6c009058</span>&gt;\n)&#125;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b4640</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>x20, repeats = Yes, order = <span class="hljs-number">0</span>, callout = _UIGestureRecognizerUpdateObserver (<span class="hljs-number">0x115d51473</span>), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x600000bb5a40&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b0c80</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">1999000</span>, callout = _beforeCACommitHandler (<span class="hljs-number">0</span>x1161aedfc), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x7ffe<span class="hljs-number">6b7018e0</span>&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b05a0</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (<span class="hljs-number">0</span>x1117046ae), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x0&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x60<span class="hljs-number">00011b0b40</span> [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">2001000</span>, callout = _afterCACommitHandler (<span class="hljs-number">0</span>x1161aee75), context = &lt;CFRunLoopObserver context <span class="hljs-number">0</span>x7ffe<span class="hljs-number">6b7018e0</span>&gt;&#125;&quot;,<br>    &quot;&lt;CFRunLoopObserver <span class="hljs-number">0</span>x6000011b0aa0 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;valid = Yes, activities = <span class="hljs-number">0</span>xa0, repeats = Yes, order = <span class="hljs-number">2147483647</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="hljs-number">0</span>x<span class="hljs-number">11617f1b1</span>), context = &lt;CFArray <span class="hljs-number">0</span>x600002efc360 [<span class="hljs-number">0</span>x10bee2b68]&gt;&#123;type = mutable-small, count = <span class="hljs-number">1</span>, values = (\n\t0 : &lt;<span class="hljs-number">0</span>x7ffe<span class="hljs-number">6c009058</span>&gt;\n)&#125;&#125;&quot;<br>),<br></code></pre></td></tr></table></figure><p>其中第1和第6个观察者，两者的<code>activities</code>分别是<code>0x1</code>和<code>0xa0</code>。<code>activities</code>表示的是当前 runloop 所处的状态，下面是 CFRunloop.h 中定义的 activities 枚举值：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/* Run Loop Observer Activities */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">CF_OPTIONS</span>(<span class="hljs-built_in">CFOptionFlags</span>, <span class="hljs-built_in">CFRunLoopActivity</span>) &#123;<br>    kCFRunLoopEntry = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">0</span>),<br>    kCFRunLoopBeforeTimers = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">1</span>),<br>    kCFRunLoopBeforeSources = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">2</span>),<br>    kCFRunLoopBeforeWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">5</span>),<br>    kCFRunLoopAfterWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">6</span>),<br>    kCFRunLoopExit = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">7</span>),<br>    kCFRunLoopAllActivities = <span class="hljs-number">0x0FFFFFFF</span>U<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>activities &#x3D; 0x1，对应的就是 kCFRunLoopEntry；activities &#x3D; 0xa0，对应的就是 kCFRunLoopBeforeWaiting | kCFRunLoopExit。</p></blockquote><p>解释一下，<code>kCFRunLoopEntry</code>表示 runloop 已启动；<code>kCFRunLoopBeforeWaiting</code>表示 runloop 没事做了即将休眠；<code>kCFRunLoopExit</code>表示 runloop 已结束；从第1和第6个观察者的 callout 描述可以看到，它们的回调都是_wrapRunLoopWithAutoreleasePoolHandler，关于这个回调，目前我尚未查到其源码，它具体怎么实现自动释放池的创建和销毁暂不能一探究竟。按照网上各大博主的说法：</p><ul><li>在进入runloop时（kCFRunLoopEntry），观察者回调中会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li><li>在runloop即将休眠时（kCFRunLoopBeforeWaiting），观察者回调中会调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；</li><li>在runloop退出时（kCFRunLoopExit），观察者回调中会调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个观察者的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li></ul><p>虽然_wrapRunLoopWithAutoreleasePoolHandler的源码我暂时不得而知，但_objc_autoreleasePoolPush()和_objc_autoreleasePoolPop()的源码是可追踪的，后面的5.2小节中会具体讲解~</p><p><strong>小结：</strong>系统提供的自动释放池，其创建发生在两个时机：runloop启动时 和 runloop即将休眠时。</p><h5 id="3-2-手动"><a href="#3-2-手动" class="headerlink" title="3.2.手动"></a>3.2.手动</h5><p>绝大多数情况下，系统会帮我们自动创建和销毁自动释放池。但是，根据 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-SW5">开发文档</a> 的描述，以下场景下我们需要自己创建自动释放池：</p><ul><li>If you are writing a program that is not based on a UI framework, such as a command-line tool.</li></ul><p>如果你的项目不是基于UI framework的，比如命令行工具，则你需要自己创建自动释放池管理对象的生命周期。</p><ul><li>If you write a loop that creates many temporary objects.</li></ul><blockquote><p>You may use an autorelease pool block inside the loop to dispose of those objects before the next iteration. Using an autorelease pool block in the loop helps to reduce the maximum memory footprint of the application.</p></blockquote><p>就是说，当你的循环体内创建了大量的临时对象时，你需要在循环体内创建一个自动释放池，这样临时对象会被标记为 autorelease 并在下次循环之前销毁。 在循环体内使用自动释放池可以降低内存峰值。</p><p>#示例2：在一个模态弹出的界面的<code>viewDidLoad</code>方法中模拟一个循环体内大量创建临时变量的情况：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>        <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>            <span class="hljs-built_in">NSString</span> *string = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;ADFAFDSFNKFNASFSKJFNSFSDAFAOSJDSAFASFJDSJFIOWJFIOKALNFJASFASLKFLSAJFSLAFK&quot;</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是<strong>不使用</strong>自动释放池，反复弹出界面时的内存峰值状况图：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_WithoutPool.png" alt="不使用释放池"></p><p>这是<strong>使用</strong>自动释放池，反复弹出界面时的内存峰值状况图：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_WithPool.png" alt="使用释放池"></p><p>通过对比，可以清楚的看到，使用自动释放池时，即使创建了大量的临时对象，对象都能及时释放，内存的峰值也几乎没变化~</p><ul><li>If you spawn a secondary thread.</li></ul><blockquote><p>You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects.</p></blockquote><p>当你创建了一个子线程时，也需要在线程启动时主动创建一个自动释放池，否则会产生内存泄露。</p><p>#示例3：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSThread</span> *thread = [[[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onHandleThread) object:<span class="hljs-literal">nil</span>] autorelease];<br>        [thread start];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br>- (<span class="hljs-type">void</span>)onHandleThread<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        Person *person = [[[Person alloc] init] autorelease];<br>        person.name = <span class="hljs-string">@&quot;IOI&quot;</span>;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++子线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Person.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br>-(<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++PERSON IS DEALLOCED~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>注意，先将 Build Settings-&gt;Objective-C Automotic Reference Counting 选项设置为NO，禁用ARC。运行后，输出日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">+++++子线程:&lt;NSThread: <span class="hljs-number">0x600002bf8180</span>&gt;&#123;number = <span class="hljs-number">3</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++++PERSON <span class="hljs-keyword">IS</span> DEALLOCED~<br></code></pre></td></tr></table></figure><p>如日志所示，MRC环境下，在子线程中创建对象之后，使用 autorelease pool 并将对象标记为 autorelease，任务执行完成之后对象能正常释放。你也可以试着将 @autorelease{ } 块和 autorelease 去掉，运行之后对象不会销毁。</p><p><strong>需要注意的是</strong>，子线程中需要自己创建释放池的说法只针对MRC的环境。在ARC的环境下，我们在子线程中创建新的对象后，该对象是能自动释放的。可以将 Build Settings-&gt;Objective-C Automotic Reference Counting 选项设置为 YES，启用ARC，修改代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onHandleThread) object:<span class="hljs-literal">nil</span>];<br>    [thread start];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br>- (<span class="hljs-type">void</span>)onHandleThread<br>&#123;<br>    Person *person = [[Person alloc] init];<br>    person.name = <span class="hljs-string">@&quot;IOI&quot;</span>;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++子线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">+++++子线程:&lt;NSThread: <span class="hljs-number">0x600003d3f040</span>&gt;&#123;number = <span class="hljs-number">3</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++++PERSON <span class="hljs-keyword">IS</span> DEALLOCED~<br></code></pre></td></tr></table></figure><p>可以看到，ARC环境下，在子线程中创建了 Person 的实例对象，并且没有主动在子线程中添加释放池，但 person 对象最后确实销毁了。</p><p>那么为啥 ARC 环境下子线程中不使用自动释放池，临时对象也能释放呢？StackOverflow 的 <a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now">这篇帖子</a> 中有一种解释：</p><blockquote><p>The latest version of the runtime (646, which shipped with OS X 10.10 and iOS 8) does indeed add a pool if you perform an autorelease without a pool on the current thread. The previous version of the runtime (551.1, which came with OS X 10.9 and iOS 7), also did this.</p></blockquote><p>从 OSX 10.9 和 iOS7 开始，如果我们在线程中没有使用 autorelease pool，那么苹果会自动帮我们创建一个 pool 来释放对象，避免了内存泄露。我瞄了一眼这份<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/RevisionHistory.html#//apple_ref/doc/uid/20001607-CJBGIAGF">开发文档</a>的更新日志，上次更新时间竟还停留在 2012-07-17！下面是最新的 <a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 中的源码：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-built_in">id</span> autorelease(<span class="hljs-built_in">id</span> obj)<br>    &#123;<br>        <span class="hljs-keyword">assert</span>(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>obj<span class="hljs-operator">-&gt;</span>isTaggedPointer());<br>        <span class="hljs-built_in">id</span> <span class="hljs-operator">*</span>dest __unused <span class="hljs-operator">=</span> autoreleaseFast(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>dest  <span class="hljs-operator">||</span>  dest <span class="hljs-operator">==</span> EMPTY_POOL_PLACEHOLDER  <span class="hljs-operator">||</span>  <span class="hljs-operator">*</span>dest <span class="hljs-operator">==</span> obj);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是 autorelease 方法底层实现的源码，在子线程中不创建自动释放池，直接将对象标记为 autorelease 时，会调用 autoreleaseFast()，参数为当前 autorelease 对象。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sas">static inline id <span class="hljs-comment">*autoreleaseFast(id obj)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        AutoreleasePoolPage *page = hotPage();</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">page</span> <span class="hljs-variable">&amp;&amp;</span> !<span class="hljs-keyword">page</span>-&gt;full()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">page</span>-&gt;<span class="hljs-keyword">add</span>(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">page</span>) &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseFullPage(obj, <span class="hljs-keyword">page</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>因为没有创建释放池，所以 autoreleaseFast() 内会直接进入最后一个判断语句中，接着调用 autoreleaseNoPage()，参数为 autorelease 对象。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">static</span> __attribute__((noinline))<br>    id *autoreleaseNoPage(id obj)<br>    &#123;<br>        <span class="hljs-comment">// &quot;No page&quot; could mean no pool has been pushed</span><br>        <span class="hljs-comment">// or an empty placeholder pool has been pushed and has no contents yet</span><br>        <span class="hljs-keyword">assert</span>(!hotPage());<br><br>        bool pushExtraBoundary = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;<br>            <span class="hljs-comment">// We are pushing a second pool over the empty placeholder pool</span><br>            <span class="hljs-comment">// or pushing the first object into the empty placeholder pool.</span><br>            <span class="hljs-comment">// Before doing that, push a pool boundary on behalf of the pool </span><br>            <span class="hljs-comment">// that is currently represented by the empty placeholder.</span><br>            pushExtraBoundary = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing an object with no pool in place, </span><br>            <span class="hljs-comment">// and no-pool debugging was requested by environment.</span><br>            _objc_inform(<span class="hljs-string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br>                         <span class="hljs-string">&quot;autoreleased with no pool in place - &quot;</span><br>                         <span class="hljs-string">&quot;just leaking - break on &quot;</span><br>                         <span class="hljs-string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, <br>                         pthread_self(), (<span class="hljs-keyword">void</span>*)obj, object_getClassName(obj));<br>            objc_autoreleaseNoPool(obj);<br>            <span class="hljs-keyword">return</span> nil;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing a pool with no pool in place,</span><br>            <span class="hljs-comment">// and alloc-per-pool debugging was not requested.</span><br>            <span class="hljs-comment">// Install and return the empty pool placeholder.</span><br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">setEmptyPoolPlaceholder</span><span class="hljs-params">()</span></span>;<br>        &#125;<br><br>        <span class="hljs-comment">// We are pushing an object or a non-placeholder&#x27;d pool.</span><br><br>        <span class="hljs-comment">// Install the first page.创建page </span><br>        AutoreleasePoolPage *page = <span class="hljs-keyword">new</span> AutoreleasePoolPage(nil);<br>        setHotPage(page); <span class="hljs-comment">//设置为当前正在使用的 pool</span><br>        <br>        <span class="hljs-comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br>        <span class="hljs-keyword">if</span> (pushExtraBoundary) &#123;<br>            page-&gt;add(POOL_BOUNDARY);<br>        &#125;<br>        <br>        <span class="hljs-comment">// Push the requested object or pool.</span><br>        <span class="hljs-keyword">return</span> page-&gt;add(obj);<br>    &#125;<br></code></pre></td></tr></table></figure><p>进入函数后，因为没设置释放池，所以 haveEmptyPoolPlaceholder() 返回 false；又因为传进来的 obj 参数是 autorelease 对象而非 POOL_BOUNDARY(边界对象)，所以会直接创建 page 并将其设置为当前正在使用的 pool；随后将 autorelease 对象加入自动释放池的栈顶；在当前线程结束后 pool 会出栈，其中的 autorelease 对象也会随之释放。</p><p>可见，<strong>ARC环境下苹果已经更改了实现，子线程中会帮我们创建自动释放池，只是文档未更新</strong>。</p><h4 id="4-pool的销毁"><a href="#4-pool的销毁" class="headerlink" title="4.pool的销毁"></a>4.pool的销毁</h4><p>在 3.1 小节中讲过，自动释放池的销毁时机主要有两个：runloop即将进入休眠时 和 runloop退出时~</p><ul><li>AppKit 与自动释放池</li></ul><blockquote><p>AppKit and UIKit frameworks process each event-loop iteration (such as a mouse down event or a tap) within an autorelease pool block. Therefore you typically do not have to create an autorelease pool block yourself, or even see the code that is used to create one.</p></blockquote><p>在事件循环(event-loop)开始时，AppKit 和 UIKit 会在主线程中创建一个自动释放池，不需要我们手动创建。当事件循环结束时，自动释放池会执行 drain 并销毁。</p><ul><li>线程与自动释放池</li></ul><p>每个线程(包括主线程)都维护着自己的<code>自动释放池栈</code>，新创建的 pool 会被 push 到栈顶，当 pool 销毁时它会 pop 出栈。当前线程中被标记为 autorelease 的对象会被加入到栈顶的 pool 内。当线程销毁时，与当前线程相关的 pool 也都会通过 drain 自动销毁。</p><h4 id="5-结构与源码"><a href="#5-结构与源码" class="headerlink" title="5.结构与源码"></a>5.结构与源码</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   Autorelease pool implementation</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"></span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   A thread&#x27;s autorelease pool is a stack of pointers. </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   Each pointer is either an object to release, or POOL_BOUNDARY which is </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     an autorelease pool boundary.</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   A pool token is a pointer to the POOL_BOUNDARY for that pool. When </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     the pool is popped, every object hotter than the sentinel is released.</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   The stack is divided into a doubly-linked list of pages. Pages are added </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     and deleted as necessary. </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">   Thread-local storage points to the hot page, where newly autoreleased </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">     objects are stored. </span></span><br><span class="hljs-emphasis"><span class="hljs-strong">*</span>**</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*/</span></span><br></code></pre></td></tr></table></figure><p>这是 <a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 源码中对 autorelease pool 的描述。它明确指出：</p><ul><li>autorelease pool 是一个保存着指针的栈，此栈由一个双向的 pages(AutoreleasePoolPage) 链表组成，链表会在需要时被添加和删除；</li><li>栈内指针指向的对象有两种：一种是被标记为 autorelease 而待 release 的对象；另一种是表示 pool 边界的哨兵对象(POOL_BOUNDARY)；</li><li>当 pool 被销毁而出栈时，哨兵对象前面的所有 autorelease 对象都会收到 release 消息而释放。</li></ul><h5 id="5-1-栈与链表"><a href="#5-1-栈与链表" class="headerlink" title="5.1.栈与链表"></a>5.1.栈与链表</h5><p>这里我们先讲一下上面提到的链表。Autorelease pool 并没有单独的结构体，它由若干个<code>AutoreleasePoolPage</code>以双向链表的形式组合而成。<a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 中有关于 AutoreleasePoolPage 的定义，成员变量部分摘要如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoreleasePoolPage</span> &#123;<br>    <span class="hljs-type">magic_t</span> <span class="hljs-type">const</span> magic;<br>    id *next;<br>    <span class="hljs-type">pthread_t</span> <span class="hljs-type">const</span> thread;<br>    AutoreleasePoolPage * <span class="hljs-type">const</span> parent;<br>    AutoreleasePoolPage *child;<br>    <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> depth;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>thread，表示当前线程，每个线程中都有与之对应的 pool，线程启动时创建pool，线程销毁时 drain pool；</li><li>id *next，游标，指向栈顶最新 add 进来的 autorelease 对象的下一个位置。</li><li>parent，指向父 page；</li><li>child，指向子 page；</li></ul><p>每个线程中都有一个自动释放池的栈，栈内可能有一个或多个<code>AutoreleasePoolPage</code>对象；当将对象标记为<code>autorelease</code>时，此对象会被 add 到栈顶的 page 内；如果此 page 已满，则会创建一个新的 page 作为 <code>child</code>，新 page 的<code>next</code>指针被初始化在栈底；标记为 autorelease 的对象会被 add 到这个新建的 page 内；文字不如图表，这里借用博主 <a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">©sunnyxx</a> 的一张图能更清晰的看到添加 autorelease 对象后 page 的结构：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_add_autoreleaseObj.jpg" alt="image"></p><h5 id="5-2-pool的创建"><a href="#5-2-pool的创建" class="headerlink" title="5.2.pool的创建"></a>5.2.pool的创建</h5><p>上面对 autorelease pool 的栈结构在原理上有了一个简单的描述，那么在代码层上 pool 是如何被创建的呢？</p><p>#示例4：使用 @autoreleasepool{ } 来<code>手动</code>创建一个自动释放池</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    @autoreleasepool &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">void</span> (^ blk)(<span class="hljs-type">void</span>) = ^()&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;varable in block:%d&quot;</span>,count);<br>        &#125;;<br>        <span class="hljs-built_in">blk</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用Clang编译后得到的结果如下，这里只截取关键部分的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">extern <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-constructor">__declspec(<span class="hljs-params">dllimport</span>)</span> void<span class="hljs-operator"> * </span>objc<span class="hljs-constructor">_autoreleasePoolPush(<span class="hljs-params">void</span>)</span>;<br>extern <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-constructor">__declspec(<span class="hljs-params">dllimport</span>)</span> void objc<span class="hljs-constructor">_autoreleasePoolPop(<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>;<br><br><span class="hljs-keyword">struct</span> __AtAutoreleasePool &#123;<br>  <span class="hljs-constructor">__AtAutoreleasePool()</span> &#123;atautoreleasepoolobj = objc<span class="hljs-constructor">_autoreleasePoolPush()</span>;&#125;<br>  ~<span class="hljs-constructor">__AtAutoreleasePool()</span> &#123;objc<span class="hljs-constructor">_autoreleasePoolPop(<span class="hljs-params">atautoreleasepoolobj</span>)</span>;&#125;<br>  void<span class="hljs-operator"> * </span>atautoreleasepoolobj;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, const <span class="hljs-built_in">char</span><span class="hljs-operator"> * </span>argv<span class="hljs-literal">[]</span>) &#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>        <span class="hljs-built_in">int</span> count = <span class="hljs-number">10</span>;<br>        void (* blk)(void) = ((void (*)<span class="hljs-literal">()</span>)&amp;<span class="hljs-constructor">__main_block_impl_0((<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, count));<br>        ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们声明的 count 和 block 变量及其调用，在编译后的结果中是被 {__AtAutoreleasePool…} 包裹着的。所以实际上，@autoreleasepool{ } 就是通过<code>__AtAutoreleasePool</code>来实现的，它是一个结构体，其定义中包含了：</p><ul><li>构造函数，负责pool的创建或入栈；</li><li>析构函数，负责pool的出栈、销毁；</li><li>一个通过析构函数创建的 atautoreleasepoolobj 对象的指针。</li></ul><p>构造函数和析构函数中分别调用了<code>objc_autoreleasePoolPush()</code>和<code>objc_autoreleasePoolPop()</code>，关于这两个函数，我们可以在 <a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/NSObject.mm.auto.html">NSObject.mm</a> 源码中追踪到其具体的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> *<span class="hljs-title function_">objc_autoreleasePoolPush</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">AutoreleasePoolPage</span>::<span class="hljs-title function_">push</span>();<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">objc_autoreleasePoolPop</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *ctxt</span>)<br>&#123;<br>    <span class="hljs-title class_">AutoreleasePoolPage</span>::<span class="hljs-title function_">pop</span>(ctxt);<br>&#125;<br><span class="hljs-keyword">void</span> *<span class="hljs-title function_">_objc_autoreleasePoolPush</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">objc_autoreleasePoolPush</span>();<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">_objc_autoreleasePoolPop</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *ctxt</span>)<br>&#123;<br>    <span class="hljs-title function_">objc_autoreleasePoolPop</span>(ctxt);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里注意，_objc_autoreleasePoolPush 和_objc_autoreleasePoolPop 正是在3.2小节的最后提到的那两个函数，也就是之前说的，主线程会在 Runloop<code>启动</code>和<code>即将休眠</code>时通过回调函数中调用_objc_autoreleasePoolPush()创建 pool，在<code>即将休眠</code>和<code>退出loop</code>时调用_objc_autoreleasePoolPop()释放 pool。这两个函数的内部也只是调用了 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop（注：函数名的开头不带下划线）。</p><p>因为本小节是介绍 pool 入栈，所以先只讲解 objc_autoreleasePoolPush 函数。它跟 pool 的创建和入栈有什么关系呢？<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-autoreleasepoolpush-void">Clang文档</a> 中有一段关于此函数的描述：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> *objc_autoreleasePoolPush(<span class="hljs-type">void</span>);<br>Creates a <span class="hljs-built_in">new</span> autorelease pool that <span class="hljs-keyword">is</span> enclosed <span class="hljs-keyword">by</span> the <span class="hljs-keyword">current</span> pool, makes that the <span class="hljs-keyword">current</span> pool, <span class="hljs-keyword">and</span> <span class="hljs-keyword">returns</span> an <span class="hljs-type">opaque</span> “handle” <span class="hljs-keyword">to</span> it.<br></code></pre></td></tr></table></figure><p>就是说，此函数就是用来创建 autorelease pool 并将其设置为当前 pool，它的内部的调用了<code>AutoreleasePoolPage::push()</code>函数：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-operator">*</span>push() <br>    &#123;<br>        <span class="hljs-built_in">id</span> <span class="hljs-operator">*</span>dest;<br>        <span class="hljs-keyword">if</span> (DebugPoolAllocation) &#123;<span class="hljs-comment">//调试模式</span><br>            <span class="hljs-comment">// Each autorelease pool starts on a new pool page.</span><br>            dest <span class="hljs-operator">=</span> autoreleaseNewPage(POOL_BOUNDARY);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dest <span class="hljs-operator">=</span> autoreleaseFast(POOL_BOUNDARY);<br>        &#125;<br>        <span class="hljs-keyword">assert</span>(dest <span class="hljs-operator">==</span> EMPTY_POOL_PLACEHOLDER <span class="hljs-operator">||</span> <span class="hljs-operator">*</span>dest <span class="hljs-operator">==</span> POOL_BOUNDARY);<br>        <span class="hljs-keyword">return</span> dest;<br>    &#125;<br></code></pre></td></tr></table></figure><p>if 语句第一个条件是针对调试模式，调试模式下每次自动释放池都会调用 autoreleaseNewPage() 方法，因为是第一次调用所以没有page，就创建一个新的 page。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">id *autorelease<span class="hljs-constructor">NewPage(<span class="hljs-params">id</span> <span class="hljs-params">obj</span>)</span><br>    &#123;<br>        AutoreleasePoolPage *page = hot<span class="hljs-constructor">Page()</span>;<br>        <span class="hljs-keyword">if</span> (page) return autorelease<span class="hljs-constructor">FullPage(<span class="hljs-params">obj</span>, <span class="hljs-params">page</span>)</span>;<br>        <span class="hljs-keyword">else</span> return autorelease<span class="hljs-constructor">NoPage(<span class="hljs-params">obj</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这是调试模式下的实现，我们不用关心它，我们只需要看<code>autoreleaseFast()</code>函数，其参数为<code>POOL_BOUNDARY</code>(注意这个参数，后面讲 autorelease 对象入栈时，会有对比)。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl">static inline id *autoreleaseFast(id obj)<br>    &#123;<br>        AutoreleasePoolPage *<span class="hljs-built_in">page</span> = hotPage();<span class="hljs-comment">//获取当前 pool 栈中正在使用的page</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span> &amp;&amp; !<span class="hljs-built_in">page</span>-&gt;</span>full()) &#123;<span class="hljs-comment">//如果当前有page且page没有满，则autorelease对象入栈</span><br>            <span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-built_in">page</span>-&gt;</span>add(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>) &#123;<span class="hljs-comment">//如果此page已经满了，则新建一个page并将此autorelease对象压入栈</span><br>            return autoreleaseFullPage(obj, <span class="hljs-built_in">page</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果没有page，则会创建一个空的占位池</span><br>            return autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br>static inline AutoreleasePoolPage *hotPage() <br>    &#123;<br>        AutoreleasePoolPage *result = (AutoreleasePoolPage *)<br>            tls_get_direct(key);<span class="hljs-comment">//通过线程局部存储(Thread Local Storage)获取当前正在使用的page</span><br>        <span class="hljs-keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) return <span class="hljs-literal">nil</span>;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (result) result-&gt;</span>fastcheck();<br>        return result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>autoreleaseFast() 函数中，hotPage()用来获取当前 pool 栈内正在使用的 page，首次调用<code>push()</code>时没有 page，所以会进入最后一个判断，调用 autoreleaseNoPage()函数来创建一个<code>空的占位池</code>。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">id *autoreleaseNoPage(id obj)<br>    &#123;<br>        <span class="hljs-comment">// &quot;No page&quot; could mean no pool has been pushed</span><br>        <span class="hljs-comment">// or an empty placeholder pool has been pushed and has no contents yet</span><br>        <span class="hljs-keyword">assert</span>(!hotPage());<br><br>        bool pushExtraBoundary = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//是否要 push 边界对象</span><br>        <span class="hljs-keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;<span class="hljs-comment">//如果有占位的 EMPTY_POOL_PLACEHOLDER，则设置需&quot;pushExtraBoundary=TRUE&quot;</span><br>            <span class="hljs-comment">// We are pushing a second pool over the empty placeholder pool</span><br>            <span class="hljs-comment">// or pushing the first object into the empty placeholder pool.</span><br>            <span class="hljs-comment">// Before doing that, push a pool boundary on behalf of the pool </span><br>            <span class="hljs-comment">// that is currently represented by the empty placeholder.</span><br>            pushExtraBoundary = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing an object with no pool in place, </span><br>            <span class="hljs-comment">// and no-pool debugging was requested by environment.</span><br>            _objc_inform(<span class="hljs-string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span><br>                         <span class="hljs-string">&quot;autoreleased with no pool in place - &quot;</span><br>                         <span class="hljs-string">&quot;just leaking - break on &quot;</span><br>                         <span class="hljs-string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, <br>                         pthread_self(), (<span class="hljs-keyword">void</span>*)obj, object_getClassName(obj));<br>            objc_autoreleaseNoPool(obj);<br>            <span class="hljs-keyword">return</span> nil;<br>        &#125;<br>        <span class="hljs-comment">//如果不是调试模式，且对象是边界对象，则去设置空的占位池，也就是 EMPTY_POOL_PLACEHOLDER</span><br>        <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation)</span> </span>&#123;<br>            <span class="hljs-comment">// We are pushing a pool with no pool in place,</span><br>            <span class="hljs-comment">// and alloc-per-pool debugging was not requested.</span><br>            <span class="hljs-comment">// Install and return the empty pool placeholder.</span><br>            <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">setEmptyPoolPlaceholder</span><span class="hljs-params">()</span></span>;<br>        &#125;<br><br>        <span class="hljs-comment">// We are pushing an object or a non-placeholder&#x27;d pool.</span><br><br>        <span class="hljs-comment">// Install the first page.创建第一个page</span><br>        AutoreleasePoolPage *page = <span class="hljs-keyword">new</span> AutoreleasePoolPage(nil);<br>        setHotPage(page);<span class="hljs-comment">//设置最新的page</span><br>        <br>        <span class="hljs-comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br>        <span class="hljs-keyword">if</span> (pushExtraBoundary) &#123;<br>            page-&gt;add(POOL_BOUNDARY);<br>        &#125;<br>        <br>        <span class="hljs-comment">// Push the requested object or pool.</span><br>        <span class="hljs-keyword">return</span> page-&gt;add(obj);<span class="hljs-comment">//添加一个对象</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>第一次进入此函数时，haveEmptyPoolPlaceholder()会返回 false，所以会进入最后一个判断，调用 setEmptyPoolPlaceholder():</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static inline id* set<span class="hljs-constructor">EmptyPoolPlaceholder()</span><br>    &#123;<br>        <span class="hljs-keyword">assert</span>(tls<span class="hljs-constructor">_get_direct(<span class="hljs-params">key</span>)</span><span class="hljs-operator"> == </span>nil);<br>        tls<span class="hljs-constructor">_set_direct(<span class="hljs-params">key</span>, (<span class="hljs-params">void</span> <span class="hljs-operator">*</span>)</span>EMPTY_POOL_PLACEHOLDER);<br>        return EMPTY_POOL_PLACEHOLDER;<br>    &#125;<br></code></pre></td></tr></table></figure><p>setEmptyPoolPlaceholder() 会通过 TLS 返回一个 EMPTY_POOL_PLACEHOLDER，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// EMPTY_POOL_PLACEHOLDER is stored in TLS when exactly one pool is </span><br><span class="hljs-comment">// pushed and it has never contained any objects. This saves memory </span><br><span class="hljs-comment">// when the top level (i.e. libdispatch) pushes and pops pools but </span><br><span class="hljs-comment">// never uses them.</span><br><span class="hljs-meta">#   <span class="hljs-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span><br></code></pre></td></tr></table></figure><p>EMPTY_POOL_PLACEHOLDER 是一个空的占位池，它存储在 TLS 中，不包含任何对象。</p><p>至此，执行 @autorelease{ }，第一次调用 push() 函数，最终创建了一个空的占位池~</p><h5 id="5-3-对象入栈"><a href="#5-3-对象入栈" class="headerlink" title="5.3.对象入栈"></a>5.3.对象入栈</h5><p>如果在 @autorelease block 内创建了对象，那么这些对象就会被自动标记为 autorelease，并加入到自动释放池中：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-built_in">id</span> autorelease(<span class="hljs-built_in">id</span> obj)<br>    &#123;<br>        <span class="hljs-keyword">assert</span>(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>obj<span class="hljs-operator">-&gt;</span>isTaggedPointer());<br>        <span class="hljs-built_in">id</span> <span class="hljs-operator">*</span>dest __unused <span class="hljs-operator">=</span> autoreleaseFast(obj);<br>        <span class="hljs-keyword">assert</span>(<span class="hljs-operator">!</span>dest  <span class="hljs-operator">||</span>  dest <span class="hljs-operator">==</span> EMPTY_POOL_PLACEHOLDER  <span class="hljs-operator">||</span>  <span class="hljs-operator">*</span>dest <span class="hljs-operator">==</span> obj);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br></code></pre></td></tr></table></figure><p>从函数实现的源码中可以看到，对象被标记为 autorelease 后，会调用 autoreleaseFast()。上面在介绍 pool 的创建时，已经介绍过这个函数，当时 autoreleaseFast 的参数是一个边界对象(哨兵)，这里的参数则是被标记为 autorelease 的对象本身：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xl">static inline id *autoreleaseFast(id obj)<br>    &#123;<br>        AutoreleasePoolPage *<span class="hljs-built_in">page</span> = hotPage();<span class="hljs-comment">//获取当前 pool 栈中正在使用的page</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span> &amp;&amp; !<span class="hljs-built_in">page</span>-&gt;</span>full()) &#123;<span class="hljs-comment">//如果当前有page且page没有满，则autorelease对象入栈</span><br>            <span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-built_in">page</span>-&gt;</span>add(obj);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>) &#123;<span class="hljs-comment">//如果此page已经满了，则新建一个page并将此autorelease对象压入栈</span><br>            return autoreleaseFullPage(obj, <span class="hljs-built_in">page</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果没有page，则会创建一个新的page并插入边界对象</span><br>            return autoreleaseNoPage(obj);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>进入函数体之后，会先调用 hotPage() 获取当前在用的page，</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">static</span> <span class="hljs-variable">inline</span> <span class="hljs-variable">AutoreleasePoolPage</span> *<span class="hljs-function"><span class="hljs-title">hotPage</span>() </span><br><span class="hljs-function">    &#123;</span><br><span class="hljs-function">        <span class="hljs-variable">AutoreleasePoolPage</span> *<span class="hljs-variable"><span class="hljs-class">result</span></span> = (<span class="hljs-variable">AutoreleasePoolPage</span> *)</span><br>            <span class="hljs-function"><span class="hljs-title">tls_get_direct</span>(<span class="hljs-variable">key</span>);</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> ((<span class="hljs-variable">id</span> *)<span class="hljs-variable"><span class="hljs-class">result</span></span> == <span class="hljs-variable">EMPTY_POOL_PLACEHOLDER</span>) <span class="hljs-variable">return</span> <span class="hljs-variable"><span class="hljs-literal">nil</span></span>;</span><br><span class="hljs-function">        <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-class">result</span></span>) <span class="hljs-variable"><span class="hljs-class">result</span></span>-&gt;<span class="hljs-title">fastcheck</span>();</span><br><span class="hljs-function">        <span class="hljs-variable">return</span> <span class="hljs-variable"><span class="hljs-class">result</span></span>;</span><br><span class="hljs-function">    &#125;</span><br></code></pre></td></tr></table></figure><p>当前是第一次调用 autorelease，栈中还没有创建好的page，只在5.2 小节中执行 @autorelease 时创建了一个 EMPTY_POOL_PLACEHOLDER(空的占位池)，所以 hotPage() 会返回 nil。因此 autoreleaseFast()函数会继续调用 autoreleaseNoPage()。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">id *autorelease<span class="hljs-constructor">NoPage(<span class="hljs-params">id</span> <span class="hljs-params">obj</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">assert</span>(!hot<span class="hljs-constructor">Page()</span>);<br><br>        <span class="hljs-built_in">bool</span> pushExtraBoundary = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (have<span class="hljs-constructor">EmptyPoolPlaceholder()</span>) &#123;<br>            pushExtraBoundary = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj != POOL_BOUNDARY<span class="hljs-operator">  &amp;&amp;  </span>DebugMissingPools) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">            </span>return nil;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj<span class="hljs-operator"> == </span>POOL_BOUNDARY<span class="hljs-operator">  &amp;&amp;  </span>!DebugPoolAllocation) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">            ...</span><br><span class="hljs-operator">            </span>return set<span class="hljs-constructor">EmptyPoolPlaceholder()</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Install the first page.</span><br>        AutoreleasePoolPage *page = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AutoreleasePoolPage(<span class="hljs-params">nil</span>)</span>;<br>        set<span class="hljs-constructor">HotPage(<span class="hljs-params">page</span>)</span>;<br>        <br>        <span class="hljs-comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span><br>        <span class="hljs-keyword">if</span> (pushExtraBoundary) &#123;<br>            page-&gt;add(POOL_BOUNDARY);<br>        &#125;<br>        <br>        <span class="hljs-comment">// Push the requested object or pool.</span><br>        return page-&gt;add(obj);<br>    &#125;<br></code></pre></td></tr></table></figure><p>因为之前在创建空的占位池时 autoreleaseNoPage()内调用了 setEmptyPoolPlaceholder()，所以这次 haveEmptyPoolPlaceholder() 会返回 true，进入第一个条件语句，pushExtraBoundary 被置为 true，所以最后创建了一个新的page，插入了边界对象，autorelease 对象入栈。</p><p>将对象压入栈时，会调用 add() 函数，首先解除保护；随后将对象插入到 page 中，并重新设置 next 指针；最后设置保护，返回值为当前 autorelease 对象下一位的索引。源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">id</span> *add(<span class="hljs-built_in">id</span> obj)<br>    &#123;<br>        <span class="hljs-keyword">assert</span>(!full());<br>        unprotect();<br>        <span class="hljs-built_in">id</span> *ret = <span class="hljs-built_in">next</span>;  // faster than `<span class="hljs-keyword">return</span> <span class="hljs-built_in">next</span>-<span class="hljs-number">1</span>` because of aliasing<br>        *<span class="hljs-built_in">next</span>++ = obj;//将对象压到栈顶，并重新定位栈顶<br>        protect();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure><p>至此，<strong>第一个 autorelease 对象完成入栈~</strong> </p><p>后面再有对象被标记为 autorelease 时，依然走 autoreleaseFast()，但这时 page 已经存在，如果 page 没满，则直接 page-&gt;add() 让对象入栈；如果page已满，则调用 autoreleaseFullPage()新建page，再让对象入栈；</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">static __attribute__((noinline))<br>    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *<span class="hljs-built_in">page</span>)<br>    &#123;<br>        <span class="hljs-comment">// The hot page is full. </span><br>        <span class="hljs-comment">// Step to the next non-full page, adding a new page if necessary.</span><br>        <span class="hljs-comment">// Then add the object to that page.</span><br>        assert(<span class="hljs-built_in">page</span> == hotPage());<br>        <span class="hljs-comment">//判断page-&gt;child是否存在</span><br>        <span class="hljs-function"><span class="hljs-title">assert</span>(<span class="hljs-built_in">page</span>-&gt;</span>full()  ||  DebugPoolAllocation);<br><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>) <span class="hljs-built_in">page</span> = <span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>;//存在<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>的话就将 <span class="hljs-built_in">page</span>置为<span class="hljs-built_in">page</span>-&gt;</span>child<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">page</span> = new AutoreleasePoolPage(<span class="hljs-built_in">page</span>);<span class="hljs-comment">////否则就去创建新的page</span><br>        &#125; <span class="hljs-function"><span class="hljs-title">while</span> (<span class="hljs-built_in">page</span>-&gt;</span>full());<br><br>        setHotPage(<span class="hljs-built_in">page</span>);<br>        <span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-built_in">page</span>-&gt;</span>add(obj);<br>    &#125;<br></code></pre></td></tr></table></figure><p>因为是栈式结构，所以先入栈的对象会在栈底，后入栈的对象则依次往栈顶的方向添加，具体可以参考 5.1 小节中的示意图。</p><h5 id="5-4-对象释放"><a href="#5-4-对象释放" class="headerlink" title="5.4.对象释放"></a>5.4.对象释放</h5><p>当 Runloop 即将进入休眠 和 Runloop 退出时，如线程执行完任务销毁时，autorelease pool 会 drain 并销毁，销毁前向其中保存着的 autorelease 对象依次发送 release 消息，从而释放对象。那么自动释放池的底层是如何释放对象的呢？</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs xl">void objc_autoreleasePoolPop(void *ctxt)<br>&#123;<br>    AutoreleasePoolPage::pop(ctxt);<br>&#125;<br><br>static inline void pop(void *token) <br>    &#123;<br>        AutoreleasePoolPage *<span class="hljs-built_in">page</span>;<br>        id *stop;<br><br>        <span class="hljs-comment">//如果是空的占位池</span><br>        <span class="hljs-keyword">if</span> (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123;<br>            <span class="hljs-comment">// Popping the top-level placeholder pool.</span><br>            <span class="hljs-keyword">if</span> (hotPage()) &#123;<br>                <span class="hljs-comment">// Pool was used. Pop its contents normally.</span><br>                <span class="hljs-comment">// Pool pages remain allocated for re-use as usual.</span><br>                <span class="hljs-function"><span class="hljs-title">pop</span>(coldPage()-&gt;</span>begin());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Pool was never used. Clear the placeholder.</span><br>                setHotPage(<span class="hljs-literal">nil</span>);<br>            &#125;<br>            return;<br>        &#125;<br><br>        <span class="hljs-built_in">page</span> = pageForPointer(token);<br>        stop = (id *)token;<br>        <span class="hljs-keyword">if</span> (*stop != POOL_BOUNDARY) &#123;<br>            <span class="hljs-comment">//不是边界对象的情况，如MRC环境中，在子线程中没使用@autorelease，而直接调用了autorelease，这时添加到pool的对象就不是 POOL_BOUNDARY</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (stop == <span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">begin</span>()  &amp;&amp;  !<span class="hljs-built_in">page</span>-&gt;</span>parent) &#123;<span class="hljs-comment">//栈底不是哨兵对象</span><br>                <span class="hljs-comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span><br>                <span class="hljs-comment">// 1. top-level pool is popped, leaving the cold page in place</span><br>                <span class="hljs-comment">// 2. an object is autoreleased with no pool </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Error. For bincompat purposes this is not </span><br>                <span class="hljs-comment">// fatal in executables built with old SDKs.</span><br>                return badPop(token);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (PrintPoolHiwat) printHiwat();<br><br>        <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>releaseUntil(stop);<span class="hljs-comment">//从栈顶开始向栈中的对象发送release消息，直到遇到第一个边界对象</span><br><br>        <span class="hljs-comment">// memory: delete empty children</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (DebugPoolAllocation  &amp;&amp;  <span class="hljs-built_in">page</span>-&gt;</span>empty()) &#123;<br>            <span class="hljs-comment">// special case: delete everything during page-per-pool debugging</span><br>            A<span class="hljs-function"><span class="hljs-title">utoreleasePoolPage</span> *parent = <span class="hljs-built_in">page</span>-&gt;</span>parent;<br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>kill();<br>            setHotPage(parent);<br>        &#125; <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (DebugMissingPools  &amp;&amp;  <span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">empty</span>()  &amp;&amp;  !<span class="hljs-built_in">page</span>-&gt;</span>parent) &#123;<br>            <span class="hljs-comment">// special case: delete everything for pop(top) </span><br>            <span class="hljs-comment">// when debugging missing autorelease pools</span><br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>kill();<br>            setHotPage(<span class="hljs-literal">nil</span>);<br>        &#125; <br>        <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>-&gt;</span>child) &#123;<br>            <span class="hljs-comment">// hysteresis: keep one empty child if page is more than half full</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-built_in">page</span>-&gt;</span>lessThanHalfFull()) &#123;<br>                <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span>kill();<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span>child) &#123;<br>                <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">child</span>-&gt;</span>kill();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>static AutoreleasePoolPage *pageForPointer(uintptr_t p) <br>    &#123;<br>        AutoreleasePoolPage *result;<br>        uintptr_t offset = p % SIZE;<br><br>        assert(offset &gt;= sizeof(AutoreleasePoolPage));<br><br>        result = (AutoreleasePoolPage *)(p - offset);<br>        <span class="hljs-function"><span class="hljs-title">result</span>-&gt;</span>fastcheck();<br><br>        return result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>objc_autoreleasePoolPop()即 Runloop 退出，自动释放池出栈时调用的函数。函数内会判断当前 token 是 EMPTY_POOL_PLACEHOLDER 还是 POOL_BOUNDARY 或者 autorelease 对象。如果是空的占位池，则清空占位池；如果栈底不是边界对象，则直接报错；其他情况，直接调用 releaseUntil()，释放对象。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xl">void releaseUntil(id *stop) <br>    &#123;<br>        <span class="hljs-comment">// Not recursive: we don&#x27;t want to blow out the stack </span><br>        <span class="hljs-comment">// if a thread accumulates a stupendous amount of garbage</span><br>        <br>        <span class="hljs-function"><span class="hljs-title">while</span> (this-&gt;</span>next != stop) &#123;<br>            <span class="hljs-comment">// Restart from hotPage() every time, in case -release </span><br>            <span class="hljs-comment">// autoreleased more objects</span><br>            AutoreleasePoolPage *<span class="hljs-built_in">page</span> = hotPage();<br><br>            <span class="hljs-comment">// fixme I think this `while` can be `if`, but I can&#x27;t prove it</span><br>            <span class="hljs-function"><span class="hljs-title">while</span> (<span class="hljs-built_in">page</span>-&gt;</span>empty()) &#123;<br>                <span class="hljs-function"><span class="hljs-title">page</span> = <span class="hljs-built_in">page</span>-&gt;</span>parent;<br>                setHotPage(<span class="hljs-built_in">page</span>);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>unprotect();<br>            <span class="hljs-function"><span class="hljs-title">id</span> obj = *--<span class="hljs-built_in">page</span>-&gt;</span>next;<br>            <span class="hljs-function"><span class="hljs-title">memset</span>((void*)<span class="hljs-built_in">page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>, SCRIBBLE, sizeof(*<span class="hljs-built_in">page</span>-&gt;</span>next));<br>            <span class="hljs-function"><span class="hljs-title">page</span>-&gt;</span>protect();<br><br>            <span class="hljs-keyword">if</span> (obj != POOL_BOUNDARY) &#123;<br>                objc_release(obj);<br>            &#125;<br>        &#125;<br><br>        setHotPage(this);<br><br>#<span class="hljs-keyword">if</span> DEBUG<br>        <span class="hljs-comment">// we expect any children to be completely empty</span><br>        <span class="hljs-function"><span class="hljs-title">for</span> (AutoreleasePoolPage *<span class="hljs-built_in">page</span> = child; <span class="hljs-built_in">page</span>; <span class="hljs-built_in">page</span> = <span class="hljs-built_in">page</span>-&gt;</span>child) &#123;<br>            <span class="hljs-function"><span class="hljs-title">assert</span>(<span class="hljs-built_in">page</span>-&gt;</span>empty());<br>        &#125;<br>#endif<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面章节中讲到，第一次将对象标记为 autorelease 时，在对象入栈前会往栈内插入一个边界对象(哨兵)，这些边界对象可以视为一个 pool 的开始。当 pool 需要释放对象时，会从栈顶开始，依次向栈底边界对象的方向清理掉这中间的所有 autorelease 对象，具体流程为：</p><ol><li>根据传入的哨兵对象地址找到哨兵对象所处的 page；</li><li>向当前 page 中晚于哨兵对象插入的所有 autorelease 对象发送 -release 消息；</li><li>回头移动 next 指针到正确位置；</li><li>从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page。</li></ol><p>以上，就是 MRC 中有关 retain，release，autorelease 和自动释放池相关的原理和具体的实现。</p><h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>ARC，自动引用计数是苹果在 iOS5 之后推出的新技术。使用ARC时，我们不再需要手动添加<code>retain</code>、<code>release</code>、<code>autorelease</code>这样的内存管理代码，编译器会在编译代码时自动帮我们添加。比如系统会自动帮我们在主线程 Runloop 中创建一个自动释放池，ARC下自动释放池内的对象会被自动标记为 autorelease，等 Runloop 退出时线程结束，pool被销毁，autorelease 对象就会 release。</p><p>ARC 不仅减少了开发者的麻烦，还避免了因为疏忽而导致的内存泄露或者过度释放等问题，我们只需要专注于自己的业务。</p><blockquote><p>ARC differs from tracing garbage collection in that there is no background process that deallocates the objects asynchronously at runtime.[3] Unlike garbage collection, ARC does not handle reference cycles automatically. This means that as long as there are “strong” references to an object, it will not be deallocated. Strong cross-references can accordingly create deadlocks and memory leaks. It is up to the developer to break cycles by using weak references.</p></blockquote><h4 id="2-ARC与GC"><a href="#2-ARC与GC" class="headerlink" title="2.ARC与GC"></a>2.ARC与GC</h4><p><code>ARC</code> <strong>!&#x3D;</strong> <code>垃圾回收机制</code>！</p><p>ARC 发生在<code>编译阶段</code>，它是LLVM 3.0 编译器中的新特性。ARC 环境中，编译器在代码<code>编译时</code>帮我们将对象标记为 autorelease、retain、release，我们无须再写这些内存管理的代码，只需要用<code>strong</code>或者<code>weak</code>表示你对对象的所有权，或者注意像循环强引用这种问题即可。</p><p>JAVA中的垃圾回收机制则是在<code>运行时</code>检查对象的依赖，如果没有指针指向某个对象，那么这个对象就是垃圾对象，到达一定量级后系统就会自动清除这些垃圾对象，或者由调用者主动调用GC清理~</p><p>作为对比来说，OC中的<code>引用计数</code>更靠近垃圾回收机制一些，即当对象的引用计数&#x3D;0时，就会自动调用对象的<code>dealloc</code>函数进行销毁。</p><h4 id="3-变量修饰符"><a href="#3-变量修饰符" class="headerlink" title="3.变量修饰符"></a>3.变量修饰符</h4><p>ARC下的四个变量修饰符：</p><ul><li>__strong</li></ul><p>对应属性修饰符中的<code>strong</code>，强引用，表示指针指向并拥有某个对象（引用计数+1）。这是声明对象时默认的修饰符，如果想释放强引用的对象，则将指针置为nil即可。ARC下当没有任何一个强引用指向对象时，对象才会销毁。</p><ul><li>__weak</li></ul><p>对应属性修饰符中的<code>weak</code>，弱引用，表示指向但不拥有某个对象（引用计数不变）。__weak 不会影响对象的释放，即只要没有强引用指向对象，即使有N个弱引用指向此对象，那么对象还是会销毁。对象被释放时，__weak 指针会被自动置为nil，不会引发野指针问题。</p><ul><li>__autoreleasing</li></ul><p>相当于MRC中的 autorelease，属性不能使用此修饰符。使用示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//ARC</span><br><span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span> __autoreleasing dic <span class="hljs-operator">=</span> [[<span class="hljs-type">NSDictionary</span> alloc] <span class="hljs-keyword">init</span>];<br><span class="hljs-comment">//MRC</span><br><span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span>dic <span class="hljs-operator">=</span> [[[<span class="hljs-type">NSDictionary</span> alloc] <span class="hljs-keyword">init</span>] autorelease];<br></code></pre></td></tr></table></figure><ul><li>__unsafe_unretained</li></ul><p>对应属性修饰符中的<code>unsafe_unretained</code>，相当于 MRC 中的<code>assign</code>，只是将指针指向某对象，不改变其引用计数，不影响其释放。之所以以<code>unsafe</code>开头，是因为当此对象被释放时，原指针仍会指向此对象所在的内存区域，再次调用此指针时会引发野指针问题，不安全。</p><p>Clang<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">文档</a>中有这样一段描述：</p><blockquote><p>Methods in the alloc, copy, init, mutableCopy, and new families are implicitly marked <strong>attribute</strong>((ns_returns_retained)). This may be suppressed by explicitly marking the method <strong>attribute</strong>((ns_returns_not_retained)).</p></blockquote><p>与MRC一样，以 <code>alloc</code>、<code>init</code>、<code>copy</code>、<code>mutableCopy</code>、<code>new</code>开头的方法返回的对象，会被隐式的标记为<code>ns_returns_retained</code>，其他情况下创建的对象则会被标记为 autorelease 并加入自动释放池中。</p><h4 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h4><ul><li>不能再手动向对象发送retain, release, autorelease、retainCount、dealloc消息；</li><li>可以重写 dealloc 方法，但不能在其内部调用[super dealloc]；</li><li>不能使用 NSAutoreleasePool 对象，而是使用 @autoreleasepool{}；</li><li>属性修饰符 weak 相当于原来的 assign，strong 相当于原来的 retain；</li><li>注意循环引用问题；</li></ul><p>在整个 XCode 中 开关 ARC，可以通过 Build Settings -&gt; Objective-C Automotic Reference Counting 选项来设置。设置单独的某个或某几个文件开关 ARC 时，可到 Build Phases -&gt; Compile Sources 中双击对应的文件，添加<code>-fobjc-arc</code>或<code>-fno-objc-arc</code>即可~</p><hr><p>相关参考：</p><p>#<a href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting">©wiki-Automatic_Reference_Counting</a></p><p>#<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">©Clang llvm-ARC</a></p><p>#<a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool?language=objc">©Apple-NSAutoreleasePool</a></p><p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-SW5">©Apple-Autorelease Pool Blocks</a></p><p>#<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">©sunnyxx</a></p><p>#<a href="https://www.2cto.com/kf/201804/739679.html">©ZCMUCZX-自动释放池</a></p><p>#<a href="http://www.cnblogs.com/flyFreeZn/p/4264220.html">©不忘初“辛”-ARC技术要点</a></p><p>#<a href="http://www.cocoachina.com/bbs/read.php?tid=1729516">©CocoaChina论坛7楼-垃圾收集机制与ARC</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVO 的实现</title>
    <link href="/2018/04/13/kvo.html"/>
    <url>/2018/04/13/kvo.html</url>
    
    <content type="html"><![CDATA[<h3 id="是啥"><a href="#是啥" class="headerlink" title="#是啥?"></a>#是啥?</h3><p>KVO 是通过一个 key 来找到某个属性并监听其值的改变。其实这也是一种典型的观察者模式。</p><h3 id="咋用"><a href="#咋用" class="headerlink" title="#咋用?"></a>#咋用?</h3><ol><li>添加观察者</li><li>在观察者中实现监听方法：-observeValueForKeyPath: ofObject: change: context:。</li><li>移除观察者</li></ol><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Person.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Model.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSCoding</span>&gt;</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> age;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *nickArr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) Model *model; <span class="hljs-comment">// 包含了一个Model对象</span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//Model.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Model</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在监听者类中注册监听的属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> *nickArrContext = &amp;nickArrContext;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    Person *p = [[Person alloc] init];<br>    <br>    <span class="hljs-comment">//监听p.model.name字段的变化</span><br>    [p addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;model.name&quot;</span><br>           options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> context:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-comment">//赋值 触发观察者</span><br>    p.model = [Model new];<br>    p.model.name = <span class="hljs-string">@&quot;211&quot;</span>;<br>    <br>    <span class="hljs-comment">//监听数组属性的变化</span><br>    [p addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;nickArr&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> context:nickArrContext];<br>    p.nickArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObject:<span class="hljs-string">@&quot;david1&quot;</span>];<span class="hljs-comment">//会触发回调</span><br>    [p.nickArr addObject:<span class="hljs-string">@&quot;Davi1&quot;</span>];<span class="hljs-comment">//不会触发回调</span><br>    <br>    <span class="hljs-built_in">NSMutableArray</span> *mutNickArr = [p mutableArrayValueForKey:<span class="hljs-string">@&quot;nickArr&quot;</span>];<br>    <span class="hljs-comment">//mutNickArr = [NSMutableArray arrayWithObject:@&quot;david2&quot;];如果重新赋值后再调用 addObject将不会触发KVO回调</span><br>    [mutNickArr addObject:<span class="hljs-string">@&quot;Davi2&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++p.nickArr:%@&quot;</span>,p.nickArr);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -监听回调</span><br>-(<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath<br>                     ofObject:(<span class="hljs-type">id</span>)object<br>                       change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-type">id</span>&gt; *)change<br>                      context:(<span class="hljs-type">void</span> *)context&#123;<br>    <span class="hljs-type">id</span> newValue = change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>];<br>    <br>    <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-string">@&quot;model.name&quot;</span>]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++model.name newValue:%@&quot;</span>,newValue);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<span class="hljs-string">@&quot;nickArr&quot;</span>])&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++nickArr newValue:%@&quot;</span>,newValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe">++++model.name <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>:&lt;<span class="hljs-literal">null</span>&gt;<br>++++model.name <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>:<span class="hljs-number">211</span><br>++++nickArr <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>:(<br>    david1<br>)<br>++++nickArr <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>:(<br>    Davi2<br>)<br>++++p.nickArr:<span class="hljs-type"></span>(<br>    david1,<br>    Davi1,<br>    Davi2<br>)<br></code></pre></td></tr></table></figure><p>最后不要忘记在合适的时机（如dealloc或者回调中）移除监听。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[<span class="hljs-variable language_">self</span> <span class="hljs-symbol">removeObserver:</span><span class="hljs-variable language_">self</span> <span class="hljs-symbol">forKeyPath:</span>@<span class="hljs-string">&quot;name&quot;</span>];<br></code></pre></td></tr></table></figure><ul><li>数组的监听</li></ul><p>注意，在监听数组属性<code>nickArr</code>时，如果是给此数组重新赋值，会触发回调；但如果直接使用此数组添加对象<code>addObject:</code>时，不会触发回调！所以我们需要使用<code>mutableArrayValueForKey:</code>来返回一个原数组的<code>代理数组对象</code>，之后在此代理对象上的操作都会在原对象上有相同的效果，并且会收到回调。下面是此方法的使用说明：</p><blockquote><p>The default implementation of this method recognizes the same simple accessor methods and array accessor methods as -valueForKey:’s, and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that -valueForKey: would return.</p></blockquote><h3 id="KVO底层原理"><a href="#KVO底层原理" class="headerlink" title="#KVO底层原理?"></a>#KVO底层原理?</h3><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html#//apple_ref/doc/uid/20002307-BAJEAIEE">官方文档</a> 解释如下：</p><p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p><p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p><p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p><p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p><p>简而言之，苹果使用了一种 isa 交换的技术。当一个类的属性被观察时，Runtime 会动态的创建一个中间类，将原类的 isa 指针指向此中间类。中间类中重写原类被观察属性的 setter 方法，这样给原类属性赋值时调用的实际上是中间类的 setter 方法。重写的 setter 方法会调用 [super setValue:newName forKey:@”name”] 并在此方法前后分别插入 [self willChangeValueForKey:@“name”] 和 [self didChangeValueForKey:@”name”]，以通知观察对象值的改变。</p><p>以上面案例中的 Model 为例，当 name 属性被观察后，aModel 对象的 isa 指针被指向了一个新建的 Model 的中间类 NSKVONotifying_Model，这个中间类重写了被观察值的 setter 方法和 class 方法、dealloc 及 _isKVO 方法，然后使 aModel 对象的 isa 指针指向这个新建的类。所以事实上 aModel 变为了 NSKVONotifying_Model 的实例对象，执行方法要从这个类的方法列表里找。</p><p>苹果警告我们，通过 isa 获取类的类型是不可靠的，通过 class 方法才能得到正确的类。</p><h3 id="主动触发KVO"><a href="#主动触发KVO" class="headerlink" title="#主动触发KVO"></a>#主动触发KVO</h3><p>如上所述，当属性发生变化时能收到通知，是因为 Runtime 使用 <code>isa-swizzling</code> 技术在中间类中属性的 <code>setter</code> 赋值语句前后主动调用了下面两个方法： </p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>willChangeValueForKey:<span class="hljs-params">(NSString *)</span>key;<br>- <span class="hljs-params">(void)</span>didChangeValueForKey:<span class="hljs-params">(NSString *)</span>key;<br></code></pre></td></tr></table></figure><p>所以，当我们需要属性值的改变在符合某个条件时才触发 KVO 时，我们需要做以下几件事：</p><ul><li>重写类方法 +automaticallyNotifiesObserversForKey，禁用目标属性的系统 KVO 通知；</li><li>定义属性并声明合成语句；</li><li>提供属性的 getter、setter 函数并在 setter 中成员变量赋值前后加入上面两个方法；</li><li>注册监听事件并重写回调函数；</li></ul><p>#完整示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSCoding</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><br><span class="hljs-keyword">@synthesize</span> name = _name; <span class="hljs-comment">//合成</span><br><br><span class="hljs-comment">//判断目标属性</span><br>+ (<span class="hljs-type">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="hljs-built_in">NSString</span> *)key<br>&#123;<br>    <span class="hljs-keyword">if</span> ([key isEqualToString:<span class="hljs-string">@&quot;name&quot;</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<span class="hljs-comment">//禁用系统的通知，不然会触发两次 KVO 回调</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-comment">//自己实现存取</span><br>- (<span class="hljs-built_in">NSString</span> *)name&#123;<br>    <span class="hljs-keyword">return</span> _name;<br>&#125;<br><br>-(<span class="hljs-type">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name&#123;<br>    <br>    <span class="hljs-keyword">if</span> ([name isEqualToString:<span class="hljs-string">@&quot;David&quot;</span>]) &#123;<span class="hljs-comment">//设置条件</span><br>        [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;name&quot;</span>];<span class="hljs-comment">// 主动触发通知</span><br>        _name = name;<br>        <span class="hljs-comment">//其他业务逻辑</span><br>        [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        _name = name;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用并查看结果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">self</span>.person = [Person new];<br>    [<span class="hljs-keyword">self</span>.person addObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span> options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span> context:<span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">self</span>.person.name = <span class="hljs-string">@&quot;David&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath<br>                     ofObject:(<span class="hljs-type">id</span>)object<br>                       change:(<span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSKeyValueChangeKey</span>,<span class="hljs-type">id</span>&gt; *)change<br>                      context:(<span class="hljs-type">void</span> *)context&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++字段:%@, New:%@&quot;</span>,keyPath,change);<br>    [<span class="hljs-keyword">self</span>.person removeObserver:<span class="hljs-keyword">self</span> forKeyPath:<span class="hljs-string">@&quot;name&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVC 的实现</title>
    <link href="/2018/04/12/kvc.html"/>
    <url>/2018/04/12/kvc.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-KVC是啥"><a href="#1-KVC是啥" class="headerlink" title="1.KVC是啥?"></a>1.KVC是啥?</h3><p>键值编码（key value coding）是一种可以通过字符串的名字（key）来访问类属性的机制。区别于通过调用Setter、Getter来访问属性的方法。</p><h3 id="2-啥用"><a href="#2-啥用" class="headerlink" title="2.啥用?"></a>2.啥用?</h3><p>通常我们要访问一个类中属性的值时，可以使用点语法（如 people.name）。但当你想访问私有属性或成员变量时，点语法就没用了。而有了 KVC 问题就迎刃而解。</p><ul><li><strong>常用方法?</strong></li></ul><p><code>NSKeyValueCoding.h</code>中有个 NSObject 的分类：<code>NSObject(NSKeyValueCoding)</code>，其中定义了以下方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(id)</span>valueForKey:<span class="hljs-params">(NSString *)</span>key;<br>- <span class="hljs-params">(id)</span>valueForKeyPath:<span class="hljs-params">(NSString *)</span>keyPath;<br>- <span class="hljs-params">(void)</span>setValue:<span class="hljs-params">(nullable id)</span>value forKey:<span class="hljs-params">(NSString *)</span>key;<br>- <span class="hljs-params">(void)</span>setValue:<span class="hljs-params">(nullable id)</span>value forKeyPath:<span class="hljs-params">(NSString *)</span>keyPath;<br></code></pre></td></tr></table></figure><p>其中，-valueForKey: 与 -valueForKeyPath:在一般的属性访问时，效果是一样的。但要访问类似下面案例1中 Student.index 这种子属性时，就只能使用后者，使用前者编译时没问题但运行时会崩溃。</p><p>#示例1：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">Student </span>: NSObject<br><span class="hljs-variable">@property</span> (nonatomic,assign) int index;<br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">People </span>: NSObject<br>&#123;<br>    <span class="hljs-selector-tag">NSString</span> *<span class="hljs-selector-tag">name</span>;<span class="hljs-comment">//私有变量</span><br>    <span class="hljs-selector-tag">Student</span> *<span class="hljs-selector-tag">student</span>;<br>&#125;<br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;People.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Student</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *eMail;<span class="hljs-comment">//私有属性</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span></span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">People</span> *people = [<span class="hljs-symbol">People</span> new];<br><span class="hljs-symbol">Student</span> *student = [<span class="hljs-symbol">Student</span> new];<br><br>[people setValue:@<span class="hljs-string">&quot;David&quot;</span> forKey:@<span class="hljs-string">&quot;name&quot;</span>];<br>[people setValue:@<span class="hljs-string">&quot;email@&quot;</span> forKey:@<span class="hljs-string">&quot;eMail&quot;</span>];<br>[people setValue:student forKey:@<span class="hljs-string">&quot;student&quot;</span>];<br>[people setValue:@(<span class="hljs-number">101</span>) forKeyPath:@<span class="hljs-string">&quot;student.index&quot;</span>];<br><br><span class="hljs-symbol">NSString</span> *name = [people valueForKey:@<span class="hljs-string">&quot;name&quot;</span>];<br>int index = [[people valueForKeyPath:@<span class="hljs-string">&quot;student.index&quot;</span>] intValue];<br><span class="hljs-symbol">NSLog</span>(@<span class="hljs-string">&quot;++++name:%@，index:%d&quot;</span>,name,index);<br></code></pre></td></tr></table></figure><h3 id="3-底层的原理"><a href="#3-底层的原理" class="headerlink" title="3.底层的原理?"></a>3.底层的原理?</h3><p>在<code>NSKeyValueCoding.h</code>对<code>KVC</code>的实现过程有详细的解释。</p><h4 id="3-1-valueForKey"><a href="#3-1-valueForKey" class="headerlink" title="3.1.valueForKey:"></a>3.1.valueForKey:</h4><ol><li>在方法接收者的类中先按照 getKey，key，isKey 的顺序查找 getter 方法，找到直接调用。如果是 BOOL，int 等内建值类型，会做 NSNumber 类型转化。</li><li>没有找到的话，如果方法接收者的 accessInstanceVariablesDirectly 属性返回YES（默认返回YES），那么依次搜索符合_key，_isKey，key，isKey 格式的成员变量，找到后返回它的值。</li><li>再没找到的话，会调用 -valueForUndefinedKey，在没被重写的情况下，此方法默认抛出 NSUndefinedKeyException 异常。</li></ol><h4 id="3-2-setValue-forKey"><a href="#3-2-setValue-forKey" class="headerlink" title="3.2.setValue:forKey:"></a>3.2.setValue:forKey:</h4><ol><li>首先在方法接收者所属的类中搜索 setKey: 格式的方法并检测其参数类型。如果参数类型符合则直接调用该方法；如果参数不是对象指针类型但值为nil，则会调用 -setNilValueForKey: 并抛出异常；</li><li>第一步中没有找到格式相符的方法的话，如果 accessInstanceVariablesDirectly 属性返回 YES。那么就去依次查询符合_key，_isKey，key，isKey 格式的成员变量，找到后给它赋值。</li><li>如果仍没找到符合的成员变量，则调用 setValue:forUnderfinedKey: 并抛出 NSUndefinedKeyException 异常。</li></ol><p>由上述过程可以得知：<code>valueForKey</code>会调用属性的<code>getter</code>，<code>setValue:forKey:</code>会调用属性的<code>setter</code>函数。</p><p>#示例2：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">Model </span>: NSObject<br><span class="hljs-variable">@property</span> (nonatomic, strong) NSString *_modelString;<br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">People </span>: NSObject<br><span class="hljs-variable">@property</span> (nonatomic, strong) NSString *stringA;<br><span class="hljs-variable">@property</span> (nonatomic, strong) Model *modelA;<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;People.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Model</span></span><br>- (<span class="hljs-type">void</span>)set_modelString:(<span class="hljs-built_in">NSString</span> *)_modelString<br>&#123;<br>    __modelString = _modelString;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行 setter _modelString&quot;</span>);<br>&#125;<br>- (<span class="hljs-type">void</span>)setModelString:(<span class="hljs-built_in">NSString</span> *)modelString<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行 setter modelString&quot;</span>);<br>&#125;<br>- (<span class="hljs-type">void</span>)setNoExist1:(<span class="hljs-built_in">NSString</span> *)noExist<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行 setter noExist1 &quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span></span><br><br>- (<span class="hljs-type">void</span>)setStringA:(<span class="hljs-built_in">NSString</span> *)stringA<br>&#123;<br>    _stringA = stringA;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行 setter stringA&quot;</span>);<br>&#125;<br>- (<span class="hljs-keyword">instancetype</span>)init<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        <span class="hljs-keyword">self</span>.modelA = [[Model alloc] init];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)kvcTest<br>&#123;<br>    People *apeo = [[People alloc] init];<br>    <span class="hljs-comment">//调用了setter</span><br>    apeo.stringA = <span class="hljs-string">@&quot;stringA setter&quot;</span>;<br>    <span class="hljs-comment">//也调用了setter</span><br>    ①[apeo setValue:<span class="hljs-string">@&quot;stringA KVC&quot;</span> forKey:<span class="hljs-string">@&quot;stringA&quot;</span>];<br>    <span class="hljs-comment">//没调用setter 但最终赋值给了此属性对应的成员变量_stringA</span><br>    ②[apeo setValue:<span class="hljs-string">@&quot;_stringA KVC&quot;</span> forKey:<span class="hljs-string">@&quot;_stringA&quot;</span>]; <br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++apeo.stringA 值: %@&quot;</span>, apeo.stringA);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++++++++++++++++++++++++++++&quot;</span>);<br>    <br>    <span class="hljs-comment">// 调用-set_modelString:</span><br>    ③[apeo setValue:<span class="hljs-string">@&quot;_modelString kvc&quot;</span> forKeyPath:<span class="hljs-string">@&quot;modelA._modelString&quot;</span>];<br>    <span class="hljs-comment">//不存在的属性，但会调用-setModelString:函数</span><br>    ④[apeo setValue:<span class="hljs-string">@&quot;modelString kvc&quot;</span> forKeyPath:<span class="hljs-string">@&quot;modelA.modelString&quot;</span>];<br>    <span class="hljs-comment">//没调用setter 但最终赋值给了modelA的属性对应的成员变量_modelString</span><br>    ⑤[apeo setValue:<span class="hljs-string">@&quot;__modelString kvc&quot;</span> forKeyPath:<span class="hljs-string">@&quot;modelA.__modelString&quot;</span>];<br>    <br>    <span class="hljs-comment">//不存在的属性 但会调用其setter函数-setNoExist1:</span><br>    ⑥[apeo setValue:<span class="hljs-string">@&quot;noExist1&quot;</span> forKeyPath:<span class="hljs-string">@&quot;modelA.noExist1&quot;</span>];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++apeo.modelA._modelString 值: %@&quot;</span>, apeo.modelA._modelString);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++++++++++++++++++++++++++++&quot;</span>);<br>    <br>    ⑦<span class="hljs-built_in">NSString</span> *s1 = [apeo valueForKeyPath:<span class="hljs-string">@&quot;modelA._modelString&quot;</span>];<br>    ⑧<span class="hljs-built_in">NSString</span> *s2 = [apeo valueForKeyPath:<span class="hljs-string">@&quot;modelA.modelString&quot;</span>];<br>    ⑨<span class="hljs-built_in">NSString</span> *s3 = [apeo valueForKeyPath:<span class="hljs-string">@&quot;modelA.__modelString&quot;</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++s1:%@ s2:%@ s3:%@&quot;</span>,s1,s2,s3);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+++</span>+执行 setter stringA<br><span class="hljs-code">+++</span>+执行 setter stringA<br><span class="hljs-section">++++apeo.stringA 值: _stringA KVC</span><br><span class="hljs-section">++++++++++++++++++++++++++++++</span><br><span class="hljs-code">+++</span>+执行 setter <span class="hljs-emphasis">_modelString</span><br><span class="hljs-emphasis">++++执行 setter modelString</span><br><span class="hljs-emphasis">++++执行 setter noExist1</span><br><span class="hljs-emphasis">++++apeo.modelA._modelString 值: __modelString kvc</span><br><span class="hljs-emphasis">++++++++++++++++++++++++++++++</span><br><span class="hljs-emphasis">++++s1:__modelString kvc s2:__modelString kvc s3:__</span>modelString kvc<br></code></pre></td></tr></table></figure><p>日志显示：①~⑨全部执行成功；其中①③④⑥ 执行了setter方法，⑦⑧执行了getter方法，②⑤⑨直接访问的实例变量。</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3.小结"></a>3.3.小结</h4><p>当我们使用<code>id objectA = objectB.value2</code>时是否代表 objectB 有一个 value2<code>属性</code>呢？实际上不一定，例如<code>object.class</code>，NSObject 中 并没有<code>class</code>属性，只有一个<code>class</code>方法。</p><p>OC的点语法中，<code>.</code>表示调用方法，即<code>.</code>操作只是去寻找一个名称匹配参数匹配的方法。我们习以为常的属性调用只是因为属性刚好有<code>getter</code>，<code>setter</code>方法符合要求而已。如果<code>.</code>表达式在<code>=</code>左边，则该属性的<code>setter</code>方法被调用；如果<code>.</code>表达式在<code>=</code>的右边，则属性的<code>getter</code>方法被调用。</p><h3 id="KVC与集合运算符"><a href="#KVC与集合运算符" class="headerlink" title="#KVC与集合运算符"></a>#KVC与集合运算符</h3><p>多数情况下，<code>keyPath</code>被用来读取对象中子对象的某个属性，如示例1中的<code>[people valueForKeyPath:@&quot;student.index&quot;]</code>。除此之外，苹果还将此方法用在了集合中，用以实现某些常见的集合运算，如求最大值、最小值、求和等，这就是我们要介绍的<code>集合运算符</code>在<code>KVC</code>中的应用。</p><blockquote><p>When you send a key-value coding compliant object the valueForKeyPath: message, you can embed a collection operator in the key path. A collection operator is one of a small list of keywords preceded by an at sign (@) that specifies an operation that the getter should perform to manipulate the data in some way before returning it. The default implementation of valueForKeyPath: provided by NSObject implements this behavior.</p></blockquote><p>我们可以在<code>keyPath</code>中加入<code>集合运算符</code>，它们以<code>@</code>开头，用来指定对数据的某种操作，最终返回处理后的结果。具体格式为：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_keypath.jpg" alt="keypath"></p><p>格式说明：</p><ul><li>左边：将要执行运算的集合；</li><li>中间：运算符；</li><li>右边：集合中对象的属性；</li></ul><p>如果是数组调用了<code>valueForKeyPath</code>，则左边部分可以省略；</p><p>运算符为数组的<code>count</code>时右边的部分可以忽略，其他运算的右边不能为空。</p><p>#示例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//银行卡</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Card</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">int</span> cardNumber; <span class="hljs-comment">// 编号</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">float</span> money;    <span class="hljs-comment">// 余额</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//用户</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Card.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">User</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSInteger</span> age; <span class="hljs-comment">//年龄</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSArray</span> *cardArr; <span class="hljs-comment">//拥有的银行卡</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//调用</span><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    Card *card1 = [Card new];<br>    card1.cardNumber = <span class="hljs-number">100</span>;<br>    card1.money = <span class="hljs-number">1000</span>;<br>    <br>    Card *card2 = [Card new];<br>    card2.cardNumber = <span class="hljs-number">101</span>;<br>    card2.money = <span class="hljs-number">2000</span>;<br>    <br>    User *user = [User new];<br>    user.age = <span class="hljs-number">20</span>;<br>    user.cardArr = @[card1,card2];<br>    <br>    User *user2 = [User new];<br>    user2.age = <span class="hljs-number">30</span>;<br>    <br>    <span class="hljs-built_in">NSArray</span> *userArr = @[user,user2];<br>    <br>    <span class="hljs-type">int</span> min = [[user valueForKeyPath:<span class="hljs-string">@&quot;cardArr.@min.money&quot;</span>] intValue];<br>    <span class="hljs-type">int</span> max = [[user valueForKeyPath:<span class="hljs-string">@&quot;cardArr.@max.money&quot;</span>] intValue];<br>    <span class="hljs-type">int</span> sum = [[user valueForKeyPath:<span class="hljs-string">@&quot;cardArr.@sum.money&quot;</span>] intValue];<br>    <span class="hljs-type">int</span> avg = [[user valueForKeyPath:<span class="hljs-string">@&quot;cardArr.@avg.money&quot;</span>] intValue];<br>    <span class="hljs-type">int</span> count = [[userArr valueForKeyPath:<span class="hljs-string">@&quot;cardArr.@count&quot;</span>] intValue];<br>    <span class="hljs-comment">//直接对数组进行查询</span><br>    <span class="hljs-type">int</span> count2 = [[userArr valueForKeyPath:<span class="hljs-string">@&quot;@count&quot;</span>] intValue];<br>    <span class="hljs-type">int</span> maxAge = [[userArr valueForKeyPath:<span class="hljs-string">@&quot;@max.age&quot;</span>] intValue];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>#示例2：数组中数字运算</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stan">- (<span class="hljs-type">void</span>)kvcToSumArr<br>&#123;<br>    NSArray *<span class="hljs-type">array</span> = @[@<span class="hljs-string">&quot;1&quot;</span>,@<span class="hljs-string">&quot;2&quot;</span>, @<span class="hljs-string">&quot;3&quot;</span>];<br>    <span class="hljs-comment">// 最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = [[<span class="hljs-type">array</span> valueForKeyPath:@<span class="hljs-string">&quot;@max.intValue&quot;</span>] intValue];<br>    <span class="hljs-comment">// 最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">min</span> = [[<span class="hljs-type">array</span> valueForKeyPath:@<span class="hljs-string">&quot;@min.intValue&quot;</span>] intValue];<br>    <span class="hljs-comment">// 求和</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = [[<span class="hljs-type">array</span> valueForKeyPath:@<span class="hljs-string">&quot;@sum.intValue&quot;</span>] intValue];<br>    <span class="hljs-comment">// 平均值</span><br>    float avg = [[<span class="hljs-type">array</span> valueForKeyPath:@<span class="hljs-string">&quot;@avg.floatValue&quot;</span>] floatValue];<br>    <br>    NSLog(@<span class="hljs-string">&quot;+++Max:%d,Min:%d,Sum:%d,Avg:%f&quot;</span>,<span class="hljs-built_in">max</span>,<span class="hljs-built_in">min</span>,<span class="hljs-built_in">sum</span>,avg);<br>    <span class="hljs-comment">//输出+++Max:3,Min:1,Sum:6,Avg:2.000000</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/CollectionOperators.html">©Apple-KVC Using Collection Operators</a></p><p>#<a href="https://juejin.im/post/5ac5f4b46fb9a028d5675645">©掘金</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>weak 的实现</title>
    <link href="/2018/03/27/weak.html"/>
    <url>/2018/03/27/weak.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>weak 表示的是一个弱引用，不会增加对象的引用计数，并且在所指向的对象被释放之后，weak 指针会被置为nil。weak 引用通常是用于处理循环引用的问题。</p></blockquote><h2 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h2><ul><li>初始化：</li></ul><p>runtime 调用 <code>objc_initWeak</code> 函数，初始化一个新的 <code>weak</code> 指针指向对象的地址。</p><ul><li>添加引用：</li></ul><p><code>objc_initWeak</code> 调用 <code>objc_storeWeak</code> 来更新指针指向，创建对应的弱引用表。</p><ul><li>释放：</li></ul><p>调用 <code>clearDeallocating</code> 函数，先根据对象地址获取所有 weak 指针地址的数组；再遍历这个数组把其中的数据置为 nil；然后把这个 entry 从 weak 表中删除；最后清理对象的记录。</p><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p>#示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">NSObject *newObj <span class="hljs-operator">=</span> [[NSObject alloc] init]<span class="hljs-comment">;</span><br>id __weak weakObj <span class="hljs-operator">=</span> newObj<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>初始化 weak 变量时，Runtime 会调用 <a href="https://opensource.apple.com//source/objc4/objc4-680/runtime/NSObject.mm">NSObject.mm</a> 中的 objc_initWeak 函数：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Initialize a fresh weak pointer to some object location. </span><br><span class="hljs-comment"> * It would be used for code like: </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * (The nil case) </span><br><span class="hljs-comment"> * __weak id weakPtr;</span><br><span class="hljs-comment"> * (The non-nil case) </span><br><span class="hljs-comment"> * NSObject *o = ...;</span><br><span class="hljs-comment"> * __weak id weakPtr = o;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param location Address of __weak ptr. </span><br><span class="hljs-comment"> * @param newObj Object ptr. </span><br><span class="hljs-comment"> */</span><br> <br>id objc_initWeak(id *location, id <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>) &#123;<br><span class="hljs-comment">// 查看对象实例是否有效</span><br><span class="hljs-comment">// 无效对象直接导致指针释放</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>) &#123;<br>        *location = nil;<br>        <span class="hljs-keyword">return</span> nil;<br>    &#125;<br>    <span class="hljs-keyword">return</span> storeWeak(location, (objc_object*)<span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的编译器模拟代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">id weakObj;<br>objc<span class="hljs-constructor">_initWeak(&amp;<span class="hljs-params">weakObj</span>, <span class="hljs-params">newObj</span>)</span>;<br></code></pre></td></tr></table></figure><p>即<code>objc_initWeak</code>将<code>weakObj</code>对象的指针及<code>newObj</code>对象作为参数，最终调用<code>storeWeak</code>方法。</p><h3 id="2-添加引用"><a href="#2-添加引用" class="headerlink" title="2.添加引用"></a>2.添加引用</h3><p><code>objc_storeWeak()</code> 的作用是更新指针指向，创建对应的弱引用表，详细实现如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">id objc<span class="hljs-constructor">_storeWeak(<span class="hljs-params">id</span> <span class="hljs-operator">*</span><span class="hljs-params">location</span>, <span class="hljs-params">id</span> <span class="hljs-params">newObj</span>)</span><br>&#123;<br>    id oldObj;<br>    SideTable *oldTable;<br>    SideTable *newTable;<br>    ......<br>    <span class="hljs-comment">// Acquire locks for old and new values.</span><br>    <span class="hljs-comment">// Order by lock address to prevent lock ordering problems. </span><br>    <span class="hljs-comment">// Retry if the old value changes underneath us.</span><br> retry:<br>    oldObj = *location;<br>    oldTable = SideTable::table<span class="hljs-constructor">ForPointer(<span class="hljs-params">oldObj</span>)</span>;<br>    newTable = SideTable::table<span class="hljs-constructor">ForPointer(<span class="hljs-params">newObj</span>)</span>;<br>    ......<br>    <span class="hljs-keyword">if</span> (*location != oldObj) &#123;<br>        <span class="hljs-constructor">OSSpinLockUnlock(<span class="hljs-params">lock1</span>)</span>;<br>#<span class="hljs-keyword">if</span> SIDE_TABLE_STRIPE &gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (lock1 != lock2) <span class="hljs-constructor">OSSpinLockUnlock(<span class="hljs-params">lock2</span>)</span>;<br>#endif<br>        goto retry;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (oldObj) &#123;<br>        weak<span class="hljs-constructor">_unregister_no_lock(&amp;<span class="hljs-params">oldTable</span>-&gt;<span class="hljs-params">weak_table</span>, <span class="hljs-params">oldObj</span>, <span class="hljs-params">location</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (newObj) &#123;<br>        newObj = weak<span class="hljs-constructor">_register_no_lock(&amp;<span class="hljs-params">newTable</span>-&gt;<span class="hljs-params">weak_table</span>, <span class="hljs-params">newObj</span>,<span class="hljs-params">location</span>)</span>;<br>        <span class="hljs-comment">// weak_register_no_lock returns NULL if weak store should be rejected</span><br>    &#125;<br>    <span class="hljs-comment">// Do not set *location anywhere else. That would introduce a race.</span><br>    *location = newObj;<br>    ......<br>    return newObj;<br>&#125;<br></code></pre></td></tr></table></figure><p>先是根据 weak 指针找到其指向的老对象：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">oldObj</span> <span class="hljs-operator">=</span> *location<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后获取到与新旧对象相关的 <code>SideTable</code> 对象：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">oldTable</span> = SideTable::tableForPointer(oldObj)<span class="hljs-comment">;</span><br><span class="hljs-attr">newTable</span> = SideTable::tableForPointer(newObj)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后在老对象的 <code>弱引用表</code> 中移除指向信息，而在新对象的 <code>弱引用表</code> 中建立关联信息：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (oldObj) &#123;<br>    weak<span class="hljs-constructor">_unregister_no_lock(&amp;<span class="hljs-params">oldTable</span>-&gt;<span class="hljs-params">weak_table</span>, <span class="hljs-params">oldObj</span>, <span class="hljs-params">location</span>)</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (newObj) &#123;<br>    newObj = weak<span class="hljs-constructor">_register_no_lock(&amp;<span class="hljs-params">newTable</span>-&gt;<span class="hljs-params">weak_table</span>, <span class="hljs-params">newObj</span>,<span class="hljs-params">location</span>)</span>;<br>    <span class="hljs-comment">// weak_register_no_lock returns NULL if weak store should be rejected</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来将弱引用指针指向新的对象：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">*<span class="hljs-keyword">location</span> <span class="hljs-title">= newObj</span>;<br></code></pre></td></tr></table></figure><p>最后返回这个新对象：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>;<br></code></pre></td></tr></table></figure><p>小结：<code>objc_storeWeak</code>最终将<code>weakObj</code>的指针指向<code>newObj</code>，同时将二者保存到<code>SideTable</code>中。</p><hr><h4 id="2-1-SideTable"><a href="#2-1-SideTable" class="headerlink" title="2.1.SideTable"></a>2.1.SideTable</h4><p>为了管理所有对象的引用计数和 <code>weak</code> 指针，系统创建了一个全局的 <code>SideTables</code>。它是一个全局的 <code>hash</code> 表，里面保存的是 <code>SideTable</code> 结构体。<code>SideTables</code> 使用对象的内存地址作为 <code>key</code>，通过 <code>SideTables[key]</code> 来得到 <code>SideTable</code>。这个 <code>SideTable</code> 的数据结构定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SideTable</span> &#123;<br>    <span class="hljs-comment">// 保证原子操作的自旋锁</span><br>    <span class="hljs-type">spinlock_t</span> slock;<br>    <span class="hljs-comment">// 引用计数的 hash 表</span><br>    RefcountMap refcnts;<br>    <span class="hljs-comment">// 全局的弱引用 hash 表</span><br>    <span class="hljs-type">weak_table_t</span> weak_table;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-弱引用表"><a href="#2-2-弱引用表" class="headerlink" title="2.2.弱引用表"></a>2.2.弱引用表</h4><p>runtime 维护了一个<code>弱引用表</code>，即上面 <code>SideTable</code> 结构体中最后一个参数 <code>weak_table_t</code>。它存储了某个对象的所有弱引用信息，其数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">weak_table_t</span> &#123;<br>    <span class="hljs-comment">// 保存了所有指向指定对象的 weak 指针</span><br>    <span class="hljs-type">weak_entry_t</span> *weak_entries;<br>    <span class="hljs-comment">// 存储空间</span><br>    <span class="hljs-type">size_t</span>    num_entries;<br>    <span class="hljs-comment">// 参与判断引用计数辅助量</span><br>    <span class="hljs-type">uintptr_t</span> mask;<br>    <span class="hljs-comment">// hash key 最大偏移值</span><br>    <span class="hljs-type">uintptr_t</span> max_hash_displacement;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>weak_entry_t</code> 是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用 hash 表。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> objc_object ** <span class="hljs-type">weak_referrer_t</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">weak_entry_t</span> &#123;<br>    DisguisedPtrobjc_object&gt; referent;<br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-keyword">struct</span> &#123;<br>            <span class="hljs-type">weak_referrer_t</span> *referrers;<br>            <span class="hljs-type">uintptr_t</span>        out_of_line : <span class="hljs-number">1</span>;<br>            <span class="hljs-type">uintptr_t</span>        num_refs : PTR_MINUS_1;<br>            <span class="hljs-type">uintptr_t</span>        mask;<br>            <span class="hljs-type">uintptr_t</span>        max_hash_displacement;<br>        &#125;;<br>        <span class="hljs-keyword">struct</span> &#123;<br>            <span class="hljs-comment">// out_of_line=0 is LSB of one of these (don&#x27;t care which)</span><br>            <span class="hljs-type">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>referent</code> 是被引用的对象，即示例代码中的 <code>newObj</code> 对象。下面的 <code>union</code> 即存储了所有指向该对象的弱引用。由注释可以看到，当<code>out_of_line</code>等于0时，hash表被一个数组所代替。另外，所有的弱引用对象的地址都是存储在<code>weak_referrer_t</code>指针的地址中。</p><h3 id="3-释放"><a href="#3-释放" class="headerlink" title="3.释放"></a>3.释放</h3><p>当 <code>weak</code> 指针指向的对象的引用计数&#x3D;0时，触发对象的 <code>dealloc</code> 函数，析构的详细流程如下：</p><ul><li>3.1.<code>调用_objc_rootDealloc</code> 函数：</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs scss">- (void)dealloc &#123;<br>    <span class="hljs-built_in">_objc_rootDealloc</span>(self);<br>&#125;<br><br>void <span class="hljs-built_in">_objc_rootDealloc</span>(id obj)<br>&#123;<br>    <span class="hljs-built_in">assert</span>(obj);<br>    obj-&gt;<span class="hljs-built_in">rootDealloc</span>();<br>&#125;<br><br>inline void objc_object::<span class="hljs-built_in">rootDealloc</span>()<br>&#123;<br>    if (isTaggedPointer()) return; <br><br>    if (fastpath(isa.nonpointer  &amp;&amp;  <br>                 !isa.weakly_referenced  &amp;&amp;  <br>                 !isa.has_assoc  &amp;&amp;  <br>                 !isa.has_cxx_dtor  &amp;&amp;  <br>                 !isa.has_sidetable_rc))<br>    &#123;<br>        <span class="hljs-built_in">assert</span>(!sidetable_present());<br>        <span class="hljs-built_in">free</span>(this);<br>    &#125; <br>    else &#123;<br>        <span class="hljs-built_in">object_dispose</span>((id)this);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>rootDealloc</code>中会判断是否有弱引用表和 <code>SideTable</code> 等，没有就通过<code>free</code>函数清除对象内存；有就继续调用 <code>object_dispose</code> 函数：</p><ul><li>3.2.调用 <code>objc_destructInstance</code> 函数并最终释放对象内存：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">id <span class="hljs-keyword">object</span><span class="hljs-constructor">_dispose(<span class="hljs-params">id</span> <span class="hljs-params">obj</span>)</span> <br>&#123;<br>    <span class="hljs-keyword">if</span> (!obj) return nil;<br><br>    objc<span class="hljs-constructor">_destructInstance(<span class="hljs-params">obj</span>)</span>;    <br>    free(obj);<br>    return nil;<br>&#125;<br><br>void *objc<span class="hljs-constructor">_destructInstance(<span class="hljs-params">id</span> <span class="hljs-params">obj</span>)</span> <br>&#123;<br>    <span class="hljs-keyword">if</span> (obj) &#123;<br>        <span class="hljs-comment">// Read all of the flags at once for performance.</span><br>        <span class="hljs-built_in">bool</span> cxx = obj-&gt;has<span class="hljs-constructor">CxxDtor()</span>;<br>        <span class="hljs-built_in">bool</span> assoc = obj-&gt;has<span class="hljs-constructor">AssociatedObjects()</span>;<br><br>        <span class="hljs-comment">// This order is important.</span><br>        <span class="hljs-keyword">if</span> (cxx) <span class="hljs-keyword">object</span><span class="hljs-constructor">_cxxDestruct(<span class="hljs-params">obj</span>)</span>;<br>        <span class="hljs-keyword">if</span> (assoc) <span class="hljs-constructor">_object_remove_assocations(<span class="hljs-params">obj</span>)</span>;<br>        obj-&gt;clear<span class="hljs-constructor">Deallocating()</span>;<br>    &#125;<br>    return obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>object_cxxDestruct</code> 是用来释放对象的实例变量；<code>_object_remove_assocations</code>用来移除所有关联的属性；</p><ul><li>3.3.调用 <code>objc_clear_deallocating</code> 函数：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void objc<span class="hljs-constructor">_clear_deallocating(<span class="hljs-params">id</span> <span class="hljs-params">obj</span>)</span> <br>&#123;<br>    ......<br>    SideTable *table = SideTable::table<span class="hljs-constructor">ForPointer(<span class="hljs-params">obj</span>)</span>;<br>    <span class="hljs-comment">// clear any weak table items</span><br>    <span class="hljs-comment">// clear extra retain count and deallocating bit</span><br>    <span class="hljs-comment">// (fixme warn or abort if extra retain count == 0 ?)</span><br>    <span class="hljs-constructor">OSSpinLockLock(&amp;<span class="hljs-params">table</span>-&gt;<span class="hljs-params">slock</span>)</span>;<br>    <span class="hljs-keyword">if</span> (seen_weak_refs) &#123;<br>        arr<span class="hljs-constructor">_clear_deallocating(&amp;<span class="hljs-params">table</span>-&gt;<span class="hljs-params">weak_table</span>, <span class="hljs-params">obj</span>)</span>;<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>首先取出对象对应的 <code>SideTable</code> 实例，如果这个对象有关联的弱引用，则调用 arr_clear_deallocating 来清除对象的弱引用信息。</p><ul><li>3.4.调用 <code>arr_clear_deallocating</code> 函数：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">PRIVATE_EXTERN <span class="hljs-built_in">void</span> arr_clear_deallocating(weak_table_t *weak_table, id <span class="hljs-built_in">ref</span>erent) &#123;<br>    &#123;<br>        weak_entry_t *entry = weak_entry_for_referent(weak_table, <span class="hljs-built_in">ref</span>erent);<br>        <span class="hljs-keyword">if</span> (entry == NULL) &#123;<br>            ......<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// zero out references</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; entry-&gt;<span class="hljs-built_in">ref</span>errers.num_allocated; ++i) &#123;<br>            id *<span class="hljs-built_in">ref</span>errer = entry-&gt;<span class="hljs-built_in">ref</span>errers.<span class="hljs-built_in">ref</span>s[i].<span class="hljs-built_in">ref</span>errer;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ref</span>errer) &#123;<br>                <span class="hljs-keyword">if</span> (*<span class="hljs-built_in">ref</span>errer == <span class="hljs-built_in">ref</span>erent) &#123;<br>                    *<span class="hljs-built_in">ref</span>errer = nil;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*<span class="hljs-built_in">ref</span>errer) &#123;<br>                    _objc_inform(<span class="hljs-string">&quot;__weak variable @ %p holds %p instead of %p\n&quot;</span>, <br>                    <span class="hljs-built_in">ref</span>errer, *<span class="hljs-built_in">ref</span>errer, <span class="hljs-built_in">ref</span>erent);<br>                &#125;<br>            &#125;<br>        &#125;<br>        weak_entry_remove_no_lock(weak_table, entry);<br>        weak_table-&gt;num_weak_refs--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先找出对象对应的 <code>weak_entry_t</code> 链表，然后挨个将弱引用置为 nil，最后清理对象的记录。</p><h3 id="4-后记"><a href="#4-后记" class="headerlink" title="4.后记"></a>4.后记</h3><p>一个 weak 引用的处理涉及各种查表、添加与删除操作，还是有一定消耗的。所以如果大量使用 weak 变量的话，会对性能造成一定的影响。那么，我们应该在什么时候去使用 weak 呢？《Objective-C高级编程》给我们的建议是只在避免循环引用的时候使用 <code>__weak</code> 修饰符。</p><hr><p>相关参考：</p><p>#<a href="http://www.cocoachina.com/ios/20150605/11990.html">©CocoaChina</a><br>#<a href="https://www.jianshu.com/p/1be2526f5879">©初心丶可曾记-dealloc</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>block 的实现</title>
    <link href="/2018/03/15/block.html"/>
    <url>/2018/03/15/block.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-block："><a href="#1-block：" class="headerlink" title="#1.block："></a>#1.block：</h3><p>从本质上来说，<code>block</code>是带有自动变量的<code>匿名函数</code>，是<code>闭包</code>在 OC 中的实现。</p><h4 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1.语法"></a>1.1.语法</h4><p>#block表达式:</p><blockquote><p>^ 返回值类型 (参数列表) {表达式}</p></blockquote><p>#示例1.1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">^<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>#block类型变量:</p><blockquote><p>返回值类型 (^变量名)(参数列表) &#x3D; Block表达式</p></blockquote><p>#示例1.2：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> (^increment)(<span class="hljs-built_in">int</span>) = ^(<span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span> + <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>#block类型变量作为函数的参数：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">- (<span class="hljs-keyword">int</span>)blockAsParam:(<span class="hljs-keyword">int</span> (^)(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b))ablock<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">ablock</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>#block类型变量作为返回值：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">- (<span class="hljs-built_in">int</span>(^)(<span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b))blockAsReturnValue&#123;<br>    <span class="hljs-keyword">return</span> ^<span class="hljs-built_in">int</span> (<span class="hljs-built_in">int</span> x,<span class="hljs-built_in">int</span> y)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>#完整示例1.3：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UOBlocks</span> : <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-type">void</span>)callBlocks;<br>- (<span class="hljs-type">int</span>)blockAsParam:(<span class="hljs-type">int</span> (^)(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b))ablock;<span class="hljs-comment">//作为参数</span><br>- (<span class="hljs-type">int</span>(^)(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b))blockAsReturnValue;<span class="hljs-comment">//作为返回值</span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;UOBlocks.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>(^multiBlock)(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b);<span class="hljs-comment">//宏定义</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UOBlocks</span>()</span><br><span class="hljs-comment">//作为属性</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) multiBlock mMultiBlock;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">int</span> (^clickBlock)(<span class="hljs-type">int</span> a);<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UOBlocks</span></span><br><br>- (<span class="hljs-type">void</span>)callBlocks<br>&#123;<br>    <span class="hljs-keyword">self</span>.mMultiBlock = ^<span class="hljs-type">int</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++%d&quot;</span>,<span class="hljs-keyword">self</span>.mMultiBlock(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    <br>    <span class="hljs-keyword">self</span>.clickBlock = ^<span class="hljs-type">int</span>(<span class="hljs-type">int</span> a) &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;;<br>    <span class="hljs-keyword">self</span>.clickBlock(<span class="hljs-number">5</span>);<br>&#125;<br><br>- (<span class="hljs-type">int</span>)blockAsParam:(<span class="hljs-type">int</span> (^)(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b))ablock<br>&#123;<br>    <span class="hljs-keyword">return</span> ablock(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>&#125;<br><br>- (<span class="hljs-type">int</span>(^)(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b))blockAsReturnValue&#123;<br>    <span class="hljs-keyword">return</span> ^<span class="hljs-type">int</span> (<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>#调用示例：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">UOBlocks *<span class="hljs-keyword">blocks </span>= [UOBlocks new];<br>[<span class="hljs-keyword">blocks </span>callBlocks];<br>[<span class="hljs-keyword">blocks </span><span class="hljs-keyword">blockAsParam:^int(int </span>a, int <span class="hljs-keyword">b) </span>&#123;<br>    return a * <span class="hljs-keyword">b;</span><br><span class="hljs-keyword"></span>&#125;];<br></code></pre></td></tr></table></figure><h3 id="2-类型"><a href="#2-类型" class="headerlink" title="#2.类型"></a>#2.类型</h3><ul><li><strong>NSGlobalBlock</strong></li></ul><p>全局的静态 block。不使用外部变量，或者只使用静态变量或全局变量。</p><ul><li><strong>NSStackBlock</strong></li></ul><p>保存在栈中的 block。内部引用局部变量或属性，且不能赋值给强引用或copy修饰的变量；</p><p>当函数返回时 block 会销毁。</p><ul><li><strong>NSMallocBlock</strong></li></ul><p>保存在堆中的 block。引用了局部变量或属性，且赋值给强引用或copy修饰的变量。</p><p>block 被 copy 时其 isa 指针会被修改为此类型；当引用计数为 0 时 block 会销毁。</p><p>三种类型的 block 分别被存储在<code>全局区</code>、<code>栈区</code>、<code>堆区</code>，需要注意的是在 ARC 环境中， block 的类型会与上面的定义有所差异，且往下看~</p><h4 id="2-1-MRC"><a href="#2-1-MRC" class="headerlink" title="2.1.MRC"></a>2.1.MRC</h4><p><code>Xcode</code>-&gt;<code>Build Phases</code>-&gt;<code>Compile Sources</code>找到<code>AppDelegate.m</code>，设置<code>-fno-objc-arc</code>，禁用其<code>ARC</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">int</span> aGlobalVar = <span class="hljs-number">10</span>;<br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^aCopyPropertyBlock)();<br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//On Global</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> aStaticVar = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">int</span> aConstVar = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">void</span> (^aGlobalBlock)() = ^()&#123;<br>        aGlobalVar = <span class="hljs-number">1</span>;<br>        aStaticVar = <span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%d&quot;</span>,aConstVar);<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aGlobalBlock info:%@&quot;</span>,aGlobalBlock);<br>    <br>    <span class="hljs-comment">//On Stack</span><br>    <span class="hljs-type">int</span> var = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">void</span> (^aStackBlock)() = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%d&quot;</span>,var);<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aStackBlock info:%@&quot;</span>,aStackBlock);<br>    <br>    <span class="hljs-comment">//copy</span><br>    <span class="hljs-type">void</span> (^aCopyBlock)() = [aGlobalBlock <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyBlock info1:%@&quot;</span>,aCopyBlock);<br>    <br>    aCopyBlock = [aStackBlock <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyBlock info2:%@&quot;</span>,aCopyBlock);<br>    <br>    <span class="hljs-comment">//property</span><br>    <span class="hljs-keyword">self</span>.aCopyPropertyBlock = ^&#123;<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyPropertyBlock info1:%@&quot;</span>,<span class="hljs-keyword">self</span>.aCopyPropertyBlock);<br>    <br>    <span class="hljs-keyword">self</span>.aCopyPropertyBlock = aStackBlock;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyPropertyBlock info2:%@&quot;</span>,<span class="hljs-keyword">self</span>.aCopyPropertyBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">++aGlobalBlock info:<span class="hljs-tag">&lt;<span class="hljs-name">__NSGlobalBlock__:</span> <span class="hljs-attr">0x10600a8f8</span>&gt;</span><br>++aStackBlock info:<span class="hljs-tag">&lt;<span class="hljs-name">__NSStackBlock__:</span> <span class="hljs-attr">0x7ffee9c35d30</span>&gt;</span><br>++aCopyBlock info1:<span class="hljs-tag">&lt;<span class="hljs-name">__NSGlobalBlock__:</span> <span class="hljs-attr">0x10600a8f8</span>&gt;</span><br>++aCopyBlock info2:<span class="hljs-tag">&lt;<span class="hljs-name">__NSMallocBlock__:</span> <span class="hljs-attr">0x6000020a4ae0</span>&gt;</span><br>++aCopyPropertyBlock info1:<span class="hljs-tag">&lt;<span class="hljs-name">__NSGlobalBlock__:</span> <span class="hljs-attr">0x10600a958</span>&gt;</span><br>++aCopyPropertyBlock info2:<span class="hljs-tag">&lt;<span class="hljs-name">__NSMallocBlock__:</span> <span class="hljs-attr">0x6000020bc990</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从示例及日志可以看出:</p><ul><li>未访问任何变量、或者只访问了全局变量、静态变量、常量的是 <code>NSGlobalBlock</code>；</li><li>访问了局部变量的是 <code>NSStackBlock</code>；</li><li>对 <code>NSGlobalBlock</code> 的拷贝还是 <code>NSGlobalBlock</code>；</li><li>对 <code>NSStackBlock</code> 的拷贝变成了 <code>NSMallocBlock</code>；</li><li>对于 <code>copy</code> 修饰的 block 属性，将其指向 <code>NSStackBlock</code> 类型的 block2 时，block2 会被拷贝到堆区，变成 <code>NSMallocBlock</code>。</li></ul><p><code>MRC</code>环境中 block 的类型与前面讲到的定义相吻合；</p><p>另外对于 block 拷贝后得到的结果，其类型是否变化依据源 block 而定，<strong>并不是所有的 block 都会被拷贝到<code>堆上</code></strong>~</p><h4 id="2-2-ARC"><a href="#2-2-ARC" class="headerlink" title="2.2.ARC"></a>2.2.ARC</h4><p>删除之前在<code>AppDelegate.m</code>文件后的<code>-fno-objc-arc</code>，启用<code>ARC</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^aCopyPropertyBlock)();<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-type">void</span> (^aStrongPropertyBlock)();<br><span class="hljs-keyword">@end</span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//On Global</span><br>    <span class="hljs-type">void</span> (^aGlobalBlock)() = ^()&#123;<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aGlobalBlock info:%@&quot;</span>,aGlobalBlock);<br><br>    <span class="hljs-type">int</span> var = <span class="hljs-number">0</span>;    <br>    <span class="hljs-comment">// On Stack，引用局部变量，但赋值给weak变量，在栈上，StackBlock</span><br>    <span class="hljs-type">void</span> (^__<span class="hljs-keyword">weak</span> aStackBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++%d&quot;</span>,var);<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aStackBlock:%@&quot;</span>,aStackBlock);<br><br>    <span class="hljs-comment">//On heap，引用局部变量或属性，赋值给强引用变量，在堆上，MallocBlock</span><br>    <span class="hljs-type">void</span> (^aMallocBlock)() = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%d&quot;</span>,var);<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aMallocBlock info:%@&quot;</span>,aMallocBlock);<br>        <br>    <span class="hljs-comment">//copy</span><br>    <span class="hljs-type">void</span> (^aCopyBlock)() = [aGlobalBlock <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyBlock from aGlobalBlock info1:%@&quot;</span>,aCopyBlock);<br>    <br>    aCopyBlock = [aStackBlock <span class="hljs-keyword">copy</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyBlock from aStackBlock info2:%@&quot;</span>,aCopyBlock);<br>    <br>    <span class="hljs-comment">//copy property</span><br>    <span class="hljs-keyword">self</span>.aCopyPropertyBlock = ^&#123;<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyPropertyBlock from aGlobalBlock info1:%@&quot;</span>,<span class="hljs-keyword">self</span>.aCopyPropertyBlock);<br>    <br>    <span class="hljs-keyword">self</span>.aCopyPropertyBlock = aStackBlock;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aCopyPropertyBlock from aStackBlock info2:%@&quot;</span>,<span class="hljs-keyword">self</span>.aCopyPropertyBlock);<br>    <br>    <span class="hljs-comment">//strong property</span><br>    <span class="hljs-keyword">self</span>.aStrongPropertyBlock = ^&#123;<br>    &#125;;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aStrongPropertyBlock from aGlobalBlock info1:%@&quot;</span>,<span class="hljs-keyword">self</span>.aStrongPropertyBlock);<br>    <br>    <span class="hljs-keyword">self</span>.aStrongPropertyBlock = aGlobalBlock;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aStrongPropertyBlock from aGlobalBlock info2:%@&quot;</span>,<span class="hljs-keyword">self</span>.aStrongPropertyBlock);<br>    <br>    <span class="hljs-keyword">self</span>.aStrongPropertyBlock = aStackBlock;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aStrongPropertyBlock from aStackBlock info3:%@&quot;</span>,<span class="hljs-keyword">self</span>.aStrongPropertyBlock);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">++aGlobalBlock info:<span class="hljs-variable">&lt;__NSGlobalBlock__: 0x1058440e8&gt;</span><br>++aStackBlock:<span class="hljs-variable">&lt;__NSStackBlock__: 0x7ffeea3bf8c0&gt;</span><br>++aMallocBlock info:<span class="hljs-variable">&lt;__NSMallocBlock__: 0x60000269e070&gt;</span><br>++aCopyBlock <span class="hljs-keyword">from</span> aGlobalBlock info1:<span class="hljs-variable">&lt;__NSGlobalBlock__: 0x1058440e8&gt;</span><br>++aCopyBlock <span class="hljs-keyword">from</span> aStackBlock info2:<span class="hljs-variable">&lt;__NSMallocBlock__: 0x6000026f6490&gt;</span><br>++aCopyPropertyBlock <span class="hljs-keyword">from</span> aGlobalBlock info1:<span class="hljs-variable">&lt;__NSGlobalBlock__: 0x105844128&gt;</span><br>++aCopyPropertyBlock <span class="hljs-keyword">from</span> aStackBlock info2:<span class="hljs-variable">&lt;__NSMallocBlock__: 0x60000269ddd0&gt;</span><br>++aStrongPropertyBlock <span class="hljs-keyword">from</span> aGlobalBlock info1:<span class="hljs-variable">&lt;__NSGlobalBlock__: 0x105844148&gt;</span><br>++aStrongPropertyBlock <span class="hljs-keyword">from</span> aGlobalBlock info2:<span class="hljs-variable">&lt;__NSGlobalBlock__: 0x1058440e8&gt;</span><br>++aStrongPropertyBlock <span class="hljs-keyword">from</span> aStackBlock info3:<span class="hljs-variable">&lt;__NSMallocBlock__: 0x600002699800&gt;</span><br></code></pre></td></tr></table></figure><p>从示例及日志来分析：</p><ul><li>未访问任何变量的是 <code>NSGlobalBlock</code>；</li><li>访问了局部变量但赋值给”非”强引用对象的是 <code>NSStackBlock</code>；</li><li>访问了局部变量但赋值给强引用对象的是 <code>NSMallocBlock</code>；</li><li>对 <code>NSGlobalBlock</code> 的拷贝还是 <code>NSGlobalBlock</code>；</li><li>将 <code>NSStackBlock</code> 赋值给copy或strong修饰的block属性时，得到的是 <code>NSMallocBlock</code>；</li></ul><p><code>ARC</code>中 block 的类型与前面的定义不再完全相同：</p><p>将<code>=</code>后面引用了局部变量的block，赋值给默认修饰符为strong的<code>aMallocBlock</code>时，得到的是一个<code>NSMallocBlock</code>！也就是说<code>ARC</code>中 原本在<code>栈上</code>的 block 现在会被自动拷贝到<code>堆上</code>。</p><h3 id="3-修饰符"><a href="#3-修饰符" class="headerlink" title="#3.修饰符"></a>#3.修饰符</h3><p><code>block</code>也是对象，作为属性时其修饰符可以使用<code>copy</code>和<code>strong</code>。不过，相信很多人和我一样，从开始接受的教育就是使用<code>copy</code>。这一章节就来探讨为何这么做，示例分为<code>MRC</code>和<code>ARC</code>两种环境。</p><h4 id="3-1-MRC"><a href="#3-1-MRC" class="headerlink" title="3.1.MRC"></a>3.1.MRC</h4><p>#示例3.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">retain</span>) <span class="hljs-type">void</span> (^aBlock)();<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">void</span>)retBlock&#123;<br>    <span class="hljs-keyword">self</span>.aBlock = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++aBlock&quot;</span>);<br>    &#125;;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-keyword">self</span> retBlock];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aBlock info1:%@&quot;</span>,<span class="hljs-keyword">self</span>.aBlock);<br>    <span class="hljs-keyword">self</span>.aBlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++</span><span class="hljs-comment">aBlock info1:</span>&lt;<span class="hljs-comment">__NSGlobalBlock__: 0x1032f78f8</span>&gt;<br><span class="hljs-literal">++++</span><span class="hljs-comment">aBlock</span><br></code></pre></td></tr></table></figure><p>示例为<code>MRC</code>环境，block 属性<code>aBlock</code>声明时使用的修饰符为<code>retain</code>。因为没有引用局部变量，所以此 block 为<code>NSGlobalBlock</code>类型。运行之后程序正常执行和输出日志，即我们<strong>能在定义域外正常访问此<code>NSGlobalBlock</code>类型的 block</strong>。</p><p>#示例3.2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)retBlock&#123;<br>    <span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">self</span>.aBlock = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++aBlock:%d&quot;</span>,var);<br>    &#125;;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-keyword">self</span> retBlock];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aBlock info1:%@&quot;</span>,<span class="hljs-keyword">self</span>.aBlock);<br>    <span class="hljs-keyword">self</span>.aBlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>示例对<code>retBlock</code>方法稍作修改，即<code>aBlock</code>引用了局部变量，其他代码不变。运行之后程序会在“NSLog(@”++aBlock info1:%@”,self.aBlock);”处崩溃，错误信息为“EXC_BAD_ACCESS (code&#x3D;1, address&#x3D;0x28)”，即访问了已经被释放的内存。所以，我们<strong>不能在定义域外访问<code>NSStackBlock</code>类型的 block</strong>，即使将其保存到集合中，在定义域外访问时也会出现野指针问题。</p><p>这是因为 block 属性<code>aBlock</code>访问了局部变量，属于<code>NSStackBlock</code>，被分配在<code>栈上</code>。同时其修饰符为<code>retain</code>，只是引用关系并不改变内存分布。栈上的变量在出了当前定义域之后，随时可能被回收。所以在定义域外访问此 block 时，<code>aBlock</code>在栈上的内存已经被回收，最终发生崩溃。实际上在声明<code>aBlock</code>属性时，编译器就已经给出了警示”Retain’ed block property does not copy the block - use copy attribute instead”。</p><p>#示例3.3：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^aBlock)();<span class="hljs-comment">//修饰符改为copy</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">void</span>)retBlock&#123;<br>    <span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">self</span>.aBlock = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++aBlock:%d&quot;</span>,var);<br>    &#125;;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-keyword">self</span> retBlock];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++aBlock info1:%@&quot;</span>,<span class="hljs-keyword">self</span>.aBlock);<br>    <span class="hljs-keyword">self</span>.aBlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>示例中属性的修饰符改为<code>copy</code>，其他代码不变。运行后输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++</span><span class="hljs-comment">aBlock info1:</span>&lt;<span class="hljs-comment">__NSMallocBlock__: 0x600002adeb80</span>&gt;<br><span class="hljs-literal">++++</span><span class="hljs-comment">aBlock:10</span><br></code></pre></td></tr></table></figure><p>使用<code>copy</code>修饰符时，<code>aBlock</code>类型为<code>NSMallocBlock</code>，即被拷贝到了<code>堆上</code>，所以这次访问<code>aBlock</code>时，没有再出现野指针问题。</p><h4 id="3-2-ARC"><a href="#3-2-ARC" class="headerlink" title="3.2.ARC"></a>3.2.ARC</h4><p>再来探讨一下<code>ARC</code>环境中 block 属性的修饰符问题。</p><p>#示例3.4：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-type">void</span> (^aBlock1)();<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-type">void</span> (^aBlock2)();<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^aBlock3)();<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">void</span>)retBlock&#123;<br>    <span class="hljs-type">int</span> var = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">self</span>.aBlock1 = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++aBlock1&quot;</span>);<br>    &#125;;<br>    <span class="hljs-keyword">self</span>.aBlock2 = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++aBlock2:%d&quot;</span>,var);<br>    &#125;;<br>    <span class="hljs-keyword">self</span>.aBlock3 = ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++aBlock3:%d&quot;</span>,var);<br>    &#125;;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-keyword">self</span> retBlock];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++info1:%@&quot;</span>,<span class="hljs-keyword">self</span>.aBlock1);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++info2:%@&quot;</span>,<span class="hljs-keyword">self</span>.aBlock2);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++info3:%@&quot;</span>,<span class="hljs-keyword">self</span>.aBlock3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">++info1:<span class="hljs-tag">&lt;<span class="hljs-name">__NSGlobalBlock__:</span> <span class="hljs-attr">0x10faa28f0</span>&gt;</span><br>++info2:<span class="hljs-tag">&lt;<span class="hljs-name">__NSMallocBlock__:</span> <span class="hljs-attr">0x6000029edbc0</span>&gt;</span><br>++info3:<span class="hljs-tag">&lt;<span class="hljs-name">__NSMallocBlock__:</span> <span class="hljs-attr">0x6000029ed9e0</span>&gt;</span><br></code></pre></td></tr></table></figure><p>程序正常运行，可以看到<code>ARC</code>环境下 block 属性不论是否访问了局部变量，在其定义域外都能正常访问和调用。且使用<code>strong</code>修饰符时 block 的类型也会自动变成<code>NSMallocBlock</code>，效果与使用<code>copy</code>时一样。</p><h4 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3.小结"></a>3.3.小结</h4><p>综上，<code>block</code>属性使用<code>copy</code>修饰符最为稳妥：</p><p>1、没有引用局部变量的 block 是<code>NSGlobalBlock</code>类型，使用retain、strong和copy修饰符时，都能正常在其定义域外访问和调用；</p><p>2、引用了局部变量的 block，MRC 中属于<code>NSStackBlock</code>类型，被保存在<code>栈上</code>随时可能被回收，使用retain修饰符时，在其定义域外调用会发生野指针问题，除非使用 copy 将其拷贝到<code>堆上</code>；</p><p>3、引用了局部变量的 block，ARC 中赋值给 strong 和 copy 属性时，属于<code>NSMallocBlock</code>类型，都能在其定义域外正常访问和调用。且 strong 修饰的 block 会自动将源 block 拷贝到了<code>堆上</code>，效果与 copy 一样。</p><h3 id="4-编译与实现"><a href="#4-编译与实现" class="headerlink" title="#4.编译与实现"></a>#4.编译与实现</h3><p>新建 command line tool 工程，在<code>main.m</code>文件中写一个 block 的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.m</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    @autoreleasepool &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">void</span> (^ blk)(<span class="hljs-type">void</span>) = ^()&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;varable in block:%d&quot;</span>,count);<br>        &#125;;<br>        <span class="hljs-built_in">blk</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 LLVM 编译器的<code>clang</code>命令将此段 OC 代码转换成 C++ 的源代码，以查看 block 的具体实现方式：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">clang  -<span class="hljs-built_in">rewrite</span>-objc  main.m<br></code></pre></td></tr></table></figure><p>编译后会得到一个<code>main.cpp</code>文件，文件内容比较长，详细内容可到这里 <a href="https://davidlii.nos-eastchina1.126.net/code_main.cpp">查看</a>，这里只看重点的部分：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">struct __block_impl &#123;<br>  void *isa<span class="hljs-comment">;</span><br>  int Flags<span class="hljs-comment">;</span><br>  int Reserved<span class="hljs-comment">;</span><br>  void *FuncPtr<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个<code>__block_impl</code>就是 block 的结构体。block 在编译过程中会被当做结构体进行处理，这里的<code>isa</code>字段指向 block 所属的类型，前面有具体的介绍；<code>FuncPtr</code>字段表示函数指针，即对应的是 block 中的<code>&#123; &#125;</code>部分，它会指向下面编译器给我们生成的静态函数<code>__main_block_func_0</code>。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sqf">static void <span class="hljs-variable">__main_block_func_0</span>(struct <span class="hljs-variable">__main_block_impl_0</span> *<span class="hljs-variable">__cself</span>) &#123;<br>    int <span class="hljs-built_in">count</span> = <span class="hljs-variable">__cself</span>-&gt;<span class="hljs-built_in">count</span>; <span class="hljs-comment">// bound by copy</span><br>    printf(<span class="hljs-string">&quot;varable in block:%d&quot;</span>,<span class="hljs-built_in">count</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个静态函数<code>__xxx_block_func_0</code>是一个函数的实现（前缀会根据.m文件的命名而变)，对应的是 block 中<code>&#123; &#125;</code>的部分。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  <span class="hljs-built_in">int</span> count;<br>  <span class="hljs-constructor">__main_block_impl_0(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__main_block_desc_0</span> <span class="hljs-operator">*</span><span class="hljs-params">desc</span>, <span class="hljs-params">int</span> <span class="hljs-params">_count</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>=0)</span> : count(_count) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>是该 block 的具体实现。此结构体中<code>impl</code>字段是<code>__block_impl</code>结构体的实例，<code>__main_block_impl_0</code>是对<code>__block_impl</code>的进一步封装；<code>count</code>字段是我们引入的外部变量；<code>Desc</code>即结构体的描述信息。最后结构体内部还提供了一个初始化函数<code>__main_block_impl_0()</code>，函数内对相关字段进行了初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__main_block_desc_0</span> &#123;<br>  <span class="hljs-type">size_t</span> reserved;<br>  <span class="hljs-type">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> __main_block_impl_0)&#125;;<br></code></pre></td></tr></table></figure><p>这是一个<code>__main_block_desc_0</code>结构体，用来描述<code>__main_block_impl_0</code>结构体的信息。其中的<code>Block_size</code>字段用于记录结构体大小；后面的<code>__main_block_desc_0_DATA</code>就是新生成的<code>__main_block_desc_0</code>实例。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">int main(int argc, <span class="hljs-keyword">const</span> char * argv[]) &#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; <br>        int count = <span class="hljs-number">10</span>;<br>        <span class="hljs-literal">void</span> (* blk)(<span class="hljs-literal">void</span>) = ((<span class="hljs-literal">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-literal">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, count));<br>        <br>        <span class="hljs-function"><span class="hljs-params">((<span class="hljs-literal">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">    <span class="hljs-title">return</span> 0;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这是<code>main.m</code>文件中 main 函数编译后的具体内容，看上去有点复杂，下面逐步解析这段内容具体做了什么：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-variable">__main_block_impl_0</span>((void *)<span class="hljs-variable">__main_block_func_0</span>, &amp;<span class="hljs-variable">__main_block_desc_0_DATA</span>, <span class="hljs-built_in">count</span>))<br></code></pre></td></tr></table></figure><p>#1、通过<code>__main_block_impl_0()</code>构造器创建了一个<code>__main_block_impl_0</code>结构体的实例。参数<code>__main_block_func_0</code>正是上面提到的函数实现，对应 block的 <code>&#123; &#125;</code>里的内容；<code>__main_block_desc_0_DATA</code>是<code>__main_block_desc_0</code>结构体的实例，描述<code>__main_block_impl_0</code>结构体的大小信息；参数<code>count</code>是我们之前通过<code>int count = 10</code>声明的局部变量，这里作为值类型传进来。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">&amp;<span class="hljs-variable">__main_block_impl_0</span>((void *)<span class="hljs-variable">__main_block_func_0</span>, &amp;<span class="hljs-variable">__main_block_desc_0_DATA</span>, <span class="hljs-built_in">count</span>))<br></code></pre></td></tr></table></figure><p>#2、在上一步的基础上加了<code>&amp;</code>运算符，用来取上面刚创建的<code>__main_block_impl_0</code>结构体实例的地址。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">((void <span class="hljs-comment">(*)())&amp;__main_block_impl_0((void *)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, count))<br></code></pre></td></tr></table></figure><p>#3、把实例地址转为一个函数地址。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">void <span class="hljs-comment">(* blk)(void) = ((void (*)</span>())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, count));<br></code></pre></td></tr></table></figure><p>#4、这一整句的作用就是：定义一个函数指针，指向一个新创建的<code>__main_block_impl_0</code>结构体的实例的地址。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">((void <span class="hljs-comment">(*)(__block_impl *)</span>)((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);<br></code></pre></td></tr></table></figure><p>#5、这是 block 的调用<code>blk();</code>在编译后的结果，通过函数指针 blk 调用函数的实现<code>FnucPtr</code>。</p><h3 id="5-变量的捕获"><a href="#5-变量的捕获" class="headerlink" title="#5.变量的捕获"></a>#5.变量的捕获</h3><h4 id="5-1-捕获的实现"><a href="#5-1-捕获的实现" class="headerlink" title="5.1.捕获的实现"></a>5.1.捕获的实现</h4><p>上面#4章节的示例中，<code>__main_block_impl_0</code> 结构体中<code>impl.isa</code>指向的是<code>NSConcreteStackBlock</code>类型。这是因为 main.m 中我们在 block 外声明了一个变量<code>int count = 10</code>，并且在 block 内部访问了该变量，所以 block 实例被保存在了栈上。</p><p>当然，如果我们在 block 内不访问任何局部变量，<code>impl.isa</code>应该是指向<code>NSConcreteGlobalBlock</code>类型，但实际上 clang 编译出来的结果却是指向<code>NSConcreteStackBlock</code>类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.m</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    @autoreleasepool &#123;<br>        ^(<span class="hljs-type">void</span>)&#123;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">struct</span> __main_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __main_block_desc_0* Desc;<br>  <span class="hljs-constructor">__main_block_impl_0(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__main_block_desc_0</span> <span class="hljs-operator">*</span><span class="hljs-params">desc</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>=0)</span> &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这和 clang 改写的实现及 ARC 有关，关于这个问题可以参考 <a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/">唐巧</a> 的博客，这里有具体的解释。</p><p>比较访问和不访问局部变量的两个版本编译后的<code>main.cpp</code>文件，注意构造函数<code>__main_block_impl_0()</code>这部分代码：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//访问局部变量</span><br>__main_block_impl_0(<span class="hljs-keyword">void</span> *fp, <br>    struct __main_block_desc_0 *<span class="hljs-keyword">desc</span>, <br>    <span class="hljs-built_in">int</span> _count, <span class="hljs-built_in">int</span> flags=<span class="hljs-number">0</span>) : <span class="hljs-keyword">count</span>(_count) &#123;<br>    <span class="hljs-comment">//略</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">//未访问局部变量</span><br>__main_block_impl_0(<span class="hljs-keyword">void</span> *fp, <br>    struct __main_block_desc_0 *<span class="hljs-keyword">desc</span>, <br>    <span class="hljs-built_in">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//略</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>访问局部变量时，构造函数<code>__main_block_impl_0()</code>的参数里多出一个<code>_count</code>，这里就是 <strong>block 对变量的自动捕获</strong>。在声明 block 时，栈上局部变量<code>count</code>的值被复制给<code>_count</code>，继而以参数的形式传入构造函数中，再被复制到<code>__main_block_impl_0</code>结构体中。</p><p><mark>在block中访问的外部变量是复制过去的，写操作不对原变量生效。<mark></p><h4 id="5-2-可修改性"><a href="#5-2-可修改性" class="headerlink" title="5.2.可修改性"></a>5.2.可修改性</h4><p>捕获后可以修改的变量：</p><ul><li>静态变量</li><li>全局变量</li><li>静态全局变量</li></ul><p>捕获后不可以修改的变量：</p><ul><li>局部变量</li></ul><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">int</span> aGloableVal = <span class="hljs-number">1</span>;<span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> aStaticGloable = <span class="hljs-number">2</span>;<span class="hljs-comment">//静态全局变量</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> aStaticVal = <span class="hljs-number">3</span>;<span class="hljs-comment">//静态变量</span><br>    <span class="hljs-type">int</span> anInt = <span class="hljs-number">0</span>;<span class="hljs-comment">//局部变量</span><br>    <span class="hljs-built_in">NSMutableArray</span> *array = [<span class="hljs-built_in">NSMutableArray</span> array];<span class="hljs-comment">//可变数组</span><br>    <br>    <span class="hljs-type">void</span> (^blockT)(<span class="hljs-type">int</span>) = ^(<span class="hljs-type">int</span> blockVal)&#123;<br>        aGloableVal = <span class="hljs-number">8</span>;<br>        aStaticGloable = <span class="hljs-number">9</span>;<br>        aStaticVal = <span class="hljs-number">10</span>;<span class="hljs-comment">//以上三个都可以正常赋值</span><br>        <br>        <span class="hljs-comment">//anInt = 1;</span><br>        <span class="hljs-comment">//array = [NSMutableArray array];</span><br>        <span class="hljs-comment">//以上两个赋值操作会报错:&quot;variable is not assignable&quot;!!</span><br>        [array addObject:<span class="hljs-string">@&quot;2&quot;</span>];<span class="hljs-comment">//数组可以正常添加对象</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;局部变量:%d,\n全局变量:%d,\n静态全局变量:%d,\n静态变量:%d,\n数组容量:%lu&quot;</span>,<br>        anInt,aGloableVal,aStaticGloable,aStaticVal,(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)array.count);<br>    &#125;;<br>    aGloableVal = <span class="hljs-number">4</span>;<br>    aStaticGloable = <span class="hljs-number">5</span>;<br>    aStaticVal = <span class="hljs-number">6</span>;<br>    anInt = <span class="hljs-number">7</span>;<br>    [array addObject:<span class="hljs-string">@&quot;1&quot;</span>];<br>    <br>    blockT(<span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">局部变量:0,</span><br><span class="hljs-section">全局变量:8,</span><br><span class="hljs-section">静态全局变量:9,</span><br><span class="hljs-section">静态变量:10,</span><br><span class="hljs-section">数组容量:2</span><br></code></pre></td></tr></table></figure><p>根据示例，可以得到以下几个信息：</p><p>1、<code>全局变量</code>、<code>静态变量</code>、<code>静态全局变量</code>在 block 内可以重新赋值，而<code>局部变量</code>不行。anInt 在 block 内部重新赋值时，编译器报错“variable is not assignable”。</p><p>2、<code>全局变量</code>、<code>静态变量</code>、<code>静态全局变量</code>在初始化时都有默认值，block 内重新赋值后，最终打印出的都是重新修改之后的值。而<code>局部变量</code> anInt 初始化时 &#x3D; 0，在调用 block 之前重新赋值 &#x3D; 1；而 block 内打印的 anInt 的值仍为赋值前的<code>0</code>。这说明 block 内捕获的局部变量的值是 blok 声明之前的那个值。</p><p>3、<code>局部变量</code>array 赋值时报错“variable is not assignable”，而执行 addObject 操作却不会报错。所以，block 中使用到的局部变量可以执行操作而不能赋值。</p><p>4、block 捕获局部变量仅捕获 block 闭包里面会用到的值，其他用不到的变量，它并不会去捕获。</p><h3 id="6-问题来了"><a href="#6-问题来了" class="headerlink" title="#6.问题来了"></a>#6.问题来了</h3><p><em>为啥全局变量、静态变量在 block 内能修改，而局部变量不能修改？</em></p><p>内存区域分为：堆区、栈区、全局区(数据区)、代码区。</p><ul><li>全局变量、静态全局变量都存储在<code>全局区</code>，所以在 block 内可以直接被修改。</li><li>静态变量传递给 block 的是<code>内存地址</code>值，所以能在 block 里面直接改变值。</li><li>局部变量是以<code>值</code>的方式传递到 block 的构造函数里，block 内不能改变此自动变量的值。</li></ul><p>想要在 block 中修改变量的值，有2种方式：</p><ul><li>传递内存地址指针到 block 中;</li><li>改变存储区方式(如__block anInt);</li></ul><p>下面看看通过<code>__block</code>修饰变量并在 block 内修改变量值的示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * argv[])</span> </span>&#123;<br>    @autoreleasepool &#123;<br>        __block <span class="hljs-type">int</span> count = <span class="hljs-number">10</span>;<br>        <span class="hljs-built_in">void</span> (^ blk)(<span class="hljs-type">void</span>) = ^()&#123;<br>            count = <span class="hljs-number">11</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;update varable in block:%d&quot;</span>,count);<br>        &#125;;<br>        <span class="hljs-built_in">blk</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 clang 编译后得到新的<code>main.cpp</code>文件：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sqf">struct <span class="hljs-variable">__Block_byref_count_0</span> &#123;<br>  void *<span class="hljs-variable">__isa</span>;<br><span class="hljs-variable">__Block_byref_count_0</span> *<span class="hljs-variable">__forwarding</span>;<br> int <span class="hljs-variable">__flags</span>;<br> int <span class="hljs-variable">__size</span>;<br> int <span class="hljs-built_in">count</span>;<br>&#125;;<br><br>struct <span class="hljs-variable">__main_block_impl_0</span> &#123;<br>  struct <span class="hljs-variable">__block_impl</span> impl;<br>  struct <span class="hljs-variable">__main_block_desc_0</span>* Desc;<br>  <span class="hljs-variable">__Block_byref_count_0</span> *<span class="hljs-built_in">count</span>; <span class="hljs-comment">// by ref</span><br>  <span class="hljs-variable">__main_block_impl_0</span>(void *fp, struct <span class="hljs-variable">__main_block_desc_0</span> *desc, <span class="hljs-variable">__Block_byref_count_0</span> *<span class="hljs-variable">_count</span>, int flags=<span class="hljs-number">0</span>) : <span class="hljs-built_in">count</span>(<span class="hljs-variable">_count</span>-&gt;<span class="hljs-variable">__forwarding</span>) &#123;<br>    impl.isa = &amp;<span class="hljs-variable">_NSConcreteStackBlock</span>;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到源码中增加了一个<code>__Block_byref_count_0</code>类型的结构体，内部保存着我们用<code>__block</code>修饰的变量<code>count</code>。而<code>__main_block_impl_0()</code>构造函数中引用的是<code>__Block_byref_count_0</code>的结构体指针<code>*_count</code>。这里，结构体指针不能再修改了。但指针指向的内存空间里的值是可以修改的。因此，在 block 内再次对<code>__block</code>修饰的变量赋值时，实际上是通过修改变量对应的结构体指针内存空间里的 value 来修改变量的值。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html">©Apple官方文档</a> 及 #<a href="http://www.cnblogs.com/YouXianMing/p/3702508.html?utm_source=tuicool&utm_medium=referral">©翻译</a></p><p>#<a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/">©唐巧</a></p><p>#<a href="https://segmentfault.com/a/1190000006479320">©思否</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环引用</title>
    <link href="/2018/03/05/retaincircle.html"/>
    <url>/2018/03/05/retaincircle.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>循环引用可以简单理解为 A 强引用 B，B 又强引用了 A，双方同时保持对方的一个引用，导致引用计数不为0，始终无法释放。</p><p><strong>影响？</strong></p><p>导致对象无法释放，造成内存泄露。如果是 ViewController 内出现循环引用，在反复 push &amp; pop 后，ViewController 释放不掉，导致内存激增，甚至引发crash。</p><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h3><h4 id="2-1-block"><a href="#2-1-block" class="headerlink" title="2.1.block"></a>2.1.block</h4><p>下面是一段关于 block 的描述：</p><blockquote><p>When a block is copied, it creates strong references to object variables used within the block. If you use a block within the implementation of a method:</p></blockquote><blockquote><p>If you access an instance variable by reference, a strong reference is made to self;</p></blockquote><blockquote><p>If you access an instance variable by value, a strong reference is made to the variable.</p></blockquote><p>使用<code>copy</code>修饰的 block 会被放到堆中。block 会强引用 block 块中捕获到的对象。</p><ul><li>如果在 block 中访问了属性，那么 block 就会强引用 self。</li><li>如果在 block 中访问了一个局部变量，那么 block 就会强引用该变量。</li></ul><p>block 的循环引用一般表现为，block 作为属性被类的实例(self)强引用，然后实例在block中又引用了实例本身。<code>self -&gt; block -&gt; self</code>。编写代码时，这种循环引用编译器能捕捉到并给出提醒：“Capturing ‘self’ strongly in this block is likely to lead to a retain cycle”。</p><p>注意：并不是所有block都会造成循环引用。只有被<code>强引用</code>了的 block 才会产生循环引用，一些系统封装的block就不存在循环引用问题，如：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">dispatch_async(dispatch_get_main_queue(), ^</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">);</span><br><span class="language-xml"></span><br><span class="language-xml">[UIView animateWithDuration:1 animations:^</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">];</span><br></code></pre></td></tr></table></figure><h5 id="循环引用示例1"><a href="#循环引用示例1" class="headerlink" title="#循环引用示例1"></a>#循环引用示例1</h5><p>自定义的一个<code>Student</code>类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//.h文件</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>(^StudentBlock)();<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Student</span> : <span class="hljs-title">NSObject</span></span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span> , <span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">copy</span> , <span class="hljs-keyword">nonatomic</span>) StudentBlock block;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//.m文件</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Student</span></span><br><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%@ dealloced~&quot;</span>,[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在某个VC中调用：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl">- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    Student *student = [[Student alloc] init];<br>    student.<span class="hljs-keyword">name</span> = @<span class="hljs-string">&quot;D&quot;</span>;<br>    student.<span class="hljs-keyword">block</span> = ^&#123;<br>        NSLog(@<span class="hljs-string">&quot;Hello %@ ~&quot;</span>,student.<span class="hljs-keyword">name</span>);<br>    &#125;;<br>    student.<span class="hljs-keyword">block</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>此示例中，<code>student</code>中有个<code>block</code>属性，<code>block</code>内强引用了<code>student</code>对象本身，这就造成循环引用，导致<code>student</code>无法释放。</p><ul><li><strong>解决办法</strong></li></ul><p>在对象的 block 内访问<code>__block</code> 修饰的变量代替原对象，并在调用完之后将<code>__block</code>变量或 block 本身置为<code>nil</code>。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xl">- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    Student *student = [[Student alloc] init];<br>    student.<span class="hljs-keyword">name</span> = @<span class="hljs-string">&quot;D&quot;</span>;<br>    <span class="hljs-comment">//创建__block修饰的变量</span><br>    __<span class="hljs-keyword">block</span> Student *st = student;<br>    student.<span class="hljs-keyword">block</span> = ^&#123;<br>        NSLog(@<span class="hljs-string">&quot;Hello %@ ~&quot;</span>,st.<span class="hljs-keyword">name</span>);<span class="hljs-comment">//访问__block变量</span><br>        <span class="hljs-comment">//case1：置为nil</span><br>        st = <span class="hljs-literal">nil</span>;<br>    &#125;;<br>    student.<span class="hljs-keyword">block</span>();<br>    <span class="hljs-comment">//case2：student.block = nil;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种办法的缺点很明显：如果不调用此 block 或没将其置为 nil，那么<code>st</code>就不被置为 nil，依然强引用<code>student</code>，循环引用依然存在。</p><h5 id="循环引用示例2"><a href="#循环引用示例2" class="headerlink" title="#循环引用示例2"></a>#循环引用示例2</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;AppDelegate.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^aBlock)(<span class="hljs-type">void</span>);<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *aName;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//有循环引用问题</span><br>    <span class="hljs-keyword">self</span>.aBlock = ^&#123;<br>        <span class="hljs-keyword">self</span>.aName = <span class="hljs-string">@&quot;THIS IS A NAME&quot;</span>;<span class="hljs-comment">//有警告</span><br>    &#125;;<br>    <span class="hljs-comment">//无循环引用问题</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-keyword">self</span>.aName = <span class="hljs-string">@&quot;THIS IS A NAME 2&quot;</span>;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li><strong>解决办法1：</strong></li></ul><p>通过<code>__weak</code>修饰符，先弱引用<code>self</code>，再通过<code>__strong</code>强引用<code>weakSelf</code>，然后在 block 里使用<code>strongSelf</code>即可。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++self.rfc:%ld&quot;</span>,(<span class="hljs-type">long</span>)<span class="hljs-built_in">CFGetRetainCount</span>((__bridge <span class="hljs-built_in">CFTypeRef</span>)(<span class="hljs-keyword">self</span>)));<br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++self.rfc:%ld,weakSelf.rfc:%ld&quot;</span>,(<span class="hljs-type">long</span>)<span class="hljs-built_in">CFGetRetainCount</span>((__bridge <span class="hljs-built_in">CFTypeRef</span>)(<span class="hljs-keyword">self</span>)),<span class="hljs-built_in">CFGetRetainCount</span>((__bridge <span class="hljs-built_in">CFTypeRef</span>)(weakSelf)));<br>    <span class="hljs-keyword">self</span>.aBlock = ^&#123;<br>        __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++weakself.rfc:%ld&quot;</span>,(<span class="hljs-type">long</span>)<span class="hljs-built_in">CFGetRetainCount</span>((__bridge <span class="hljs-built_in">CFTypeRef</span>)(weakSelf)));<br>        strongSelf.aName = <span class="hljs-string">@&quot;THIS IS A NAME&quot;</span>;<br>    &#125;;<br>    <span class="hljs-keyword">self</span>.aBlock();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">self</span><span class="hljs-string">.</span><span class="hljs-comment">rfc:1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">self</span><span class="hljs-string">.</span><span class="hljs-comment">rfc:1</span><span class="hljs-string">,</span><span class="hljs-comment">weakSelf</span><span class="hljs-string">.</span><span class="hljs-comment">rfc:2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">执行block</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">weakself</span><span class="hljs-string">.</span><span class="hljs-comment">rfc:3</span><br></code></pre></td></tr></table></figure><p>原理：<code>__weak</code>修饰的<code>weakSelf</code>是一个弱引用，它指向<code>self</code>但不会增加<code>self</code>的引用计数，从而打破<code>self</code>与<code>block</code>之间的循环引用。</p><p><strong>ps：</strong> 这里之所以再强引用一下 weakSelf，是因为<code>__weak</code>修饰的对象都是弱引用，随时可能会被系统释放，造成后面调用 weakSelf 时 weakSelf 可能已经是nil了。<code>__strong</code>修饰的<code>strongSelf</code>是一个强引用，保证了<code>weakSelf</code>在 block 声明周期内不会被销毁，而且<code>strongSelf</code>是一个自动变量，在 block 执行完毕后会自动释放。</p><ul><li><strong>解决办法2：</strong></li></ul><p>将在 block 内要使用到的对象（一般为self对象），以 block 参数的形式传入，block 就不会捕获该对象，而是将其作为参数使用，其生命周期由系统的栈自动管理，也不会造成内存泄露。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-type">void</span> (^aBlock)(AppDelegate *delSelf);<span class="hljs-comment">//将本类作为参数</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *aName;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">self</span>.aBlock = ^(AppDelegate *delSelf)&#123;<br>        delSelf.aName = <span class="hljs-string">@&quot;THIS IS A NAME&quot;</span>;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="2-2-NSTimer"><a href="#2-2-NSTimer" class="headerlink" title="2.2.NSTimer"></a>2.2.NSTimer</h4><p>一般是 NSTimer 被作为类的成员变量，在期望类销毁时，NSTimer 尚处于 validate 状态。此时不管 NSTimer 对象是否被置为nil，类都无法正常销毁。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSTimer</span> *aTimer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    _aTimer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">2</span> target:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(action) userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;dealloced!!!&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)viewWillDisappear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewWillDisappear:animated];<br>    _aTimer = <span class="hljs-literal">nil</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)action&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;a Timer action!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>上面的示例中， ViewController 出现后过段时间退出，dealloc 不会执行。这是因为 NSTimer 创建后被加入到 NSRunloop 中，失效之前会一直持有 self 作为 target。需要在合适的时机执行 invalidate 来打破这个循环引用即可。如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewWillDisappear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewWillDisappear:animated];<br>    [_aTimer invalidate];<span class="hljs-comment">//敲黑板 划重点!!</span><br>    _aTimer = <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-delegate"><a href="#2-3-delegate" class="headerlink" title="2.3.delegate"></a>2.3.delegate</h4><p>一般是 A 类中声明了一个 strong 的 delegate，B 类强引用 A 类，同时把 A 类的 delegate 指向 B 自己。B -&gt; A -&gt; delegate -&gt; B。解决办法：声明 delegate 时，使用 weak 修饰符。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//ClassA</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">CustomDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br>- (<span class="hljs-type">void</span>)onDelegateCallback;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ClassA</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-type">id</span> &lt;CustomDelegate&gt; delegate;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//ClassB</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ClassB</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) ClassA *classA;<br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ClassB</span></span><br>－ (<span class="hljs-type">void</span>)viewDidLoad <br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad]; <br>    <span class="hljs-keyword">self</span>.classA = [[ClassA alloc] init];<br>    <span class="hljs-keyword">self</span>.classA.delegate = <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>block</tag>
      
      <tag>循环引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFNetworking</title>
    <link href="/2018/01/31/afn.html"/>
    <url>/2018/01/31/afn.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-导入库"><a href="#1-导入库" class="headerlink" title="1.导入库"></a>1.导入库</h3><p>导入 AFN 的 Podfile：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">source <span class="hljs-string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="hljs-keyword">platform</span> :ios, <span class="hljs-string">&#x27;8.0&#x27;</span><br>target <span class="hljs-string">&#x27;TargetName&#x27;</span> <span class="hljs-keyword">do</span><br>pod <span class="hljs-string">&#x27;AFNetworking&#x27;</span>, <span class="hljs-string">&#x27;~&gt; 3.0&#x27;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>写这篇文章时最新的版本是AFNetworking (3.1.0)。</p><h3 id="2-模块划分"><a href="#2-模块划分" class="headerlink" title="2.模块划分"></a>2.模块划分</h3><table><thead><tr><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>NSURLSession</td><td>发起请求、上传、下载任务，处理回调数据</td></tr><tr><td>Serialization</td><td>请求响应的序列化、拼接参数</td></tr><tr><td>Reachability</td><td>监听网络状态</td></tr><tr><td>Security</td><td>网络安全策略、证书校验</td></tr><tr><td>UIKit</td><td>视图+分类，控件中网络资源的下载</td></tr></tbody></table><h3 id="3-NSURLSession"><a href="#3-NSURLSession" class="headerlink" title="3.NSURLSession"></a>3.NSURLSession</h3><h4 id="1-AFURLSessionManager"><a href="#1-AFURLSessionManager" class="headerlink" title="1.AFURLSessionManager"></a>1.AFURLSessionManager</h4><p>网络请求的基类，它维护了一个<code>NSURLSession</code>对象，主要功能包括：</p><ul><li>Init &amp; 配置网络请求的安全策略、队列、锁。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (instancetype)initWithSessionConfiguration:<br>(<span class="hljs-type">NSURLSessionConfiguration</span> <span class="hljs-operator">*</span>)configuration <br>&#123;<br>    <span class="hljs-comment">//略..</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>configuration) &#123;<br>        configuration <span class="hljs-operator">=</span> [<span class="hljs-type">NSURLSessionConfiguration</span> defaultSessionConfiguration];<br>    &#125;<br>    <span class="hljs-keyword">self</span>.sessionConfiguration <span class="hljs-operator">=</span> configuration;<br><br>    <span class="hljs-comment">//回调所在队列</span><br>    <span class="hljs-keyword">self</span>.operationQueue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br>    <span class="hljs-comment">//并发数 = 1（串行）</span><br>    <span class="hljs-comment">/*按照URLSession接口的要求，其回调所在队列必须是一个串行队列，</span><br><span class="hljs-comment">     *所以队列的并发数须是1，这是为了保证回调的顺序。*/</span><br>    <span class="hljs-keyword">self</span>.operationQueue.maxConcurrentOperationCount <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">self</span>.session <span class="hljs-operator">=</span> [<span class="hljs-type">NSURLSession</span> sessionWithConfiguration:<span class="hljs-keyword">self</span>.sessionConfiguration <br>    delegate:<span class="hljs-keyword">self</span> <br>    delegateQueue:<span class="hljs-keyword">self</span>.operationQueue];<br><br>    <span class="hljs-keyword">self</span>.responseSerializer <span class="hljs-operator">=</span> [<span class="hljs-type">AFJSONResponseSerializer</span> serializer];<br>    <span class="hljs-keyword">self</span>.securityPolicy <span class="hljs-operator">=</span> [<span class="hljs-type">AFSecurityPolicy</span> defaultPolicy];<br>    <br>    <span class="hljs-comment">//字典：映射 NSURLSessionTask 与 AFURLSessionManagerTaskDelegate</span><br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier <span class="hljs-operator">=</span> [[<span class="hljs-type">NSMutableDictionary</span> alloc] <span class="hljs-keyword">init</span>];<br><br>    <span class="hljs-keyword">self</span>.lock <span class="hljs-operator">=</span> [[<span class="hljs-type">NSLock</span> alloc] <span class="hljs-keyword">init</span>];<br>    <span class="hljs-keyword">self</span>.lock.name <span class="hljs-operator">=</span> <span class="hljs-type">AFURLSessionManagerLockName</span>;<br>    <br>    <span class="hljs-comment">//遍历当前正在执行的网络任务，根据任务标识符将各个 block 置为 nil</span><br>    [<span class="hljs-keyword">self</span>.session getTasksWithCompletionHandler:<span class="hljs-operator">^</span>(<br>    <span class="hljs-type">NSArray</span> <span class="hljs-operator">*</span>dataTasks, <span class="hljs-type">NSArray</span> <span class="hljs-operator">*</span>uploadTasks, <span class="hljs-type">NSArray</span> <span class="hljs-operator">*</span>downloadTasks) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">NSURLSessionDataTask</span> <span class="hljs-operator">*</span>task <span class="hljs-keyword">in</span> dataTasks) &#123;<br>            [<span class="hljs-keyword">self</span> addDelegateForDataTask:task <br>            uploadProgress:<span class="hljs-literal">nil</span> <br>            downloadProgress:<span class="hljs-literal">nil</span> <br>            completionHandler:<span class="hljs-literal">nil</span>];<br>        &#125;<br>    <span class="hljs-comment">//略..</span><br>    &#125;];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>self.operationQueue</code>是请求回调时所在的队列，而非发起请求时的队列。其最大并发数设置为1，是 NSURLSession 为了保证其回调的顺序，要求其<code>delegateQueue</code>必须是一个串行队列：</p><blockquote><p>An operation queue for scheduling the delegate calls and completion handlers. The queue should be a serial queue, in order to ensure the correct ordering of callbacks. If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.</p></blockquote><p>defaultSessionConfiguration的<code>HTTPMaximumConnectionsPerHost</code>属性默认为4，即每个主机默认同时并发请求数为4个。必要时也可自己提供额外的 OperationManager 控制并发情况。</p><ul><li>发起网络请求。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>数据任务<br>- (NSURLSessionDataTask *)dataTaskWithRequest:completionHandler:<br><span class="hljs-regexp">//</span>上传任务<br>- (NSURLSessionUploadTask *)uploadTaskWithRequest:fromFile:progress:completionHandler:<br><span class="hljs-regexp">//</span>下载任务<br>- (NSURLSessionDownloadTask *)downloadTaskWithRequest:progress:destination:completionHandler:<br></code></pre></td></tr></table></figure><ul><li>接收数据 &amp; 处理回调。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - NSURLSessionDataDelegate</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>didReceiveData:(<span class="hljs-built_in">NSData</span> *)data<br>&#123;<br>    <span class="hljs-comment">//取出字典中的 Delegate 对象，让它处理后续的业务逻辑。</span><br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:dataTask];<br>    [delegate URLSession:session dataTask:dataTask didReceiveData:data];<br>    <span class="hljs-comment">//略。。。</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - NSURLSessionDownloadDelegate</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>      downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask<br>didFinishDownloadingToURL:(<span class="hljs-built_in">NSURL</span> *)location<br>&#123;<br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:downloadTask];<br>    <span class="hljs-comment">//略。。。</span><br>    [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-AFHTTPSessionManager"><a href="#2-AFHTTPSessionManager" class="headerlink" title="2.AFHTTPSessionManager"></a>2.AFHTTPSessionManager</h4><p>继承自<code>AFURLSessionManager</code>，将父类中的<code>dataTaskWithRequest</code>进一步细分成 6 大类：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>请求指定页面的信息，返回数据实体；</td></tr><tr><td>HEAD</td><td>与GET类似，不同在于只返回头信息而没有具体数据；</td></tr><tr><td>POST</td><td>将数据封装在请求体中，上传至指定目录，由服务器创建或更新对应的资源；</td></tr><tr><td>PUT</td><td>将数据传送给服务器以取代指定文档中的内容；</td></tr><tr><td>PATCH</td><td>是对PUT方法的补充，用来对已知资源进行局部更新；</td></tr><tr><td>DELETE</td><td>请求删除指定页面或资源；</td></tr></tbody></table><p>对应的6大接口：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby">- (NSURLSessionDataTask*)<span class="hljs-variable constant_">GET</span><span class="hljs-symbol">:parameters</span><span class="hljs-symbol">:progress</span><span class="hljs-symbol">:success</span><span class="hljs-symbol">:failure</span>:<br><br>- (NSURLSessionDataTask*)<span class="hljs-variable constant_">POST</span><span class="hljs-symbol">:parameters</span><span class="hljs-symbol">:</span>...<span class="hljs-symbol">progress:</span><span class="hljs-symbol">success:</span><span class="hljs-symbol">failure:</span><br><br>- (NSURLSessionDataTask*)<span class="hljs-variable constant_">PUT</span><span class="hljs-symbol">:parameters</span><span class="hljs-symbol">:success</span><span class="hljs-symbol">:failure</span>:<br><br>- (NSURLSessionDataTask*)<span class="hljs-variable constant_">DELETE</span><span class="hljs-symbol">:parameters</span><span class="hljs-symbol">:success</span><span class="hljs-symbol">:failure</span>:<br><br>- (NSURLSessionDataTask*)<span class="hljs-variable constant_">HEAD</span><span class="hljs-symbol">:parameters</span><span class="hljs-symbol">:success</span><span class="hljs-symbol">:failure</span>:<br><br>- (NSURLSessionDataTask*)<span class="hljs-variable constant_">PATCH</span><span class="hljs-symbol">:parameters</span><span class="hljs-symbol">:success</span><span class="hljs-symbol">:failure</span><span class="hljs-symbol">:</span><br></code></pre></td></tr></table></figure><p>6 种任务最终通过下面这个统一入口调用父类AFURLSessionManager中的方法发起网络任务。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//AFHTTPSessionManager.m</span><br>- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:<br><span class="hljs-symbol">URLString:</span>parameters:uploadProgress:downloadProgress:success:failure:<br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">//拼接request参数</span><br>    NSMutableURLRequest *<span class="hljs-attr">request</span> <span class="hljs-operator">=</span> [self.requestSerializer<br><span class="hljs-symbol">    requestWithMethod:</span>method <br><span class="hljs-symbol">    URLString:</span>[[NSURL URLWithString:URLString <br><span class="hljs-symbol">    relativeToURL:</span>self.baseURL] absoluteString] <br><span class="hljs-symbol">    parameters:</span>parameters <br><span class="hljs-symbol">    error:</span><span class="hljs-variable">&amp;</span>serializationError]<span class="hljs-punctuation">;</span><br>    <span class="hljs-comment">/***略***/</span><br>    __block NSURLSessionDataTask *dataT<span class="hljs-attr">ask</span> <span class="hljs-operator">=</span> <span class="hljs-attr">nil</span><span class="hljs-punctuation">;</span><br>    <span class="hljs-comment">//调用父类 AFURLSessionManager 中的方法发起请求</span><br>    dataT<span class="hljs-attr">ask</span> <span class="hljs-operator">=</span> [self dataTaskWithRequest:request<br><span class="hljs-symbol">                          uploadProgress:</span>uploadProgress<br><span class="hljs-symbol">                        downloadProgress:</span>downloadProgress<br><span class="hljs-symbol">                       completionHandler:</span>^(/../) <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">/**略**/</span><br>    <span class="hljs-punctuation">&#125;</span>]<span class="hljs-punctuation">;</span><br>    return dataT<span class="hljs-attr">ask</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>AFURLSessionManager中对应的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//AFURLSessionManager.m</span><br>- (<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:<br>uploadProgress:downloadProgress:completionHandler:<br>&#123;<br>    __block <span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">//修复iOS8以下并发队列中任务标识符不唯一的问题（串行+同步）</span><br>    url_session_manager_create_task_safely(^&#123;<br>        dataTask = [<span class="hljs-keyword">self</span>.session dataTaskWithRequest:request];<span class="hljs-comment">//发起请求</span><br>    &#125;);<br>    <span class="hljs-comment">//绑定 AFURLSessionManagerTaskDelegate 对象</span><br>    [<span class="hljs-keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];<br>    <span class="hljs-keyword">return</span> dataTask;<br>&#125;<br></code></pre></td></tr></table></figure><p>发起请求的操作被放在一个名为 url_session_manager_create_task_safely 的 block 里：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">url_session_manager_create_task_safely</span>(<br>dispatch_block_t block) &#123;<br>    if (NSFoundationVersionNumber &lt; <br>    NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;<br>        <span class="hljs-built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);<br>    &#125; else &#123;<br>        block();<br>    &#125;<br>&#125;<br>static dispatch_queue_t <span class="hljs-built_in">url_session_manager_creation_queue</span>() &#123;<br>    static dispatch_queue_t af_url_session_manager_creation_queue;<br>    static dispatch_once_t onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        af_url_session_manager_creation_queue = dispatch_queue_create(<br>        &quot;com.alamofire.networking.session.manager.creation&quot;, <br>        DISPATCH_QUEUE_SERIAL);<br>    &#125;);<br>    return af_url_session_manager_creation_queue;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 block 是用来修复 iOS8 以下创建 NSURLSession 时<code>taskIdentifier</code>不唯一的问题。</p><p><code>taskIdentifier</code>在后面会被用作保存 AFURLSessionManagerTaskDelegate 对象的 key。所以存在多个 NSURLSession 时，如果此值不唯一，那么 AFURLSessionManagerTaskDelegate 对象与 dataTask 的映射就会出问题。修复方法就是在iOS8以下使用<code>串行</code>+<code>同步</code>的方式发起请求。</p><h4 id="3-TaskDelegate"><a href="#3-TaskDelegate" class="headerlink" title="3.TaskDelegate"></a>3.TaskDelegate</h4><p>这是一个定义在<code>AFURLSessionManager.m</code>内部的类，内容如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AFURLSessionManagerTaskDelegate</span> : <span class="hljs-title">NSObject</span> </span><br><br>&lt;<span class="hljs-built_in">NSURLSessionTaskDelegate</span>, <br><span class="hljs-built_in">NSURLSessionDataDelegate</span>, <br><span class="hljs-built_in">NSURLSessionDownloadDelegate</span>&gt;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) AFURLSessionManager *manager;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableData</span> *mutableData;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSProgress</span> *uploadProgress;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSProgress</span> *downloadProgress;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSURL</span> *downloadFileURL;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock <br>downloadTaskDidFinishDownloading;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) AFURLSessionTaskProgressBlock uploadProgressBlock;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) AFURLSessionTaskProgressBlock downloadProgressBlock;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) AFURLSessionTaskCompletionHandler completionHandler;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>作用：作为工具类处理 NSURLSession 的数据回调：持有返回的数据、监听进度、回到主线程。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - NSURLSessionDataTaskDelegate</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>didReceiveData:(<span class="hljs-built_in">NSData</span> *)data<br>&#123;<br>    [<span class="hljs-keyword">self</span>.mutableData appendData:data];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark - NSURLSessionTaskDelegate</span><br>- (<span class="hljs-type">void</span>)URLSession:(__unused <span class="hljs-built_in">NSURLSession</span> *)session<br>task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-comment">//略..</span><br>    <span class="hljs-comment">//dispatch_group 的方式回到主线程执行 block</span><br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        dispatch_group_async(<br>                manager.completionGroup ?: url_session_manager_completion_group(),<br>                manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.completionHandler) &#123;<br>                <span class="hljs-keyword">self</span>.completionHandler(task.response, responseObject, error);<br>            &#125;<br>            <span class="hljs-comment">//略..</span><br>            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];<span class="hljs-comment">//发送通知</span><br>            &#125;);<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;<br>            <span class="hljs-comment">//执行回调&amp;发送通知 代码略..</span><br>            &#125;);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AFURLSessionManagerTaskDelegate 与 AFURLSessionManager 是如何关联起来的呢？</p><p><code>#1.2</code>章节中说到，AFURLSessionManager 最终会通过统一的入口调用父类中的方法发起请求。在父类发起网络请求后，紧接着就会调用到以下函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- (<span class="hljs-keyword">void</span>)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask<br>uploadProgress:(<span class="hljs-keyword">void</span> (^)(NSProgress *uploadProgress)) uploadProgressBlock<br>downloadProgress:(<span class="hljs-keyword">void</span> (^)(NSProgress *downloadProgress)) downloadProgressBlock<br>completionHandler:(<span class="hljs-keyword">void</span> (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler<br>&#123;<br>    AFURLSessionManagerTaskDelegate *<span class="hljs-built_in">delegate</span> = [[AFURLSessionManagerTaskDelegate <br>    alloc] <span class="hljs-keyword">init</span>];<br>    <span class="hljs-built_in">delegate</span>.manager = self;<br>    <span class="hljs-built_in">delegate</span>.completionHandler = completionHandler;<br><br>    dataTask.taskDescription = self.taskDescriptionForSessionTasks;<br>    [<span class="hljs-meta">self setDelegate:delegate forTask:dataTask</span>];<br><br>    <span class="hljs-built_in">delegate</span>.uploadProgressBlock = uploadProgressBlock;<br>    <span class="hljs-built_in">delegate</span>.downloadProgressBlock = downloadProgressBlock;<br>&#125;<br>- (<span class="hljs-keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)<span class="hljs-built_in">delegate</span> forTask:(NSURLSessionTask *)task<br>&#123;<br>    [<span class="hljs-meta">self.lock lock</span>];<span class="hljs-comment">//保证读写操作的线程安全</span><br>    self.mutableTaskDelegatesKeyedByTaskIdentifier<br>    [@(task.taskIdentifier)] = <span class="hljs-built_in">delegate</span>; <span class="hljs-comment">//以task的标识符为键，与delegate进行映射</span><br>    <br>    [<span class="hljs-meta">delegate setupProgressForTask:task</span>];<br>    [<span class="hljs-meta">self addNotificationObserverForTask:task</span>];<br>    [<span class="hljs-meta">self.lock unlock</span>];<br>&#125;<br>- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task <br>&#123;<br>    AFURLSessionManagerTaskDelegate *<span class="hljs-built_in">delegate</span> = nil;<br>    [<span class="hljs-meta">self.lock lock</span>];<br>    <span class="hljs-built_in">delegate</span> = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];<br>    [<span class="hljs-meta">self.lock unlock</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">delegate</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，<code>AFURLSessionManagerTaskDelegate</code>是通过 -setDelegate:forTask: 方法，作为 AFURLSessionManager 中<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>字典属性的 value 被保存起来的，其key 是 NSURLSessionTask 的<code>taskIdentifier</code>。读取时通过-delegateForTask: 根据此标识符取出 task 对应的代理。</p><p>另外，AFURLSessionManagerTaskDelegate 定义里有个属性：AFURLSessionManager *manager，在函数 -addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler: 里这个 manager 被设置为 self。那么这里存在一个引用链：AFURLSessionManager -&gt; mutableTaskDelegatesKeyedByTaskIdentifier -&gt; AFURLSessionManagerTaskDelegate -&gt; AFURLSessionManager。</p><p>这里看似有个相互引用问题，AFN的处理是使用<code>weak</code>声明 manager 属性（见上面的定义），并在请求执行完成后的回调函数里做了如下处理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    AFURLSessionManagerTaskDelegate *delegate = [<span class="hljs-keyword">self</span> delegateForTask:task];<br>    <span class="hljs-keyword">if</span> (delegate) &#123;<br>        [delegate URLSession:session task:task didCompleteWithError:error];<br>        [<span class="hljs-keyword">self</span> removeDelegateForTask:task];<span class="hljs-comment">//注意 就是这一个操作</span><br>    &#125;<br>&#125;<br>- (<span class="hljs-type">void</span>)removeDelegateForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task <br>&#123;<br>    [<span class="hljs-keyword">self</span>.lock lock];<br>    <span class="hljs-comment">//移除 AFURLSessionManagerTaskDelegate 对象</span><br>    [<span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure><p>AFURLSessionManagerTaskDelegate 对象被从 mutableTaskDelegatesKeyedByTaskIdentifier 字典中移除。那么这个引用链就被打破，也就不存在相互引用问题了。</p><h4 id="4-监听进度"><a href="#4-监听进度" class="headerlink" title="4.监听进度"></a>4.监听进度</h4><p>TaskDelegate 作为<code>代理</code>会监听任务的进度。其内部是通过 KVO 监听 NSURLSessionTask 的<code>countOfBytesSent</code>等字段实现的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)setupProgressForTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task <br>&#123;<br>    [task addObserver:<span class="hljs-keyword">self</span><br>           forKeyPath:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesReceived))<br>              options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span><br>              context:<span class="hljs-literal">NULL</span>];<br>    [task addObserver:<span class="hljs-keyword">self</span><br>           forKeyPath:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToReceive))<br>              options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span><br>              context:<span class="hljs-literal">NULL</span>];<br><br>    [task addObserver:<span class="hljs-keyword">self</span><br>           forKeyPath:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesSent))<br>              options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span><br>              context:<span class="hljs-literal">NULL</span>];<br>    [task addObserver:<span class="hljs-keyword">self</span><br>           forKeyPath:<span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesExpectedToSend))<br>              options:<span class="hljs-built_in">NSKeyValueObservingOptionNew</span><br>              context:<span class="hljs-literal">NULL</span>];<br>    <span class="hljs-comment">//。。。</span><br>&#125;<br><br>- (<span class="hljs-type">void</span>)observeValueForKeyPath:(<span class="hljs-built_in">NSString</span> *)keyPath ofObject:(<span class="hljs-type">id</span>)object change:(<span class="hljs-built_in">NSDictionary</span> *)change context:(<span class="hljs-type">void</span> *)context <br>&#123;<br>    <span class="hljs-keyword">if</span> ([object isKindOfClass:[<span class="hljs-built_in">NSURLSessionTask</span> <span class="hljs-keyword">class</span>]] || <br>    [object isKindOfClass:[<span class="hljs-built_in">NSURLSessionDownloadTask</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        <span class="hljs-keyword">if</span> ([keyPath isEqualToString:<br>        <span class="hljs-built_in">NSStringFromSelector</span>(<span class="hljs-keyword">@selector</span>(countOfBytesReceived))]) &#123;<br>            <span class="hljs-keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="hljs-built_in">NSKeyValueChangeNewKey</span>] longLongValue];<br>        &#125;<br>        <span class="hljs-comment">//。。。</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.downloadProgress]) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.downloadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.downloadProgressBlock(object);<span class="hljs-comment">//下载回调</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([object isEqual:<span class="hljs-keyword">self</span>.uploadProgress]) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.uploadProgressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.uploadProgressBlock(object);<span class="hljs-comment">//上传回调</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Serialization"><a href="#4-Serialization" class="headerlink" title="4.Serialization"></a>4.Serialization</h3><h4 id="1-AFURLRequestSerialization"><a href="#1-AFURLRequestSerialization" class="headerlink" title="1.AFURLRequestSerialization"></a>1.AFURLRequestSerialization</h4><p>根据用户设置的请求类型，设置 NSURLRequest 的各项参数。</p><ul><li>自定义属性参数：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSStringEncoding</span> stringEncoding;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-type">BOOL</span> allowsCellularAccess;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSURLRequestCachePolicy</span> cachePolicy;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-type">BOOL</span> HTTPShouldHandleCookies;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-type">BOOL</span> HTTPShouldUsePipelining;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSURLRequestNetworkServiceType</span> networkServiceType;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSTimeInterval</span> timeoutInterval;<br></code></pre></td></tr></table></figure><ul><li>设置请求方法、请求头、请求体：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="hljs-built_in">NSString</span> *)method URLString:(<span class="hljs-built_in">NSString</span> *)URLString parameters:(<span class="hljs-type">id</span>)parameters error:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:URLString];<br>    <span class="hljs-built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="hljs-built_in">NSMutableURLRequest</span> <br>    alloc] initWithURL:url];<br>    <span class="hljs-comment">//设置HTTPMethod（GET POST等）</span><br>    mutableRequest.HTTPMethod = method;<br>    <span class="hljs-comment">//。。</span><br>    mutableRequest = [[<span class="hljs-keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];<br>    <span class="hljs-keyword">return</span> mutableRequest;<br>&#125;<br><br>- (<span class="hljs-built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request withParameters:(<span class="hljs-type">id</span>)parameters error:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-comment">//。。。</span><br>    <span class="hljs-keyword">if</span> (parameters) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.queryStringSerialization) &#123;<span class="hljs-comment">//如果有自定义的解析方式</span><br>            <span class="hljs-built_in">NSError</span> *serializationError;<br>            query = <span class="hljs-keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);<br>            <span class="hljs-comment">//...</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//默认的解析方式</span><br>            <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">self</span>.queryStringSerializationStyle) &#123;<br>                <span class="hljs-keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:<br>                    query = AFQueryStringFromParameters(parameters);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果是GET、HEAD、DELETE方法，参数追加到 URL 尾部</span><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:<br>        [[request HTTPMethod] uppercaseString]]) &#123;<br>        <span class="hljs-keyword">if</span> (query &amp;&amp; query.length &gt; <span class="hljs-number">0</span>) &#123;<br>            mutableRequest.URL = [<span class="hljs-built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString]  stringByAppendingFormat:mutableRequest.URL.query ? <span class="hljs-string">@&quot;&amp;%@&quot;</span> : <span class="hljs-string">@&quot;?%@&quot;</span>, query]];<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//POST、PUT方法的参数会放到 HTTPBody 里</span><br>        <span class="hljs-keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>]) &#123;<br>            [mutableRequest setValue:<span class="hljs-string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="hljs-string">@&quot;Content-Type&quot;</span>];<br>        &#125;<br>        <span class="hljs-comment">//设置HTTPBody</span><br>        [mutableRequest setHTTPBody:<br>        [query dataUsingEncoding:<span class="hljs-keyword">self</span>.stringEncoding]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> mutableRequest;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-AFHTTPResponseSerializer"><a href="#2-AFHTTPResponseSerializer" class="headerlink" title="2.AFHTTPResponseSerializer"></a>2.AFHTTPResponseSerializer</h4><p>校验返回的<code>response</code>和<code>data</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)validateResponse:(<span class="hljs-built_in">NSHTTPURLResponse</span> *)response<br>                    data:(<span class="hljs-built_in">NSData</span> *)data<br>                   error:(<span class="hljs-built_in">NSError</span> * __autoreleasing *)error<br>&#123;<br>    <span class="hljs-type">BOOL</span> responseIsValid = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-built_in">NSError</span> *validationError = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="hljs-built_in">NSHTTPURLResponse</span> <span class="hljs-keyword">class</span>]]) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="hljs-keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp; !([response MIMEType] == <span class="hljs-literal">nil</span> &amp;&amp; [data length] == <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-keyword">if</span> ([data length] &gt; <span class="hljs-number">0</span> &amp;&amp; [response URL]) &#123;<br>                <span class="hljs-comment">//不支持的 content-type</span><br>                responseIsValid = <span class="hljs-literal">NO</span>;<br>            &#125;<br>            responseIsValid = <span class="hljs-literal">NO</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="hljs-keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="hljs-built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;<br>            <span class="hljs-comment">//返回了不支持的状态码</span><br>            responseIsValid = <span class="hljs-literal">NO</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;<br>        *error = validationError;<br>    &#125;<br>    <span class="hljs-keyword">return</span> responseIsValid;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Reachability"><a href="#5-Reachability" class="headerlink" title="5.Reachability"></a>5.Reachability</h3><p>使用 SystemConfiguration.framework 中的 SCNetworkReachability 类，监听网络状态：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The current network reachability status.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) AFNetworkReachabilityStatus networkReachabilityStatus;<br></code></pre></td></tr></table></figure><p>网络状况的枚举定义如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;<br>    AFNetworkReachabilityStatusUnknown          = -<span class="hljs-number">1</span>,<span class="hljs-regexp">//</span>未知<br>    AFNetworkReachabilityStatusNotReachable     = <span class="hljs-number">0</span>, <span class="hljs-regexp">//</span>未联网<br>    AFNetworkReachabilityStatusReachableViaWWAN = <span class="hljs-number">1</span>, <span class="hljs-regexp">//</span>蜂窝网络<br>    AFNetworkReachabilityStatusReachableViaWiFi = <span class="hljs-number">2</span>, <span class="hljs-regexp">//</span>WIFI<br>    AFNetworkReachabilityStatusReachableVia2G = <span class="hljs-number">3</span>,   <span class="hljs-regexp">//</span><span class="hljs-number">2</span>G<br>    AFNetworkReachabilityStatusReachableVia3G = <span class="hljs-number">4</span>,   <span class="hljs-regexp">//</span><span class="hljs-number">3</span>G<br>    AFNetworkReachabilityStatusReachableVia4G = <span class="hljs-number">5</span>,   <span class="hljs-regexp">//</span><span class="hljs-number">4</span>G<br>&#125;;<br></code></pre></td></tr></table></figure><p>可在 AppDelegate 中开启网络状态的监听：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//开启AFNetworking网络监测</span><br>    AFNetworkReachabilityManager *shareMana = [AFNetworkReachabilityManager sharedManager];<br>    [shareMana startMonitoring];<br>    [shareMana setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;<br>        <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;);<br>    &#125;];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-Security"><a href="#6-Security" class="headerlink" title="6.Security"></a>6.Security</h3><p>处理与服务器交互时的验证问题，保证应用与服务器通信时的SSL连接安全。</p><p>客户端与服务器进行通信时，服务器会返回一个SSL证书，客户端需要验证证书的颁发机构、公钥、是否过期等信息。SSL Pinning 就是iOS中用来处理此类事务的，它可以按照你的设置，将服务器下发的证书与本地保存的证书进行对比，验证通过才能继续通信。这些设置在 AFN 中分三类：</p><table><thead><tr><th>验证模式</th><th>作用</th></tr></thead><tbody><tr><td>AFSSLPinningModeNone</td><td>客户端无条件地信任服务器端返回的证书，不做校验；</td></tr><tr><td>AFSSLPinningModePublicKey</td><td>只验证服务器端返回的证书中公钥的部分，与本地证书一致才继续；有效期等不做校验（省去过期的麻烦）；</td></tr><tr><td>AFSSLPinningModeCertificate</td><td>验证服务器端返回的证书和本地保存的证书中的所有内容，有一项不符合则验证失败；</td></tr></tbody></table><p>AFN 会根据用户设置的验证模式处理 SSL Pinning 验证业务。其中后两种验证模式需要将服务器的证书文件拷贝一份保存到工程目录中。</p><ul><li>具体实践：</li></ul><p>AFN的 AFHTTPSessionManager 类中有个<code>securityPolicy</code>属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> The security policy used by created session to evaluate server trust for secure connections. </span><br><span class="hljs-comment"> *`AFURLSessionManager` uses the `defaultPolicy` unless otherwise specified.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) AFSecurityPolicy *securityPolicy;<br></code></pre></td></tr></table></figure><p>一般是在基于 AFHTTPSessionManager 的单例类中给 securityPolicy 属性指定一个验证模式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TLHttpAPIClient</span> : <span class="hljs-title">AFHTTPSessionManager</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TLHttpAPIClient</span></span><br>+ (<span class="hljs-keyword">instancetype</span>)sharedClient &#123;<br>    <span class="hljs-keyword">static</span> TLHttpAPIClient *sharedClient = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        sharedClient = [TLHttpAPIClient new];<br>        <span class="hljs-comment">// 设置证书验证模式</span><br>        AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode: AFSSLPinningModeCertificate];<br>        <span class="hljs-comment">// 证书在bundle中的路径</span><br>        <span class="hljs-built_in">NSString</span> *cerPath = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@&quot;Demo&quot;</span> ofType:<span class="hljs-string">@&quot;cer&quot;</span>];<br>        <span class="hljs-built_in">NSData</span> *cerData  = [<span class="hljs-built_in">NSData</span> dataWithContentsOfFile:cerPath];<br>        [securityPolicy setPinnedCertificates:@[cerData]];<br>        sharedClient.securityPolicy = securityPolicy;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> sharedClient;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>AFSSLPinningModeNone模式下不用设置证书路径。使用证书进行验证时，注意证书是否过期。</p><h3 id="7-小结"><a href="#7-小结" class="headerlink" title="7.小结"></a>7.小结</h3><p>源码部分暂时先写到这，UIKit+AFNetworking 部分及其他细节待续~~说说目前对AFN的感受吧。</p><ul><li>各模块分工清晰，职责明确，高聚合、低耦合；</li><li>请求被封装成6个数据接口和上传下载接口，方便地应对各种场景；</li><li>大量使用了异步、block、C函数；</li></ul><p>多翻翻 AFN 在Github上的 <a href="https://github.com/AFNetworking/AFNetworking/issues">issue</a> 和解决方案，看人家是怎么解决问题的，会有很多收获~</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDWebImage</title>
    <link href="/2018/01/28/sd.html"/>
    <url>/2018/01/28/sd.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-导入"><a href="#1-导入" class="headerlink" title="1.导入"></a>1.导入</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">platform</span> :ios, <span class="hljs-string">&#x27;10.0&#x27;</span><br><span class="hljs-comment">//ASDF替换为自己项目的target名</span><br>target ‘ASDF’ <span class="hljs-keyword">do</span><br>pod <span class="hljs-string">&#x27;SDWebImage&#x27;</span>, <span class="hljs-string">&#x27;~&gt; 3.7.3&#x27;</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h3><p>以常用的<code>UIImageView</code>设置图片为例：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>sd_setImageWithURL:<span class="hljs-params">(NSURL *)</span>url <br>          placeholderImage:<span class="hljs-params">(UIImage *)</span>placeholder <br>                   options:<span class="hljs-params">(SDWebImageOptions)</span>options <br>                  progress:<span class="hljs-params">(SDWebImageDownloaderProgressBlock)</span>progressBlock <br>                 completed:<span class="hljs-params">(SDWebImageCompletionBlock)</span>completedBlock;<br></code></pre></td></tr></table></figure><p>参数</p><ul><li>url为图片地址。</li><li>placeholder为占位图。</li><li>progressBlock为进度。</li><li>completedBlock下载完成或有缓存时的回调。</li><li>options一般使用 SDWebImageRetryFailed | SDWebImageLowPriority，具体如下：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;<br><br>    SDWebImageRetryFailed = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,    <span class="hljs-regexp">//</span>下载失败了会再次尝试下载(默认情况下失败的图片链接不会再重新下载)<br>    WebImageLowPriority = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,      <span class="hljs-regexp">//</span>UIScrollView等正在滚动时延迟下载图片（默认情况下不延迟，立刻开始）<br>    SDWebImageCacheMemoryOnly = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,<span class="hljs-regexp">//</span>只缓存到内存中<br>    SDWebImageProgressiveDownload = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,<span class="hljs-regexp">//</span> 图片会边下边显示<br>    SDWebImageRefreshCached = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>, <span class="hljs-regexp">//</span>强制重新请求图片并刷新缓存，将硬盘缓存交给系统自带的NSURLCache去处理<br>    SDWebImageContinueInBackground = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>,<span class="hljs-regexp">//</span>后台下载<br>    SDWebImageHandleCookies = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>, <span class="hljs-regexp">//</span>处理cookie，请求的request.HTTPShouldHandleCookies 会被置为 YES;<br>    SDWebImageAllowInvalidSSLCertificates = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>,<span class="hljs-regexp">//</span> 允许不受信任的SSL证书<br>    SDWebImageHighPriority = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>,  <span class="hljs-regexp">//</span>优先下载，下载任务的优先级为高<br>    SDWebImageDelayPlaceholder = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>,<span class="hljs-regexp">//</span>延迟占位符<br>    SDWebImageTransformAnimatedImage = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>,<span class="hljs-regexp">//</span>改变动画形象<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-WebCache分类"><a href="#1-WebCache分类" class="headerlink" title="1.+WebCache分类"></a>1.+WebCache分类</h4><p>作用：对外暴露设置图片的接口。</p><ol><li>在新的图片加载前，取消本视图之前正在进行的下载任务；</li><li>交由 SDWebImageManager 接着处理图片下载逻辑；</li><li>保存当前下载任务；</li><li>图片下载成功或失败，回到主线程回调数据并给视图设置图片；</li></ol><p>源码摘要：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// UIImageView+WebCache.m</span><br><br>- (<span class="hljs-type">void</span>)sd_setImageWithURL:(<span class="hljs-built_in">NSURL</span> *)url<br>placeholderImage:(<span class="hljs-built_in">UIImage</span> *)placeholder<br>options:(SDWebImageOptions)options<br>progress:(SDWebImageDownloaderProgressBlock)progressBlock<br>completed:(SDWebImageCompletionBlock)completedBlock<br>&#123;<br>    <span class="hljs-comment">//step.1 取消之前正在下载的操作</span><br>    [<span class="hljs-keyword">self</span> sd_cancelCurrentImageLoad];<br>    <span class="hljs-comment">//保存该视图用到的图片URL</span><br>    objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-keyword">if</span> (url) &#123;<br>        __<span class="hljs-keyword">weak</span> __<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>)wself = <span class="hljs-keyword">self</span>;<br>        <span class="hljs-comment">//step.2 由SDWebImageManager下载图片</span><br>        <span class="hljs-type">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager<br>        downloadImageWithURL:url<br>        options:options<br>        progress:progressBlock<br>        completed:^(<span class="hljs-built_in">UIImage</span> *image,<br>        <span class="hljs-built_in">NSError</span> *error, SDImageCacheType cacheType,<br>        <span class="hljs-type">BOOL</span> finished, <span class="hljs-built_in">NSURL</span> *imageURL)<br>        &#123;<br>            <span class="hljs-comment">/*step.4 图片下载结果返回，回到主线层*/</span><br>        &#125;];<br>        <span class="hljs-comment">//step.3 保存此次下载操作</span><br>        [<span class="hljs-keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="hljs-string">@&quot;UIImageViewImageLoad&quot;</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现细节：</p><ul><li>1、创建下载任务</li></ul><p>图片的下载任务是由 SDWebImageManager 执行的，它的实现细节后面会讲，这里只需要知道下载的操作经过两次封装，最终被封装到 SDWebImageCombinedOperation 对象中：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@protocol</span> SDWebImageOperation &lt;NSObject&gt;<br>- (void)cancel; <span class="hljs-comment">// 只定义了这么一个取消的方法~~</span><br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">SDWebImageCombinedOperation </span>: NSObject &lt;SDWebImageOperation&gt;<br><br><span class="hljs-variable">@property</span> (assign, nonatomic, getter = isCancelled) BOOL cancelled;<br><span class="hljs-variable">@property</span> (copy, nonatomic) SDWebImageNoParamsBlock cancelBlock; <span class="hljs-comment">// 在创建任务时会被赋值</span><br><span class="hljs-variable">@property</span> (strong, nonatomic) NSOperation *cacheOperation; <span class="hljs-comment">// 真正执行下载任务的类</span><br><br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><p>调用<code>SDWebImageManager</code>执行下载时，会返回一个<code>SDWebImageCombinedOperation</code>任务对象：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs erlang">// SDWebImageManager.m<br>- <span class="hljs-params">(id &lt;SDWebImageOperation&gt;)</span>downloadImageWithURL:<span class="hljs-params">(NSURL *)</span>url<br>                                         options:<span class="hljs-params">(SDWebImageOptions)</span>options<br>                                        progress:<span class="hljs-params">(SDWebImageDownloaderProgressBlock)</span>progressBlock<br>                                       completed:<span class="hljs-params">(SDWebImageCompletionWithFinishedBlock)</span>completedBlock&#123;<br>                                       <br>                        __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];<br>                        // 略...<br>                        return operation;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>2、保存下载任务</li></ul><p>上面返回的 SDWebImageCombinedOperation 任务对象会被保存到当前视图的对象中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> UIImageView+WebCache.m<br>[self sd_setImageLoadOperation:operation forKey:@<span class="hljs-string">&quot;UIImageViewImageLoad&quot;</span>];<br></code></pre></td></tr></table></figure><p>保存接口的具体实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 属性Getter</span><br>- (<span class="hljs-built_in">NSMutableDictionary</span> *)operationDictionary &#123;<br>    <span class="hljs-comment">// 如果关联对象存在，则返回它</span><br>    <span class="hljs-built_in">NSMutableDictionary</span> *operations = objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;loadOperationKey);<br>    <span class="hljs-keyword">if</span> (operations) &#123;<br>        <span class="hljs-keyword">return</span> operations;<br>    &#125;<br>    <span class="hljs-comment">// 如果关联对象不存在，则创建一个新的并返回它</span><br>    operations = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>    objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br>    <span class="hljs-keyword">return</span> operations;<br>&#125;<br><span class="hljs-comment">// 保存任务</span><br>- (<span class="hljs-type">void</span>)sd_setImageLoadOperation:(<span class="hljs-type">id</span>)operation forKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-comment">// 如果同一个视图之前有下载任务，则先取消之前的任务</span><br>    [<span class="hljs-keyword">self</span> sd_cancelImageLoadOperationWithKey:key];<br>    <span class="hljs-built_in">NSMutableDictionary</span> *operationDictionary = [<span class="hljs-keyword">self</span> operationDictionary];<br>    [operationDictionary setObject:operation forKey:key];<br>&#125;<br></code></pre></td></tr></table></figure><p>使用对象关联技术将下载任务保存到当前分类中的<code>operationDictionary</code>字典属性中。</p><ul><li>3、取消上一个正在进行的下载任务；</li></ul><p>场景：cell 被重用时上一张图片尚未加载完，需要取消上一次的加载任务并加载新的图片。</p><p>当前视图中所有的下载任务都保存在<code>operationDictionary</code>中，取消任务时要先从此字典中取出之前的任务，再执行取消方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)sd_cancelCurrentImageLoad &#123;<br>    [<span class="hljs-keyword">self</span> sd_cancelImageLoadOperationWithKey:<span class="hljs-string">@&quot;UIImageViewImageLoad&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-comment">// Cancel in progress downloader from queue</span><br>    <span class="hljs-built_in">NSMutableDictionary</span> *operationDictionary = [<span class="hljs-keyword">self</span> operationDictionary];<br>    <span class="hljs-comment">// 取出任务</span><br>    <span class="hljs-type">id</span> operations = [operationDictionary objectForKey:key];<br>    <span class="hljs-keyword">if</span> (operations) &#123;<br>        <span class="hljs-keyword">if</span> ([operations isKindOfClass:[<span class="hljs-built_in">NSArray</span> <span class="hljs-keyword">class</span>]]) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">id</span> &lt;SDWebImageOperation&gt; operation <span class="hljs-keyword">in</span> operations) &#123;<br>                <span class="hljs-keyword">if</span> (operation) &#123;<br>                    [operation cancel]; <span class="hljs-comment">// 取消</span><br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([operations conformsToProtocol:<span class="hljs-class"><span class="hljs-keyword">@protocol</span>(<span class="hljs-title">SDWebImageOperation</span>)])</span>&#123;<br>            [(<span class="hljs-type">id</span>&lt;SDWebImageOperation&gt;) operations cancel]; <span class="hljs-comment">// 取消</span><br>        &#125;<br>        [operationDictionary removeObjectForKey:key];  <span class="hljs-comment">//从字典中移除上一个任务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>取消操作调用的是 SDWebImageCombinedOperation 对象 的 cancel 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SDWebImageCombinedOperation</span></span><br><br>- (<span class="hljs-type">void</span>)cancel &#123;<br>    <span class="hljs-keyword">self</span>.cancelled = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cacheOperation) &#123;<br>        [<span class="hljs-keyword">self</span>.cacheOperation cancel];<br>        <span class="hljs-keyword">self</span>.cacheOperation = <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.cancelBlock) &#123;<br>        <span class="hljs-keyword">self</span>.cancelBlock();<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> this is a temporary fix to #809.</span><br>        <span class="hljs-comment">// Until we can figure the exact cause of the crash, going with the ivar instead of the setter</span><br><span class="hljs-comment">//        self.cancelBlock = nil;</span><br>        _cancelBlock = <span class="hljs-literal">nil</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，最终取消的是真正的图片下载任务<code>cacheOperation</code>对象，这是一个 NSOperation 实例。</p><h4 id="2-Manager"><a href="#2-Manager" class="headerlink" title="2.Manager"></a>2.Manager</h4><p>作用：做下载前的各项检查，缓存下载完成后的图片并返回。</p><ol><li>检测URL是否下载失败过，失败过的URL不再重复下载；</li><li>根据URL生成的key查询图片缓存，有缓存且不要求强制刷新缓存时使用缓存图片；</li><li>没有缓存时，交给 SDWebImageDownloader，封装请求并创建任务和队列，发起网络请求；</li><li>缓存下载完成后的图片，返回主线程；</li></ol><p>源码摘要：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// SDWebImageManager.m</span><br><br>- (<span class="hljs-type">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="hljs-built_in">NSURL</span> *)url<br>options:(SDWebImageOptions)options<br>progress:(SDWebImageDownloaderProgressBlock)progressBlock<br>completed:(SDWebImageCompletionWithFinishedBlock)completedBlock<br>&#123;<br>    <span class="hljs-comment">/*...*/</span><br>    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];<br><br>    <span class="hljs-comment">//step.1 检测URL之前是否下载失败</span><br>    <span class="hljs-type">BOOL</span> isFailedUrl = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>.failedURLs) &#123;<br>        isFailedUrl = [<span class="hljs-keyword">self</span>.failedURLs containsObject:url];<br>    &#125;<br>    <span class="hljs-comment">//URL错误或之前下载失败过，则不再重复下载失效的URL</span><br>    <span class="hljs-keyword">if</span> (url.absoluteString.length == <span class="hljs-number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;<br>        dispatch_main_sync_safe(^&#123;<br>            <span class="hljs-built_in">NSError</span> *error = ...;<br>            completedBlock(<span class="hljs-literal">nil</span>, error, SDImageCacheTypeNone, <span class="hljs-literal">YES</span>, url);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> operation;<br>    &#125;<br>    <span class="hljs-comment">//将当前下载 operation 加入到数组中</span><br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>.runningOperations) &#123;<br>        [<span class="hljs-keyword">self</span>.runningOperations addObject:operation];<br>    &#125;<br>    <span class="hljs-comment">//step.2 根据URL生成对应的key查询缓存 没有缓存则开始下载</span><br>    <span class="hljs-built_in">NSString</span> *key = [<span class="hljs-keyword">self</span> cacheKeyForURL:url];<br>    operation.cacheOperation = [<span class="hljs-keyword">self</span>.imageCache queryDiskCacheForKey:key<br>                                                done:^(<span class="hljs-built_in">UIImage</span> *image, SDImageCacheType cacheType)&#123;<br>    <span class="hljs-keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp;<br>    (![<span class="hljs-keyword">self</span>.delegate respondsToSelector:<br>    <span class="hljs-keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] ||<br>    [<span class="hljs-keyword">self</span>.delegate imageManager:<span class="hljs-keyword">self</span> shouldDownloadImageForURL:url]))<br>    &#123;<br>        <span class="hljs-comment">/*如果有缓存但采用了 RefreshCached 策略，</span><br><span class="hljs-comment">        则执行回调并继续下载，以便让服务器刷新 NSURLCache 里的内容。*/</span><br>        <span class="hljs-keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;<br>            dispatch_main_sync_safe(^&#123;<br>                completedBlock(image, <span class="hljs-literal">nil</span>, cacheType, <span class="hljs-literal">YES</span>, url);<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">//step.4 使用imageDownloader开启网络下载</span><br>        <span class="hljs-type">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="hljs-keyword">self</span>.imageDownloader<br>        downloadImageWithURL:url<br>        options:downloaderOptions<br>        progress:progressBlock<br>        completed:^(<span class="hljs-built_in">UIImage</span> *downloadedImage, <span class="hljs-built_in">NSData</span> *data, <span class="hljs-built_in">NSError</span> *error, <span class="hljs-type">BOOL</span> finished)<br>        &#123;<br>            <span class="hljs-comment">//step.5 图片下载完成，根据设置进行图片转换和缓存</span><br>            /.../<br>            <span class="hljs-keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;<br>                <span class="hljs-comment">//step.5 图片下载完成，不需要转换时，将图片保存到缓存中并返回主线程</span><br>                [<span class="hljs-keyword">self</span>.imageCache storeImage:downloadedImage<br>                recalculateFromImage:<span class="hljs-literal">NO</span><br>                imageData:data<br>                forKey:key<br>                toDisk:cacheOnDisk];<br>            &#125;<br>            dispatch_main_sync_safe(^&#123;<br>                <span class="hljs-keyword">if</span> (!weakOperation.isCancelled) &#123;<br>                    completedBlock(downloadedImage, <span class="hljs-literal">nil</span>, SDImageCacheTypeNone, finished, url);<br>            &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (image) &#123;<br>        <span class="hljs-comment">//step.3 有缓存且不要求强制刷新缓存时，在缓存中找到图片，直接返回</span><br>        dispatch_main_sync_safe(^&#123;<br>            <span class="hljs-keyword">if</span> (!weakOperation.isCancelled) &#123;<br>                completedBlock(image, <span class="hljs-literal">nil</span>, cacheType, <span class="hljs-literal">YES</span>, url);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    &#125;];<br>    <span class="hljs-keyword">return</span> operation;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Downloader"><a href="#3-Downloader" class="headerlink" title="3.Downloader"></a>3.Downloader</h4><p>作用：配置Request，设置下载任务优先级与依赖关系。</p><ol><li>设置 URLRequest；</li><li>创建 SDWebImageDownloaderOperation 任务，加入到并发数&#x3D;6的 Queue 中，开始下载；</li><li>根据配置信息设置下载任务Operation的优先级和依赖关系；</li><li>下载成功，调用 CompletedBlock。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// SDWebImageDownloader.m</span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithSessionConfiguration:(<span class="hljs-built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init])) &#123;<br>        _operationClass = [SDWebImageDownloaderOperation <span class="hljs-keyword">class</span>];<br>        _shouldDecompressImages = <span class="hljs-literal">YES</span>; <span class="hljs-comment">//默认解压缩下载到的图片</span><br>        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;<br>        _downloadQueue = [<span class="hljs-built_in">NSOperationQueue</span> new];<br>        _downloadQueue.maxConcurrentOperationCount = <span class="hljs-number">6</span>; <span class="hljs-comment">//最大下载并发数</span><br>        _downloadQueue.name = <span class="hljs-string">@&quot;com.hackemist.SDWebImageDownloader&quot;</span>;<br>        <span class="hljs-comment">// 省略。。。</span><br>        _HTTPHeaders = headerDictionary;<br>        _operationsLock = dispatch_semaphore_create(<span class="hljs-number">1</span>);<br>        _headersLock = dispatch_semaphore_create(<span class="hljs-number">1</span>);<br>        _downloadTimeout = <span class="hljs-number">15.0</span>;<br><br>        [<span class="hljs-keyword">self</span> createNewSessionWithConfiguration:sessionConfiguration];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)createNewSessionWithConfiguration:(<span class="hljs-built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;<br>    [<span class="hljs-keyword">self</span> cancelAllDownloads];<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.session) &#123;<br>        [<span class="hljs-keyword">self</span>.session invalidateAndCancel];<br>    &#125;<br>    <span class="hljs-keyword">self</span>.session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration<br>                                                 delegate:<span class="hljs-keyword">self</span><br>                                            delegateQueue:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>- (<span class="hljs-type">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="hljs-built_in">NSURL</span> *)url<br>                                         options:(SDWebImageDownloaderOptions)options<br>                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock<br>                                       completed:(SDWebImageDownloaderCompletedBlock)completedBlock<br>&#123;<br>    <span class="hljs-comment">/*...*/</span><br>    <span class="hljs-comment">//step.1 设置request</span><br>    <span class="hljs-built_in">NSMutableURLRequest</span> *request = [[<span class="hljs-built_in">NSMutableURLRequest</span> alloc]<br>                                    initWithURL:url<br>                                    cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ?<br>    <span class="hljs-built_in">NSURLRequestUseProtocolCachePolicy</span> :<span class="hljs-built_in">NSURLRequestReloadIgnoringLocalCacheData</span>)<br>                                timeoutInterval:timeoutInterval];<br><br>    request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);<br>    request.HTTPShouldUsePipelining = <span class="hljs-literal">YES</span>;<br>    request.allHTTPHeaderFields = wself.HTTPHeaders;<br><br>    <span class="hljs-comment">//step.2 创建下载 Operation</span><br>    operation = [[SDWebImageDownloaderOperation alloc] initWithRequest:request<br>        options:options<br>        progress:^(<span class="hljs-built_in">NSInteger</span> receivedSize, <span class="hljs-built_in">NSInteger</span> expectedSize) &#123;...&#125;<br>        completed:^(<span class="hljs-built_in">UIImage</span> *image, <span class="hljs-built_in">NSData</span> *data, <span class="hljs-built_in">NSError</span> *error, <span class="hljs-type">BOOL</span> finished) &#123;<br>        <br>        SDWebImageDownloader *sself = wself;<br>        <span class="hljs-keyword">if</span> (!sself) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//step.3 下载成功，执行完成的callback</span><br>        __block <span class="hljs-built_in">NSArray</span> *callbacksForURL;<br>        dispatch_barrier_sync(sself.barrierQueue, ^&#123;<br>            callbacksForURL = [sself.URLCallbacks[url] <span class="hljs-keyword">copy</span>];<br>            <span class="hljs-keyword">if</span> (finished) &#123;<br>                [sself.URLCallbacks removeObjectForKey:url];<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSDictionary</span> *callbacks <span class="hljs-keyword">in</span> callbacksForURL) &#123;<br>            SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];<br>            <span class="hljs-keyword">if</span> (callback)<br>            callback(image, data, error, finished);<br>        &#125;<br>    &#125;<br>        cancelled:^&#123;...&#125;];<br><br>    operation.shouldDecompressImages = wself.shouldDecompressImages;<span class="hljs-comment">//是否需要解码</span><br>    <span class="hljs-comment">//设置任务优先级</span><br>    <span class="hljs-keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;<br>        operation.queuePriority = <span class="hljs-built_in">NSOperationQueuePriorityHigh</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;<br>        operation.queuePriority = <span class="hljs-built_in">NSOperationQueuePriorityLow</span>;<br>    &#125;<br>    <span class="hljs-comment">//任务加到队列中</span><br>    [wself.downloadQueue addOperation:operation];<br>    <span class="hljs-keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;<br>        <span class="hljs-comment">//如果设置了后进的任务先执行，则添加依赖关系，前一个任务依赖当前任务</span><br>        [wself.lastAddedOperation addDependency:operation];<br>        wself.lastAddedOperation = operation;<br>    &#125;<br>    &#125;];<br>    <span class="hljs-keyword">return</span> operation;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-Operation"><a href="#4-Operation" class="headerlink" title="4.Operation"></a>4.Operation</h4><p>作用：自定义SDWebImageDownloaderOperation，执行下载任务并处理图片scale与解码。</p><ul><li>重写了<code>start</code>函数；</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)start &#123;<br>    <span class="hljs-meta">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.isCancelled) &#123;<br>            <span class="hljs-keyword">self</span>.finished <span class="hljs-operator">=</span> <span class="hljs-type">YES</span>;<br>            [<span class="hljs-keyword">self</span> reset];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-keyword">#if</span> <span class="hljs-type">TARGET_OS_IPHONE</span> <span class="hljs-operator">&amp;&amp;</span> __IPHONE_OS_VERSION_MAX_ALLOWED <span class="hljs-operator">&gt;=</span> __IPHONE_4_0<br>        <span class="hljs-type">Class</span> <span class="hljs-type">UIApplicationClass</span> <span class="hljs-operator">=</span> <span class="hljs-type">NSClassFromString</span>(@<span class="hljs-string">&quot;UIApplication&quot;</span>);<br>        <span class="hljs-type">BOOL</span> hasApplication <span class="hljs-operator">=</span> <span class="hljs-type">UIApplicationClass</span> <span class="hljs-operator">&amp;&amp;</span> <br>                        [<span class="hljs-type">UIApplicationClass</span> respondsToSelector:<span class="hljs-meta">@selector</span>(sharedApplication)];<br>        <span class="hljs-comment">// 进入后台时，开启后台模式</span><br>        <span class="hljs-keyword">if</span> (hasApplication <span class="hljs-operator">&amp;&amp;</span> [<span class="hljs-keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;<br>            __weak __typeof__ (<span class="hljs-keyword">self</span>) wself <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>;<br>            <span class="hljs-type">UIApplication</span> <span class="hljs-operator">*</span> app <span class="hljs-operator">=</span> [<span class="hljs-type">UIApplicationClass</span> performSelector:<span class="hljs-meta">@selector</span>(sharedApplication)];<br>            <span class="hljs-keyword">self</span>.backgroundTaskId <span class="hljs-operator">=</span> [app beginBackgroundTaskWithExpirationHandler:<span class="hljs-operator">^</span>&#123;<br>                __strong __typeof (wself) sself <span class="hljs-operator">=</span> wself;<br>                <span class="hljs-keyword">if</span> (sself) &#123;<br>                    [sself cancel];<br><br>                    [app endBackgroundTask:sself.backgroundTaskId];<br>                    sself.backgroundTaskId <span class="hljs-operator">=</span> <span class="hljs-type">UIBackgroundTaskInvalid</span>;<br>                &#125;<br>            &#125;];<br>        &#125;<br><span class="hljs-keyword">#endif</span><br>        <span class="hljs-comment">// 创建下载请求</span><br>        <span class="hljs-keyword">self</span>.executing <span class="hljs-operator">=</span> <span class="hljs-type">YES</span>;<br>        <span class="hljs-keyword">self</span>.connection <span class="hljs-operator">=</span> [[<span class="hljs-type">NSURLConnection</span> alloc] initWithRequest:<span class="hljs-keyword">self</span>.request <br>                                                          delegate:<span class="hljs-keyword">self</span> startImmediately:<span class="hljs-type">NO</span>];<br>        <span class="hljs-keyword">self</span>.thread <span class="hljs-operator">=</span> [<span class="hljs-type">NSThread</span> currentThread];<br>    &#125;<br>    <span class="hljs-comment">// 启动</span><br>    [<span class="hljs-keyword">self</span>.connection start];<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.connection) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.progressBlock) &#123;<br>            <span class="hljs-keyword">self</span>.progressBlock(<span class="hljs-number">0</span>, <span class="hljs-type">NSURLResponseUnknownLength</span>);<br>        &#125;<br>        dispatch_async(dispatch_get_main_queue(), <span class="hljs-operator">^</span>&#123;<br>            [[<span class="hljs-type">NSNotificationCenter</span> defaultCenter] postNotificationName:<br>            <span class="hljs-type">SDWebImageDownloadStartNotification</span> object:<span class="hljs-keyword">self</span>];<br>        &#125;);<br>        <span class="hljs-comment">// 在默认模式下运行当前runlooprun，直到调用CFRunLoopStop停止运行</span><br>        <span class="hljs-keyword">if</span> (floor(<span class="hljs-type">NSFoundationVersionNumber</span>) <span class="hljs-operator">&lt;=</span> <span class="hljs-type">NSFoundationVersionNumber_iOS_5_1</span>) &#123;<br>            <span class="hljs-comment">// Make sure to run the runloop in our background thread so it can process downloaded data</span><br>            <span class="hljs-comment">// Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span><br>            <span class="hljs-comment">// not waking up the runloop, leading to dead threads</span><br>            <span class="hljs-type">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="hljs-number">10</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">CFRunLoopRun</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span><span class="hljs-keyword">self</span>.isFinished) &#123;<br>            [<span class="hljs-keyword">self</span>.connection cancel];<br>            [<span class="hljs-keyword">self</span> connection:<span class="hljs-keyword">self</span>.connection didFailWithError:<br>            [<span class="hljs-type">NSError</span> errorWithDomain:<span class="hljs-type">NSURLErrorDomain</span> code:<span class="hljs-type">NSURLErrorTimedOut</span> <br>            userInfo:@&#123;<span class="hljs-type">NSURLErrorFailingURLErrorKey</span> : <span class="hljs-keyword">self</span>.request.<span class="hljs-type">URL</span>&#125;]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.completedBlock) &#123;<br>            <span class="hljs-keyword">self</span>.completedBlock(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, [<span class="hljs-type">NSError</span> errorWithDomain:<span class="hljs-type">NSURLErrorDomain</span> <br>                code:<span class="hljs-number">0</span> userInfo:@&#123;NSLocalizedDescriptionKey : @<span class="hljs-string">&quot;Connection can&#x27;t be initialized&quot;</span>&#125;], <span class="hljs-type">YES</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">#if</span> <span class="hljs-type">TARGET_OS_IPHONE</span> <span class="hljs-operator">&amp;&amp;</span> __IPHONE_OS_VERSION_MAX_ALLOWED <span class="hljs-operator">&gt;=</span> __IPHONE_4_0<br>    <span class="hljs-type">Class</span> <span class="hljs-type">UIApplicationClass</span> <span class="hljs-operator">=</span> <span class="hljs-type">NSClassFromString</span>(@<span class="hljs-string">&quot;UIApplication&quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-operator">!</span><span class="hljs-type">UIApplicationClass</span> <span class="hljs-operator">||</span> <span class="hljs-operator">!</span>[<span class="hljs-type">UIApplicationClass</span> respondsToSelector:<span class="hljs-meta">@selector</span>(sharedApplication)]) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.backgroundTaskId <span class="hljs-operator">!=</span> <span class="hljs-type">UIBackgroundTaskInvalid</span>) &#123;<br>        <span class="hljs-type">UIApplication</span> <span class="hljs-operator">*</span> app <span class="hljs-operator">=</span> [<span class="hljs-type">UIApplication</span> performSelector:<span class="hljs-meta">@selector</span>(sharedApplication)];<br>        [app endBackgroundTask:<span class="hljs-keyword">self</span>.backgroundTaskId];<br>        <span class="hljs-keyword">self</span>.backgroundTaskId <span class="hljs-operator">=</span> <span class="hljs-type">UIBackgroundTaskInvalid</span>;<br>    &#125;<br><span class="hljs-keyword">#endif</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接收数据</li></ul><p>通过<code>-connection: didReceiveData:</code>代理接收数据并保存到 NSMutableData 对象中。如果设置了边下载边显示，则这里会渐进式地绘制、缩放图片，默认还会对图片进行解码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)connection:(<span class="hljs-built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="hljs-built_in">NSData</span> *)data &#123;<br>[<span class="hljs-keyword">self</span>.imageData appendData:data];<br>...<br><span class="hljs-comment">//绘制图片</span><br><span class="hljs-built_in">CGImageSourceRef</span> imageSource = <span class="hljs-built_in">CGImageSourceCreateWithData</span>((__bridge <span class="hljs-built_in">CFDataRef</span>)<span class="hljs-keyword">self</span>.imageData, <span class="hljs-literal">NULL</span>);<br>...<br><span class="hljs-built_in">CGImageRef</span> partialImageRef = <span class="hljs-built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>...<br><span class="hljs-comment">//图片缩放</span><br><span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="hljs-number">1</span> orientation:orientation];<br><span class="hljs-built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="hljs-keyword">self</span>.request.URL];<br><span class="hljs-built_in">UIImage</span> *scaledImage = [<span class="hljs-keyword">self</span> scaledImageForKey:key image:image];<br><br><span class="hljs-comment">//图片解码</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.shouldDecompressImages) &#123;<br>    image = [<span class="hljs-built_in">UIImage</span> decodedImageWithImage:scaledImage];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    image = scaledImage;<br>&#125;<br><span class="hljs-built_in">CGImageRelease</span>(partialImageRef);<br>dispatch_main_sync_safe(^&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.completedBlock) &#123;<br>        <span class="hljs-keyword">self</span>.completedBlock(image, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">NO</span>);<br>    &#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>下载完成</li></ul><p>下载完成后在<code>-connectionDidFinishLoading</code>代理中完成图片的缩放、解码并返回。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)connectionDidFinishLoading:(<span class="hljs-built_in">NSURLConnection</span> *)aConnection &#123;<br>SDWebImageDownloaderCompletedBlock completionBlock = <span class="hljs-keyword">self</span>.completedBlock;<br>    <span class="hljs-keyword">@synchronized</span>(<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>        ...<br>    &#125;);<br>&#125;<br>...<br><span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> sd_imageWithData:<span class="hljs-keyword">self</span>.imageData];<br><br><span class="hljs-comment">// 图片缩放</span><br><span class="hljs-built_in">NSString</span> *key = [[SDWebImageManager sharedManager]<br>cacheKeyForURL:<span class="hljs-keyword">self</span>.request.URL];<br>image = [<span class="hljs-keyword">self</span> scaledImageForKey:key image:image];<br><br><span class="hljs-comment">// 图片解码</span><br><span class="hljs-comment">// Do not force decoding animated GIFs</span><br><span class="hljs-keyword">if</span> (!image.images) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.shouldDecompressImages) &#123;<br>        image = [<span class="hljs-built_in">UIImage</span> decodedImageWithImage:image];<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 执行回调 返回图片</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">CGSizeEqualToSize</span>(image.size, <span class="hljs-built_in">CGSizeZero</span>)) &#123;<br>    completionBlock(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, [<span class="hljs-built_in">NSError</span>...], <span class="hljs-literal">YES</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    completionBlock(image, <span class="hljs-keyword">self</span>.imageData, <span class="hljs-literal">nil</span>, <span class="hljs-literal">YES</span>);<br>&#125;<br>...<br><span class="hljs-keyword">self</span>.completionBlock = <span class="hljs-literal">nil</span>;<br>[<span class="hljs-keyword">self</span> done];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-图片scale"><a href="#5-图片scale" class="headerlink" title="5.图片scale"></a>5.图片scale</h4><p>上面两个下载的回调中调用了一个共同的方法：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">- (UIImage *)scaledImageForKey:(NSString *)<span class="hljs-built_in">key</span> <span class="hljs-built_in">image</span>:(UIImage *)<span class="hljs-built_in">image</span> &#123;<br>    <span class="hljs-built_in">return</span> SDScaledImageForKey(<span class="hljs-built_in">key</span>, <span class="hljs-built_in">image</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：根据图片URL字符串推断图片的scale，按此scale绘制一张新图。</p><p>为啥要做这个操作呢？这里要提到三个关于图片尺寸信息的概念：</p><p>1、<strong>pixel dimensions</strong></p><p>这是指图片的<code>实际像素尺寸</code>，就是在文件夹中显示的真实图片尺寸。比如@1x图的尺寸是40*40，那么@2x的实际尺寸就是80*80，@3x的实际尺寸就是120*120。图片的清晰度只和图片本身的像素尺寸有关，实际尺寸越大则图片显示越清晰。</p><p>2、<strong>size</strong></p><p><a href="https://developer.apple.com/documentation/uikit/uiimage/1624105-size">官方文档</a>中是这么描述的：</p><p>The logical dimensions of the image, measured in points.</p><p>This value reflects the logical size of the image and takes the image’s current orientation into account. Multiply the size values by the value in the scale property to get the pixel dimensions of the image.</p><p>size 是图片的<code>逻辑尺寸</code>，<code>实际尺寸</code>要在size对应字段的基础上再乘以scale：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">实际宽度 <span class="hljs-operator">=</span> size.width * scale<span class="hljs-comment">;</span><br>size.width <span class="hljs-operator">=</span> 实际宽度 / scale<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>根据上面的公式：</p><table><thead><tr><th>scale</th><th>pixel</th><th>size</th></tr></thead><tbody><tr><td>@1x</td><td>40*40</td><td>40*40</td></tr><tr><td>@2x</td><td>80*80</td><td>40*40</td></tr><tr><td>@3x</td><td>120*120</td><td>40*40</td></tr></tbody></table><p>如果设置了 imageview 的frame自适应其素材的大小，则提供三种倍数下对应pixel尺寸的图片，就能保证在不同分辨率的设备上 imageview.frame.size 的一致性。</p><p>3、<strong>scale</strong></p><p><a href="https://developer.apple.com/documentation/uikit/uiimage/1624110-scale">官方文档</a>中是这么描述的：</p><p>The scale factor of the image.</p><p>If you load an image from a file whose name includes the @2x modifier, the scale is set to 2.0. You can also specify an explicit scale factor when initializing an image from a Core Graphics image. All other images are assumed to have a scale factor of 1.0.<br>If you multiply the logical size of the image (stored in the size property) by the value in this property, you get the dimensions of the image in pixels.</p><p>这是图片的缩放比例，是一个CGFloat数值，依图片本身的命名而定。如果图片名为 park@2x.png 则图片的scale就是2；如果图片名为 park@3x.png 则图片的scale就是3。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">UIImage <span class="hljs-symbol">*</span>p1 = [UIImage imageNamed:<span class="hljs-meta">@&quot;park</span><span class="hljs-meta">@2x&quot;];</span><br>UIImage <span class="hljs-symbol">*</span>p2 = [UIImage imageNamed:<span class="hljs-meta">@&quot;park</span><span class="hljs-meta">@3x&quot;];</span><br>NSLog(<span class="hljs-meta">@&quot;+++</span><span class="hljs-meta">@2x.scale:%.0f,</span> <span class="hljs-meta">@3x.scale:%.0f&quot;,p1.scale,p2.scale);</span><br>// 日志：+++<span class="hljs-meta">@2x.scale:2,</span> <span class="hljs-meta">@3x.scale:3</span><br></code></pre></td></tr></table></figure><p>除以@2x和@3x命名的图片外，其他所有图片的scale都是1.0。这意味着我们以 park.png 命名，或者从网络上下载的图片，它们的scale默认都是1.0。这也正是SD库中下载完图片或者从缓存中取出图片后，执行上面的方法重置图片scale属性的原因~</p><p>为了适配不同尺寸的设备，我们的素材需要提供三个版本，park.png，park@2x.png，part@3x.png。使用素材时：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">UIImage</span> *img = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;park&quot;</span>];<br></code></pre></td></tr></table></figure><p>系统会自动根据当前屏幕的scale选择对应后缀的图片素材。在4&#x2F;4s之后的手机上系统会自动加载以@2x为后缀的图片；在6p之后的plus版本手机上系统会自动加载以@3x为后缀的图片。</p><p>问题来了，从网络上下载的图片其scale默认是1.0，而其实际尺寸是确定的。根据公式：<code>size</code> &#x3D; <code>实际尺寸</code> &#x2F; <code>scale</code>，同一张图，scale越小其size就越大。如果设置了imageview自适应素材的大小，则本该使用@2x或@3x素材的视图，其frame.size会比预想的要大，所以为了效果的准确性，还是需要正确设置图片的scale参数。</p><p>SD中重置图片scale的具体实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">inline</span> <span class="hljs-built_in">UIImage</span> *SDScaledImageForKey(<span class="hljs-built_in">NSString</span> *key, <span class="hljs-built_in">UIImage</span> *image) &#123;<br>    <span class="hljs-keyword">if</span> (!image) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-comment">//数组不空，则返回一个动图</span><br>    <span class="hljs-keyword">if</span> ([image.images count] &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">NSMutableArray</span> *scaledImages = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">UIImage</span> *tempImage <span class="hljs-keyword">in</span> image.images) &#123;<br>            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];<br>        &#125;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">UIImage</span> animatedImageWithImages:scaledImages duration:image.duration];<br>    &#125;<br>    <span class="hljs-comment">//根据图片URL，判断图片比例，重新绘制新图并返回</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ([[<span class="hljs-built_in">UIScreen</span> mainScreen] respondsToSelector:<span class="hljs-keyword">@selector</span>(scale)]) &#123;<br>            <span class="hljs-built_in">CGFloat</span> scale = [<span class="hljs-built_in">UIScreen</span> mainScreen].scale;<br>            <br>            <span class="hljs-comment">// &quot;@2x.png&quot; 或者 &quot;@2x.png&quot; 字符串的长度=7，加上@符号之前的名字，必定&gt;=8</span><br>            <span class="hljs-keyword">if</span> (key.length &gt;= <span class="hljs-number">8</span>) &#123;<br>                <span class="hljs-built_in">NSRange</span> range = [key rangeOfString:<span class="hljs-string">@&quot;@2x.&quot;</span>];<br>                <span class="hljs-keyword">if</span> (range.location != <span class="hljs-built_in">NSNotFound</span>) &#123;<span class="hljs-comment">//URL包含@2x，推测为2倍图</span><br>                    scale = <span class="hljs-number">2.0</span>;<br>                &#125;<br>                range = [key rangeOfString:<span class="hljs-string">@&quot;@3x.&quot;</span>];<br>                <span class="hljs-keyword">if</span> (range.location != <span class="hljs-built_in">NSNotFound</span>) &#123;<span class="hljs-comment">//URL包含@3x，推测为3倍图</span><br>                    scale = <span class="hljs-number">3.0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-built_in">UIImage</span> *scaledImage = [[<span class="hljs-built_in">UIImage</span> alloc] initWithCGImage:image.CGImage <br>                                                              scale:scale <br>                                                              orientation:image.imageOrientation];<br>            image = scaledImage;<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-图片解码"><a href="#6-图片解码" class="headerlink" title="6.图片解码"></a>6.图片解码</h4><p>默认情况下<code>_shouldDecompressImages=YES</code>，SD会对下载的图片执行解码（动图除外）。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">UIImage</span> *)decodedImageWithImage:(<span class="hljs-built_in">UIImage</span> *)image &#123;<br>    <span class="hljs-comment">// while downloading huge amount of images</span><br>    <span class="hljs-comment">// autorelease the bitmap context</span><br>    <span class="hljs-comment">// and all vars to help system to free memory</span><br>    <span class="hljs-comment">// when there are memory warning.</span><br>    <span class="hljs-comment">// on iOS7, do not forget to call</span><br>    <span class="hljs-comment">// [[SDImageCache sharedImageCache] clearMemory];</span><br>    <span class="hljs-keyword">@autoreleasepool</span>&#123;<br>        <span class="hljs-comment">// do not decode animated images</span><br>        <span class="hljs-keyword">if</span> (image.images) &#123; <span class="hljs-keyword">return</span> image; &#125;<br>    <br>        <span class="hljs-built_in">CGImageRef</span> imageRef = image.CGImage;<br>    <br>        <span class="hljs-comment">//图片如果有alpha通道，就返回原始image，因为jpg图片有alpha的话，就不压缩</span><br>        <span class="hljs-built_in">CGImageAlphaInfo</span> alpha = <span class="hljs-built_in">CGImageGetAlphaInfo</span>(imageRef);<br>        <span class="hljs-type">BOOL</span> anyAlpha = (alpha == kCGImageAlphaFirst ||<br>                         alpha == kCGImageAlphaLast ||<br>                         alpha == kCGImageAlphaPremultipliedFirst ||<br>                         alpha == kCGImageAlphaPremultipliedLast);<br>    <br>        <span class="hljs-keyword">if</span> (anyAlpha) &#123; <span class="hljs-keyword">return</span> image; &#125;<br>    <br>        size_t width = <span class="hljs-built_in">CGImageGetWidth</span>(imageRef);<br>        size_t height = <span class="hljs-built_in">CGImageGetHeight</span>(imageRef);<br>    <br>        <span class="hljs-comment">// current</span><br>        <span class="hljs-built_in">CGColorSpaceModel</span> imageColorSpaceModel = <span class="hljs-built_in">CGColorSpaceGetModel</span>(<span class="hljs-built_in">CGImageGetColorSpace</span>(imageRef));<br>        <span class="hljs-built_in">CGColorSpaceRef</span> colorspaceRef = <span class="hljs-built_in">CGImageGetColorSpace</span>(imageRef);<br>        <br>        <span class="hljs-type">bool</span> unsupportedColorSpace = (imageColorSpaceModel == <span class="hljs-number">0</span> || <br>                                    imageColorSpaceModel == <span class="hljs-number">-1</span> || <br>                                    imageColorSpaceModel == kCGColorSpaceModelCMYK || <br>                                    imageColorSpaceModel == kCGColorSpaceModelIndexed);<br>        <span class="hljs-keyword">if</span> (unsupportedColorSpace)<span class="hljs-comment">//如果属于上述不支持的ColorSpace，则ColorSpace就使用RGB</span><br>            colorspaceRef = <span class="hljs-built_in">CGColorSpaceCreateDeviceRGB</span>();<br>    <br>        <span class="hljs-built_in">CGContextRef</span> context = <span class="hljs-built_in">CGBitmapContextCreate</span>(<span class="hljs-literal">NULL</span>, width,<br>                                                     height,<br>                                                     <span class="hljs-built_in">CGImageGetBitsPerComponent</span>(imageRef),<br>                                                     <span class="hljs-number">0</span>,<br>                                                     colorspaceRef,<br>                                                     kCGBitmapByteOrderDefault | <br>                                                     kCGImageAlphaPremultipliedFirst);<br>    <br>        <span class="hljs-comment">// Draw the image into the context and retrieve the new image, which will now have an alpha layer</span><br>        <span class="hljs-built_in">CGContextDrawImage</span>(context, <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height), imageRef);<br>        <span class="hljs-built_in">CGImageRef</span> imageRefWithAlpha = <span class="hljs-built_in">CGBitmapContextCreateImage</span>(context);<br>        <span class="hljs-built_in">UIImage</span> *imageWithAlpha = [<span class="hljs-built_in">UIImage</span> imageWithCGImage:imageRefWithAlpha <br>                                                      scale:image.scale orientation:image.imageOrientation];<br>    <br>        <span class="hljs-keyword">if</span> (unsupportedColorSpace)<br>            <span class="hljs-built_in">CGColorSpaceRelease</span>(colorspaceRef);<br>        <br>        <span class="hljs-built_in">CGContextRelease</span>(context);<br>        <span class="hljs-built_in">CGImageRelease</span>(imageRefWithAlpha);<br>        <br>        <span class="hljs-keyword">return</span> imageWithAlpha;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SD为啥要解码图片呢？</p><p>一般下载的图片或者我们手动拖进主 bundle 的图片都是 PNG 或者 JPG 格式的图片，它们都是经过编码压缩后的图片数据，并不是控件可以直接显示的位图。如果我们直接使用 “[UIImage imageNamed:]” 来加载图片，系统默认会在主线程立即进行图片的解码工作，这个过程就是把图片数据解码成可供控件直接显示的位图数据。由于这个解码操作比较耗时，并且默认是在主线程进行，所以当在主线程大量调用时就会产生卡顿。反过来，由于位图体积较大，在磁盘缓存中不会直接缓存位图数据，而是编码压缩过的PNG 或者 JPG 数据。</p><p>这里更准确的说，[UIImage imageNamed:] 加载图片时，不是立即解码的，而是在图片设置到<code>UIImageView</code>或者<code>CALayer.contents</code>中，并且 CALayer 被提交到GPU进行渲染前才会解码。另外，使用这种方式加载图片时，系统会自动缓存一份该图片，后面再使用此图时会直接从缓存中取，不再次解码。即使如此，使用这种方式加载图片时，最后的解码部分仍然时在主线程中进行的，所以当大量加载图片时，仍然有可能会出现卡顿现象。</p><p>SD 这里所做的正是对图片进行解码，而且是在异步线程里。<strong>SD缓存图片到内存时保存的是解码后的图片</strong>，缓存是通过 NSCache 实现的。这一步的目的是提高加载图片的速度和效率，需要注意的是，它在解码时会占用相当一部分内存，是典型的空间换时间。如果你遇到了内存问题，可以尝试禁止自动解码或者清空缓存：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[<span class="hljs-comment">[SDImageCache sharedImageCache]</span> setShouldDecompressImages:NO]</span>;<br><span class="hljs-comment">[<span class="hljs-comment">[SDWebImageDownloader sharedDownloader]</span> setShouldDecompressImages:NO]</span>;<br><span class="hljs-comment">[<span class="hljs-comment">[SDImageCache sharedImageCache]</span> clearMemory]</span>;<br></code></pre></td></tr></table></figure><h4 id="7-图片缓存"><a href="#7-图片缓存" class="headerlink" title="7.图片缓存"></a>7.图片缓存</h4><p>写这篇文章时最新SD版本为3.7.3，缓存相关功能主要由 SDImageCache 类实现。这里的缓存包括了内存和磁盘两种方式。其中，内存缓存使用的是继承自 NSCache 的 AutoPurgeCache 类；磁盘缓存的操作被单独放在一个串行队列 ioQueue 中。这个类中主要的方法及实现如下：</p><h5 id="1-查询缓存"><a href="#1-查询缓存" class="headerlink" title="1.查询缓存"></a>1.查询缓存</h5><ol><li>从内存中检测；</li><li>从磁盘中检测（异步+串行队列）；</li><li>磁盘中检测到缓存后，根据需要缓存到内存中；</li><li>返回结果；</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="hljs-built_in">NSString</span> *)key<br>done:(SDWebImageQueryCompletedBlock)doneBlock<br>&#123;<br>...<br>    <span class="hljs-comment">//step.1 先从内存中检测</span><br>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-keyword">self</span> imageFromMemoryCacheForKey:key];<br>    <span class="hljs-keyword">if</span> (image) &#123;<br>        doneBlock(image, SDImageCacheTypeMemory);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//step.2 内存中没有再从磁盘中检测</span><br>    <span class="hljs-built_in">NSOperation</span> *operation = [<span class="hljs-built_in">NSOperation</span> new];<br>    <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-keyword">self</span>.ioQueue, ^&#123;<br>        <span class="hljs-keyword">if</span> (operation.isCancelled) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>            <span class="hljs-built_in">UIImage</span> *diskImage = [<span class="hljs-keyword">self</span> diskImageForKey:key];<br>            <span class="hljs-comment">//step.3 磁盘中检测到缓存后 根据需要缓存到内存中</span><br>            <span class="hljs-keyword">if</span> (diskImage &amp;&amp; <span class="hljs-keyword">self</span>.shouldCacheImagesInMemory) &#123;<br>                <span class="hljs-built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);<br>                [<span class="hljs-keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];<br>            &#125;<br><br>            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                doneBlock(diskImage, SDImageCacheTypeDisk);<br>            &#125;);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> operation;<br>&#125;<br><br>- (<span class="hljs-built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span>.memCache objectForKey:key];<br>&#125;<br><br>- (<span class="hljs-built_in">UIImage</span> *)diskImageForKey:(<span class="hljs-built_in">NSString</span> *)key &#123;<br>    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];<br>    <span class="hljs-keyword">if</span> (data) &#123;<br>        <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> sd_imageWithData:data];<br>         <span class="hljs-comment">// 重置图片scale</span><br>        image = [<span class="hljs-keyword">self</span> scaledImageForKey:key image:image];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.shouldDecompressImages) &#123;<br>            <span class="hljs-comment">// 图片解码</span><br>            image = [<span class="hljs-built_in">UIImage</span> decodedImageWithImage:image];<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-保存图片"><a href="#2-保存图片" class="headerlink" title="2.保存图片"></a>2.保存图片</h5><p>图片下载成功后，默认会解码并保存到内存中。</p><p>保存到磁盘时，会先检测图片的格式，文件名为URL对应的MD5值。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)storeImage:(<span class="hljs-built_in">UIImage</span> *)image<br>recalculateFromImage:(<span class="hljs-type">BOOL</span>)recalculate<br>         imageData:(<span class="hljs-built_in">NSData</span> *)imageData<br>            forKey:(<span class="hljs-built_in">NSString</span> *)key<br>            toDisk:(<span class="hljs-type">BOOL</span>)toDisk<br>&#123;<br>    ...<br>    <span class="hljs-comment">//保存到内存 NSCache，cost为像素值</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.shouldCacheImagesInMemory) &#123;<br>        <span class="hljs-built_in">NSUInteger</span> cost = SDCacheCostForImage(image);<br>        [<span class="hljs-keyword">self</span>.memCache setObject:image forKey:key cost:cost];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (toDisk) &#123;<br>        <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-keyword">self</span>.ioQueue, ^&#123;<br>            <span class="hljs-built_in">NSData</span> *data = imageData;<br><br>            <span class="hljs-keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;<br>            <span class="hljs-meta">#<span class="hljs-keyword">if</span> TARGET_OS_IPHONE</span><br><br>                <span class="hljs-type">int</span> alphaInfo = <span class="hljs-built_in">CGImageGetAlphaInfo</span>(image.CGImage);<br>                <span class="hljs-type">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||<br>                alphaInfo == kCGImageAlphaNoneSkipFirst ||<br>                alphaInfo == kCGImageAlphaNoneSkipLast);<br>                <span class="hljs-type">BOOL</span> imageIsPng = hasAlpha;<br><br>                <span class="hljs-comment">//检测 图片data 的前缀是否是 PNG 格式</span><br>                <span class="hljs-keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;<br>                    imageIsPng = ImageDataHasPNGPreffix(imageData);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (imageIsPng) &#123;<br>                    data = <span class="hljs-built_in">UIImagePNGRepresentation</span>(image);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    data = <span class="hljs-built_in">UIImageJPEGRepresentation</span>(image, (<span class="hljs-built_in">CGFloat</span>)<span class="hljs-number">1.0</span>);<br>                &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>                data = [<span class="hljs-built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:<br>                image.representations<br>                usingType: <span class="hljs-built_in">NSJPEGFileType</span> properties:<span class="hljs-literal">nil</span>];<br>            <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            &#125;<br><br>            <span class="hljs-comment">// get cache Path for image key</span><br>            <span class="hljs-built_in">NSString</span> *cachePathForKey = [<span class="hljs-keyword">self</span> defaultCachePathForKey:key];<br>            <span class="hljs-comment">// transform to NSUrl</span><br>            <span class="hljs-built_in">NSURL</span> *fileURL = [<span class="hljs-built_in">NSURL</span> fileURLWithPath:cachePathForKey];<br><br>            <span class="hljs-comment">// 保存到磁盘中</span><br>            [_fileManager createFileAtPath:cachePathForKey contents:data attributes:<span class="hljs-literal">nil</span>];<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>保存到磁盘时，图片的命名规则如下：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs prolog">- (<span class="hljs-symbol">NSString</span> *)cachedFileNameForKey:(<span class="hljs-symbol">NSString</span> *)key &#123;<br>    const char *str = [key <span class="hljs-symbol">UTF8String</span>];<br>    if (str == <span class="hljs-symbol">NULL</span>) &#123;<br>        str = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    unsigned char r[<span class="hljs-symbol">CC_MD5_DIGEST_LENGTH</span>];<br>    <span class="hljs-symbol">CC_MD5</span>(str, (<span class="hljs-symbol">CC_LONG</span>)strlen(str), r);<br>    <span class="hljs-symbol">NSString</span> *filename = [<span class="hljs-symbol">NSString</span> stringWithFormat:<br>    @<span class="hljs-string">&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;</span>,<br>    r[<span class="hljs-number">0</span>], r[<span class="hljs-number">1</span>], r[<span class="hljs-number">2</span>], r[<span class="hljs-number">3</span>], r[<span class="hljs-number">4</span>], r[<span class="hljs-number">5</span>],<br>    r[<span class="hljs-number">6</span>], r[<span class="hljs-number">7</span>], r[<span class="hljs-number">8</span>], r[<span class="hljs-number">9</span>], r[<span class="hljs-number">10</span>],<br>    r[<span class="hljs-number">11</span>], r[<span class="hljs-number">12</span>], r[<span class="hljs-number">13</span>], r[<span class="hljs-number">14</span>], r[<span class="hljs-number">15</span>],<br>    [[key pathExtension] isEqualToString:@<span class="hljs-string">&quot;&quot;</span>] ?<br>    @<span class="hljs-string">&quot;&quot;</span> : [<span class="hljs-symbol">NSString</span> stringWithFormat:@<span class="hljs-string">&quot;.%@&quot;</span>,<br>    [key pathExtension]]];<br>    return filename;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-清除缓存"><a href="#3-清除缓存" class="headerlink" title="3.清除缓存"></a>3.清除缓存</h5><p>程序出现内存警告时会清除内存中的缓存；退出应用、进入后台时则根据策略清除相关磁盘缓存：</p><ul><li>清除过期的文件，默认一星期;</li><li>超过最大缓存限制时，遍历删除最旧的文件，直到当前缓存文件的大小为最大缓存的一半;</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock<br>&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-keyword">self</span>.ioQueue, ^&#123;<br>        <span class="hljs-comment">/*...*/</span><br>        <span class="hljs-built_in">NSDate</span> *expirationDate = [<span class="hljs-built_in">NSDate</span> dateWithTimeIntervalSinceNow:<br>        -<span class="hljs-keyword">self</span>.maxCacheAge];<br>        <span class="hljs-built_in">NSMutableDictionary</span> *cacheFiles = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        <span class="hljs-built_in">NSUInteger</span> currentCacheSize = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">//遍历缓存目录中的所有文件</span><br>        <span class="hljs-built_in">NSMutableArray</span> *urlsToDelete = [[<span class="hljs-built_in">NSMutableArray</span> alloc] init];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSURL</span> *fileURL <span class="hljs-keyword">in</span> fileEnumerator) &#123;<br>            <span class="hljs-built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys<br>            error:<span class="hljs-literal">NULL</span>];<br>            <span class="hljs-comment">/*...*/</span><br>            <span class="hljs-comment">// 删除过期的文件</span><br>            <span class="hljs-built_in">NSDate</span> *modificationDate = resourceValues[<span class="hljs-built_in">NSURLContentModificationDateKey</span>];<br>            <span class="hljs-keyword">if</span> ([[modificationDate laterDate:expirationDate]<br>            isEqualToDate:expirationDate]) &#123;<br>                [urlsToDelete addObject:fileURL];<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">/*...*/</span><br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSURL</span> *fileURL <span class="hljs-keyword">in</span> urlsToDelete) &#123;<br>            [_fileManager removeItemAtURL:fileURL error:<span class="hljs-literal">nil</span>];<br>        &#125;<br><br>        <span class="hljs-comment">//如果剩下的磁盘缓存超过最大限制，再次删掉最老的文件，</span><br>        <span class="hljs-comment">//直到当前缓存文件的大小为最大缓存大小的一半;</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.maxCacheSize &gt; <span class="hljs-number">0</span> &amp;&amp; currentCacheSize &gt; <span class="hljs-keyword">self</span>.maxCacheSize) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-built_in">NSUInteger</span> desiredCacheSize = <span class="hljs-keyword">self</span>.maxCacheSize / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<br>            <span class="hljs-built_in">NSSortConcurrent</span><br>            usingComparator:^<span class="hljs-built_in">NSComparisonResult</span>(<span class="hljs-type">id</span> obj1, <span class="hljs-type">id</span> obj2) &#123;<br>                <span class="hljs-keyword">return</span> [obj1[<span class="hljs-built_in">NSURLContentModificationDateKey</span>]<br>                compare:obj2[<span class="hljs-built_in">NSURLContentModificationDateKey</span>]];<br>            &#125;];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSURL</span> *fileURL <span class="hljs-keyword">in</span> sortedFiles) &#123;<br>                <span class="hljs-keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="hljs-literal">nil</span>])&#123;<br>                    <span class="hljs-built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];<br>                    <span class="hljs-built_in">NSNumber</span> *totalAllocatedSize =<br>                    resourceValues[<span class="hljs-built_in">NSURLTotalFileAllocatedSizeKey</span>];<br><br>                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];<br><br>                    <span class="hljs-keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (completionBlock) &#123;<br>            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                completionBlock();<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-后记"><a href="#3-后记" class="headerlink" title="3.后记"></a>3.后记</h3><p>SD 是一个优秀的网络图片下载缓存库，让我们在视图中加载网络图片或缓存图片到本地变得很轻松，有很多值得学习的地方：</p><ul><li>库中各类职责清晰；</li><li>网络图片的下载、解码、缓存等都是异步进行，保证了主线程的流畅性；</li><li>大量使用 NSOperation 和 GCD，为我们处理线程同步问题提供了范例；</li><li>图片加载前，先在异步线程中解码成位图，极大优化了应用性能；</li><li>设计良好的缓存策略，提高了应用的性能表现；</li></ul><p>本文是根据原项目中使用的 3.7.3 版本来分析的，目前SD的最新版本号为 4.4.1。大致看了下最新的版本，网络下载部分已经使用了 URLSession，也新增了很多新的类，后面有时间会继续研究一下~</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/documentation/uikit/uiimage#//apple_ref/occ/instp/UIImage/scale">©AppleDev-UIImage</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>.a &amp; .framework</title>
    <link href="/2018/01/25/framework.html"/>
    <url>/2018/01/25/framework.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-库？"><a href="#1-库？" class="headerlink" title="1.库？"></a>1.库？</h3><p>库是代码的集合、共享代码的一种方式。分为：</p><ul><li>开源库：源代码公开，能看到具体的实现。（如SD、AF）</li><li>闭源库：源码不公开，是经过编译后的二进制文件，看不到具体实现。</li></ul><p>其中，闭源库有两种形式：</p><ul><li>静态库：.a 和 .framework</li><li>动态库：.dylib 和 .framework</li></ul><p>问：framework 为啥即是静态库又是动态库？</p><p>答：系统提供的.framework是动态库，我们自定义的是静态库。</p><p>系统提供的有UIKit.framework等，自定义的包括AFN.framework等。</p><p>在早期，很多应用基于.framework动态库实现热更新，而苹果不允许这种行为，它禁止使用自定义动态库的应用上架。我们自己建的.framework中 Mach-O Type 需要设置为 Static Library，即静态库。现在苹果已经允许我们将.framework设置成动态库，只是苹果会在集成自定义动态库的应用上架时，再经过一次AppStore的签名，防止在线更新动态库。当然，自建的.dylib还是不允许。</p><h3 id="2-静态库"><a href="#2-静态库" class="headerlink" title="2.静态库"></a>2.静态库</h3><p>静态库是在编译阶段进行链接，成为应用可执行文件的一部分，会增加包体的大小。</p><p>多个应用使用相同的静态库时，各应用都会完整地复制一份到可执行文件中，内存中有冗余。</p><p>因为可执行文件变大，启动时需加载的内容变多，可能会导致应用启动变慢。</p><h3 id="3-动态库"><a href="#3-动态库" class="headerlink" title="3.动态库"></a>3.动态库</h3><p>动态库是在启动阶段进行链接，不包含在应用的可执行文件中，可有效减小包体大小。</p><p>多个应用使用相同的动态库时，系统只会在内存中加载一次，多个应用共享，节省内存。</p><p>动态库在多个应用程序间共享，系统和其他应用可更新此库，而不用更新所有依赖它的应用。</p><h3 id="4-封装格式"><a href="#4-封装格式" class="headerlink" title="4.封装格式"></a>4.封装格式</h3><p>.a与.framework都是二进制文件的封装格式。</p><h4 id="1-静态库-a"><a href="#1-静态库-a" class="headerlink" title="1.静态库.a"></a>1.静态库.a</h4><p>.m等文件在编译后会变成.o文件，而.a是多个.o的集合。</p><p>.o是Mach-O文件类型，每个.o都包含 Mach header、Segment、section、Blob。</p><p>多个.o中可能有相同的 Mach header 等冗余，所以包体会大于动态库的framework。</p><h4 id="2-动态库-framework"><a href="#2-动态库-framework" class="headerlink" title="2.动态库.framework"></a>2.动态库.framework</h4><p>.framework可将库的代码与资源文件打包到一起，方便管理和分发。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.framework</span> = (<span class="hljs-selector-class">.a</span> + <span class="hljs-selector-class">.h</span> + sourceFile)<br></code></pre></td></tr></table></figure><p>.a是一个纯二进制文件，.framework 中除了有二进制文件之外还有资源文件。</p><p>.a不能直接使用，至少要有.h文件配合，.framework 文件可以直接使用。</p><p>framework中所有.o文件的前三段合并到了一起，只有一个公共的 Mach header、Segment、Section，从而优化了.a中每个.o都含这些头块区的冗余问题，减小了包体。</p><p>自己建的 framework 虽然叫动态库，但它的实质却是 Embedded Framework。</p><ul><li>基于沙盒，最终打包到ipa的&#x2F;framework目录(包括pods)，与其他应用隔离。</li><li>需要签名，即使跟别的应用同名，也不共享。</li><li>可以上架，但不允许热更新(AppStore会再一次签名)。</li></ul><p>不同应用使用同名自定义动态库framework，内存中并非只加载一份，而是分别打包、签名、加载各自的。它只是保留了与系统动态库相同的链接方式，但是仅能在各自的应用中使用。</p><h3 id="5-制作-a"><a href="#5-制作-a" class="headerlink" title="5.制作.a"></a>5.制作.a</h3><ul><li>新建 Cocoa Touch Static Library 工程，编写逻辑代码。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//.h文件</span><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">Aframe </span>: NSObject<br>- (void)mathAdd;<br><span class="hljs-variable">@end</span><br><br><span class="hljs-comment">//.m文件</span><br>#import <span class="hljs-string">&quot;Aframe.h&quot;</span><br><span class="hljs-variable">@implementation</span> Aframe<br>- (void)mathAdd&#123;<br>    <span class="hljs-selector-tag">NSLog</span>(@<span class="hljs-string">&quot;1 + 1 = 2&quot;</span>);<br>&#125;<br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure><ul><li>Targets-&gt;Build Settings 参数设置：</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;Build Active Architecture Only&quot;</span> 设置为<span class="hljs-string">&quot;NO&quot;</span><br></code></pre></td></tr></table></figure><ul><li>Targets-&gt;Build Phases 参数设置：</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">&quot;Copy Files&quot;</span> 中添加需要暴露的<span class="hljs-string">.h</span> 文件<br></code></pre></td></tr></table></figure><ul><li>Run 修改 scheme</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">选择左上角静态库-&gt;Run-&gt;<span class="hljs-keyword">Info</span>-&gt;Build Configuration 设置为Release<br></code></pre></td></tr></table></figure><ul><li>编译生成静态库.a文件：</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">分别选择真机和 <span class="hljs-variable">iPhone</span> 模拟器进行编译。<br>找到真机和模拟器编译成功生成的<span class="hljs-operator">.</span><span class="hljs-variable">a</span>文件<span class="hljs-operator">,</span><span class="hljs-built_in">Show</span> <span class="hljs-built_in">In</span> <span class="hljs-variable">Finder</span>，分别在 <span class="hljs-built_in">Release</span><span class="hljs-operator">-</span><span class="hljs-variable">iphoneos</span>、<span class="hljs-built_in">Release</span><span class="hljs-operator">-</span><span class="hljs-variable">iphonesimulator</span>目录中。<br></code></pre></td></tr></table></figure><ul><li>合成通用版的静态库.a文件</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">打开终端输入以下命令行：<br>lipo -<span class="hljs-built_in">create</span> /xx.<span class="hljs-keyword">a</span>(真机.<span class="hljs-keyword">a</span>文件路径) /xx.<span class="hljs-keyword">a</span>(模拟器.<span class="hljs-keyword">a</span>文件路径) -output Desktop/xx.<span class="hljs-keyword">a</span><br></code></pre></td></tr></table></figure><ul><li>测试自己制作的静态库文件</li></ul><p>将.h 以及上步导出的.a文件导入自己的工程中，调用.h 中的接口。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;AppDelegate.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Aframe.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">void</span>)testLibA&#123;<br>    Aframe *aframe = [Aframe new];<br>    [aframe mathAdd];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-keyword">self</span> testLibA];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h3 id="6-制作-framework"><a href="#6-制作-framework" class="headerlink" title="6.制作.framework"></a>6.制作.framework</h3><ul><li>新建 Cocoa Touch Framework 工程，编写逻辑代码。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//.h文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">MathTool</span> : <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-type">void</span>)mathAdd;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//.m文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;MathTool.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MathTool</span></span><br>- (<span class="hljs-type">void</span>)mathAdd&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1 + 1 = 2&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li>更改参数：</li></ul><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">TARGETS-&gt;Build Settings-&gt;Dead Code Stripping 设置为NO。<br>TARGETS-&gt;Build Settings-&gt;Link With Stantard <span class="hljs-keyword">Libraries</span> 设置为NO。<br></code></pre></td></tr></table></figure><ul><li>设置需要暴露的头文件</li></ul><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zephir">TARGETS-&gt;Build Phases-&gt;Headers 的 <span class="hljs-keyword">public</span>选项下 把需要暴露的头文件拖进来。<br></code></pre></td></tr></table></figure><ul><li>在新建项目时，自动生成的xxx.h文件里将要暴露的头文件 import 进来。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-comment">//! Project version number for Framework.</span><br>FOUNDATION_EXPORT <span class="hljs-type">double</span> FrameworkVersionNumber;<br><br><span class="hljs-comment">//! Project version string for Framework.</span><br>FOUNDATION_EXPORT <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> FrameworkVersionString[];<br><br><span class="hljs-comment">//import all the public headers of your framework</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Framework/MathTool.h&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>Edit Scheme</li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">左上角<span class="hljs-function"><span class="hljs-title">scheme</span>-&gt;</span>R<span class="hljs-function"><span class="hljs-title">un</span>-&gt;</span>I<span class="hljs-function"><span class="hljs-title">nfo</span>-&gt;</span>Build Configuration 设置为 Release<br></code></pre></td></tr></table></figure><ul><li>编译 framework</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">分别选中模拟器和<span class="hljs-keyword">Generic</span> iOS Device 编译。<br>选中 Products 下的xxx.framework，show <span class="hljs-keyword">in</span> Finder。<br></code></pre></td></tr></table></figure><ul><li>合成通用 framework</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">lipo -create <span class="hljs-regexp">/xx.framework/</span>xx(真机.framework文件路径) <br><span class="hljs-regexp">/xx.framework/</span>xx(模拟器.framework文件路径) <br>-output Desktop/xx<br></code></pre></td></tr></table></figure><p>这一步可能会报错，但依然会生成一个<code>xx.lipo</code>文件，将其后缀去掉并复制到<code>/xx.framework</code>(真机.framework文件路径)下，替换目录中原有的framework。</p><ul><li>测试 framework</li></ul><p>将上一步中替换完成的xx.framework 复制到新的工程里，导入头文件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Framework/Framework.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">void</span>)testFramework&#123;<br>    MathTool *mathTool = [MathTool new];<br>    [mathTool mathAdd];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application <br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-keyword">self</span> testFramework];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离屏渲染</title>
    <link href="/2018/01/20/offscreen.html"/>
    <url>/2018/01/20/offscreen.html</url>
    
    <content type="html"><![CDATA[<h3 id="1、Cell-的重用"><a href="#1、Cell-的重用" class="headerlink" title="1、Cell 的重用"></a>1、Cell 的重用</h3><p>#示例1：常见用法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">UITableViewCell</span> *)tableView:(<span class="hljs-built_in">UITableView</span> *)tableView<br>cellForRowAtIndexPath:(<span class="hljs-built_in">NSIndexPath</span> *)indexPath <br>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *CellIdentifier = <span class="hljs-string">@&quot;Cell&quot;</span>;<br>  <span class="hljs-built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == cell) &#123;<br>    cell = [[<span class="hljs-built_in">UITableViewCell</span> alloc] initWithStyle:<br>    <span class="hljs-built_in">UITableViewCellStyleDefault</span> <br>    reuseIdentifier:CellIdentifier];<br>  &#125;<br>  <span class="hljs-keyword">return</span> cell;<br>&#125;<br></code></pre></td></tr></table></figure><p>[tableView dequeueReusableCellWithIdentifier:CellIdentifier]; 就是 cell 重用的标志性语句。上面的代码逻辑是：当需要显示一个 Cell 时，系统会先去重用队列中查询是否有可重用的 cell，如果有则复用它，如果没有则新建一个 cell。</p><p>#示例2：读取 UITableView 的属性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">+ (void)ivarList<br>&#123;<br>    unsigned <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>    Ivar *ivars = <span class="hljs-keyword">class</span><span class="hljs-constructor">_copyIvarList([UITableView <span class="hljs-params">class</span>], &amp;<span class="hljs-params">count</span>)</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt;count; i++)&#123;<br>        Ivar ivar = ivars<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        const <span class="hljs-built_in">char</span> *charName = ivar<span class="hljs-constructor">_getName(<span class="hljs-params">ivar</span>)</span>;<br>        const <span class="hljs-built_in">char</span> *charType = ivar<span class="hljs-constructor">_getTypeEncoding(<span class="hljs-params">ivar</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;Name:%s,Type:%s&quot;</span>,<span class="hljs-params">charName</span>,<span class="hljs-params">charType</span>)</span>;<br>    &#125;<br>    free(ivars);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面通过运行时函数 <code>class_copyIvarList</code> 来读取 UITableView 中所有成员变量。结果如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">Name</span>:<span class="hljs-variable">_visibleCells</span>,<span class="hljs-built_in">Type</span>:@<span class="hljs-string">&quot;NSMutableArray&quot;</span><br><span class="hljs-built_in">Name</span>:<span class="hljs-variable">_reusableTableCells</span>,<span class="hljs-built_in">Type</span>:@<span class="hljs-string">&quot;NSMutableDictionary&quot;</span><br></code></pre></td></tr></table></figure><p>从打印结果可以看到，UITableView 中包括了以下两个属性：</p><ul><li><strong>visibleCells</strong>：（保存当前屏幕范围内显示的 cells）</li><li><strong>reusableTableCells</strong>：（保存可重用的 cells）</li></ul><p><strong>Cell的重用逻辑：</strong></p><p>（1）假如当前屏幕能显示10个 Cell，在 UITableView 开始渲染时，系统会通过 <code>-initWithStyle:reuseIdentifier:</code> 方法创建10个新的 cell （标志相同） 并显示，这些 cell 会被放入 <code>visibleCells</code> 这个数组中。</p><p>（2）向下滑动 TableView，当 <strong>cell1</strong> 完全移出屏幕，并且 <strong>cell11</strong> (它也是alloc出来的，原因同上)完全显示出来时，<strong>cell11</strong> 会被加入到 <code>visiableCells</code>，而 <strong>cell1</strong> 则被移出 <code>visiableCells</code> 并加入到 <code>reusableTableCells</code> 中。</p><p>（3）接着向下滑动 TableView，因为 <strong>cell1</strong> 已经在 <code>reusableTableCells</code> 中，所以 即将显示的第12个 cell 会重用 <strong>cell1</strong>。因此 <strong>cell1</strong> 会被移出 <code>reusableTableCells</code> 并加入到 <code>visiableCells</code> 中；同时 <strong>cell2</strong> 移出 <code>visiableCells</code> 并加入到 <code>reusableTableCells</code> 中。</p><p>（4）接下来的重用以此类推。。</p><p><strong>注意：</strong> cell 是重用的，所以在配置 cell 时一定要重新设置重用的 cell，不要遗留老的数据。</p><h3 id="2、卡顿与离屏渲染"><a href="#2、卡顿与离屏渲染" class="headerlink" title="2、卡顿与离屏渲染"></a>2、卡顿与离屏渲染</h3><p>Tableview 使用中常会出现性能问题，其中会涉及到离屏渲染，下面这些博客里会有专业的分析，多看看，收益颇丰~</p><ul><li>#<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">©ibireme-保持界面流畅的技巧</a></li><li>#<a href="https://blog.csdn.net/qq_29846663/article/details/68960512">©于海明-离屏渲染</a></li></ul><p>以下是从上面博客摘录的部分内容：</p><h4 id="2-1-卡顿的原因"><a href="#2-1-卡顿的原因" class="headerlink" title="2.1 卡顿的原因"></a>2.1 卡顿的原因</h4><p>通常来说，计算机系统中 CPU、GPU、显示器是协同工作的：<code>CPU</code> 负责计算显示的内容，如视图的创建、布局计算、图片解码、文本绘制等，完成后提交到 GPU；<code>GPU</code> 负责对 CPU 提交的内容进行变换、合成、渲染，完成后将渲染结果放入帧缓冲区；<code>视频控制器</code>会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p><p>如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p><h4 id="2-2-离屏渲染"><a href="#2-2-离屏渲染" class="headerlink" title="2.2.离屏渲染"></a>2.2.离屏渲染</h4><p><strong>#离屏渲染：</strong> 指的是GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作；</p><p><strong>#当前屏幕渲染：</strong> 是指GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。</p><p>离屏渲染对性能影响很大，主要是因为离屏渲染会创建新的缓冲区，且在离屏渲染的整个过程，需要多次切换上下文环境。这些操作的开销很大（涉及到 OpenGL 的 pipelines 和 barrier 等），尤其是当有大量离屏渲染的情况时。</p><p><strong>#为什么会有离屏渲染机制?</strong></p><p>有些效果被认为不能直接呈现于屏幕，而需要在别的地方做额外的处理预合成。图层属性的混合体没有预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p><p><strong>#会触发离屏渲染的场景：</strong></p><ul><li>为图层设置遮罩（layer.mask）；</li><li>将图层的 layer.masksToBounds 或 view.clipsToBounds 设置为YES；</li><li>将图层 layer.allowsGroupOpacity 设置为YES 且 layer.opacity小于1.0；</li><li>为图层设置阴影（layer.[shadowRadius\shadowOffset\shadowOpacity]）；</li><li>为图层开启<a href="https://blog.csdn.net/bravegogo/article/details/80494455">光栅化</a>：layer.shouldRasterize &#x3D; YES；</li><li>为图层设置圆角 layer.cornerRadius；</li><li>为图层设置抗锯齿性：layer.allowsEdgeAntialiasing &#x3D; YES；</li><li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）；</li><li>使用 CGContext 在 drawRect :方法中绘制大部分情况下会导致离屏渲染（使用CPU渲染）。</li></ul><p><strong>#优化方案：</strong></p><ul><li>使用中间透明，四个角有背景色的图片代替圆角效果；</li><li>使用UIBezierPath给CAShapeLayer画圆角，再赋值给视图的layer.mask；</li><li>使用 ShadowPath 提前告诉CoreAnimation待渲染图层的形状(layer.shadowPath &#x3D; [UIBezierPath bezierPathWithRect:layer.bounds])；</li><li>设置 layer.opaque &#x3D; YES，减少复杂图层合成；</li><li>尽量使用不包含透明（alpha）通道的图片资源；</li><li>尽量设置 layer 的大小值为整型值。</li><li>使用异步进行 layer 渲染（如 Facebook的AsyncDisplayKit框架）；</li></ul><hr><p>相关参考：</p><p>#<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">©ibireme-保持界面流畅的技巧</a></p><p>#<a href="https://blog.csdn.net/qq_29846663/article/details/68960512">©于海明-离屏渲染</a></p><p>#<a href="http://texturegroup.org/docs/corner-rounding.html">©Texture-Corner Rounding</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>响应者链 &amp; 传递链</title>
    <link href="/2018/01/07/responder.html"/>
    <url>/2018/01/07/responder.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-响应者"><a href="#1-响应者" class="headerlink" title="1.响应者"></a>1.响应者</h3><p>UIResponder，用来响应用户的操作并处理各种事件：</p><ul><li>触摸事件</li><li>加速计事件</li><li>远程控制事件</li></ul><p>继承自<code>UIResponder</code>的类对象，如<code>UIView</code>、<code>UIViewController</code>、<code>UIApplication</code>，才能接收和处理事件，它们被称为“响应者对象”。<code>UIResponder.h</code>中定义了如下处理方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//处理触摸事件</span><br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>*)touches withEvent:(<span class="hljs-built_in">UIEvent</span>*)event;<br>- (<span class="hljs-type">void</span>)touchesMoved:(<span class="hljs-built_in">NSSet</span>*)touches withEvent:(<span class="hljs-built_in">UIEvent</span>*)event;<br>- (<span class="hljs-type">void</span>)touchesEnded:(<span class="hljs-built_in">NSSet</span>*)touches withEvent:(<span class="hljs-built_in">UIEvent</span>*)event;<br>- (<span class="hljs-type">void</span>)touchesCancelled:(<span class="hljs-built_in">NSSet</span>*)touches withEvent:(<span class="hljs-built_in">UIEvent</span>*)ev<br><br><span class="hljs-comment">//加速计事件</span><br>- (<span class="hljs-type">void</span>)motionBegan:(<span class="hljs-built_in">UIEventSubtype</span>)motion withEvent:(<span class="hljs-built_in">UIEvent</span>*)event;<br>- (<span class="hljs-type">void</span>)motionEnded:(<span class="hljs-built_in">UIEventSubtype</span>)motion withEvent:(<span class="hljs-built_in">UIEvent</span>*)event;<br>- (<span class="hljs-type">void</span>)motionCancelled:(<span class="hljs-built_in">UIEventSubtype</span>)motion withEvent:(<span class="hljs-built_in">UIEvent</span>*)event;<br><br><span class="hljs-comment">//远程控制事件</span><br>- (<span class="hljs-type">void</span>)remoteControlReceivedWithEvent:(<span class="hljs-built_in">UIEvent</span>*)event;<br></code></pre></td></tr></table></figure><h3 id="2-响应者链"><a href="#2-响应者链" class="headerlink" title="2.响应者链"></a>2.响应者链</h3><p>下面是在自定义视图<code>CustomView</code>的<code>-hitTest:withEvent:</code>方法中断点后，随机在界面中点击后得到的堆栈信息：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_response_chain.png" alt="chain"></p><p>调用顺序为底部先顶部后，大致经过了<code>main</code>-&gt;<code>UIApplication</code>-&gt;<code>UIWindow</code>-&gt;<code>UIView</code>。</p><p>用户在屏幕上做点击、缩放等操作时会触发触摸事件。UIKit会创建一个UIEvent事件对象并将其添加到事件队列中，后续由 UIApplication 负责事件的分发和传递，直到找到其最佳的响应者。</p><p>查找事件响应者的过程就是<code>Hit-Testing</code>的过程，被检测者需要做两个判断：</p><ul><li>自己是否能接收事件？</li><li>触摸点是否在自己身上？</li></ul><p>具体查找过程如下：</p><ol><li>UIApplication 从事件队列中取出最前面的事件，传递给<code>主窗口</code>（keyWindow）；</li><li>主窗口检测：①自己是否能接收事件；②触摸点是否在自己身上；</li><li>若满足此两个条件，再<code>倒序</code>遍历主窗口的子视图数组，对子视图重复以上两个判断；</li><li>若主窗口的子视图中没有符合条件的，则主窗口成为触摸事件的最佳接收者；</li><li>若主窗口的子视图<code>A</code>符合条件，则倒序遍历<code>A</code>的子视图，并重复上面的两个判断；</li><li>若<code>A</code>的子视图中没有符合条件的，则<code>A</code>成为最佳接收视图；</li><li>若<code>A</code>的子视图中有符合条件的<code>X</code>，则继续遍历X的子视图，直到找到最合适的视图；</li></ol><p><strong>不能接收事件的情况</strong></p><ul><li>userInteractionEnabled &#x3D; NO;</li><li>hidden &#x3D; YES; （注：父视图隐藏时，子视图也会隐藏，不能接收事件）</li><li>alpha &lt; 0.01;</li></ul><p><strong>触摸点范围检测</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>pointInside:<span class="hljs-params">(CGPoint)</span>point withEvent:<span class="hljs-params">(UIEvent *)</span>event;<br></code></pre></td></tr></table></figure><p>返回YES，则触摸点在当前 view 上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">UIView</span> *)hitTest:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123;<br>    <span class="hljs-comment">// 1.判断下窗口能否接收事件</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.userInteractionEnabled ||<br>        <span class="hljs-keyword">self</span>.hidden == <span class="hljs-literal">YES</span> ||<br>        <span class="hljs-keyword">self</span>.alpha &lt;= <span class="hljs-number">0.01</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.判断触摸点在不在当前视图上</span><br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> pointInside:point withEvent:event])&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>; <span class="hljs-comment">//nil，表示不在当前视图上，无法响应</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 3.如果触摸点在当前视图范围内，则继续从后往前遍历子视图数组</span><br>    <span class="hljs-type">int</span> count = (<span class="hljs-type">int</span>)<span class="hljs-keyword">self</span>.subviews.count;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 获取子视图</span><br>        <span class="hljs-built_in">UIView</span> *childView = <span class="hljs-keyword">self</span>.subviews[i];<br>        <span class="hljs-comment">// 坐标系的转换,把当前视图上的点转换为子视图上的点</span><br>        <span class="hljs-built_in">CGPoint</span> childP = [<span class="hljs-keyword">self</span> convertPoint:point toView:childView];<br>        <span class="hljs-built_in">UIView</span> *fitView = [childView hitTest:childP withEvent:event];<br>        <span class="hljs-keyword">if</span> (fitView) &#123; <span class="hljs-comment">//不为空，说明触摸点在子视图上</span><br>            <span class="hljs-keyword">return</span> fitView; <span class="hljs-comment">//返回子视图，事件交由子视图接收</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 4.没有找到更合适的view，返回self，事件由自己接收</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>触摸事件传递给视图<code>A</code>后，会触发A的<code>hitTest:</code>方法。</p><p>若此方法返回 nil，则<code>A</code>和其子视图都不是响应者，响应为<code>A</code>的父视图。</p><p>响应者链是<code>从父视图到子视图</code>，若父视图不能响应事件，则子视图也就不能响应。</p><p>找到最合适的视图后会触发视图的<code>-touches</code>方法，开始向上(从子视图到父视图)传递事件。</p><h4 id="2-1-应用-事件的拦截"><a href="#2-1-应用-事件的拦截" class="headerlink" title="2.1.应用-事件的拦截"></a>2.1.应用-事件的拦截</h4><p>正因为<code>hitTest:</code>可以返回响应者视图，所以想让谁成为响应者就重写谁父视图的<code>hitTest:</code>方法返回指定的子视图；或者重写自己的<code>hitTest:</code>方法并返回<code>self</code>。</p><p>一般来说，建议在父视图的<code>hitTest:</code>中返回子视图作为最佳响应者！</p><h5 id="案例1-指定响应视图"><a href="#案例1-指定响应视图" class="headerlink" title="案例1-指定响应视图"></a>案例1-指定响应视图</h5><p>默认情况下 label 的<code>userInteractionEnabled</code>为 NO，即 label 不能接收触摸事件，接下来的示例还是以3.2小节中的树形结构为例，要让 label 响应触摸事件。可能你会觉得这个功能有点鸡肋，是的，这里我只是想演示一下如何让指定视图响应触摸或点击事件。</p><p><strong>思路</strong>：自定义蓝色视图和label，重写蓝色视图的<code>hitTest</code>方法，当触摸点在其子视图 label 的范围内时，返回此 label，这样触摸事件就转发给 label 并触发 label 的<code>-touch:</code> 系列方法。</p><ul><li>蓝色视图 ASDFBlueView:</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;ASDFBlueView.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ASDFBlueView</span></span><br><br>- (<span class="hljs-built_in">UIView</span> *)hitTest:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-comment">// 1.判断下窗口能否接收事件</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.userInteractionEnabled ||<br>        <span class="hljs-keyword">self</span>.hidden == <span class="hljs-literal">YES</span> ||<br>        <span class="hljs-keyword">self</span>.alpha &lt;= <span class="hljs-number">0.01</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.判断触摸点在不在窗口上</span><br>    <span class="hljs-keyword">if</span> (![<span class="hljs-keyword">self</span> pointInside:point withEvent:event])&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3.从后往前遍历子视图数组</span><br>    <span class="hljs-type">int</span> count = (<span class="hljs-type">int</span>)<span class="hljs-keyword">self</span>.subviews.count;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 获取子视图</span><br>        <span class="hljs-built_in">UIView</span> *childView = <span class="hljs-keyword">self</span>.subviews[i];<br>        <span class="hljs-comment">// 坐标系的转换,把窗口上的点转换为子视图上的点</span><br>        <span class="hljs-comment">// 把自己视图上的点转换成子视图上的点</span><br>        <span class="hljs-built_in">CGPoint</span> childP = [<span class="hljs-keyword">self</span> convertPoint:point toView:childView];<br>        <br>        <span class="hljs-comment">//label的interaction enable默认被关闭，这里让label响应触摸事件</span><br>        <span class="hljs-keyword">if</span> ([childView isKindOfClass:<span class="hljs-built_in">NSClassFromString</span>(<span class="hljs-string">@&quot;ASDFResponsibleLabel&quot;</span>)] &amp;&amp;<br>            [childView pointInside:childP withEvent:event]) &#123;<br>            <span class="hljs-keyword">return</span> childView;<br>        &#125;<br>        <span class="hljs-built_in">UIView</span> *fitView = [childView hitTest:childP withEvent:event];<br>        <span class="hljs-keyword">if</span> (fitView) &#123;<br>            <span class="hljs-keyword">return</span> fitView;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 4.没有找到更合适的view，返回自己</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Touched ASDFBlueView~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li>自定义的 ASDFResponsibleLabel</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;ASDFBlueView.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ASDFBlueView</span></span><br><br>- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Touched ASDFBlueView~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li>ViewController中重写touch方法</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++Touch began in ViewController~&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><ul><li>如果只点击橙色或白色区域，则只会触发<code>ViewController</code>中的<code>-touch:</code>方法；</li><li>如果点击 label 以外的蓝色区域，则只会触发<code>ASDFBlueView</code>中的<code>-touch:</code>方法；</li><li>如果点击 label，则 label 会响应点击并触发其<code>-touch:</code>方法；</li></ul><p><strong>延伸</strong>：</p><p>1、按照上面的思路，如果点击任何地方都只让当前<code>ViewController</code>响应事件，则重写其所有子视图的<code>-hitTest</code>方法并都返回<code>nil</code>即可；</p><p>2、如果既想 label 响应事件，又想蓝色视图响应事件，只需在 label 的<code>-touch:</code>方法中调用<code>[super touch..]</code>即可。</p><h5 id="案例2-抢红包"><a href="#案例2-抢红包" class="headerlink" title="案例2-抢红包"></a>案例2-抢红包</h5><p>需求：红包按照某种轨迹飘落，点到飘落中的红包才算抢到。</p><p>思路分析：</p><ul><li>飘落中的红包实则是一个执行了<code>position</code>动画的视图；</li><li>对于静止的红包，判断点击是否命中时只需在响应链将事件传递到红包视图时，判断触摸点是否在视图中即可；</li><li>但红包视图在执行位移动画，其实际位置在动画过程中并未真正改变，对动画中的红包判断触摸点并不可行；</li><li>红包视图的图层树中，<code>presentationLayer</code>保存了动画时 layer 的位置信息，只需判断触摸点是否在此图层中即可~</li></ul><p>步骤1：自定义红包视图</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;AnimateClickedView.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AnimateClickedView</span></span><br><br>- (<span class="hljs-built_in">UIView</span> *)hitTest:(<span class="hljs-built_in">CGPoint</span>)point withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123;<br>    <span class="hljs-comment">//转换point到presentationLayer的坐标系中</span><br>    <span class="hljs-built_in">CGPoint</span> convertedPoint = [<span class="hljs-keyword">self</span>.layer convertPoint:point toLayer:<span class="hljs-keyword">self</span>.layer.presentationLayer];<br>    <br>    <span class="hljs-comment">//判断点击是否在运动中的红包范围内</span><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.layer.presentationLayer containsPoint:convertedPoint]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++++恭喜您中奖了！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;没点中红包，继续加油哦~&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>步骤2：将红包视图添加到界面中并执行动画</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;AnimateClickedView.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) AnimateClickedView *animateView;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    <span class="hljs-comment">//添加视图</span><br>    _animateView = [[AnimateClickedView alloc] init];<br>    _animateView.backgroundColor = [<span class="hljs-built_in">UIColor</span> redColor];<br>    <span class="hljs-type">float</span> size = <span class="hljs-number">50</span>;<br>    uint32_t originX = arc4random() % (<span class="hljs-type">int</span>)(<span class="hljs-keyword">self</span>.view.frame.size.width - size);<span class="hljs-comment">//视图x起点为随机数</span><br>    _animateView.frame = <span class="hljs-built_in">CGRectMake</span>(originX, -size, size, size);<br>    [<span class="hljs-keyword">self</span>.view addSubview:_animateView];<br>&#125;<br><br><span class="hljs-comment">//模拟开始动画</span><br>-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-keyword">if</span> (aInt != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    aInt +=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//创建路径</span><br>    <span class="hljs-built_in">UIBezierPath</span> *path = [<span class="hljs-built_in">UIBezierPath</span> bezierPath];<br>    [path moveToPoint:_animateView.center];<span class="hljs-comment">//动画路径的起点为视图中心点</span><br>    <span class="hljs-comment">//路径中的控制点随机</span><br>    <span class="hljs-built_in">CGFloat</span> height = <span class="hljs-built_in">CGRectGetHeight</span>(<span class="hljs-keyword">self</span>.view.frame);<br>    [path addCurveToPoint:<span class="hljs-built_in">CGPointMake</span>(_animateView.frame.origin.x, height)<br>            controlPoint1:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">0</span>, arc4random() % (<span class="hljs-type">int</span>)(height / <span class="hljs-number">4.0</span>))<br>            controlPoint2:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-built_in">CGRectGetWidth</span>(<span class="hljs-keyword">self</span>.view.frame), height - <span class="hljs-number">200</span>)];<br>    <span class="hljs-comment">//创建动画</span><br>    <span class="hljs-built_in">CAKeyframeAnimation</span> *animation = [<span class="hljs-built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="hljs-string">@&quot;position&quot;</span>];<br>    animation.path = path.CGPath;<br>    animation.duration = <span class="hljs-number">5</span>;<br>    animation.autoreverses = <span class="hljs-literal">NO</span>;<br>    animation.removedOnCompletion = <span class="hljs-literal">NO</span>;<br>    animation.fillMode = kCAFillModeForwards;<br>    <span class="hljs-comment">//执行动画</span><br>    [_animateView.layer addAnimation:animation forKey:<span class="hljs-string">@&quot;HAPPY_NEW_YEAR_ANIMATION&quot;</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>步骤3：点击界面中的红包，查看日志信息~</p><h3 id="3-事件的传递"><a href="#3-事件的传递" class="headerlink" title="3.事件的传递"></a>3.事件的传递</h3><p>事件的响应者确定后，其内部的<code>-touches</code>系列方法会自动触发并开始处理事件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span> *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123; <br>    <span class="hljs-comment">// 默认会把事件传递给下一个响应者,下一个响应者是父视图,交给父视图处理</span><br>    [<span class="hljs-variable language_">super</span> touchesBegan:touches withEvent:event]; <br>    <span class="hljs-comment">// 注意不是调用父视图的touches方法，而是调用父类的touches方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果视图实现了<code>touches</code>系列方法，则事件将由该视图来处理；</p><p>如果调用了<code>[super touches….]</code>，则事件还将传递给其下一个响应者；</p><p>下一个响应者触发其<code>touches</code>系列方法(自己处理事件或者接着向上传递)；</p><p>如此循环下去就构成了事件的<code>传递链</code>。</p><h4 id="3-1-nextResponder"><a href="#3-1-nextResponder" class="headerlink" title="3.1. nextResponder"></a>3.1. nextResponder</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">nullable</span>) <span class="hljs-built_in">UIResponder</span> *nextResponder;<br></code></pre></td></tr></table></figure><p>这是<code>UIResponder</code>中的属性，用来查找下一个响应者。事件从第一个响应者开始传递，直到被某个响应者处理时事件才会停止传递；如果事件传到最后都没有被响应，则该事件就被丢弃。</p><p>事件传递的过程:</p><ol><li>若当前<code>view</code>是控制器的<code>self.view</code>，则控制器就是下一个响应者，事件传递给控制器响应；</li><li>若当前<code>view</code>不是控制器的<code>self.view</code>，则<code>view</code>的父视图就是下一个响应者，事件就传递给它的父视图响应；</li><li>在视图层次结构的最顶级视图，如果也不能处理该事件，则该事件会被传递给<code>window</code>对象；</li><li>若<code>window</code>对象也不处理，则事件会传递给<code>UIApplication</code>对象；</li><li>若<code>UIApplication</code>也不能处理该事件，则将其丢弃，本次点击毫无反应。</li></ol><p>小结：事件是从子视图往父视图传递。</p><p>#示例：</p><p>在<code>ViewController</code>的<code>self.view</code>(橙色)中有个白色圆角的视图(UIViewInspectable)，圆角视图内有个自定义的蓝色视图(ASDFBlueView)，蓝色视图中有个<code>label</code>，如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_responsiblelabel.png" alt="responsiblelabel"></p><p>结构图：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ViewController<br>    <span class="hljs-string">|--self.view</span><br>        <span class="hljs-string">|--圆角的视图</span><br>            <span class="hljs-string">|--蓝色视图</span><br>                <span class="hljs-string">|--label</span><br></code></pre></td></tr></table></figure><p>下面是根据响应者链查找<code>Label</code>所属<code>ViewController</code>的使用方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">UIViewController</span> *)findSuperControllerForView:(<span class="hljs-built_in">UIView</span> *)view<br>&#123;<br>    <span class="hljs-built_in">UIViewController</span> *resultController;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">UIView</span> *next = view; next; next = [next superview]) &#123;<br>        <span class="hljs-built_in">UIResponder</span> *responder = [next nextResponder];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++Class:%@&quot;</span>,[responder <span class="hljs-keyword">class</span>]);<br>        <span class="hljs-keyword">if</span> ([responder isKindOfClass:[<span class="hljs-built_in">UIViewController</span> <span class="hljs-keyword">class</span>]]) &#123;<br>            resultController = (<span class="hljs-built_in">UIViewController</span>*)responder;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++Equal Self?:%@&quot;</span>,[resultController isEqual:<span class="hljs-keyword">self</span>] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span>);<br>    <span class="hljs-keyword">return</span> resultController;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">Class:ASDFBlueView</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">Class:UIViewInspectable</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">Class:UIView</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">Class:ViewController</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">Class:UIApplication</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">Equal Self?:YES</span><br></code></pre></td></tr></table></figure><p>日志展示了响应者的查找过程，从子视图一直向父视图和<code>UIWindow</code>及<code>UIApplication</code>查找。最终找到<code>label</code>所属的控制器，即当前<code>ViewController</code>。</p><h4 id="3-2-应用-拖拽视图"><a href="#3-2-应用-拖拽视图" class="headerlink" title="3.2.应用-拖拽视图"></a>3.2.应用-拖拽视图</h4><p>自定义一个view，并重写下面方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)touchesMoved:(<span class="hljs-built_in">NSSet</span> *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event<br>&#123;<br>    <span class="hljs-built_in">UITouch</span> *touch = [touches anyObject];<br>    <br>    <span class="hljs-built_in">CGPoint</span> curP = [touch locationInView:<span class="hljs-keyword">self</span>];<br>    <span class="hljs-built_in">CGPoint</span> preP = [touch previousLocationInView:<span class="hljs-keyword">self</span>];<br>    <span class="hljs-built_in">CGFloat</span> offsetX = curP.x - preP.x;<br>    <span class="hljs-built_in">CGFloat</span> offsetY = curP.y - preP.y;<br>    <br>    <span class="hljs-keyword">self</span>.transform = <span class="hljs-built_in">CGAffineTransformTranslate</span>(<span class="hljs-keyword">self</span>.transform, offsetX, offsetY);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h3><ul><li>事件的响应者链是从上到下（父视图到子视图，子视图数组内从后往前）。</li><li>事件的传递链是从下到上（顺着响应者链条向上传递：子视图到父视图）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CALayer、动画、frame</title>
    <link href="/2017/12/29/draw.html"/>
    <url>/2017/12/29/draw.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-图层的绘制"><a href="#1-图层的绘制" class="headerlink" title="1.图层的绘制"></a>1.图层的绘制</h3><p>图层，即<code>CALayer</code>的绘有两种实现方案：</p><ol><li>自己绘制；</li><li>交给代理对象绘制。</li></ol><h4 id="1-1-自己绘制"><a href="#1-1-自己绘制" class="headerlink" title="1.1.自己绘制"></a>1.1.自己绘制</h4><p>图层自己绘制时，需要重写 -drawInContext 方法，具体步骤为：</p><ul><li>调用 CALayer 对象的 setNeedsDisplay 方法触发重绘；</li><li>重写 drawInContext: 方法绘制新内容。</li></ul><p>#示例1.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomLayer</span></span><br><br><span class="hljs-comment">//重写drawInContext</span><br>- (<span class="hljs-type">void</span>)drawInContext:(<span class="hljs-built_in">CGContextRef</span>)ctx<br>&#123;<br>    <span class="hljs-built_in">CGContextSetLineWidth</span>(ctx, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">CGContextSetFillColorWithColor</span>(ctx, [<span class="hljs-built_in">UIColor</span> blueColor].CGColor);<br>    <span class="hljs-built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor);<br>    <br>    <span class="hljs-comment">//贝塞尔曲线画三角形</span><br>    <span class="hljs-built_in">UIBezierPath</span> *aPath = [<span class="hljs-built_in">UIBezierPath</span> bezierPath];<br>    aPath.lineWidth = <span class="hljs-number">2.0</span>; <span class="hljs-comment">//设置线宽</span><br>    aPath.lineCapStyle = kCGLineCapRound; <span class="hljs-comment">//线条拐角</span><br>    aPath.lineJoinStyle = kCGLineCapRound; <span class="hljs-comment">//终点处理</span><br>    [aPath moveToPoint:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>)];<br>    [aPath addLineToPoint:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">150</span>, <span class="hljs-number">100</span>)];<br>    [aPath addLineToPoint:<span class="hljs-built_in">CGPointMake</span>(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>)];<br>    [aPath closePath];<br><br>    <span class="hljs-built_in">CGContextAddPath</span>(ctx, aPath.CGPath);<br>    <span class="hljs-built_in">CGContextDrawPath</span>(ctx, kCGPathFillStroke);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>将自定义 CustomLayer 添加到视图上，调用-setNeedsDisplay触发重绘：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    CustomLayer *layer = [[CustomLayer alloc] init];<br>    layer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    layer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:layer];<br>    [layer setNeedsDisplay];<span class="hljs-comment">//调用此方法触发重绘</span><br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="1-2-代理绘制"><a href="#1-2-代理绘制" class="headerlink" title="1.2.代理绘制"></a>1.2.代理绘制</h4><p>图层内部没有实现<code>-drawInContext</code>方法时，就需要将绘制任务代理给别的对象。默认情况下，CALayer的代理是其所属的视图。代理给别的对象时，此对象需要实现 CALayerDelegate。</p><ul><li>设置 CALayer 的 CALayerDelegate；</li><li>调用 CALayer 的-setNeedsDisplay 触发绘制；</li><li>在代理方法-drawLayer:inContext:的实现中绘制内容。</li></ul><p>#示例1.2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomLayer</span></span><br><span class="hljs-comment">//这里不重写-drawInContext:方法</span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>将自定义CALayer添加到视图上，设置代理并调用-setNeedsDisplay触发重绘：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">CALayerDelegate</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    CustomLayer *layer = [[CustomLayer alloc] init];<br>    layer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    layer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    layer.delegate = <span class="hljs-keyword">self</span>;<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:layer];<br>    [layer setNeedsDisplay];<span class="hljs-comment">//调用此方法触发重绘</span><br>&#125;<br><br><span class="hljs-comment">//CALayerDelegate</span><br>-(<span class="hljs-type">void</span>)drawLayer:(<span class="hljs-built_in">CALayer</span> *)layer inContext:(<span class="hljs-built_in">CGContextRef</span>)ctx<br>&#123;<br>    <span class="hljs-built_in">CGContextAddEllipseInRect</span>(ctx, <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>));<br>    <span class="hljs-built_in">CGContextSetRGBFillColor</span>(ctx, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">CGContextDrawPath</span>(ctx, kCGPathFillStroke);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>如果既重写了 CustomLayer 中的-drawInContext:，又实现了 CALayerDelegate，那么最终只会在-drawInContext中进行重绘。</p><h3 id="2-视图的绘制"><a href="#2-视图的绘制" class="headerlink" title="2.视图的绘制"></a>2.视图的绘制</h3><h4 id="2-1-显示原理"><a href="#2-1-显示原理" class="headerlink" title="2.1.显示原理"></a>2.1.显示原理</h4><p>通常，我们会使用UIView等控件来设置需要显示的内容，但实际上，视图本身并不负责内容的显示，甚至动画也不是在视图上执行的。从继承关系上来看，视图都直接或间接的继承自 UIResponder，从设计目标上来看视图的主要作用是处理用户交互。那么，显示和动画的工作由谁来处理呢？答案：CALayer！</p><blockquote><p>CALayer<br>An object that manages image-based content and allows you to perform animations on that content.</p></blockquote><p>视图内部默认有个.layer属性，这个<code>CALayer</code>对象正是视图显示和动画的幕后主角，视图的绘制本质上来说就是图层的绘制。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/* An object providing <span class="hljs-keyword">the</span> <span class="hljs-built_in">contents</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> layer, typically a CGImageRef,<br> * <span class="hljs-keyword">but</span> may be something <span class="hljs-keyword">else</span>. (For example, NSImage objects are<br> * supported <span class="hljs-keyword">on</span> Mac OS X <span class="hljs-number">10.6</span> <span class="hljs-keyword">and</span> later.) Default value <span class="hljs-keyword">is</span> nil.<br> * Animatable. */<br><br>@<span class="hljs-keyword">property</span>(nullable, strong) <span class="hljs-built_in">id</span> <span class="hljs-built_in">contents</span>;<br></code></pre></td></tr></table></figure><p>CALayer 中有个<code>contents</code>属性，即图层的内容，是一个位图（CGImageRef），指向一片叫做 backing store(后备存储区)的缓存区。默认情况下，此属性的值为空，它会从<code>后备存储</code>中读取内容并显示。当我们通过视图展示内容时：</p><ul><li>使用视图及其子控件，设置好宽高、背景色等内容；</li><li>runloop即将休眠或退出时，开始视图的绘制，调用 drawRect 方法；</li><li>drawRect 内通过 CoreGraphics 在 CGContextRef 中绘制内容并保存为位图；</li><li>绘制的位图被保存到由 CPU 开辟的一片叫 backing store 的缓存中；</li><li>图层的<code>contents</code>会从 backing store 中读取内容；</li><li>图层将<code>contents</code>中的位图交给<code>GPU</code>进行合成、转换和渲染；</li><li>GPU 将渲染结果放入<code>帧缓冲区</code>；</li><li><code>视频控制器</code>按照 VSync 信号逐行读取帧缓冲区的数据，经过数模转换传递给<code>显示器</code>展示。</li></ul><p>除了设置视图的宽高、背景色来展示内容外，我们也可以直接给 layer.contents 赋值，这种情况下，显示内容时不再从<code>后备存储</code>中读取内容，而是直接使用<code>contents</code>中的位图。</p><blockquote><p>If you are using the layer to display a static image, you can set this property to the CGImageRef containing the image you want to display. Assigning a value to this property causes the layer to use your image rather than create a separate backing store.</p></blockquote><h4 id="2-2-drawRect"><a href="#2-2-drawRect" class="headerlink" title="2.2.drawRect"></a>2.2.drawRect</h4><p>一般在自定义一个视图的绘制时，我们需要重写其-drawRect:方法。</p><p>#示例2.2:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomView.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br>    <br>    CustomView *view = [[CustomView alloc] init];<br>    view.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor];<br>    view.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view addSubview:view];<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomView.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomView</span></span><br><span class="hljs-comment">//自定义视图并重写drawRect</span><br>- (<span class="hljs-type">void</span>)drawRect:(<span class="hljs-built_in">CGRect</span>)rect<br>&#123;<br>    <span class="hljs-comment">//边宽</span><br>    <span class="hljs-built_in">CGFloat</span> lineWidth = <span class="hljs-number">3.0</span>f;<br>    <span class="hljs-comment">//半径</span><br>    <span class="hljs-built_in">CGFloat</span> radius = (<span class="hljs-built_in">CGRectGetWidth</span>(rect) - lineWidth * <span class="hljs-number">2</span>) / <span class="hljs-number">2.0</span>;<br>    <span class="hljs-comment">//圆心</span><br>    <span class="hljs-built_in">CGPoint</span> center = <span class="hljs-built_in">CGPointMake</span>(<span class="hljs-built_in">CGRectGetWidth</span>(rect)/<span class="hljs-number">2.0</span>, <span class="hljs-built_in">CGRectGetHeight</span>(rect) / <span class="hljs-number">2.0</span>);<br>    <span class="hljs-comment">//扇形起点</span><br>    <span class="hljs-built_in">CGFloat</span> startAngle = - M_PI_2;<br>    <span class="hljs-comment">//根据进度计算扇形结束位置</span><br>    <span class="hljs-built_in">CGFloat</span> endAngle = startAngle + <span class="hljs-number">0.8</span> * M_PI * <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//根据起始点、原点、半径绘制弧线</span><br>    <span class="hljs-built_in">UIBezierPath</span> *path = [<span class="hljs-built_in">UIBezierPath</span> bezierPathWithArcCenter:center radius:radius startAngle:startAngle endAngle:endAngle clockwise:<span class="hljs-literal">YES</span>];<br>    <br>    <span class="hljs-built_in">CGContextRef</span> ref = <span class="hljs-built_in">UIGraphicsGetCurrentContext</span>();<br>    <span class="hljs-built_in">CGContextSetLineWidth</span>(ref, lineWidth);<br>    <span class="hljs-built_in">CGContextSetFillColorWithColor</span>(ref, [<span class="hljs-built_in">UIColor</span> yellowColor].CGColor);<br>    <span class="hljs-built_in">CGContextSetStrokeColorWithColor</span>(ref, [<span class="hljs-built_in">UIColor</span> blueColor].CGColor);<br>    <span class="hljs-comment">//从弧线结束为止绘制一条线段到圆心。这样系统会自动闭合图形，绘制一条从圆心到弧线起点的线段。</span><br>    [path addLineToPoint:center];<br>    <span class="hljs-built_in">CGContextAddPath</span>(ref, path.CGPath);<br>    <span class="hljs-built_in">CGContextDrawPath</span>(ref, kCGPathFillStroke);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="2-3-调用堆栈"><a href="#2-3-调用堆栈" class="headerlink" title="2.3.调用堆栈"></a>2.3.调用堆栈</h4><p><img src="https://davidlii.nos-eastchina1.126.net/pic_drawrect.png" alt="视图重绘"></p><p>这是调用-drawRect时的堆栈图。当前 runloop 即将休眠或退出时，观察者回调函数中自动调用视图对象中 CALayer 的<code>-display</code>方法。下面是 CALayer.h 中对此方法的描述：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/* Reload the content of this layer. Calls the -drawInContext: method</span><br><span class="hljs-comment"> * then updates the `contents&#x27; property of the layer. Typically this is</span><br><span class="hljs-comment"> * not called directly. */</span><br><br>- (<span class="hljs-type">void</span>)display;<br></code></pre></td></tr></table></figure><p>即<code>-display</code>用来更新图层的内容，其内部会继续调用<code>-drawInContext:</code>并更新<code>contents</code>中的内容。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/* Called via the -display method when the `contents&#x27; property is being</span><br><span class="hljs-comment"> * updated. Default implementation does nothing. The context may be</span><br><span class="hljs-comment"> * clipped to protect valid layer content. Subclasses that wish to find</span><br><span class="hljs-comment"> * the actual region to draw can call CGContextGetClipBoundingBox(). */</span><br><br>- (<span class="hljs-type">void</span>)drawInContext:(<span class="hljs-built_in">CGContextRef</span>)ctx;<br><br><span class="hljs-comment">/* If defined, called by the default implementation of -drawInContext: */</span><br><br>- (<span class="hljs-type">void</span>)drawLayer:(<span class="hljs-built_in">CALayer</span> *)layer inContext:(<span class="hljs-built_in">CGContextRef</span>)ctx;<br></code></pre></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Draws the layer’s content <span class="hljs-keyword">using</span> the specified graphics context.The <span class="hljs-keyword">default</span> <span class="hljs-keyword">implementation</span> <span class="hljs-keyword">of</span> this <span class="hljs-keyword">method</span> <span class="hljs-title function_">does</span> <span class="hljs-title function_">not</span> <span class="hljs-title function_">do</span> <span class="hljs-title function_">any</span> <span class="hljs-title function_">drawing</span> <span class="hljs-title function_">itself</span>. <span class="hljs-title function_">If</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">layer</span>’<span class="hljs-title function_">s</span> <span class="hljs-title function_">delegate</span> <span class="hljs-title function_">implements</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">drawLayer</span>:inContext: <span class="hljs-keyword">method</span>, <span class="hljs-title function_">that</span> <span class="hljs-title function_">method</span> <span class="hljs-title function_">is</span> <span class="hljs-title function_">called</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">do</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">actual</span> <span class="hljs-title function_">drawing</span>.<br><span class="hljs-title function_">Subclasses</span> <span class="hljs-title function_">can</span> <span class="hljs-title function_">override</span> <span class="hljs-title function_">this</span> <span class="hljs-title function_">method</span> <span class="hljs-title function_">and</span> <span class="hljs-title function_">use</span> <span class="hljs-title function_">it</span> <span class="hljs-title function_">to</span> <span class="hljs-title function_">draw</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">layer</span>’<span class="hljs-title function_">s</span> <span class="hljs-title function_">content</span>. <span class="hljs-title function_">When</span> <span class="hljs-title function_">drawing</span>, <span class="hljs-title function_">all</span> <span class="hljs-title function_">coordinates</span> <span class="hljs-title function_">should</span> <span class="hljs-title function_">be</span> <span class="hljs-title function_">specified</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">points</span> <span class="hljs-title function_">in</span> <span class="hljs-title function_">the</span> <span class="hljs-title function_">logical</span> <span class="hljs-title function_">coordinate</span> <span class="hljs-title function_">space</span>.<br></code></pre></td></tr></table></figure><p><code>-drawInContext:</code>是图层内绘制内容的地方。默认情况下方法体中什么都不做，如果图层的代理实现了 drawLayer:inContext: 代理方法，那么就由这个方法来实现真正的绘制。示例3中我们没有重写此方法，所以图层会将绘制任务代理给别人。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">In iOS, <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> layer is associated <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> UIView object, this property must be <span class="hljs-built_in">set</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> view that owns <span class="hljs-keyword">the</span> layer.<br></code></pre></td></tr></table></figure><p>默认情况下，视图中根layer的代理是视图对象本身，所以绘制任务会通过代理转交给layer所属的视图。从堆栈图来看，drawLayer:inContext:代理方法内自动调用了视图的 drawRect 方法。也就是说，本来需要由 CALayer 来完成的绘制任务，通过代理转交给了视图的 drawRect，这也正是我们重写视图 drawRect 方法所要做的事情。</p><p>调用流程梳理如下：</p><ol><li>将视图添加到界面或者调用视图对象的-setNeedsDisplay方法，触发重绘；</li><li>视图将绘制任务交给内部的.layer处理；</li><li>layer 调用 -display 方法；</li><li>-display 继续调用-drawInContext绘制内容；</li><li>因为没有重写-drawInContext，CALayer将绘制任务通过代理交给layer所属的视图；</li><li>视图实现-drawLayer:inContext:代理方法，并调用自己的-drarRect:绘制内容；</li></ol><p>有个小知识点，-drawLayer:inContext:代理方法最后有个参数<code>ctx</code>，即绘图的上下文。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)drawLayer:(<span class="hljs-built_in">CALayer</span>*)layer inContext:(<span class="hljs-built_in">CGContextRef</span>)context &#123;<br>    <span class="hljs-built_in">UIGraphicsPushContext</span>(context);<br><br>    <span class="hljs-built_in">CGRect</span> bounds;<br>    bounds = <span class="hljs-built_in">CGContextGetClipBoundingBox</span>(context);<br>    [<span class="hljs-keyword">self</span> drawRect:bounds];<br><br>    <span class="hljs-built_in">UIGraphicsPopContext</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这是博主thinkq的一篇 <a href="https://www.jianshu.com/p/c49833c04362">文章</a> 中帖出来的 drawLayer:inContext: 的实现代码，方法内将layer传递过来的 CGContextRef 压入绘图上下文栈顶。我们在视图的 drawRect 中通过 UIGraphicsGetCurrentContext() 获取的正是此上下文，最后 drawRect 中的绘制任务都会保存在此<code>ctx</code>中。CGContextRef 是 <code>per-thread</code>的，进入子线程中通过 UIGraphicsGetCurrentContext() 获取栈顶的上下文会为空。这时，就需要通过 UIGraphicsBeginImageContext() 创建一个<code>基于位图的</code>上下文并将其设为当前上下文进行绘图。</p><p>另外，通过重写视图的 drawRect 方法，使用 CoreGraphic 来绘制内容，这会消耗很大一部分内存，尤其是当你需要不断重绘时。所以，可以考虑使用 <code>CAShapeLayer</code> 来绘制。CAShapeLayer 通过矢量图形而非 bitmap 来绘制图层，所以更节省内存、渲染速度也更快。</p><h4 id="2-3-绘制与线程"><a href="#2-3-绘制与线程" class="headerlink" title="2.3.绘制与线程"></a>2.3.绘制与线程</h4><p>视图的显示流程被分为<code>绘制</code>和<code>渲染</code>两个阶段。绘制的工作是由<code>CPU</code>来处理的，视图的 drawRect 方法或者图层的 drawInContext 方法内，绘制任务默认都是在主线程进行的，当使用 CoreGraphics绘图时，如果内容比较复杂则会导致CPU性能瓶颈从而造成卡顿现象。渲染的工作是由<code>GPU</code>来完成的，当需要渲染的图片过大、有离屏渲染等情况时，渲染不能及时完成，也会造成卡顿现象。所以有时我们需要在异步线程中执行绘图任务，再回到主线程将绘制结果返回给视图或CALayer。在使用 tableviewCell 这种控件时，避免离屏渲染问题。</p><p>#示例2.3：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (<span class="hljs-type">UIImage</span><span class="hljs-operator">*</span>)drawdrawAsynchronousInRect:(<span class="hljs-type">CGRect</span>)rect<br>&#123;<br>    <span class="hljs-type">CGFloat</span> scale <span class="hljs-operator">=</span> [[<span class="hljs-type">UIScreen</span> mainScreen] scale];<br>    <br>    rect.size.width <span class="hljs-operator">*=</span> scale;<br>    rect.size.height <span class="hljs-operator">*=</span> scale;<br>    <br>    <span class="hljs-type">UIGraphicsBeginImageContext</span>(rect.size);<br>    <br>    <span class="hljs-type">CGContextRef</span> context <span class="hljs-operator">=</span> <span class="hljs-type">UIGraphicsGetCurrentContext</span>();<br>    <span class="hljs-type">CGContextScaleCTM</span>(context, scale, scale);<br>    <br>    <span class="hljs-type">UIImage</span> <span class="hljs-operator">*</span>image <span class="hljs-operator">=</span> <span class="hljs-type">UIGraphicsGetImageFromCurrentImageContext</span>();<br>    <span class="hljs-type">UIGraphicsEndImageContext</span>();<br>    <span class="hljs-keyword">return</span> [<span class="hljs-type">UIImage</span> imageWithCGImage:image.<span class="hljs-type">CGImage</span> scale:scale orientation:<span class="hljs-type">UIImageOrientationUp</span>];<br>&#125;<br><br><span class="hljs-comment">//调用示例</span><br><span class="hljs-type">UIImageView</span> <span class="hljs-operator">*</span>imageView;<br>    <span class="hljs-type">NSOperationQueue</span> <span class="hljs-operator">*</span>drawQueue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br>    [drawQueue addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-comment">//异步队列中绘图</span><br>        <span class="hljs-type">UIImage</span> <span class="hljs-operator">*</span>image <span class="hljs-operator">=</span> [<span class="hljs-keyword">self</span> drawdrawAsynchronousInRect:rect];<br>        <span class="hljs-comment">//回到主线程设置图片</span><br>        [[<span class="hljs-type">NSOperationQueue</span> mainQueue] addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>            [imageView setImage:image];<br>        &#125;];<br>    &#125;];<br></code></pre></td></tr></table></figure><h3 id="3-图层与动画"><a href="#3-图层与动画" class="headerlink" title="3.图层与动画"></a>3.图层与动画</h3><h4 id="3-1-隐式动画"><a href="#3-1-隐式动画" class="headerlink" title="3.1.隐式动画"></a>3.1.隐式动画</h4><p>当我们修改了图层的可动画属性时，属性并不会立刻显示最终结果，而是有一个平滑的过渡效果，持续0.25秒，这就是图层的<code>隐式动画</code>。这个过程中，我们没有明确指定动画的类型，仅仅是改变了某个属性。</p><p>#示例3.1.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) CustomLayer *mSublayer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    _mSublayer = [[CustomLayer alloc] init];<br>    _mSublayer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    _mSublayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_mSublayer];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = _mSublayer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    _mSublayer.affineTransform = transform;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中我们只是对刚添加的图层的<code>affineTransform</code>属性值做了修改，运行点击界面后图层会有一个0.25秒的旋转动画。</p><p>隐式动画的背后其实是<code>Core Animation</code>在默默处理动画事务：当我们修改了图层的可动画属性时，Core Animation 会通过事务将我们的属性变化包裹起来，即包含在<code>CATransaction</code>的<code>begin</code>与<code>commit</code>中；事务被保存在一个栈结构中，当隐式动画被提交之后，它就被保存在栈顶的事务中；<code>runloop</code>的循环中会自动开始栈顶的这个事务，从而执行动画过程。</p><p>我们可以试着将上面执行动画部分的代码稍作修改，加入事务的语句：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span>(void)touchesBegan:(<span class="hljs-type">NSSet</span>&lt;<span class="hljs-type">UITouch</span> *&gt; <span class="hljs-operator">*</span>)touches withEvent:(<span class="hljs-type">UIEvent</span> <span class="hljs-operator">*</span>)event&#123;<br>    <span class="hljs-comment">//创建事务</span><br>    [<span class="hljs-type">CATransaction</span> begin];<br>    <span class="hljs-comment">//自定义动画时长</span><br>    [<span class="hljs-type">CATransaction</span> setAnimationDuration:<span class="hljs-number">2</span>.0f];<br>    <span class="hljs-comment">//自定义动画结束后的处理逻辑</span><br>    [<span class="hljs-type">CATransaction</span> setCompletionBlock:<span class="hljs-operator">^</span>&#123;<br>        _mSublayer.backgroundColor <span class="hljs-operator">=</span> [<span class="hljs-type">UIColor</span> redColor].<span class="hljs-type">CGColor</span>;<br>    &#125;];<br>    <span class="hljs-type">CGAffineTransform</span> transform <span class="hljs-operator">=</span> _mSublayer.affineTransform;<br>    transform <span class="hljs-operator">=</span> <span class="hljs-type">CGAffineTransformRotate</span>(transform, <span class="hljs-type">M_PI_2</span>);<br>    _mSublayer.affineTransform <span class="hljs-operator">=</span> transform;<br>    <span class="hljs-comment">//[CATransaction commit];</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行后可以看到，如果不<code>commit</code>，动画根本不会执行~另外，可以看到可变属性的动画时长和动画后的处理语句都可以自定义，这跟下面两种<code>UIView</code>的动画方式类似：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span><br>[UIView beginAnimations:@<span class="hljs-string">&quot;x&quot;</span> context:nil];<br><span class="hljs-regexp">//</span>animation here<br>[UIView commitAnimations];<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span><br>[UIView animateWithDuration:<span class="hljs-number">2.0</span>f animations:^&#123;<br>    <span class="hljs-regexp">//</span>animation here<br>&#125;];<br></code></pre></td></tr></table></figure><p>实际上这两种方式的内部都是通过<code>事务</code>来实现的，动画的创建和提交分别调用了<code>CATransaction</code>的<code>begin</code>与<code>commit</code>。</p><p>需要注意的是，<strong>隐式动画只在我们直接创建的图层上有效，<code>UIView</code>中根图的隐式动画默认是关闭的</strong>，对<code>UIView</code>中根图层做动画时，不会有动画效果:</p><p>#示例3.1.2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    [<span class="hljs-built_in">CATransaction</span> begin];<br>    [<span class="hljs-built_in">CATransaction</span> setAnimationDuration:<span class="hljs-number">2.0</span>f];<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = <span class="hljs-keyword">self</span>.view.layer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    <span class="hljs-comment">//修改 self.view 中根图层的可变属性</span><br>    <span class="hljs-keyword">self</span>.view.layer.affineTransform = transform;<br>    [<span class="hljs-built_in">CATransaction</span> commit];<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中我们对<code>self.view.layer.affineTransform</code>做了修改，并且通过事务设置了动画时长为2秒，但运行后可以看到并没有动画效果，而是直接变到目标值。</p><p>那么，CALayer 是如何确定自己是否执行隐式动画的呢？我们对<code>#示例3.1.1</code>中的代码稍作修改：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;CustomLayer.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">CALayerDelegate</span>&gt;//修改1：声明图层代理</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) CustomLayer *mSublayer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    _mSublayer = [[CustomLayer alloc] init];<br>    <span class="hljs-comment">//修改2：指定图层的代理为当前VC</span><br>    _mSublayer.delegate = <span class="hljs-keyword">self</span>;<br>    _mSublayer.backgroundColor = [<span class="hljs-built_in">UIColor</span> whiteColor].CGColor;<br>    _mSublayer.frame = <span class="hljs-built_in">CGRectMake</span>(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>    [<span class="hljs-keyword">self</span>.view.layer addSublayer:_mSublayer];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = _mSublayer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    _mSublayer.affineTransform = transform;<br>&#125;<br><br><span class="hljs-comment">//修改3：实现代理</span><br>- (<span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForLayer:(<span class="hljs-built_in">CALayer</span> *)layer forKey:(<span class="hljs-built_in">NSString</span> *)event&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++属性:%@&quot;</span>,event);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中有三处修改，都是关于<code>CALayerDelegate</code>的。运行后点击界面触发隐式动画，下面是动画触发时的堆栈信息：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_action_for_layer.png" alt="actionForLayer"></p><p>可以看到，动画提交后，CALayer 调用了其<code>actionForKey</code>方法，试图返回一个实现了<code>CAAction</code>协议的对象，参数<code>event</code>对应的正是我们修改的可动画属性。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/** Action methods. **/</span><br><br><span class="hljs-comment">/* An &quot;action&quot; is an object that responds to an &quot;event&quot; via the</span><br><span class="hljs-comment"> * CAAction protocol (see below). Events are named using standard</span><br><span class="hljs-comment"> * dot-separated key paths. Each layer defines a mapping from event key</span><br><span class="hljs-comment"> * paths to action objects. Events are posted by looking up the action</span><br><span class="hljs-comment"> * object associated with the key path and sending it the method</span><br><span class="hljs-comment"> * defined by the CAAction protocol.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * When an action object is invoked it receives three parameters: the</span><br><span class="hljs-comment"> * key path naming the event, the object on which the event happened</span><br><span class="hljs-comment"> * (i.e. the layer), and optionally a dictionary of named arguments</span><br><span class="hljs-comment"> * specific to each event.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * To provide implicit animations for layer properties, an event with</span><br><span class="hljs-comment"> * the same name as each property is posted whenever the value of the</span><br><span class="hljs-comment"> * property is modified. A suitable CAAnimation object is associated by</span><br><span class="hljs-comment"> * default with each implicit event (CAAnimation implements the action</span><br><span class="hljs-comment"> * protocol).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The layer class also defines the following events that are not</span><br><span class="hljs-comment"> * linked directly to properties:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * onOrderIn</span><br><span class="hljs-comment"> *      Invoked when the layer is made visible, i.e. either its</span><br><span class="hljs-comment"> *      superlayer becomes visible, or it&#x27;s added as a sublayer of a</span><br><span class="hljs-comment"> *      visible layer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * onOrderOut</span><br><span class="hljs-comment"> *      Invoked when the layer becomes non-visible. */</span><br><br><span class="hljs-comment">/* Returns the default action object associated with the event named by</span><br><span class="hljs-comment"> * the string &#x27;event&#x27;. The default implementation returns a suitable</span><br><span class="hljs-comment"> * animation object for events posted by animatable properties, nil</span><br><span class="hljs-comment"> * otherwise. */</span><br><br>+ (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)defaultActionForKey:(<span class="hljs-built_in">NSString</span> *)event;<br><br><span class="hljs-comment">/* Returns the action object associated with the event named by the</span><br><span class="hljs-comment"> * string &#x27;event&#x27;. The default implementation searches for an action</span><br><span class="hljs-comment"> * object in the following places:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. if defined, call the delegate method -actionForLayer:forKey:</span><br><span class="hljs-comment"> * 2. look in the layer&#x27;s `actions&#x27; dictionary</span><br><span class="hljs-comment"> * 3. look in any `actions&#x27; dictionaries in the `style&#x27; hierarchy</span><br><span class="hljs-comment"> * 4. call +defaultActionForKey: on the layer&#x27;s class</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If any of these steps results in a non-nil action object, the</span><br><span class="hljs-comment"> * following steps are ignored. If the final result is an instance of</span><br><span class="hljs-comment"> * NSNull, it is converted to `nil&#x27;. */</span><br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForKey:(<span class="hljs-built_in">NSString</span> *)event;<br><br><span class="hljs-comment">/* A dictionary mapping keys to objects implementing the CAAction</span><br><span class="hljs-comment"> * protocol. Default value is nil. */</span><br><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSDictionary</span>&lt;<span class="hljs-built_in">NSString</span> *, <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;&gt; *actions;<br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">CALayerDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><span class="hljs-comment">//...略</span><br><br><span class="hljs-comment">/* If defined, called by the default implementation of the</span><br><span class="hljs-comment"> * -actionForKey: method. Should return an object implementing the</span><br><span class="hljs-comment"> * CAAction protocol. May return &#x27;nil&#x27; if the delegate doesn&#x27;t specify</span><br><span class="hljs-comment"> * a behavior for the current event. Returning the null object (i.e.</span><br><span class="hljs-comment"> * &#x27;[NSNull null]&#x27;) explicitly forces no further search. (I.e. the</span><br><span class="hljs-comment"> * +defaultActionForKey: method will not be called.) */</span><br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForLayer:(<span class="hljs-built_in">CALayer</span> *)layer forKey:(<span class="hljs-built_in">NSString</span> *)event;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><code>CAAction</code>可以视为图层隐式动画的行为。动画提交后图层会通过<code>-actionForKey:</code>方法寻找一个<code>CAAction</code>对象，寻找的过程如下：</p><ul><li>先尝试通过 CALayerDelegate 的 -actionForLayer:forKey: 代理方法返回一个 CAAction 对象；</li><li>如果代理方法返回 null，则停止寻找，属性的修改不执行任何动画，直接更新到目标值；</li><li>如果代理方法返回 nil，则继续从 layer 的 actions 字典中查找 CAAction 对象；</li><li>如果 actions 字典中没有包含对应的属性，则图层继续在它的 style 字典中搜索属性名；</li><li>如果在 style 里也找不到，则从 +defaultActionForKey: 方法中返回属性对应的默认行为对象；</li></ul><p>上面的搜索过程中，<code>-actionForLayer:forKey:</code>如果返回<code>null</code>对象，则不执行动画；如果返回<code>nil</code>则会执行隐式动画。如果返回<code>CAAction</code>协议对象，则由 Core Animation 创建对应的动画。</p><p>上面提到的对视图的根图层的可动画属性进行修改时，并不会触发隐式动画，实际上就是因为视图默认是其根图层的代理，<code>-actionForLayer:forKey:</code>返回了一个<code>null</code>对象。你可以尝试让当前 VC 实现<code>self.view.layer</code>的代理并返回<code>nil</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()&lt;<span class="hljs-title">CALayerDelegate</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br>-(<span class="hljs-type">void</span>)touchesBegan:(<span class="hljs-built_in">NSSet</span>&lt;<span class="hljs-built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="hljs-built_in">UIEvent</span> *)event&#123;<br>    <span class="hljs-comment">//设置代理</span><br>    <span class="hljs-keyword">self</span>.view.layer.delegate = <span class="hljs-keyword">self</span>;<br>    [<span class="hljs-built_in">CATransaction</span> begin];<br>    [<span class="hljs-built_in">CATransaction</span> setAnimationDuration:<span class="hljs-number">2.0</span>f];<br>    <span class="hljs-built_in">CGAffineTransform</span> transform = <span class="hljs-keyword">self</span>.view.layer.affineTransform;<br>    transform = <span class="hljs-built_in">CGAffineTransformRotate</span>(transform, M_PI_2);<br>    <span class="hljs-comment">//修改 self.view 中根图层的可变属性</span><br>    <span class="hljs-keyword">self</span>.view.layer.affineTransform = transform;<br>    [<span class="hljs-built_in">CATransaction</span> commit];<br>&#125;<br><br>- (<span class="hljs-type">id</span>&lt;<span class="hljs-built_in">CAAction</span>&gt;)actionForLayer:(<span class="hljs-built_in">CALayer</span> *)layer forKey:(<span class="hljs-built_in">NSString</span> *)event&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++属性:%@&quot;</span>,event);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>再运行并点击界面后可以看到，<code>self.view.layer</code>这次执行了隐式动画！</p><h4 id="3-2-图层树"><a href="#3-2-图层树" class="headerlink" title="3.2.图层树"></a>3.2.图层树</h4><p>和视图一样图层也有树形结构，称为“图层树”，即<code>展示树</code>和<code>模型树</code>。</p><ul><li>展示树</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">- (instance<span class="hljs-keyword">type</span>)presentationLayer;<br></code></pre></td></tr></table></figure><blockquote><p>Returns a copy of the presentation layer object that represents the state of the layer as it currently appears onscreen.</p></blockquote><blockquote><p>Discussion<br>The layer object returned by this method provides a close approximation of the layer that is currently being displayed onscreen. While an animation is in progress, you can retrieve this object and use it to get the current values for those animations.<br>The sublayers, mask, and superlayer properties of the returned layer return the corresponding objects from the presentation tree (not the model tree). This pattern also applies to any read-only layer methods. For example, the hitTest: method of the returned object queries the layer objects in the presentation tree.</p></blockquote><p>当 layer 处于动画状态时，<code>展示树</code>会返回一个当前正在展示中的 layer，其属性值都是当前运动状态中对应的值，动画过程中会不断变化。</p><p>注意：展示树只有当图层展示在界面上之后才会有值，在此之前调用此树会返回<code>nil</code>。</p><ul><li>模型树</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">- (instance<span class="hljs-keyword">type</span>)modelLayer;<br></code></pre></td></tr></table></figure><blockquote><p>Returns the model layer object associated with the receiver, if any.</p></blockquote><blockquote><p>Discussion<br>Calling this method on a layer in the presentation tree returns the corresponding layer object in the model tree. This method returns a value only when a transaction involving changes to the presentation layer is in progress. If no transaction is in progress, the results of calling this method are undefined.</p></blockquote><p>在<code>呈现图层</code>上调用<code>–modelLayer</code>将会返回它正在呈现所依赖的 CALayer。通常在一个图层上调用<code>-modelLayer</code>会返回<code>self</code>。</p><p>关于这两个树的应用，可以移步到<code>事件响应者链 &amp; 传递链</code>这篇文章中的<code>抢红包</code>的示例~</p><h3 id="4-位置相关属性"><a href="#4-位置相关属性" class="headerlink" title="4.位置相关属性"></a>4.位置相关属性</h3><h4 id="4-1-frame"><a href="#4-1-frame" class="headerlink" title="4.1.frame"></a>4.1.frame</h4><blockquote><p>The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.</p></blockquote><p><code>frame</code>，表示视图在其父视图坐标系中的位置和大小。这里的位置<code>frame.origin(x,y)</code>即视图的左上角，它参照的是父视图的坐标系原点。改变frame的值只会影响到视图本身，其子视图的相对位置不变。</p><h4 id="4-2-bounds"><a href="#4-2-bounds" class="headerlink" title="4.2.bounds"></a>4.2.bounds</h4><blockquote><p>The bounds rectangle, which describes the view’s location and size in its own coordinate system.</p></blockquote><p><code>bounds</code>，表示视图在其自身坐标系中的位置和大小。默认情况下，bounds &#x3D; (0, 0, frame.size.width, frame.size.heigth)，即：</p><ul><li>bounds.origin默认为 (0, 0)；</li><li>bounds.size &#x3D; frame.size；</li></ul><p>其中<code>bounds.origin(x,y)</code>参照的是视图自身的坐标系原点，修改<code>bounds.origin</code>不会改变视图本身的位置，而是改变其自身的坐标系原点；因为子视图的位置参照的是父视图坐标系的原点，所以修改视图的<code>bounds.origin</code>最终影响的是其子视图的位置。具体表现是：</p><ul><li><code>bounds.origin(x,y)</code>相当于当前视图的坐标系原点与视图左上角之间带向量的间距；</li><li>默认情况下，视图本身的坐标系原点与视图左上角重合，即bounds.origin(x,y) &#x3D; (0, 0)；</li><li>当<code>origin.x</code>为正值时，间距在x轴上拉大，因为修改origin不影响视图本身的位置，所以视图左上角位置不变，只能让视图坐标系原点向左移动；此时子视图frame和bounds的数值都没变，但受父视图坐标系原点左移的影响，子视图本身也会跟着父视图的原点左移；</li><li>当<code>origin.y</code>为正值时，间距在y轴上拉大，因为视图左上角不变，所以视图坐标系原点会向上移动；子视图frame和bounds都不变，但它的实际位置会跟着父视图的原点向上移；</li></ul><p>#示例：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_frame_bounds.png" alt="bounds"></p><p>上图中，视图A是父视图，视图B是A的子视图。</p><ul><li>粉色背景中视图A.bounds.origin &#x3D; (0,0)；视图B.bounds.origin &#x3D; (0, 0)；</li><li>绿色背景中视图A.bounds.origin被修改为(50,0)，所以视图A自身的坐标系原点会向左移动50；</li><li>视图B是视图A的子视图，所以视图B会跟着视图A的坐标系原点向左移动50；</li></ul><p><strong>结论</strong>：修改bounds.origin会影响到子视图参照的坐标系原点；修改bounds.size会影响到视图本身的大小；</p><h4 id="4-3-anchorPoint"><a href="#4-3-anchorPoint" class="headerlink" title="4.3.anchorPoint"></a>4.3.anchorPoint</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">/* Defines the <span class="hljs-built_in">anchor</span> point of the layer&#x27;s bounds rect, as a point <span class="hljs-keyword">in</span><br> * normalized layer coordinates - &#x27;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#x27; is the bottom left corner of<br> * the bounds rect, &#x27;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)&#x27; is the top right corner. Defaults <span class="hljs-keyword">to</span><br> * &#x27;(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)&#x27;, i.e. the center of the bounds rect. Animatable. */<br><br>@property CGPoint <span class="hljs-built_in">anchor</span>Point;<br><br></code></pre></td></tr></table></figure><p>翻译过来是<code>锚点</code>，这是一个<code>CGPoint</code>类型的属性，可以理解为在 layer <code>自身坐标系</code>中的一个点。锚点在<code>x</code>轴和<code>y</code>轴上数值的变化范围均为[0~1]，例如<code>(0,0)</code>表示 layer 的左上角，<code>(0.5,0.5)</code>表示 layer 的中心点，<code>(1,1)</code>表示 layer 的右下角。锚点的默认值为<code>(0.5,0.5)</code>，即 layer 的中心点。直接修改锚点的值会触发隐式动画。</p><h4 id="4-4-position"><a href="#4-4-position" class="headerlink" title="4.4.position"></a>4.4.position</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/* The position in the superlayer that the anchor point of the layer&#x27;s</span><br><span class="hljs-comment"> * bounds rect is aligned to. Defaults to the zero point. Animatable. */</span><br><br><span class="hljs-variable">@property</span> CGPoint position;<br><br></code></pre></td></tr></table></figure><p>此属性也是<code>CGPoint</code>类型，表示一个点，即 layer 的<code>锚点</code>在其父图层中对应的点，也就是说<code>anchorPoint</code>与<code>position</code>两个点是重合的，只不过前者在自身坐标系统内，后者在父图层内。</p><p>为了方便理解，你可以将 layer 想象成一张便签纸，<code>anchorPoint</code>是用来固定便签纸的一枚图钉，图钉可以扎在便签纸自身范围内的任何位置上；<code>position</code>表示黑板上的一个点，便签纸会被图钉钉在黑板上，而钉在黑板上的这个点就是<code>position</code>。</p><p>#示例：</p><p><code>bounds = (0, 0, 50, 50)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0,0)</code>，效果如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor1.png" alt="效果图1"></p><p><code>bounds = (0, 0, 50, 50)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0.5,0.5)</code>，效果如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor2.png" alt="效果图2"></p><p><code>bounds = (0, 0, 100, 100)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0.5,0.5)</code>，效果如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor3.png" alt="效果图3"></p><p><code>bounds = (0, 0, 50, 50)</code>，<code>position = (0, 0)</code>，<code>anchorPoint = (0,0)</code>，<code>affineTransform = (M_PI / 4.0);</code>效果如下：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_position_anchor4.png" alt="效果图4"></p><p><strong>结论：</strong>CALayer 在其<code>superlayer</code>上的<code>frame</code>是由其自己的<code>bounds</code>、<code>position</code>和<code>anchorPoint</code>及<code>affineTransform</code>等属性共同决定的。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/documentation/quartzcore/calayer?language=objc">©Apple-CALayer</a></p><p>#<a href="https://developer.apple.com/documentation/quartzcore/cashapelayer">©AppleDev-CAShapelayer</a></p><p>#<a href="https://www.jianshu.com/p/c49833c04362">©thinkq-关于drawRect</a></p><p>#<a href="https://blog.csdn.net/catsmen/article/details/46546897">©catsmen-隐式动画和显式动画</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UI布局 &amp; 适配</title>
    <link href="/2017/12/27/autolayout.html"/>
    <url>/2017/12/27/autolayout.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-适配的进化"><a href="#1-适配的进化" class="headerlink" title="1.适配的进化"></a>1.适配的进化</h3><h4 id="1-Autoresizing"><a href="#1-Autoresizing" class="headerlink" title="1.Autoresizing"></a>1.Autoresizing</h4><p><code>Autoresizing</code>是苹果早期的界面适配方案，那时苹果的设备还不算多，iPhone 只有 4s 及其之前的产品，都是3.5英寸屏幕；iPad 也只有 iPad1、iPad2，都是9.7英寸。并且当时 iOS 上的应用很少需要适配横屏，所以<code>Autoresizing</code>能够满足绝大部分的适配需求。</p><p><code>xib</code>或者<code>故事板</code>(iOS5)中的6条线：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_AutoResizing.png" alt="autoresizing"></p><p>代码中的6个枚举值：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">NS_OPTIONS</span>(<span class="hljs-built_in">NSUInteger</span>, <span class="hljs-built_in">UIViewAutoresizing</span>) &#123;<br>    <span class="hljs-built_in">UIViewAutoresizingNone</span>                 = <span class="hljs-number">0</span>,         <span class="hljs-comment">//不变</span><br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleLeftMargin</span>   = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>,    <span class="hljs-comment">//与父视图的左边距可变，以保证右边距不变</span><br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleWidth</span>        = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>,    <span class="hljs-comment">//自动调整自身宽度，以保证左右边距不变</span><br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleRightMargin</span>  = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>,    <span class="hljs-comment">//与父视图的右边距可变，以保证左边距不变</span><br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleTopMargin</span>    = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>,    <span class="hljs-comment">//与父视图的上边距可变，以保证底部边距不变</span><br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleHeight</span>       = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>,    <span class="hljs-comment">//自动调整自身高度，以保证上下边距不变</span><br>    <span class="hljs-built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>     <span class="hljs-comment">//与父视图的下边距可变，以保证上边距不变</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这6个枚举值在实际应用时一般都是组合起来使用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 跟随父视图的宽度和高度等比缩放，以保证上下左右边距都不变</span><br>view.autoresizingMask = <span class="hljs-built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="hljs-built_in">UIViewAutoresizingFlexibleHeight</span>;<br></code></pre></td></tr></table></figure><p>通过<code>Autoresizing</code>，你可以方便的设置某个控件<del><strong>相对于其父视图的布局</strong></del>但这也是它的最大缺点：它只能用于设置子视图相对于其父视图的布局，对于与其同级的兄弟视图，或者其他父视图内的子视图之间的位置关系，它能做的很少。</p><h4 id="2-AutoLayout"><a href="#2-AutoLayout" class="headerlink" title="2.AutoLayout"></a>2.AutoLayout</h4><p>2012年iOS6发布，随之而来的设备是 4.0 英寸的iPhone5，我们需要适配的屏幕尺寸多了一个。为了减少开发者的适配工作量，苹果提供了基于<code>约束</code>的<code>AutoLayout</code>，即自动布局这一适配方案。<code>约束</code>条件控制了各控件之间的位置关系，且不局限于子控件与其父视图之间了，任意两个控件之间都可以设置约束关系。</p><p>这是xib中的布局约束：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_autolayout.png" alt="AutoLayout"></p><p>这是代码中的布局约束：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">_mTitle.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">NO</span>;<br><span class="hljs-comment">//mTitle 宽度 100</span><br><span class="hljs-built_in">NSLayoutConstraint</span> *widthcons = [<span class="hljs-built_in">NSLayoutConstraint</span> constraintWithItem:_mTitle<br>                             attribute:<span class="hljs-built_in">NSLayoutAttributeWidth</span><br>                             relatedBy:<span class="hljs-built_in">NSLayoutRelationEqual</span><br>                                toItem:<span class="hljs-literal">nil</span><br>                             attribute:<span class="hljs-built_in">NSLayoutAttributeNotAnAttribute</span><br>                            multiplier:<span class="hljs-number">1.</span>f<br>                              constant:<span class="hljs-number">100.</span>f];<br><span class="hljs-comment">//mTitle 在self.view中水平居中</span><br><span class="hljs-built_in">NSLayoutConstraint</span> *deltXcons =[<span class="hljs-built_in">NSLayoutConstraint</span> constraintWithItem:_mTitle<br>                                                            attribute:<span class="hljs-built_in">NSLayoutAttributeCenterX</span><br>                                                            relatedBy:<span class="hljs-built_in">NSLayoutRelationEqual</span><br>                                                               toItem:<span class="hljs-keyword">self</span>.view<br>                                                            attribute:<span class="hljs-built_in">NSLayoutAttributeCenterX</span><br>                                                           multiplier:<span class="hljs-number">1.</span>f<br>                                                             constant:<span class="hljs-number">0</span>];<br><span class="hljs-comment">//mTitle 在self.view中垂直居中</span><br><span class="hljs-built_in">NSLayoutConstraint</span> *deltYcons =[<span class="hljs-built_in">NSLayoutConstraint</span> constraintWithItem:_mTitle<br>                                                            attribute:<span class="hljs-built_in">NSLayoutAttributeCenterY</span><br>                                                            relatedBy:<span class="hljs-built_in">NSLayoutRelationEqual</span><br>                                                               toItem:<span class="hljs-keyword">self</span>.view<br>                                                            attribute:<span class="hljs-built_in">NSLayoutAttributeCenterY</span><br>                                                           multiplier:<span class="hljs-number">1.</span>f<br>                                                             constant:<span class="hljs-number">0</span>];<br>[<span class="hljs-keyword">self</span>.view addConstraint:widthcons];<br>[<span class="hljs-keyword">self</span>.view addConstraint:deltXcons];<br>[<span class="hljs-keyword">self</span>.view addConstraint:deltYcons];<br>__<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) wSf = <span class="hljs-keyword">self</span>;<br>[<span class="hljs-built_in">UIView</span> animateWithDuration:<span class="hljs-number">0.5</span> animations:^&#123;<br>    __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(wSf) sSf = wSf;<br>    [sSf.mTitle layoutIfNeeded];<br>&#125;];<br></code></pre></td></tr></table></figure><ul><li>参数1：attribute</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_ENUM</span>(<span class="hljs-type">NSInteger</span>, <span class="hljs-type">NSLayoutAttribute</span>) &#123;<br>    <span class="hljs-type">NSLayoutAttributeLeft</span> = 1,<br>    <span class="hljs-type">NSLayoutAttributeRight</span>,<br>    <span class="hljs-type">NSLayoutAttributeTop</span>,<br>    <span class="hljs-type">NSLayoutAttributeBottom</span>,<br>    <span class="hljs-type">NSLayoutAttributeLeading</span>,<br>    <span class="hljs-type">NSLayoutAttributeTrailing</span>,<br>    <span class="hljs-type">NSLayoutAttributeWidth</span>,<br>    <span class="hljs-type">NSLayoutAttributeHeight</span>,<br>    <span class="hljs-type">NSLayoutAttributeCenterX</span>,<br>    <span class="hljs-type">NSLayoutAttributeCenterY</span>,<br>    <span class="hljs-type">NSLayoutAttributeLastBaseline</span>,<br>    <span class="hljs-type">NSLayoutAttributeBaseline</span> <span class="hljs-type">NS_SWIFT_UNAVAILABLE</span>(&quot;<span class="hljs-type">Use</span> &#x27;lastBaseline&#x27; instead&quot;) = <span class="hljs-type">NSLayoutAttributeLastBaseline</span>,<br>    <span class="hljs-type">NSLayoutAttributeFirstBaseline</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <br>    <br>    <span class="hljs-type">NSLayoutAttributeLeftMargin</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <span class="hljs-type">NSLayoutAttributeRightMargin</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <span class="hljs-type">NSLayoutAttributeTopMargin</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <span class="hljs-type">NSLayoutAttributeBottomMargin</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <span class="hljs-type">NSLayoutAttributeLeadingMargin</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <span class="hljs-type">NSLayoutAttributeTrailingMargin</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <span class="hljs-type">NSLayoutAttributeCenterXWithinMargins</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <span class="hljs-type">NSLayoutAttributeCenterYWithinMargins</span> <span class="hljs-type">NS_ENUM_AVAILABLE_IOS(8_0)</span>,<br>    <br>    <span class="hljs-type">NSLayoutAttributeNotAnAttribute</span> = 0<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>参数2：relation</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_ENUM</span>(<span class="hljs-type">NSInteger</span>, <span class="hljs-type">NSLayoutRelation</span>) &#123;<br>    <span class="hljs-type">NSLayoutRelationLessThanOrEqual</span> = -1,<br>    <span class="hljs-type">NSLayoutRelationEqual</span> = 0,<br>    <span class="hljs-type">NSLayoutRelationGreaterThanOrEqual</span> = 1,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>参数3：multiplier</li></ul><p>比例或者倍数，最终约束的值 &#x3D; multiplier * constant。</p><ul><li>参数4：constant</li></ul><p>默认倍数为1时的约束的值。</p><p><strong>注意事项：</strong></p><ul><li>在添加约束之前，须确保控件已经添加到父视图中；</li><li>控件的 translatesAutoresizingMaskIntoConstraints 必须要设置为NO~</li></ul><p>你还可以通过<code>VFL</code>格式创建<code>NSLayoutConstraint</code>，只是比较抽象，就不介绍了。</p><h4 id="3-SizeClasses"><a href="#3-SizeClasses" class="headerlink" title="3.SizeClasses"></a>3.SizeClasses</h4><p>2014年 iOS8 发布，随之而来的设备是4.7英寸的 iphone6 和5.5英寸的 iphone6 Plus。这样我们需要适配的屏幕尺寸又多了两款，适配难度进一步增加。这时苹果提出了<code>SizeClasses</code>概念，这是苹果对诸多设备宽高尺寸的一种抽象，它将设备的尺寸分为三类：</p><ul><li>Compact（紧凑型）</li><li>Regular（宽大型）</li><li>Any（实际上是Compact与Regular的组合）</li></ul><p>三种抽象尺寸的组合，可以描述任意类型的设备及其横、竖屏状态、SplitView等。</p><table><thead><tr><th align="left"><center>机型</center></th><th align="center"><center>iPad</center></th><th align="center"><center>iPhone 8 plus</center></th><th align="center"><center>iPhone 8</center></th><th align="center"><center>1&#x2F;3 SplitView </center></th></tr></thead><tbody><tr><td align="left">竖屏</td><td align="center">宽<strong>R</strong> 高<strong>R</strong></td><td align="center">宽<strong>C</strong> 高<strong>R</strong></td><td align="center">宽<strong>C</strong> 高<strong>R</strong></td><td align="center">宽<strong>C</strong> 高<strong>R</strong></td></tr><tr><td align="left">横屏</td><td align="center">宽<strong>R</strong> 高<strong>R</strong></td><td align="center">宽<strong>R</strong> 高<strong>C</strong></td><td align="center">宽<strong>C</strong> 高<strong>C</strong></td><td align="center">宽<strong>C</strong> 高<strong>R</strong></td></tr></tbody></table><p>示例1：（w<strong>R</strong> h<strong>R</strong>）表示<code>竖屏</code>状态下全屏的iPad：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_sizeclasses1.png" alt="竖屏iPad"></p><p>示例2：（wR hR）表示<code>横屏</code>状态下全屏的iPad：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_sizeclasses2.png" alt="横屏iPad"></p><p>示例3：（w<strong>C</strong> h<strong>R</strong>）表示<code>竖屏</code>状态下的iPhone，或者iPad上 1&#x2F;3 的 splitView：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_sizeclasses3.png" alt="竖屏iPhone"></p><p>示例4：（w<strong>C</strong> h<strong>C</strong>）表示<code>横屏</code>状态下的非 plus 版iPhone：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_sizeclasses4.png" alt="横屏iPhone"></p><p>示例5：（w<strong>R</strong> h<strong>C</strong>）表示<code>横屏</code>状态下的 plus 版iPhone：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_sizeclasses5.png" alt="横屏plus"></p><p>需要注意：<code>SizeClasses</code>只是对设备尺寸的抽象，真正的布局还需要开启<code>AutoLayout</code>。</p><h4 id="4-Vary-For-Traits"><a href="#4-Vary-For-Traits" class="headerlink" title="4.Vary For Traits"></a>4.Vary For Traits</h4><p>XIB编辑界面默认是(Any-Any)模式，此时添加的约束在任意机型下的呈现都是相同的，可以点击XIB底部的<code>View as xxx</code>，在<code>Device</code>列表中选择不同的设备，或者切换<code>Orientation</code>选项，查看相同约束在不同情形下的呈现。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_vary_for_trait_8p_cr.png" alt="相同约束相同呈现"></p><p>有时我们希望，同一个视图在不同机型、或横、竖屏下，呈现不同的布局。这就要用到 Xcode 8 之后推出的<code>Vary For Traits</code>，它基于<code>SizeClasses</code>进化而来，极大地方便了我们对这些情形的适配。</p><ul><li>1.先来配置竖屏。</li></ul><p>点击底部<code>View as xxx</code>即可打开<code>Vary For Traits</code>功能，在<code>Device</code>列表中选择<code>iPhone 8 plus</code>，<code>Orientation</code>选择竖屏，此时进入(w<strong>C</strong> h<strong>R</strong>)模式；</p><p>点击右侧<code>Vary For Traits</code>按钮，在弹出的小面板中勾选<code>Width</code>和<code>Height</code>，这样我们就能以(w<strong>C</strong> h<strong>R</strong>)模式为基准进行适配了，即适配所有宽度是紧凑、高度是正常的机型。接下来我们所设置的约束，将只适用于68款机型，包括了所有iPhone的竖屏和iPad的SplitView。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_vary_for_trait_8p_cr_all.png" alt="配置竖屏模式"></p><p>设置好约束后，点击<code>Done Varying</code>就可以完成本次适配了。</p><ul><li>2.再来适配横屏。</li></ul><p><code>Device</code>依然选择<code>iPhone 8 plus</code>，<code>Orientation</code>选择横屏，点击右侧<code>Vary for Traits</code>，勾选<code>Height</code>，这样就能以(w<strong>Any</strong> h<strong>C</strong>)模式为基准进行适配了，即适配所有横屏状态下的iPhone。接下来我们所设置的约束，将只适用于18款机型。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_vary_for_trait_8p_rc_all.png" alt="配置横屏模式"></p><p>设置好约束后，点击<code>Done Varying</code>就可以完成本次适配了。</p><p>至此，我们就完成了相同视图在竖屏与横屏模式下的不同配置，看下旋转前后的不同布局效果。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_vary_for_traits_demo_result.jpeg" alt="横竖屏不同布局效果"></p><h3 id="2-布局接口"><a href="#2-布局接口" class="headerlink" title="2.布局接口"></a>2.布局接口</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (void)layoutSubviews<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>系统会在视图需要重新计算其<code>frame</code>时调用此方法，这些情况包括：</p><ul><li>改变了视图的 frame；</li><li>更新了视图的约束；</li><li>改变了视图层级，如新增子视图；</li><li>屏幕旋转了；</li></ul><p>你也可以重写此方法，以便自定义视图及其子视图的布局信息。</p><p>此方法由系统自动调用，不建议我们手动调用。真有需要时使用 [view layoutIfNeeded] 来让系统自动触发此方法。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (void)layoutIfNeeded<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>告诉布局系统<code>立即</code>更新布局。比如你更新了约束并想立刻开始位移动画时，手动调用此方法即可。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (void)setNeedsLayout<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>将视图标记为需要更新布局，但不会立马进行，而是在下一个 update cycle 中进行。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">- (<span class="hljs-type">void</span>)drawRect:(CGRect)rect;<br></code></pre></td></tr></table></figure><p>若需要在当前视图上绘制自定义的内容，则重写此方法。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">-  (void)setNeedsDisplay<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>将视图标记为需要重绘，其实质是 layer 的重绘，最终会触发-drawRect:方法。</p><h3 id="3-约束的属性-amp-接口"><a href="#3-约束的属性-amp-接口" class="headerlink" title="3.约束的属性&amp;接口"></a>3.约束的属性&amp;接口</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">/* By default, the autoresizing mask on a view gives rise to </span><br><span class="hljs-comment">constraints that fully determine the view&#x27;s position. </span><br><span class="hljs-comment">This allows the auto layout system to track the frames of views </span><br><span class="hljs-comment">whose layout is controlled manually (through -setFrame:, for example).</span><br><span class="hljs-comment">When you elect to position the view using auto layout by </span><br><span class="hljs-comment">adding your own constraints, you must set this property to NO. </span><br><span class="hljs-comment">IB will do this for you.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">BOOL</span> translatesAutoresizingMaskIntoConstraints; <span class="hljs-comment">// Default YES</span><br></code></pre></td></tr></table></figure><p>这是<code>Autoresizing</code>时代的产物，使用 IB 创建视图时，默认为 NO；纯代码添加视图时，默认值为 YES。当需要手动添加和修改约束时，需要将此属性置为 NO。因为视图的 AutoresizingMask 会被转换成对应效果的约束。这样很可能与我们手动添加的其它约束有冲突。此属性设置成 NO 时，AutoresizingMask 就不会变成约束，即当前视图的 AutoresizingMask 失效了。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (BOOL)needsUpdateConstraints<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>“Constraint-based layout system” 使用此返回值去决定是否需要调用 updateConstraints 作为正常布局过程的一部分。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (void)updateConstraints<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>系统更新约束，自定义 view 时可以重写此方法，在其中添加 view 需要的局部 contraints。注意：要在实现在最后调用 [super updateConstraints]。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (void)updateConstraintsIfNeeded<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>立即触发约束更新，自动更新布局。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (void)setNeedsUpdateConstraints<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当有约束需要更新时，调用此方法来标记这些约束需要在未来的某个点更新，系统之后调用 updateConstraints。</p><h3 id="4-自动布局的过程"><a href="#4-自动布局的过程" class="headerlink" title="4.自动布局的过程"></a>4.自动布局的过程</h3><p><code>updating constraints</code> -&gt; <code>layout</code> -&gt; <code>display</code>，每一个步骤都依赖于上一步。</p><ul><li>updating constraints</li></ul><p>从下向上（from subview to superview），为下一步准备信息。可以调用 setNeedUpdateConstraints 触发此步。constraints 的改变也会触发此步。但是当你自定义视图时，若一些改变可能会影响到布局时，需要自己去调用 updateConstraintsIfNeeded 以通知自动布局更新约束。</p><ul><li>layout</li></ul><p>从上向下（from superview to subview），此步主要应用上一步的信息去设置视图的 center 和 bounds。可以通过调用 setNeedsLayout 去触发此步骤，此方法不会立即应用 layout。如果想要系统立即的更新 layout，可以调用 layoutIfNeeded。另外自定义视图时可以重写 layoutSubViews 方法来得到更多的定制化效果。</p><ul><li>display</li></ul><p>从上向下（from superview to subview）。此步是把视图渲染到屏幕上，它与你是否使用 Auto layout 无关，通过调用 setNeedsDisplay 触发，系统会调用 UIView 的 drawRect 方法。</p><h3 id="5-VC中视图的布局过程"><a href="#5-VC中视图的布局过程" class="headerlink" title="5.VC中视图的布局过程"></a>5.VC中视图的布局过程</h3><ul><li>-loadView</li><li>viewDidLoad</li><li>viewWillAppear</li><li>updateViewConstraints</li><li>viewWillLayoutSubviews</li><li>viewDidLayoutSubviews</li><li>viewDidAppear</li><li>viewWillDisAppear</li><li>viewDidDisAppear</li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/* Base implementation sends -updateConstraints to the view.</span><br><span class="hljs-comment">When a view has a view controller, this message is sent </span><br><span class="hljs-comment">to the view controller during the autolayout updateConstraints </span><br><span class="hljs-comment">pass in lieu of sending updateConstraints directly to the view.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">You may override this method in a UIViewController subclass for </span><br><span class="hljs-comment">updating custom constraints instead of subclassing your view </span><br><span class="hljs-comment">and overriding -[UIView updateConstraints].</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Overrides must call super or send -updateConstraints to the view.</span><br><span class="hljs-comment">*/</span><br>- (<span class="hljs-keyword">void</span>)updateViewConstraints;<br></code></pre></td></tr></table></figure><p>注意，这个<code>-updateViewConstraints</code>方法是 UIViewController 中的，不是 UIView 中的<code>-updateConstraints</code>方法。。“view 属于某个 VC”（比如 self.view），当此 view 需要执行<code>updateConstraints</code>时，会调用 VC 的<code>updateViewConstraints</code>，这样就不用你再自定义此 view 并重写其<code>updateConstraints</code>方法了。方法中需要调用其 super 方法。这个方法的默认实现是调用其所有 subview 的 updateConstraints 方法，这样就自上而下的完成了布局。 </p><p>另外，updateViewConstraints、viewWillLayoutSubviews、viewDidLayoutSubviews 在当前 vc 布局过程中可能会被多次调用，这三个方法在离开当前控制器时也会被调用。</p><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><p>除了<code>self.view</code>外，其他视图的实际 frame 要在以下两个方法执行完之后才能确定：</p><ul><li>view 的 layoutSubViews;</li><li>VC 的 viewDidLayoutSubviews;</li></ul><p>所以，当我们真的需要 frame 时要在这个两个时间点以后再去获取。这就是 viewDidLoad 里通过<code>setFrame</code>的方式修改原先在xib里拖动的约束代码无效的症结所在。因为 updateViewConstraints 在 viewDidLoad 后执行，会覆盖掉之前的设置的frame，所以无效。</p><p>另外需要注意一点：在使用 sb 或者 xib 加载 VC 时，viewDidLoad 中只有 self.view 的 frame 信息是准确的，其他所有的控件的 frame 都是它们在 sb 或 xib 中的原始尺寸，与当前设备可能不符。</p><hr><p>相关参考：</p><p>#<a href="https://blog.csdn.net/zpz5789/article/details/50922469">©zpz5789-Updating constraints、Layout</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>+load &amp; +initialize</title>
    <link href="/2017/12/25/load.html"/>
    <url>/2017/12/25/load.html</url>
    
    <content type="html"><![CDATA[<p>有时，我们需要在应用启动阶段，或者类初始化之前处理一些指定的需求，这时你可能需要这俩方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">+ (<span class="hljs-type">void</span>)<span class="hljs-keyword">load</span>;<br>+ (<span class="hljs-type">void</span>)initialize;<br></code></pre></td></tr></table></figure><h3 id="1-load"><a href="#1-load" class="headerlink" title="1.load"></a>1.load</h3><blockquote><p>Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</p></blockquote><h4 id="1-1-触发时机"><a href="#1-1-触发时机" class="headerlink" title="1.1.触发时机"></a>1.1.触发时机</h4><ol><li>dyld 加载镜像文件；</li><li>初始化runtime；</li><li>注册OC类与分类；</li><li><code>+load</code>。</li></ol><p><img src="https://davidlii.nos-eastchina1.126.net/pic_call_load.png" alt="+load"></p><p>所以，<code>+load</code>是在应用启动阶段，即加载应用可执行文件时、进入程序主入口前触发的。</p><h4 id="1-2-调用顺序"><a href="#1-2-调用顺序" class="headerlink" title="1.2.调用顺序"></a>1.2.调用顺序</h4><p><code>父类</code>-&gt;<code>子类</code>-&gt;<code>分类</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//父类</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Initializer</span></span><br>+ (<span class="hljs-type">void</span>)load&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++ super loaded~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//子类1</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SubInitializer</span> : <span class="hljs-title">Initializer</span></span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SubInitializer</span></span><br>+(<span class="hljs-type">void</span>)load&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++ SubInitializer loaded~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//子类2</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SubInitializer2</span> : <span class="hljs-title">Initializer</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SubInitializer2</span></span><br>+(<span class="hljs-type">void</span>)load&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++ SubInitializer2 loaded~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//分类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Initializer</span> (<span class="hljs-title">Category</span>)</span><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Initializer</span> (<span class="hljs-title">Category</span>)</span><br>+(<span class="hljs-type">void</span>)load&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++ category loaded~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span> <span class="hljs-comment">super loaded~</span><br><span class="hljs-literal">++++</span> <span class="hljs-comment">SubInitializer2 loaded~</span><br><span class="hljs-literal">+++</span> <span class="hljs-comment">SubInitializer loaded~</span><br><span class="hljs-literal">++++</span> <span class="hljs-comment">category loaded~</span><br></code></pre></td></tr></table></figure><p>结论：</p><ul><li>父类和子类都重写此方法时，都会触发，且子类晚于父类触发；</li><li>原类和分类都重写此方法时，都会触发，且分类晚于原类触发；</li><li>父类子类和它们的分类都重写此方法时，都会触发，顺序为：父类&gt;子类&gt;子类分类&gt;父类分类；</li><li>不在同一继承树上的类之间的触发顺序不确定；</li></ul><h4 id="1-3-示例"><a href="#1-3-示例" class="headerlink" title="1.3.示例"></a>1.3.示例</h4><p>检测添加到数组中的对象是否为 nil：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSMutableArray</span> (<span class="hljs-title">Extension</span>)</span><br><br>+(<span class="hljs-type">void</span>)load&#123;<br>    [<span class="hljs-keyword">self</span> swizzle];<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)swizzle<br>&#123;<br>    Method method1 = class_getInstanceMethod(objc_getClass(<span class="hljs-string">&quot;__NSArrayM&quot;</span>), <span class="hljs-keyword">@selector</span>(addObject:));<br>    Method method2 = class_getInstanceMethod(objc_getClass(<span class="hljs-string">&quot;__NSArrayM&quot;</span>), <span class="hljs-keyword">@selector</span>(s_ddObject:));<br>    <span class="hljs-comment">//交换方法</span><br>    method_exchangeImplementations(method1, method2);<br>&#125;<br><br>-(<span class="hljs-type">void</span>)s_ddObject:(<span class="hljs-type">id</span>)anObject<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == anObject)&#123;<br>        <span class="hljs-keyword">@try</span> &#123;<br>            [<span class="hljs-keyword">self</span> s_ddObject:anObject];<br>        &#125; <span class="hljs-keyword">@catch</span> (<span class="hljs-built_in">NSException</span> *exception) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Crash reason:\n %@&quot;</span>, [exception callStackSymbols]);<br>        &#125; <span class="hljs-keyword">@finally</span> &#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        [<span class="hljs-keyword">self</span> s_ddObject:anObject];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>交换方法之后，调用<code>addObject:</code>实际上会去调用<code>s_ddObject:</code>；而<code>s_ddObject:</code>内调用<code>s_ddObject:</code>实际上是调用数组的<code>addObject:</code>方法；所以<code>s_ddObject</code>实际上起到了中间层的作用，用来做异常的检测和其他任务。</p><p>随后通过<code>+load</code>函数在程序启动时执行该替换过程。下面是调用示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;NSMutableArray+Extension.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSMutableArray</span> *mutArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br>    [mutArr addObject:<span class="hljs-literal">nil</span>];<span class="hljs-comment">//添加nil也不会崩了</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>这样再往数组中添加 nil 对象时，就不再会崩溃，并且一旦发现 nil 对象就会将信息打印出来。</p><p>需要注意，不宜在<code>+load</code>内处理复杂任务，这会减慢应用的启动速度。优化应用启动时间时，也可从这里入手。</p><h3 id="2-initialize"><a href="#2-initialize" class="headerlink" title="2.initialize"></a>2.initialize</h3><blockquote><p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</p></blockquote><h4 id="2-1-触发时机"><a href="#2-1-触发时机" class="headerlink" title="2.1.触发时机"></a>2.1.触发时机</h4><p>在类或其子类收到第一个消息之前调用；如果类一直没被调用，则<code>+initialize</code>一直不会触发；</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_call_initialize.png" alt="+load"></p><h4 id="2-2-调用顺序"><a href="#2-2-调用顺序" class="headerlink" title="2.2.调用顺序"></a>2.2.调用顺序</h4><p><code>父类</code>-&gt;<code>子类</code>；分类覆盖原类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;Initializer.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Initializer</span></span><br><br>+(<span class="hljs-type">void</span>)initialize<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++ super Initialized~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//子类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">SubInitializer</span> : <span class="hljs-title">Initializer</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">SubInitializer</span></span><br>+(<span class="hljs-type">void</span>)initialize&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++ SubInitializer Initialized~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//分类</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Initializer</span> (<span class="hljs-title">Category</span>)</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Initializer</span> (<span class="hljs-title">Category</span>)</span><br>+(<span class="hljs-type">void</span>)initialize&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++ category Initialized~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用及日志：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>调用<br>SubInitializer *subInitial = [[SubInitializer alloc] init];<br><span class="hljs-regexp">//</span>日志<br>++++ category Initialized~<br>+++ SubInitializer Initialized~<br></code></pre></td></tr></table></figure><ul><li>原类和分类都重写此方法时，只有分类中的会触发，因为查询方法列表时先查到的是分类中的 initialize；</li><li>父类重写而子类未重写此方法时，对于每个子类，第一次向其发送消息时，都会触发父类中的 initialize，所以父类的 initialize 可能会触发多次；</li><li>父类和子类都重写此方法，首次向父类发送消息，则只会触发父类中的方法；首次向子类发送消息，则两个都会触发且子类晚于父类；先后向子和类父类发送消息，则调用到父类时只触发父类的 initialize；调用到子类时只触发子类的 initialize（因为父类中的 initialize 已经触发过了）。</li></ul><p>注意：父类中的<code>+initialize</code>可能被多次调用，若在父类的<code>+initialize</code>中单独处理某些需求，要做好判断：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Initializer</span></span><br><br>+(<span class="hljs-type">void</span>)initialize<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++class \&quot;%@\&quot; initialized~&quot;</span>,[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> == [Initializer <span class="hljs-keyword">self</span>]) &#123;<br>        <span class="hljs-comment">// ... do the initialization ...</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>另外，<code>+initialize</code>是线程安全的，也就是说当 runtime 在第一个线程中调用此方法后，其他线程中需要向此类发送消息时都会被阻塞，直到<code>+initialize</code>执行完毕。所以，此方法内不适合用来处理复杂的任务，可用来初始化全局变量。</p><h4 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3.示例"></a>2.3.示例</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Initializer.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-built_in">UIKIT_EXTERN</span> <span class="hljs-type">int</span> aGlobalInt;<br><span class="hljs-built_in">UIKIT_EXTERN</span> <span class="hljs-built_in">NSString</span> *className;<br><span class="hljs-built_in">UIKIT_EXTERN</span> <span class="hljs-built_in">NSMutableDictionary</span> *paramDic;<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Initializer</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//Initializer.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Initializer.h&quot;</span></span><br><br><span class="hljs-type">int</span> aGlobalInt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">NSString</span> *className = <span class="hljs-string">@&quot;defaultName&quot;</span>;<br><span class="hljs-built_in">NSMutableDictionary</span> *paramDic = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Initializer</span></span><br><br>+(<span class="hljs-type">void</span>)initialize<br>&#123;<br>    paramDic = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> == [Initializer <span class="hljs-keyword">self</span>]) &#123;<br>        aGlobalInt = <span class="hljs-number">1</span>;<br>        className = <span class="hljs-string">@&quot;Initializer&quot;</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        aGlobalInt = <span class="hljs-number">2</span>;<br>        className = <span class="hljs-built_in">NSStringFromClass</span>([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]);<br>    &#125;<br>    paramDic[<span class="hljs-string">@&quot;name&quot;</span>] = className;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用及日志：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//调用</span><br>Initializer *initial = <span class="hljs-literal">[[I<span class="hljs-identifier">nitializer</span> <span class="hljs-identifier">alloc</span>]</span> init];<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++Int:%d, String:%@, Dic:%@&quot;</span>,<span class="hljs-params">aGlobalInt</span>,<span class="hljs-params">className</span>,<span class="hljs-params">paramDic</span>)</span>;<br><span class="hljs-comment">//日志</span><br>++++Int:<span class="hljs-number">1</span>, String:Initializer, Dic:&#123;<br>    name = Initializer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-比较"><a href="#3-比较" class="headerlink" title="3.比较"></a>3.比较</h3><p>从触发的时间序列上来看：</p><ul><li><code>+load</code> 发生在二进制文件加载阶段，在 UIApplicationMain 这个程序主入口之前；</li><li><code>+initialize</code> 发生在程序完全启动之后，也就是在 <code>+load</code> 之后。</li></ul><p>从各类中方法的加载顺序来看：</p><ul><li><code>load</code> 发生在加载镜像期间，各类的 <code>load</code> 方法加载顺序不确定，所以不建议在一个类中调用另一个类；</li><li><code>initialize</code> 在程序启动之后，类均已在运行时环境中创建和加载，所以可以正常调用。</li></ul><p>从触发次数上来看：</p><ul><li><code>load</code> 在启动阶段会全部触发，且每个<code>load</code>只会触发一次；</li><li><code>initialize</code> 只在调用当前类时才会触发，不调用则永远不触发；父类中的<code>initialize</code>可能会触发多次；</li></ul><p>调用顺序上：</p><ul><li>两个方法在父类、子类和分类等情况下的调用顺序有所不同，注意区分~</li></ul><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc">©AppleDev-load</a></p><p>#<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize?language=objc">©AppleDev-initialize</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造器</title>
    <link href="/2017/12/24/initializer.html"/>
    <url>/2017/12/24/initializer.html</url>
    
    <content type="html"><![CDATA[<h3 id="1、指定构造函数（Designated-Initializer）"><a href="#1、指定构造函数（Designated-Initializer）" class="headerlink" title="1、指定构造函数（Designated Initializer）"></a>1、指定构造函数（Designated Initializer）</h3><p>在 OC 的很多头文件中，都会出现<code>NS_DESIGNATED_INITIALIZER</code>这个宏，如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">instancetype</span>)initWithNibName:(<span class="hljs-built_in">NSString</span> *)nibNameOrNil<br>bundle:(<span class="hljs-built_in">NSBundle</span> *)nibBundleOrNil <span class="hljs-built_in">NS_DESIGNATED_INITIALIZER</span>;<br></code></pre></td></tr></table></figure><p>这个宏就是 “指定构造函数” 的标志，它用来告诉调用者使用这个方法来初始化类对象。一个类可以定义多个构造方法，不同的构造方法可以传入不同的参数，或者通过不同的方式来初始化一个类对象，指定构造函数通常是参数最多的构造函数。一个类必须有一个指定构造器，但并不是说只能有一个。如果必要，你可以声明多个，但是通常情况下一个就足够了。</p><p>有时候为了方便，我们想使用尽量少或者不用参数，就能创建一个类对象。这时就可以使用“便利构造函数”来解决。</p><h3 id="2、便利构造函数（Convenience-Initializer）"><a href="#2、便利构造函数（Convenience-Initializer）" class="headerlink" title="2、便利构造函数（Convenience Initializer）"></a>2、便利构造函数（Convenience Initializer）</h3><p>这是为了方便调用者快速创建一个类对象而定义的一种构造函数。通常会在便利构造函数中给成员变量提供一个默认值。</p><p>#示例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Initializer</span> : <span class="hljs-title">NSObject</span></span><br>&#123;<br>    <span class="hljs-built_in">NSString</span> *aTitle;<br>    <span class="hljs-built_in">NSDate</span>   *aDate;<br>&#125;<br><br><span class="hljs-comment">//Designated Initializer</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithTitle:(<span class="hljs-built_in">NSString</span> *)title<br>date:(<span class="hljs-built_in">NSDate</span>*)date <span class="hljs-built_in">NS_DESIGNATED_INITIALIZER</span>;<br><br><span class="hljs-comment">//Convenience Initializer</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithTitle:(<span class="hljs-built_in">NSString</span> *)title;<br><br><span class="hljs-comment">//不希望调用父类(NSObject)的这个 Designated Initializer</span><br>- (<span class="hljs-keyword">instancetype</span>)init <span class="hljs-built_in">NS_UNAVAILABLE</span>;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;Initializer.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Initializer</span></span><br><br><span class="hljs-comment">//父类（NSObject）的 Designated Initializer</span><br>- (<span class="hljs-keyword">instancetype</span>) init<br>&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> initWithTitle:<span class="hljs-string">@&quot;defaultTitle&quot;</span>];<br>&#125;<br><br><span class="hljs-comment">//Convenience Initializer</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithTitle:(<span class="hljs-built_in">NSString</span> *)title<br>&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> initWithTitle:title date:[<span class="hljs-built_in">NSDate</span> date]];<br>&#125;<br><br><span class="hljs-comment">//Designated Initializer</span><br>- (<span class="hljs-keyword">instancetype</span>) initWithTitle:(<span class="hljs-built_in">NSString</span> *)title <br>date:(<span class="hljs-built_in">NSDate</span>*)date<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) <span class="hljs-comment">//调用父类的指定构造器</span><br>    &#123;<br>        aTitle = title;<br>        aDate  = date;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">//<span class="hljs-number">1</span><br><span class="hljs-symbol">Initializer</span> *ai1 = [[<span class="hljs-symbol">Initializer</span> alloc] init];<br>//<span class="hljs-number">2</span><br><span class="hljs-symbol">Initializer</span> *ai2 = [[<span class="hljs-symbol">Initializer</span> alloc] initWithTitle:@<span class="hljs-string">&quot;title2&quot;</span>];<br>//<span class="hljs-number">3</span><br><span class="hljs-symbol">Initializer</span> *ai3 = [[<span class="hljs-symbol">Initializer</span> alloc] initWithTitle:@<span class="hljs-string">&quot;title3&quot;</span> <br>date:[<span class="hljs-symbol">NSDate</span> date]];<br></code></pre></td></tr></table></figure><p>上面的调用示例中，第一种在编译时会报错。因为不希望调用者使用此方法来初始化这个类对象，所以头文件中已把<code>init</code>方法声明为<code>NS_UNAVAILABLE</code>。</p><h3 id="3、使用规范"><a href="#3、使用规范" class="headerlink" title="3、使用规范"></a>3、使用规范</h3><p>如果子类有<code>Designated Initializer</code>，那么这个<code>Designated Initializer</code> 中必须调用它直接父类的<code>Designated Initializer</code>，并且需要重写父类的<code>Designated Initializer</code>。</p><p>如果子类有<code>Designated Initializer</code>，那么<code>Convenience Initializer</code>必须调用这个子类中其它初始化函数(包括<code>Designated Initializer</code>和其他<code>Convenience Initializer</code>)，不能调用 super 的初始化函数。</p><p>由上可以推理出：</p><ul><li>Convenience Initializer 只能调用自己类中的其他初始化方法。</li><li>Designated Initializer 才有资格调用父类的 Designated Initializer。</li><li>所有的 Convenience Initializer 最终都会调到该类的 Designated Initializer。</li></ul>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件下载</title>
    <link href="/2017/12/22/download.html"/>
    <url>/2017/12/22/download.html</url>
    
    <content type="html"><![CDATA[<p>iOS 中实现文件下载有以下几种方式：</p><h3 id="一-NSData"><a href="#一-NSData" class="headerlink" title="一.NSData"></a>一.NSData</h3><p>NSData 提供了类方法实现文件下载：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSURL</span>  *aUrl = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;https://example.jpg&quot;</span>];<br><span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:aUrl];<br><span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];<br></code></pre></td></tr></table></figure><p>使用这种方式会一次性返回整个下载到的文件，且在当前线程中同步下载文件。所以，在主线程中下载时，遇到网络状况不佳的情况时，会出现卡顿的现象。</p><p>解决方案之一：把下载任务放到异步线程中进行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> downloadQueue = dispatch_queue_create(<br><span class="hljs-string">&quot;downloadQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-built_in">dispatch_async</span>(downloadQueue, ^&#123;<br>    <span class="hljs-built_in">NSURL</span> *aUrl = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;https://example.jpg&quot;</span>];<br>    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:aUrl];<br>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];<br>&#125;);<br></code></pre></td></tr></table></figure><p>此方法虽然解决了卡顿的问题，但还有另外的问题：返回的 data 是在内存中的。当目标文件过大时，内存会爆掉。所以，我们希望有这样一种方案：</p><ol><li>文件数据能分批返回。</li><li>解决保存返回的数据时内存占用过大的情况。</li></ol><p>对于第1点，我们可以使用系统提供的 NSURLConnection、NSURLSession 类来解决。它们都可以通过代理来不断接收返回的数据。</p><p>对于第2点，我们可以把接收到的数据保存到沙盒里。待全部数据接收并处理完成后，删除此沙盒文件即可。</p><h3 id="二-NSURLConnection"><a href="#二-NSURLConnection" class="headerlink" title="二.NSURLConnection"></a>二.NSURLConnection</h3><p>通过 <strong>NSURLConnection</strong> 可以实现创建连接、自动发送请求、通过代理接收服务器返回的数据。同时，可以实现暂停和断点续传功能。</p><h4 id="2-1-下载功能"><a href="#2-1-下载功能" class="headerlink" title="2.1.下载功能"></a>2.1.下载功能</h4><ol><li>创建一个 NSURL 对象，设置请求地址；</li><li>创建一个 NSURLRequest 对象，设置请求头和请求体；</li><li>使用 NSURLConnection 发送请求；</li><li>通过代理方法接收服务器的响应和数据，写入沙盒中；</li></ol><h4 id="2-2-暂停功能"><a href="#2-2-暂停功能" class="headerlink" title="2.2.暂停功能"></a>2.2.暂停功能</h4><p>NSURLConnection 本身并没有暂停的相关函数，但我们可以使用它提供的 <code>cancel</code> 方法来实现暂停功能。</p><h4 id="2-3-断点续传功能"><a href="#2-3-断点续传功能" class="headerlink" title="2.3.断点续传功能"></a>2.3.断点续传功能</h4><p>要实现断点续传，可借助 HTTP 请求头的 <code>range</code> 字段。它可以指定每次从网络上下载的数据包的大小。<code>range</code> 字段的格式如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bytes</span> = <span class="hljs-number">0</span>-<span class="hljs-number">100</span>，             从<span class="hljs-number">0</span>到<span class="hljs-number">100</span>的<span class="hljs-number">100</span>个字节。<br><span class="hljs-attribute">bytes</span> = <span class="hljs-number">200</span>-,               从<span class="hljs-number">200</span>字节以后的所有字节。<br><span class="hljs-attribute">bytes</span> = - <span class="hljs-number">500</span>,              最后<span class="hljs-number">500</span>个字节。<br><span class="hljs-attribute">bytes</span> = <span class="hljs-number">200</span>-<span class="hljs-number">300</span>，<span class="hljs-number">500</span>-<span class="hljs-number">800</span>，  同时指定几个范围。<br></code></pre></td></tr></table></figure><p>每次暂停时，在 <code>connection:didReceiveData:</code> 回调中记录已经接收到的数据大小，在恢复下载时，把此大小对应的 <code>range</code> 字段设置到请求头中，重新创建连接并发送请求即可。</p><p>具体可参考以下示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//DataTaskTool.h</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">DataTaskTool</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">DataTaskToolDelegate</span></span><br><br>- (<span class="hljs-type">void</span>)dataTaskTool:(DataTaskTool*)tool <br>onDownloadProgress:(<span class="hljs-type">double</span>)progress;<br><br>- (<span class="hljs-type">void</span>)dataTaskTool:(DataTaskTool*)tool <br>onDownloadFinishedWithInfo:(<span class="hljs-type">id</span>)info;<br><br>- (<span class="hljs-type">void</span>)dataTaskTool:(DataTaskTool*)tool <br>onDownloadFailedWithError:(<span class="hljs-built_in">NSError</span>*)error;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DataTaskTool</span> : <span class="hljs-title">NSObject</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithURL:(<span class="hljs-built_in">NSString</span>*)URL <br>delegate:(<span class="hljs-type">id</span>&lt;DataTaskToolDelegate&gt;)delegate;<br><br>- (<span class="hljs-type">void</span>)start;<br>- (<span class="hljs-type">void</span>)pause;<br>- (<span class="hljs-type">void</span>)resume;<br>- (<span class="hljs-type">void</span>)cancel;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//DataTaskTool.m</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DataTaskTool.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DataTaskTool</span> ()</span><br>&lt;<br><span class="hljs-built_in">NSURLConnectionDataDelegate</span><br>&gt;<br>&#123;<br>    <span class="hljs-built_in">NSMutableURLRequest</span> *mRequest; <span class="hljs-comment">//请求对象</span><br>    <span class="hljs-built_in">NSURLConnection</span> *mUrlConnection; <span class="hljs-comment">//连接对象</span><br>    <span class="hljs-built_in">NSFileHandle</span> *mFileHandle; <span class="hljs-comment">//文件管理</span><br>    <span class="hljs-built_in">NSString</span> *mFilePath; <span class="hljs-comment">//沙盒文件路径</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mTotalContentLength; <span class="hljs-comment">//文件总长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mCurrentContentLength; <span class="hljs-comment">//当前接收到的数据总长度</span><br>    <span class="hljs-type">double</span> mProgressValue; <span class="hljs-comment">//当前下载进度值</span><br>&#125;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-type">id</span> &lt;DataTaskToolDelegate&gt; delegate;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DataTaskTool</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithURL:(<span class="hljs-built_in">NSString</span>*)URL <br>delegate:(<span class="hljs-type">id</span>&lt;DataTaskToolDelegate&gt;)delegate<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init])<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == URL.length) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>        _delegate = delegate;<br>        <br>        <span class="hljs-comment">//设置请求</span><br>        mRequest = [[<span class="hljs-built_in">NSMutableURLRequest</span> alloc] <br>        initWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:URL]];<br>        <br>        mRequest.HTTPMethod = <span class="hljs-string">@&quot;GET&quot;</span>;<br>        mRequest.timeoutInterval = <span class="hljs-number">60</span>;<br>        <br>        <span class="hljs-comment">//创建连接对象</span><br>        mUrlConnection = [[<span class="hljs-built_in">NSURLConnection</span> alloc] <br>        initWithRequest:mRequest <br>        delegate:<span class="hljs-keyword">self</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -NSURLConnectionDataDelegate</span><br><span class="hljs-comment">//接收到服务器的响应</span><br>-(<span class="hljs-type">void</span>)connection:(<span class="hljs-built_in">NSURLConnection</span> *)connection <br>didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response<br>&#123;<br>    mTotalContentLength = response.expectedContentLength;<br>    <br>    <span class="hljs-comment">//设置文件路径</span><br>    <span class="hljs-built_in">NSString</span> *fileName = response.suggestedFilename;<br>    <span class="hljs-built_in">NSString</span>* caches = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<br>    <span class="hljs-built_in">NSCachesDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) <br>    lastObject];<br>    <br>    mFilePath = [caches stringByAppendingPathComponent:fileName];<br>    <br>    <span class="hljs-keyword">if</span> (![[<span class="hljs-built_in">NSFileManager</span> defaultManager] fileExistsAtPath:mFilePath])<br>    &#123;<br>        [[<span class="hljs-built_in">NSFileManager</span> defaultManager] <br>        createFileAtPath:mFilePath <br>        contents:<span class="hljs-literal">nil</span> attributes:<span class="hljs-literal">nil</span>];<br>    &#125;<br>    <br>    mFileHandle = [<span class="hljs-built_in">NSFileHandle</span> fileHandleForWritingAtPath:mFilePath];<br>&#125;<br><br><span class="hljs-comment">//接收到服务器返回的数据（此方法可能会回调多次）</span><br>-(<span class="hljs-type">void</span>)connection:(<span class="hljs-built_in">NSURLConnection</span> *)connection <br>didReceiveData:(<span class="hljs-built_in">NSData</span> *)data<br>&#123;<br>    <span class="hljs-comment">//移动到文件的结尾</span><br>    [mFileHandle seekToEndOfFile];<br>    <span class="hljs-comment">//新数据追加到文件中</span><br>    [mFileHandle writeData:data];<br>    <br>    <span class="hljs-comment">//计算当前下载进度</span><br>    mCurrentContentLength += data.length;<br>    mProgressValue = (<span class="hljs-type">double</span>)mCurrentContentLength / mTotalContentLength;<br>    <br>    <span class="hljs-comment">//回调进度</span><br>    [_delegate dataTaskTool:<span class="hljs-keyword">self</span> onDownloadProgress:mProgressValue];<br>&#125;<br><br><span class="hljs-comment">//下载完成</span><br>-(<span class="hljs-type">void</span>)connectionDidFinishLoading:(<span class="hljs-built_in">NSURLConnection</span> *)connection<br>&#123;<br>    <span class="hljs-comment">//结束写入</span><br>    [mFileHandle closeFile];<br>    <span class="hljs-built_in">NSError</span> *error = [<span class="hljs-built_in">NSError</span> new];<br>    [[<span class="hljs-built_in">NSFileManager</span> defaultManager] removeItemAtPath:mFilePath error:&amp;error];<br>    <br>    <span class="hljs-comment">//完成回调</span><br>    [_delegate dataTaskTool:<span class="hljs-keyword">self</span> onDownloadFinishedWithInfo:<span class="hljs-literal">nil</span>];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)connection:(<span class="hljs-built_in">NSURLConnection</span> *)connection <br>didFailWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    [_delegate dataTaskTool:<span class="hljs-keyword">self</span> onDownloadFailedWithError:error];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -BUSINESS API</span><br><span class="hljs-comment">//开始请求</span><br>- (<span class="hljs-type">void</span>)start<br>&#123;<br>    [mUrlConnection start];<br>&#125;<br><br><span class="hljs-comment">//暂停</span><br>- (<span class="hljs-type">void</span>)pause<br>&#123;<br>    [mUrlConnection cancel];<br>    mUrlConnection = <span class="hljs-literal">nil</span>;<br>&#125;<br><br><span class="hljs-comment">//恢复</span><br>- (<span class="hljs-type">void</span>)resume<br>&#123;<br>    <span class="hljs-comment">//设置断点下载的区间</span><br>    <span class="hljs-built_in">NSString</span> *range = [<span class="hljs-built_in">NSString</span> stringWithFormat:<br>    <span class="hljs-string">@&quot;bytes=%lld-&quot;</span>, mCurrentContentLength];<br>    <br>    [mRequest setValue:range forHTTPHeaderField:<span class="hljs-string">@&quot;Range&quot;</span>];<br>    <br>    mUrlConnection = [[<span class="hljs-built_in">NSURLConnection</span> alloc] <br>    initWithRequest:mRequest delegate:<span class="hljs-keyword">self</span>];<br>    <br>    [mUrlConnection start];<br>&#125;<br><br><span class="hljs-comment">//取消请求</span><br>- (<span class="hljs-type">void</span>)cancel<br>&#123;<br>    [mUrlConnection cancel];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用示例</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">/*Windows10下载地址<br>U<span class="hljs-symbol">RL:</span> htt<span class="hljs-symbol">ps:</span>//software-download.microsoft.com/<br><span class="hljs-built_in">db</span>/Win10_1709_Chinese(Simplified)_x32.iso?<br><span class="hljs-built_in">t</span>=e56bdb47-<span class="hljs-number">6973</span>-<span class="hljs-number">4</span>da2-<span class="hljs-number">9</span>e94-<span class="hljs-number">5</span>a6a458c9192&amp;e<br>=<span class="hljs-number">1513964531</span>&amp;h=d9ba28ed1645810206cd89e7c4675a5b<br>*/<br>DataTaskTool *tool = [[DataTaskTool alloc] <br>initWithU<span class="hljs-symbol">RL:ur</span>l delega<span class="hljs-symbol">te:se</span>lf];<br><br>[tool start];<br></code></pre></td></tr></table></figure><p>需要注意的是，iOS9之后，NSURLConnection 已被废弃，苹果转而推荐使用 NSURLSession。</p><h3 id="三-NSURLSession"><a href="#三-NSURLSession" class="headerlink" title="三.NSURLSession"></a>三.NSURLSession</h3><p>NSURLSession 是苹果在 iOS7 后为数据传输提供的一系列接口，它比 NSURLConnection 更强大。</p><ul><li>任务都是异步进行的，没有同步执行的单独接口；</li><li>支持后台数据上传和下载；</li><li>有单独接口支持断点续传；</li><li>数据下载会保存到缓存目录，解决了下载时的内存问题；</li><li>任务创建后不会自动发送请求，需要手动开始执行任务；</li></ul><h4 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1.配置"></a>3.1.配置</h4><p>NSURLSessionConfiguration，这是一个定义URLSession的行为和策略的配置，是实例化URLSession对象的必备参数；一旦配置完成则当前会话会使用该配置的一个备份，并忽略你对原配置对象的任何修改；如果想修改配置信息，你需要更新对应的字段并且用更新后的配置创建一个新的URLSession对象。</p><p>1、会话配置分类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">class</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionConfiguration</span> *defaultSessionConfiguration;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">class</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionConfiguration</span> *ephemeralSessionConfiguration;<br>+ (<span class="hljs-built_in">NSURLSessionConfiguration</span> *)backgroundSessionConfigurationWithIdentifier:(<span class="hljs-built_in">NSString</span> *)identifier;<br></code></pre></td></tr></table></figure><ul><li><strong>defaultSessionConfiguration</strong></li></ul><p>默认的会话配置，它会使用硬盘空间做缓存；用钥匙串保存用户的授权信息；会将cookie保存到<code>shared cookie store</code>中。</p><ul><li><strong>ephemeralSessionConfiguration</strong></li></ul><p>临时会话配置，不做硬盘缓存，而是保存到内存RAM中；不保存用户的cookie和证书；invalidate后所有配置信息会被抹去。</p><ul><li><strong>backgroundSessionConfiguration</strong></li></ul><p>后台会话配置，需要指定一个标识符。它允许在后台执行数据的上传或下载任务，使用这个配置时session会将数据的传输控制权交给系统，系统会在一个单独的进程中处理这个任务，即使应用被挂起甚至被杀掉时，仍能继续数据的上传或下载。注意这里的被杀掉是指被系统杀掉，如果是用户通过多任务界面主动杀掉了应用，则系统会自动清空当前session的所有后台传输任务，任务会暂停。用户需要主动重启应用，之前的任务才能继续。如果应用是被系统杀掉并重启的，那么应用内可以使用与之前后台会话配置中相同的<code>identifier</code>标识符重新创建配置和URLSession对象，此session对象可以返回后台任务被杀掉时所处的状态。关于后台任务的具体实现，后面章节中会详细介绍~</p><p>2、可配置属性</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/* identifier for the background session configuration */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *identifier; <span class="hljs-comment">// 后台任务的标识符</span><br><br><span class="hljs-comment">/* default cache policy for requests */</span><br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">NSURLRequestCachePolicy</span> requestCachePolicy; <span class="hljs-comment">// 请求的缓存策略</span><br><br><span class="hljs-comment">/* default timeout for requests.  This will cause a timeout if no data is transmitted </span><br><span class="hljs-comment"> *for the given timeout value, and is reset whenever data is transmitted. */</span><br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">NSTimeInterval</span> timeoutIntervalForRequest; <span class="hljs-comment">// 超时时长</span><br><br><span class="hljs-comment">/* allow request to route over cellular. */</span><br><span class="hljs-keyword">@property</span> <span class="hljs-type">BOOL</span> allowsCellularAccess; <span class="hljs-comment">// 是否允许蜂窝网路</span><br><br><span class="hljs-comment">/* allows background tasks to be scheduled at the discretion of the system for optimal performance. */</span><br><span class="hljs-comment">// 数据量大时，让系统自主优化后台任务（比如连上WiFi再开始传输）</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">getter</span>=isDiscretionary) <span class="hljs-type">BOOL</span> discretionary; <br><br><span class="hljs-comment">/* The maximum number of simultanous persistent connections per host */</span><br><span class="hljs-keyword">@property</span> <span class="hljs-built_in">NSInteger</span> HTTPMaximumConnectionsPerHost; <span class="hljs-comment">// 单个主机允许的最大同时并发连接数</span><br><br><span class="hljs-comment">/* The cookie storage object to use, or nil to indicate that no cookies should be handled */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">retain</span>) <span class="hljs-built_in">NSHTTPCookieStorage</span> *HTTPCookieStorage;<br><br><span class="hljs-comment">/* The credential storage object, or nil to indicate that no credential storage is to be used */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">retain</span>) <span class="hljs-built_in">NSURLCredentialStorage</span> *URLCredentialStorage;<br><br><span class="hljs-comment">/* The URL resource cache, or nil to indicate that no caching is to be performed */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">retain</span>) <span class="hljs-built_in">NSURLCache</span> *URLCache;<br></code></pre></td></tr></table></figure><h4 id="3-2-创建会话"><a href="#3-2-创建会话" class="headerlink" title="3.2.创建会话"></a>3.2.创建会话</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="hljs-built_in">NSURLSessionConfiguration</span> *)configuration;<br>+ (<span class="hljs-built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="hljs-built_in">NSURLSessionConfiguration</span> *)configuration <br>                                  delegate:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span> &lt;<span class="hljs-built_in">NSURLSessionDelegate</span>&gt;)delegate <br>                             delegateQueue:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSOperationQueue</span> *)queue;<br></code></pre></td></tr></table></figure><ul><li><strong>参数1</strong>：configuration</li></ul><p>配置信息，包括cookie、缓存策略、代理、超时、证书配置等；</p><ul><li><strong>参数2</strong>：delegate</li></ul><p>会话的代理对象，处理鉴权、缓存策略等事宜，在AFN中是AFURLSessionManager类；</p><blockquote><p>The session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you do not invalidate the session by calling the invalidateAndCancel or finishTasksAndInvalidate method, your app leaks memory until it exits.</p></blockquote><p>注意：session会强引用 delegate 对象直到通过<code>invalidateAndCancel</code>或<code>finishTasksAndInvalidate</code>将session置为无效，如果不将session作废就会造成内存泄露。</p><ul><li><strong>参数3</strong>：queue</li></ul><p>代理所处的队列，可以是主队列或我们创建的私有队列。</p><blockquote><p>An operation queue for scheduling the delegate calls and completion handlers. The queue should be a serial queue, in order to ensure the correct ordering of callbacks. If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.</p></blockquote><p>注意：queue参数必须是串行队列，这是为了保证回调的顺序。如果为nil则session会自动创建一个串行队列执行代理。</p><h4 id="3-3-创建任务"><a href="#3-3-创建任务" class="headerlink" title="3.3.创建任务"></a>3.3.创建任务</h4><p>URLSession提供了数据下载和上传相关的API，通过不同接口可以创建不同类型的任务：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 普通任务，返回的数据保存在内存中，不支持后台任务</span><br>- (<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTaskWithURL:(<span class="hljs-built_in">NSURL</span> *)url;<br><br><span class="hljs-comment">// 上传任务，支持后台上传</span><br>- (<span class="hljs-built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request fromData:(<span class="hljs-built_in">NSData</span> *)bodyData;<br><br><span class="hljs-comment">// 下载任务，保存到本地文件中，支持后台下载</span><br>- (<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithURL:(<span class="hljs-built_in">NSURL</span> *)url;<br><br><span class="hljs-comment">// 数据流任务，从指定的服务器和端口建立一个 TCP/IP 连接</span><br>- (<span class="hljs-built_in">NSURLSessionStreamTask</span> *)streamTaskWithHostName:(<span class="hljs-built_in">NSString</span> *)hostname port:(<span class="hljs-built_in">NSInteger</span>)port;<br></code></pre></td></tr></table></figure><p>每个NSURLSession对象可以包含多个任务，类似于浏览器中多个窗口可以分别处理网页浏览和数据下载等任务。</p><h4 id="3-4-会话作废"><a href="#3-4-会话作废" class="headerlink" title="3.4.会话作废"></a>3.4.会话作废</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">/* -finishTasksAndInvalidate returns immediately <span class="hljs-built_in">and</span> existing tasks will be allowed<br> * <span class="hljs-keyword">to</span> run <span class="hljs-keyword">to</span> completion.  <span class="hljs-built_in">New</span> tasks may <span class="hljs-built_in">not</span> be created.  The session<br> * will <span class="hljs-keyword">continue</span> <span class="hljs-keyword">to</span> make <span class="hljs-keyword">delegate</span> callbacks <span class="hljs-keyword">until</span> URLSession:didBecomeInvalidWithError:<br> * has been issued. <br> *<br> * -finishTasksAndInvalidate <span class="hljs-built_in">and</span> -invalidateAndCancel <span class="hljs-keyword">do</span> <span class="hljs-built_in">not</span><br> * have any effect <span class="hljs-keyword">on</span> the <span class="hljs-keyword">shared</span> session singleton.<br> *<br> * <span class="hljs-keyword">When</span> invalidating a background session, it <span class="hljs-built_in">is</span> <span class="hljs-built_in">not</span> safe <span class="hljs-keyword">to</span> create another background<br> * session <span class="hljs-keyword">with</span> the same identifier <span class="hljs-keyword">until</span> URLSession:didBecomeInvalidWithError: has<br> * been issued.<br> */<br>- (void)finishTasksAndInvalidate;<br></code></pre></td></tr></table></figure><p>作用：将session作废，但允许未完成的task继续执行完。</p><p>此方法不会等待任务完成而立刻返回，URLSession会话对象调用此方法后将不能再重用，也不再接收新的task，已存在或在执行的task则会继续执行直到全部完成。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/* -invalidateAndCancel acts as -finishTasksAndInvalidate, but issues</span><br><span class="hljs-comment"> * -cancel to all outstanding tasks for this session.  Note task </span><br><span class="hljs-comment"> * cancellation is subject to the state of the task, and some tasks may</span><br><span class="hljs-comment"> * have already have completed at the time they are sent -cancel. </span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-keyword">void</span>)invalidateAndCancel;<br></code></pre></td></tr></table></figure><p>作用：将未完成的task取消，同时将session作废。</p><p>与第一个方法的区别在于，本方法会取消未完成的任务。注意，二者对于<code>NSURLSession.sharedSession</code>会话无效。</p><h4 id="3-5-会话协议"><a href="#3-5-会话协议" class="headerlink" title="3.5.会话协议"></a>3.5.会话协议</h4><p>NSURLSessionDelegate，用来处理session-level事件的协议，比如 session 生命周期的变化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NSURLSessionDelegate</span> &lt;<span class="hljs-title">NSObject</span>&gt;</span><br><span class="hljs-keyword">@optional</span><br><br><span class="hljs-comment">/* The last message a session receives.  A session will only become</span><br><span class="hljs-comment"> * invalid because of a systemic error or when it has been</span><br><span class="hljs-comment"> * explicitly invalidated, in which case the error parameter will be nil.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session didBecomeInvalidWithError:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSError</span> *)error;<br><br><span class="hljs-comment">/* If implemented, when a connection level authentication challenge</span><br><span class="hljs-comment"> * has occurred, this delegate will be given the opportunity to</span><br><span class="hljs-comment"> * provide authentication credentials to the underlying</span><br><span class="hljs-comment"> * connection. Some types of authentication will apply to more than</span><br><span class="hljs-comment"> * one request on a given connection to a server (SSL Server Trust</span><br><span class="hljs-comment"> * challenges).  If this delegate message is not implemented, the </span><br><span class="hljs-comment"> * behavior will be to use the default handling, which may involve user</span><br><span class="hljs-comment"> * interaction. </span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge<br>completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <br><span class="hljs-built_in">NSURLCredential</span> *credential))completionHandler;<br><br><span class="hljs-comment">/* If an application has received an</span><br><span class="hljs-comment"> * -application:handleEventsForBackgroundURLSession:completionHandler:</span><br><span class="hljs-comment"> * message, the session delegate will receive this message to indicate</span><br><span class="hljs-comment"> * that all messages previously enqueued for this session have been</span><br><span class="hljs-comment"> * delivered.  At this time it is safe to invoke the previously stored</span><br><span class="hljs-comment"> * completion handler, or to begin any internal updates that will</span><br><span class="hljs-comment"> * result in invoking the completion handler.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 后台任务完成时 触发此回调</span><br>- (<span class="hljs-type">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="hljs-built_in">NSURLSession</span> *)session;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="3-6-Task"><a href="#3-6-Task" class="headerlink" title="3.6.Task"></a>3.6.Task</h4><p>数据请求可抽象为任务，即NSURLSessionTask，这是网络任务的基类，一般不直接使用此类，创建数据任务可使用其子类：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSObject</span><br>└── <span class="hljs-built_in">NSURLSessionTask</span><br>    ├── <span class="hljs-built_in">NSURLSessionDataTask</span><br>    │   └── <span class="hljs-built_in">NSURLSessionUploadTask</span><br>    ├── <span class="hljs-built_in">NSURLSessionDownloadTask</span><br>    └── <span class="hljs-built_in">NSURLSessionStreamTask</span><br></code></pre></td></tr></table></figure><p>每个类的具体作用下面章节中会继续介绍~此基类提供了任务状态和进度相关的属性，以及开始、暂停、取消等接口：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">NSURLSessionTask </span>: NSObject &lt;NSCopying, NSProgressReporting&gt;<br><br><span class="hljs-variable">@property</span> (readonly)                 NSUInteger    taskIdentifier;    <span class="hljs-comment">/* an identifier for this task, assigned by and unique to the owning session */</span><br><span class="hljs-variable">@property</span> (nullable, readonly, copy) NSURLRequest  *originalRequest;  <span class="hljs-comment">/* may be nil if this is a stream task */</span><br><span class="hljs-variable">@property</span> (nullable, readonly, copy) NSURLRequest  *currentRequest;   <span class="hljs-comment">/* may differ from originalRequest due to http server redirection */</span><br><span class="hljs-variable">@property</span> (nullable, readonly, copy) NSURLResponse *response;         <span class="hljs-comment">/* may be nil if no response has been received */</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * NSProgress object which represents the task progress.</span><br><span class="hljs-comment"> * It can be used for task progress tracking.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@property</span> (readonly, strong) NSProgress *progress <span class="hljs-built_in">API_AVAILABLE</span>(<span class="hljs-built_in">macos</span>(<span class="hljs-number">10.13</span>), <span class="hljs-built_in">ios</span>(<span class="hljs-number">11.0</span>), <span class="hljs-built_in">watchos</span>(<span class="hljs-number">4.0</span>), <span class="hljs-built_in">tvos</span>(<span class="hljs-number">11.0</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Start the network load for this task no earlier than the specified date. If</span><br><span class="hljs-comment"> * not specified, no start delay is used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Only applies to tasks created from background NSURLSession instances; has no</span><br><span class="hljs-comment"> * effect for tasks created from other session types.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@property</span> (nullable, copy) NSDate *earliestBeginDate <span class="hljs-built_in">API_AVAILABLE</span>(<span class="hljs-built_in">macos</span>(<span class="hljs-number">10.13</span>), <span class="hljs-built_in">ios</span>(<span class="hljs-number">11.0</span>), <span class="hljs-built_in">watchos</span>(<span class="hljs-number">4.0</span>), <span class="hljs-built_in">tvos</span>(<span class="hljs-number">11.0</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The number of bytes that the client expects (a best-guess upper-bound) will</span><br><span class="hljs-comment"> * be sent and received by this task. These values are used by system scheduling</span><br><span class="hljs-comment"> * policy. If unspecified, NSURLSessionTransferSizeUnknown is used.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@property</span> int64_t countOfBytesClientExpectsToSend <span class="hljs-built_in">API_AVAILABLE</span>(<span class="hljs-built_in">macos</span>(<span class="hljs-number">10.13</span>), <span class="hljs-built_in">ios</span>(<span class="hljs-number">11.0</span>), <span class="hljs-built_in">watchos</span>(<span class="hljs-number">4.0</span>), <span class="hljs-built_in">tvos</span>(<span class="hljs-number">11.0</span>));<br><span class="hljs-variable">@property</span> int64_t countOfBytesClientExpectsToReceive <span class="hljs-built_in">API_AVAILABLE</span>(<span class="hljs-built_in">macos</span>(<span class="hljs-number">10.13</span>), <span class="hljs-built_in">ios</span>(<span class="hljs-number">11.0</span>), <span class="hljs-built_in">watchos</span>(<span class="hljs-number">4.0</span>), <span class="hljs-built_in">tvos</span>(<span class="hljs-number">11.0</span>));<br><br><br><span class="hljs-comment">/* Byte count properties may be zero if no body is expected, </span><br><span class="hljs-comment"> * or NSURLSessionTransferSizeUnknown if it is not possible </span><br><span class="hljs-comment"> * to know how many bytes will be transferred.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* number of body bytes already received */</span><br><span class="hljs-variable">@property</span> (readonly) int64_t countOfBytesReceived;<br><br><span class="hljs-comment">/* number of body bytes already sent */</span><br><span class="hljs-variable">@property</span> (readonly) int64_t countOfBytesSent;<br><br><span class="hljs-comment">/* number of body bytes we expect to send, derived from the Content-Length of the HTTP request */</span><br><span class="hljs-variable">@property</span> (readonly) int64_t countOfBytesExpectedToSend;<br><br><span class="hljs-comment">/* number of byte bytes we expect to receive, usually derived from the Content-Length header of an HTTP response. */</span><br><span class="hljs-variable">@property</span> (readonly) int64_t countOfBytesExpectedToReceive;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The taskDescription property is available for the developer to</span><br><span class="hljs-comment"> * provide a descriptive label for the task.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@property</span> (nullable, copy) NSString *taskDescription;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The current state of the task within the session.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@property</span> (readonly) NSURLSessionTaskState state;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The error, if any, delivered via -URLSession:task:didCompleteWithError:</span><br><span class="hljs-comment"> * This property will be nil in the event that no error occured.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@property</span> (nullable, readonly, copy) NSError *error;<br><br><span class="hljs-comment">/* -cancel returns immediately, but marks a task as being canceled.</span><br><span class="hljs-comment"> * The task will signal -URLSession:task:didCompleteWithError: with an</span><br><span class="hljs-comment"> * error value of &#123; NSURLErrorDomain, NSURLErrorCancelled &#125;.  In some </span><br><span class="hljs-comment"> * cases, the task may signal other work before it acknowledges the </span><br><span class="hljs-comment"> * cancelation.  -cancel may be sent to a task that has been suspended.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">cancel</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Suspending a task will prevent the NSURLSession from continuing to</span><br><span class="hljs-comment"> * load data.  There may still be delegate calls made on behalf of</span><br><span class="hljs-comment"> * this task (for instance, to report data received while suspending)</span><br><span class="hljs-comment"> * but no further transmissions will be made on behalf of the task</span><br><span class="hljs-comment"> * until -resume is sent.  The timeout timer associated with the task</span><br><span class="hljs-comment"> * will be disabled while a task is suspended. -suspend and -resume are</span><br><span class="hljs-comment"> * nestable. </span><br><span class="hljs-comment"> */</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">suspend</span>;<br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">resume</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sets a scaling factor for the priority of the task. The scaling factor is a</span><br><span class="hljs-comment"> * value between 0.0 and 1.0 (inclusive), where 0.0 is considered the lowest</span><br><span class="hljs-comment"> * priority and 1.0 is considered the highest.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The priority is a hint and not a hard requirement of task performance. The</span><br><span class="hljs-comment"> * priority of a task may be changed using this API at any time, but not all</span><br><span class="hljs-comment"> * protocols support this; in these cases, the last priority that took effect</span><br><span class="hljs-comment"> * will be used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If no priority is specified, the task will operate with the default priority</span><br><span class="hljs-comment"> * as defined by the constant NSURLSessionTaskPriorityDefault. Two additional</span><br><span class="hljs-comment"> * priority levels are provided: NSURLSessionTaskPriorityLow and</span><br><span class="hljs-comment"> * NSURLSessionTaskPriorityHigh, but use is not restricted to these.</span><br><span class="hljs-comment"> */</span><br>@<span class="hljs-selector-tag">property</span> <span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">priority</span> <span class="hljs-selector-tag">API_AVAILABLE</span>(<span class="hljs-built_in">macos</span>(<span class="hljs-number">10.10</span>), <span class="hljs-built_in">ios</span>(<span class="hljs-number">8.0</span>), <span class="hljs-built_in">watchos</span>(<span class="hljs-number">2.0</span>), <span class="hljs-built_in">tvos</span>(<span class="hljs-number">9.0</span>));<br><br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure><ul><li>NSURLSessionTaskDelegate</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Messages related to the operation of a specific task.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NSURLSessionTaskDelegate</span> &lt;<span class="hljs-title">NSURLSessionDelegate</span>&gt;</span><br><span class="hljs-keyword">@optional</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sent when the system is ready to begin work for a task with a delayed start</span><br><span class="hljs-comment"> * time set (using the earliestBeginDate property). The completionHandler must</span><br><span class="hljs-comment"> * be invoked in order for loading to proceed. The disposition provided to the</span><br><span class="hljs-comment"> * completion handler continues the load with the original request provided to</span><br><span class="hljs-comment"> * the task, replaces the request with the specified task, or cancels the task.</span><br><span class="hljs-comment"> * If this delegate is not implemented, loading will proceed with the original</span><br><span class="hljs-comment"> * request.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Recommendation: only implement this delegate if tasks that have the</span><br><span class="hljs-comment"> * earliestBeginDate property set may become stale and require alteration prior</span><br><span class="hljs-comment"> * to starting the network load.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If a new request is specified, the allowsCellularAccess property from the</span><br><span class="hljs-comment"> * new request will not be used; the allowsCellularAccess property from the</span><br><span class="hljs-comment"> * original request will continue to be used.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Canceling the task is equivalent to calling the task&#x27;s cancel method; the</span><br><span class="hljs-comment"> * URLSession:task:didCompleteWithError: task delegate will be called with error</span><br><span class="hljs-comment"> * NSURLErrorCancelled.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>                        willBeginDelayedRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                              completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionDelayedRequestDisposition</span> disposition, <span class="hljs-built_in">NSURLRequest</span> * _Nullable newRequest))completionHandler<br>    API_AVAILABLE(macos(<span class="hljs-number">10.13</span>), ios(<span class="hljs-number">11.0</span>), watchos(<span class="hljs-number">4.0</span>), tvos(<span class="hljs-number">11.0</span>));<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sent when a task cannot start the network loading process because the current</span><br><span class="hljs-comment"> * network connectivity is not available or sufficient for the task&#x27;s request.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This delegate will be called at most one time per task, and is only called if</span><br><span class="hljs-comment"> * the waitsForConnectivity property in the NSURLSessionConfiguration has been</span><br><span class="hljs-comment"> * set to YES.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This delegate callback will never be called for background sessions, because</span><br><span class="hljs-comment"> * the waitForConnectivity property is ignored by those sessions.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session taskIsWaitingForConnectivity:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>    API_AVAILABLE(macos(<span class="hljs-number">10.13</span>), ios(<span class="hljs-number">11.0</span>), watchos(<span class="hljs-number">4.0</span>), tvos(<span class="hljs-number">11.0</span>));<br><br><span class="hljs-comment">/* An HTTP request is attempting to perform a redirection to a different</span><br><span class="hljs-comment"> * URL. You must invoke the completion routine to allow the</span><br><span class="hljs-comment"> * redirection, allow the redirection with a modified request, or</span><br><span class="hljs-comment"> * pass nil to the completionHandler to cause the body of the redirection </span><br><span class="hljs-comment"> * response to be delivered as the payload of this request. The default</span><br><span class="hljs-comment"> * is to follow redirections. </span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For tasks in background sessions, redirections will always be followed and this method will not be called.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>                     willPerformHTTPRedirection:(<span class="hljs-built_in">NSHTTPURLResponse</span> *)response<br>                                     newRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br>                              completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLRequest</span> * _Nullable))completionHandler;<br><br><span class="hljs-comment">/* The task has received a request specific authentication challenge.</span><br><span class="hljs-comment"> * If this delegate is not implemented, the session specific authentication challenge</span><br><span class="hljs-comment"> * will *NOT* be called and the behavior will be the same as using the default handling</span><br><span class="hljs-comment"> * disposition. </span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>                            didReceiveChallenge:(<span class="hljs-built_in">NSURLAuthenticationChallenge</span> *)challenge <br>                              completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="hljs-built_in">NSURLCredential</span> * _Nullable credential))completionHandler;<br><br><span class="hljs-comment">/* Sent if a task requires a new, unopened body stream.  This may be</span><br><span class="hljs-comment"> * necessary when authentication has failed for any request that</span><br><span class="hljs-comment"> * involves a body stream. </span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>                              needNewBodyStream:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSInputStream</span> * _Nullable bodyStream))completionHandler;<br><br><span class="hljs-comment">/* Sent periodically to notify the delegate of upload progress.  This</span><br><span class="hljs-comment"> * information is also available as properties of the task.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>                                didSendBodyData:(int64_t)bytesSent<br>                                 totalBytesSent:(int64_t)totalBytesSent<br>                       totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Sent when complete statistics information has been collected for the task.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task didFinishCollectingMetrics:(<span class="hljs-built_in">NSURLSessionTaskMetrics</span> *)metrics API_AVAILABLE(macosx(<span class="hljs-number">10.12</span>), ios(<span class="hljs-number">10.0</span>), watchos(<span class="hljs-number">3.0</span>), tvos(<span class="hljs-number">10.0</span>));<br><br><span class="hljs-comment">/* Sent as the last message related to a specific task.  Error may be</span><br><span class="hljs-comment"> * nil, which implies that no error occurred and this task is complete. </span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>                           didCompleteWithError:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSError</span> *)error;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="3-7-DataTask"><a href="#3-7-DataTask" class="headerlink" title="3.7.DataTask"></a>3.7.DataTask</h4><p>NSURLSessionDataTask，上传数据并接收返回的数据，返回的数据被保存到内存中。</p><p>#GET请求示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSURLSession</span> *session = [<span class="hljs-built_in">NSURLSession</span> sharedSession];<br><span class="hljs-built_in">NSURLSessionDataTask</span> *dataTask =[session dataTaskWithURL:<br>                                 [<span class="hljs-built_in">NSURL</span> URLWithString:url]<br>                                       completionHandler:^(<span class="hljs-built_in">NSData</span> *data,<br>                                                           <span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-built_in">NSError</span> *error)<br>&#123;<br>    <span class="hljs-comment">//data为服务器返回的数据</span><br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++文件大小：%lld&quot;</span>,response.expectedContentLength);<br>    &#125;<br>&#125;];<br><span class="hljs-comment">//启动任务</span><br>[dataTask resume];<br></code></pre></td></tr></table></figure><p>dataTask也可以胜任 downloadTask 和 uploadTask 的工作。区别在于dataTask 不支持后台下载。</p><p>例如，dataTask一般用来上传表单数据，比如将用户名、密码等信息以GET的方式追加到请求的RUL.query部分；当然也可以将数据以POST请求的方式追加到http.body中；这时 datatask 的功能有点类似 uploadTask。</p><p>而服务器收到datatask上传的信息后，会返回一个状态码和对应的json数据，这时 dataTask 的功能又有点像 downloadTask；</p><p>尽管dataTask可以做这些事，URLSession还是对请求进行了详细分类，提供了专门的类单独负责上传、下载及数据流任务。</p><ul><li>NSURLSessionDataDelegate</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Messages related to the operation of a task that delivers data</span><br><span class="hljs-comment"> * directly to the delegate.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NSURLSessionDataDelegate</span> &lt;<span class="hljs-title">NSURLSessionTaskDelegate</span>&gt;</span><br><span class="hljs-keyword">@optional</span><br><span class="hljs-comment">/* The task has received a response and no further messages will be</span><br><span class="hljs-comment"> * received until the completion block is called. The disposition</span><br><span class="hljs-comment"> * allows you to cancel a request or to turn a data task into a</span><br><span class="hljs-comment"> * download task. This delegate message is optional - if you do not</span><br><span class="hljs-comment"> * implement it, you can get the response as a property of the task.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This method will not be called for background upload tasks (which cannot be converted to download tasks).</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>                                 didReceiveResponse:(<span class="hljs-built_in">NSURLResponse</span> *)response<br>                                  completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler;<br><br><span class="hljs-comment">/* Notification that a data task has become a download task.  No</span><br><span class="hljs-comment"> * future messages will be sent to the data task.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>                              didBecomeDownloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Notification that a data task has become a bidirectional stream</span><br><span class="hljs-comment"> * task.  No future messages will be sent to the data task.  The newly</span><br><span class="hljs-comment"> * created streamTask will carry the original request and response as</span><br><span class="hljs-comment"> * properties.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * For requests that were pipelined, the stream object will only allow</span><br><span class="hljs-comment"> * reading, and the object will immediately issue a</span><br><span class="hljs-comment"> * -URLSession:writeClosedForStream:.  Pipelining can be disabled for</span><br><span class="hljs-comment"> * all requests in a session, or by the NSURLRequest</span><br><span class="hljs-comment"> * HTTPShouldUsePipelining property.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The underlying connection is no longer considered part of the HTTP</span><br><span class="hljs-comment"> * connection cache and won&#x27;t count against the total number of</span><br><span class="hljs-comment"> * connections per host.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>                                didBecomeStreamTask:(<span class="hljs-built_in">NSURLSessionStreamTask</span> *)streamTask;<br><br><span class="hljs-comment">/* Sent when data is available for the delegate to consume.  It is</span><br><span class="hljs-comment"> * assumed that the delegate will retain and not copy the data.  As</span><br><span class="hljs-comment"> * the data may be discontiguous, you should use </span><br><span class="hljs-comment"> * [NSData enumerateByteRangesUsingBlock:] to access it.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>                                     didReceiveData:(<span class="hljs-built_in">NSData</span> *)data;<br><br><span class="hljs-comment">/* Invoke the completion routine with a valid NSCachedURLResponse to</span><br><span class="hljs-comment"> * allow the resulting data to be cached, or pass nil to prevent</span><br><span class="hljs-comment"> * caching. Note that there is no guarantee that caching will be</span><br><span class="hljs-comment"> * attempted for a given resource, and you should not rely on this</span><br><span class="hljs-comment"> * message to receive the resource data.</span><br><span class="hljs-comment"> */</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session dataTask:(<span class="hljs-built_in">NSURLSessionDataTask</span> *)dataTask<br>                                  willCacheResponse:(<span class="hljs-built_in">NSCachedURLResponse</span> *)proposedResponse <br>                                  completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSCachedURLResponse</span> * _Nullable cachedResponse))completionHandler;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>如果既设置了<code>completionHandler</code>，又实现了<code>NSURLSessionTaskDelegate</code>或其子类的协议方法，则优先执行 block，代理方法不再执行。</p><h4 id="3-8-DownloadTask"><a href="#3-8-DownloadTask" class="headerlink" title="3.8.DownloadTask"></a>3.8.DownloadTask</h4><p>NSURLSessionDownloadTask，将数据下载并保存到文件中，且下载文件时不需要考虑边下载边写入沙盒的问题，苹果都帮我们做好了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSURLSession</span> *session = [<span class="hljs-built_in">NSURLSession</span> sharedSession];<br><span class="hljs-built_in">NSURLSessionDownloadTask</span> *dataTask = [session downloadTaskWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:url]<br>                                                completionHandler:^(<span class="hljs-built_in">NSURL</span> *location, <span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-built_in">NSError</span> *error) &#123;<br>                                                    <span class="hljs-keyword">if</span> (!error) &#123;<br>                                                        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++文件位置：%@ \n文件大小：%lld&quot;</span>,<br>                                                              location,response.expectedContentLength);<br>                                                        <br>                                                        <span class="hljs-built_in">NSString</span> *caches = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="hljs-built_in">NSCachesDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>) lastObject];<br>                                                        <span class="hljs-built_in">NSString</span> *filePath = [caches stringByAppendingPathComponent:<br>                                                                              response.suggestedFilename];<br>                                                        <span class="hljs-comment">//移动文件</span><br>                                                        [[<span class="hljs-built_in">NSFileManager</span> defaultManager] moveItemAtPath:location.path<br>                                                                                                toPath:filePath error:<span class="hljs-literal">nil</span>];<br>                                                    &#125;<br>                                                &#125;];<br><span class="hljs-comment">//开始任务</span><br>[dataTask resume];<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">++++文件位置：Users<span class="hljs-regexp">/xxx/</span>Library<span class="hljs-regexp">/Developer/</span>CoreSimulator/<br>Devices<span class="hljs-regexp">/2EDED966-0D34-4965-A946-F547BBCE33DA/</span>data/<br>Containers<span class="hljs-regexp">/Data/</span>Application/<span class="hljs-number">5</span>A2FAF81-<span class="hljs-number">62</span>D5-<span class="hljs-number">485</span>A-B059-<span class="hljs-number">22</span>AD6DECA518<br><span class="hljs-regexp">/tmp/</span>CFNetworkDownload_JVNOrU.tmp <br>文件大小：<span class="hljs-number">100626</span><br></code></pre></td></tr></table></figure><p>从回调的参数可以看到，并没有 NSData 字段传回来。回调中包括了一个 <code>location</code> 参数，它就是下载好的文件在沙盒中的地址。下载好的文件被放到<code>tmp</code>目录下。由于<code>tmp</code>目录下的文件随时可能被系统自动删除，我们在回调中把文件移动指定的目录下即可。</p><ul><li>NSURLSessionDownloadDelegate</li></ul><p>上面的示例中，NSURLSession 通过 block 的方式返回数据，这种方式有个不好的地方是无法监听下载进度。如果想要在接收数据过程中做进一步的处理，可以通过 <code>NSURLSessionDownloadDelegate</code> 协议来实现。(更新：iOS11后可以使用新增的 <code>NSProgress * progress</code> 属性来监听进度了)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)sendRequest<br>&#123;<br>    <span class="hljs-built_in">NSURLSessionConfiguration</span> *config = [<span class="hljs-built_in">NSURLSessionConfiguration</span><br>    defaultSessionConfiguration];<br>    <br>    config.timeoutIntervalForRequest = <span class="hljs-number">60</span>;<br>    config.allowsCellularAccess = <span class="hljs-literal">YES</span>;<br>    <br>    <span class="hljs-built_in">NSURLSession</span> *session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:config<br>    delegate:<span class="hljs-keyword">self</span> delegateQueue:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-built_in">NSURLSessionDownloadTask</span> *dataTask = [session downloadTaskWithURL:<br>    [<span class="hljs-built_in">NSURL</span> URLWithString:url]];<br>    <br>    <span class="hljs-comment">//开始任务</span><br>    [dataTask resume];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -NSURLSessionDownloadDelegate</span><br><br><span class="hljs-comment">//下载完成</span><br>-(<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>     downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask<br>didFinishDownloadingToURL:(<span class="hljs-built_in">NSURL</span> *)location<br>&#123;<br>&#125;<br><br><span class="hljs-comment">//每次写入沙盒完成后</span><br>-(<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>     downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask<br>     didWriteData:(int64_t)bytesWritten<br>totalBytesWritten:(int64_t)totalBytesWritten<br>totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++下载进度：%f&quot;</span>,(<span class="hljs-type">double</span>)totalBytesWritten/totalBytesExpectedToWrite);<br>&#125;<br><br><span class="hljs-comment">//恢复下载后</span><br>-(<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>     downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask<br>didResumeAtOffset:(int64_t)fileOffset<br>expectedTotalBytes:(int64_t)expectedTotalBytes<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-9-后台任务"><a href="#3-9-后台任务" class="headerlink" title="3.9.后台任务"></a>3.9.后台任务</h4><p>对于一些耗时或者优先级不高的数据传输任务，可以在后台创建一个任务进行传输。URLSession中支持后台传输，并且可以在应用进入后台或者被系统杀掉后，继续执行传输任务。</p><ul><li>创建后台会话、发起任务</li></ul><p>这里需要给Configuration指定一个标识符，方便后台任务完成后回调函数中继续使用此标识符处理任务。同时建议打开其中两个选项，以便系统对任务进行优化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//HelNetHelper.m</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;HelNetHelper.h&quot;</span></span><br><br><span class="hljs-built_in">NSString</span> * <span class="hljs-keyword">const</span> k_BackSessionID = <span class="hljs-string">@&quot;k_URLSession_001&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HelNetHelper</span></span><br><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance&#123;<br>    <span class="hljs-keyword">static</span> HelNetHelper *instance;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> token;<br>    _<span class="hljs-built_in">dispatch_once</span>(&amp;token, ^&#123;<br>        instance = [[HelNetHelper alloc] init];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br>- (<span class="hljs-built_in">NSURLSession</span> *)backgroundSession &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">NSURLSession</span> *session = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        <span class="hljs-comment">// 1.配置后台session，指定唯一标识符。</span><br>        <span class="hljs-built_in">NSURLSessionConfiguration</span>* config = [<span class="hljs-built_in">NSURLSessionConfiguration</span> backgroundSessionConfigurationWithIdentifier:k_BackSessionID];<br>        config.discretionary = <span class="hljs-literal">YES</span>; <span class="hljs-comment">//允许系统采取最优时机执行传输任务</span><br>        config.sessionSendsLaunchEvents = <span class="hljs-literal">YES</span>; <span class="hljs-comment">// 当session中有任务完成时允许应用恢复或启动</span><br>        <span class="hljs-comment">// 2.创建session 设置代理和代理所在队列</span><br>        session = [<span class="hljs-built_in">NSURLSession</span> sessionWithConfiguration:config delegate:<span class="hljs-keyword">self</span> delegateQueue:<span class="hljs-literal">nil</span>];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> session;<br>&#125;<br><br><span class="hljs-comment">// 发起后台下载任务</span><br>- (<span class="hljs-type">void</span>)startBackgroundTask&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++start session~&quot;</span>);<br>    <span class="hljs-built_in">NSURLSession</span> *session = [[HelNetHelper shareInstance] backgroundSession];<br>    <span class="hljs-built_in">NSURLSessionDownloadTask</span> * task = [session downloadTaskWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;https://dl.360safe.com/pclianmeng/n/1__6000322__00__7777772e68616f373339392e636f6d__079b.exe&quot;</span>]];<br>    [task resume];<br>&#125;<br><br><span class="hljs-comment">// 取消任务</span><br>- (<span class="hljs-type">void</span>)stop&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++task canceled~&quot;</span>);<br>    [[[HelNetHelper shareInstance] backgroundSession] invalidateAndCancel];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -URLSession Delegate</span><br><br><span class="hljs-comment">// session中所有task都已完成时 回调此方法</span><br>-  (<span class="hljs-type">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++thread on finishEvent:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-keyword">self</span>.completeBlock();<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// 文件下载完成</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>      downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask<br>didFinishDownloadingToURL:(<span class="hljs-built_in">NSURL</span> *)location&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++downloadtask finished, file in :%@~&quot;</span>,location.path);<br>    <span class="hljs-comment">//移动文件</span><br>    <span class="hljs-comment">//[[NSFileManager defaultManager] moveItemAtURL:location toURL:targetPath error:nil];</span><br>    <span class="hljs-comment">//删除文件</span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    [[<span class="hljs-built_in">NSFileManager</span> defaultManager] removeItemAtURL:location error:&amp;error];<br>&#125;<br><br><span class="hljs-comment">//下载进行中 跟踪进度</span><br>-(<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>     downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask<br>     didWriteData:(int64_t)bytesWritten<br>totalBytesWritten:(int64_t)totalBytesWritten<br>totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++下载进度：%f&quot;</span>,(<span class="hljs-type">double</span>)totalBytesWritten/totalBytesExpectedToWrite);<br>&#125;<br><br><span class="hljs-comment">// 下载成功或失败 都会回调此方法，只是失败时error不为空，可处理错误信息</span><br>- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>              task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didCompleteWithError:(<span class="hljs-keyword">nullable</span> <span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-keyword">if</span> (error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++download failed:%@&quot;</span>,error.description);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++download succeed~&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li>AppDelegate收到下载完成回调</li></ul><p>在AppDelegate.m中将回调中的<code>completionHandler</code>保存起来，以便后面继续使用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// AppDelegate.m</span><br><br>- (<span class="hljs-type">void</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>handleEventsForBackgroundURLSession:(<span class="hljs-built_in">NSString</span> *)identifier<br>  completionHandler:(<span class="hljs-type">void</span> (^)(<span class="hljs-type">void</span>))completionHandler<br>&#123;<br>    <span class="hljs-comment">// 使用与挂起前后台任务相同的标识符 重新创建session并设置代理，系统会自动将之前的任务与当前session关联起来</span><br>    [[HelNetHelper shareInstance] backgroundSession];<br>    <br>    [HelNetHelper shareInstance].completeBlock = completionHandler;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++handleEventsForBackgroundURLSession:%@~&quot;</span>,identifier);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>HelNetHelper中回调completeBlock</li></ul><p>上面AppDelegate收到回调后，系统会在 HelNetHelper 中回调 NSURLSessionDelegate 协议的以下方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//HelNetHelper.m</span><br><br><span class="hljs-comment">/* If an application has received an</span><br><span class="hljs-comment"> * -application:handleEventsForBackgroundURLSession:completionHandler:</span><br><span class="hljs-comment"> * message, the session delegate will receive this message to indicate</span><br><span class="hljs-comment"> * that all messages previously enqueued for this session have been</span><br><span class="hljs-comment"> * delivered.  At this time it is safe to invoke the previously stored</span><br><span class="hljs-comment"> * completion handler, or to begin any internal updates that will</span><br><span class="hljs-comment"> * result in invoking the completion handler.</span><br><span class="hljs-comment"> */</span><br>-  (<span class="hljs-type">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++thread on finishEvent:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-comment">// 当前回调可能在私有队列中 需要回到主线程</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-keyword">self</span>.completeBlock();<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>回调中我们调用之前保存起来的<code>completeBlock()</code>即可。</p><p>注意，我们创建session时<code>delegateQueue</code>参数传的是nil，所以任务的回调 NSURLSessionDelegate 会在一个私有串行队列中执行，苹果要求我们在执行<code>completeBlock()</code>回调时必须在主线程中。</p><blockquote><p>The URL session API itself is fully thread-safe. You can freely create sessions and tasks in any thread context. When your delegate methods call the provided completion handlers, the work is automatically scheduled on the correct delegate queue.</p></blockquote><blockquote><p>The system may call the URLSessionDidFinishEventsForBackgroundURLSession: session delegate method on a secondary thread. However, in iOS, your implementation of that method may need to call a completion handler provided to you in your application:handleEventsForBackgroundURLSession:completionHandler: app delegate method. You must call that completion handler on the main thread.</p></blockquote><ul><li>处理下载的文件</li></ul><p>当应用回调完<code>completeBlock()</code>后，下载任务就自动完成，随后回调：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session<br>      downloadTask:(<span class="hljs-built_in">NSURLSessionDownloadTask</span> *)downloadTask<br>didFinishDownloadingToURL:(<span class="hljs-built_in">NSURL</span> *)location<br>&#123;<br>    <span class="hljs-comment">//移动文件</span><br>    [[<span class="hljs-built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:targetPath error:<span class="hljs-literal">nil</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>将下载的文件从缓存目录中移到你指定的目录中即可。</p><ul><li>应用挂起时被系统杀掉情况下任务的恢复</li></ul><p>应用被挂起时有可能被系统杀掉，后台任务在单独的进程中继续执行，当任务完成时系统会自动在后台重启你的应用。应用启动阶段你可以使用与之前的后台任务相同的标识符重新创建URLSession会话，<code>系统会自动将原来的后台任务与你的新session关联起来</code>。这样不论应用是由用户启动还是由系统启动，后台任务都会继续回调各种事件。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">// 重用后台任务标识符 重建session 设置回调代理</span><br>    [[HelNetHelper shareInstance] backgroundSession];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试</li></ul><p>在ViewController中 点击按钮开始下载任务：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">- (IBAction)onClick:(id)sender &#123;<br>    <span class="hljs-selector-attr">[[HelNetHelper shareInstance]</span> backgroundTask];<br>&#125;<br></code></pre></td></tr></table></figure><p>在模拟器中调试，控制台会不断打印当前下载的进度。此时可先直接<code>command + .</code>停止模拟器并记住控制台中最后一条进度的数值；</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">start session~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">下载进度：0</span><span class="hljs-string">.</span><span class="hljs-comment">000021</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">下载进度：0</span><span class="hljs-string">.</span><span class="hljs-comment">000025</span><br><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">下载进度：0</span><span class="hljs-string">.</span><span class="hljs-comment">012226</span><br></code></pre></td></tr></table></figure><p>随后重新运行模拟器，可以看到日志继续打印，并且进度并不是从0开始，而是以比之前数值更大的进度继续进行。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">下载进度：0</span><span class="hljs-string">.</span><span class="hljs-comment">089701</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">下载进度：0</span><span class="hljs-string">.</span><span class="hljs-comment">089829</span><br><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br></code></pre></td></tr></table></figure><p>这说明虽然应用退出但是后台任务仍在单独的进程中运行，重新启动应用后任务继续并执行回调。</p><p>如果开始下载后，直接进入后台，直到文件下载完成，则完整的日志如下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs elixir">+++start session~<br>+++下载进度：<span class="hljs-number">0.000381</span><br>+++下载进度：<span class="hljs-number">0.000573</span><br>+++下载进度：<span class="hljs-number">0.000765</span><br>+++下载进度：<span class="hljs-number">0.001149</span><br>++++<span class="hljs-symbol">handleEventsForBackgroundURLSession:</span>k_URLSession_001~<br>+++downloadtask finished, file <span class="hljs-keyword">in</span> <span class="hljs-symbol">:/Users/xxx/Library/Developer/CoreSimulator/Devices/xxx/Library/Caches/com</span>.apple.nsurlsessiond/<span class="hljs-title class_">Downloads</span>/<span class="hljs-title class_">Helko</span>/<span class="hljs-title class_">CFNetworkDownload_MaGyNe</span>.tmp~<br>+++download succeed~<br>++++thread on <span class="hljs-symbol">finishEvent:</span>&lt;<span class="hljs-symbol">NSThread:</span> <span class="hljs-number">0x6000020a56c0</span>&gt;&#123;number = <span class="hljs-number">3</span>, name = (null)&#125;<br></code></pre></td></tr></table></figure><p>即任务会在后台自动进行，直到最终完成。任务完成后，自动调用AppDelegate和我们工具类中的URLSession各项回调。</p><ul><li>后台任务的限制条件</li></ul><p>后台session中的数据传输任务是<code>在一个单独的进程中执行</code>的，重启应用是比较昂贵的操作，所以后台session会有一些限制条件：</p><ol><li>后台session必须提供一个delegate处理事件；</li><li>只支持 HTTP 和 HTTPS 协议，不支持私有协议；</li><li>允许重定向且会直接执行，不会回调 URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:方法；</li><li>只支持上传和下载，不支持dataTask；且上传的文件必须在文件夹中，上传内存中的数据或者数据流在应用退出时会失败。</li></ol><h4 id="3-10-断点下载"><a href="#3-10-断点下载" class="headerlink" title="3.10.断点下载"></a>3.10.断点下载</h4><p>NSURLSessionDownloadTask 提供了断点下载的相关方法。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs wren">[<span class="hljs-variable">dataTask</span> <span class="hljs-variable">cancelByProducingResumeData</span>:<span class="hljs-title function_">^</span>(<span class="hljs-params">NSData</span> * _<span class="hljs-params">Nullable</span> <span class="hljs-params">resumeData</span>) &#123;<br>    <span class="hljs-variable">_mResumeData</span> <span class="hljs-operator">=</span> <span class="hljs-variable">resumeData</span>;<br>&#125;];<br></code></pre></td></tr></table></figure><p>此方法用来取消下载任务，取消下载后的回调中，参数 <code>resumeData</code> 包含了继续下载文件的位置信息。<code>resumeData</code> 只包含了url和已经下载了多少数据，不会很大，不用担心内存问题。</p><p>恢复下载时，可使用下面的方法：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">mDataTask</span> = [mURLSession downloadTaskWithResumeData:_mResumeData]<span class="hljs-comment">;</span><br><span class="hljs-section">[mDataTask resume]</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>另外，由于下载失败导致的下载中断会进入此协议方法，也可以得到用来恢复的数据：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)URLSession:(<span class="hljs-built_in">NSURLSession</span> *)session <br>task:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>didCompleteWithError:(<span class="hljs-built_in">NSError</span> *)error<br>&#123;<br>    <span class="hljs-comment">// 保存恢复数据</span><br>    _mResumeData = error.userInfo[<span class="hljs-built_in">NSURLSessionDownloadTaskResumeData</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>完结，撒花~</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络</title>
    <link href="/2017/12/20/http.html"/>
    <url>/2017/12/20/http.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-网络分层"><a href="#1-网络分层" class="headerlink" title="#1.网络分层"></a>#1.网络分层</h3><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h3 id="2-术语"><a href="#2-术语" class="headerlink" title="#2.术语"></a>#2.术语</h3><h4 id="2-1-TCP"><a href="#2-1-TCP" class="headerlink" title="2.1.TCP"></a>2.1.TCP</h4><ul><li>传输控制协议：传输层协议之一；</li><li>面向连接：传输数据前需要三次握手建立连接；</li><li>稳定可靠：传输数据时有响应、重发、拥堵控制机制；</li><li>时效性低：握手、响应、重发等机制会消耗大量时间，占用大量系统资源。</li></ul><p>主要用在需要可靠传输数据的地方，如文件传输协议：HTTP、HTTPS、FTP；邮件传输协议：POP、SMTP。</p><h4 id="2-2-UDP"><a href="#2-2-UDP" class="headerlink" title="2.2.UDP"></a>2.2.UDP</h4><ul><li>用户数据报协议：也是传输层协议之一；</li><li>无连接：传输数据前不需事先建立连接，直接向目标主机发送报文；</li><li>不可靠：不保证数据能收到或完整收到，只做报文完整性校验，不完整则丢弃；</li><li>速度快：没有TCP那么复杂的机制，简单高效速度快；</li></ul><p>主要用在追求通信速度但对通信质量要求不高的地方，如语音视频、游戏画面和语音。</p><h4 id="2-3-HTTP"><a href="#2-3-HTTP" class="headerlink" title="2.3.HTTP"></a>2.3.HTTP</h4><p>超文本传输协议，属于应用层协议，基于<code>TCP</code>协议和<code>请求/响应</code>模型，用于在web服务器与客户端浏览器之间封装和传输数据。客户端发送请求后需要服务器响应，请求结束后会主动释放连接，因此它属于短连接。</p><h4 id="2-4-SOCKET"><a href="#2-4-SOCKET" class="headerlink" title="2.4.SOCKET"></a>2.4.SOCKET</h4><p><code>SOCKET</code>位于<code>应用层</code>和<code>传输层</code>之间，不是协议而是对TCP&#x2F;IP协议的抽象与封装，隐藏了TCP与IP的所有细节，并对外提供接口以供 HTTP 开发者方便地使用TCP&#x2F;IP协议。</p><p>SOCKET 通信需要两个端：客户端和服务端。</p><ul><li>服务端：监听网络状态，等待来自客户端的连接；</li><li>客户端：指定 ip 与端口，向服务器请求连接；</li><li>服务器：响应客户端的连接请求，建立一个新线程，把服务端套接字的描述发给客户端，客户端确认此描述后双方正式建立连接。</li></ul><p>理论上 SOCKET 是一种长连接，即客户端与服务端的连接建立之后，一般不会主动断掉。如果长时间没有通信则防火墙可能会断开此连接以释放资源，所以一般 SOCKET 在没有数据传输时需要发送心跳包以保持连接。</p><h4 id="2-5-IP协议"><a href="#2-5-IP协议" class="headerlink" title="2.5.IP协议"></a>2.5.IP协议</h4><p>网络层协议，解决网络路由和寻址问题。</p><h4 id="2-6-TCP-x2F-IP"><a href="#2-6-TCP-x2F-IP" class="headerlink" title="2.6.TCP&#x2F;IP"></a>2.6.TCP&#x2F;IP</h4><p>传输控制协议&#x2F;网际协议，指的是一系列协议。</p><h3 id="3-三次握手"><a href="#3-三次握手" class="headerlink" title="#3.三次握手"></a>#3.三次握手</h3><p>TCP请求在发送数据之前，会先进行三次握手，以正式建立连接：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_tcp_connect.jpeg" alt="握手"></p><p><strong>第1次</strong>：<code>主机A</code> 发送<code>SYN包</code>到 <code>主机B</code>，并进入<code>SYN_SEND</code>状态，等待 <code>主机B</code> 确认；</p><p><strong>第2次</strong>：<code>主机B</code> 收到<code>SYN包</code>，必须确认 <code>主机A</code> 的<code>SYN</code>，同时自己也发送一个<code>SYN包</code>，即<code>SYN+ACK包</code>，此时 <code>主机B</code> 进入<code>SYN_RECV状态</code>；</p><p><strong>第3次</strong>：<code>主机A</code> 收到 <code>主机B</code> 的<code>SYN＋ACK</code>包，向 <code>主机B</code> 发送确认包<code>ACK</code>；</p><p>第三个包发送完毕后 <code>主机A</code> 和 <code>主机B</code> 进入<code>ESTABLISHED</code>状态，完成三次握手。</p><h3 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="#4.四次挥手"></a>#4.四次挥手</h3><p>TCP连接在断开时需要四个步骤：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_tcp_disconnect.jpeg" alt="挥手"></p><p><strong>第1次</strong>：<code>主机A</code> 发送完数据且知道 <code>主机B</code> 已接收完，想要关闭发送数据口，发 <code>FIN</code> 给 <code>主机B</code>；</p><p><strong>第2次</strong>：<code>主机B</code> 收到 <code>主机A</code> 发送的<code>FIN</code>，表示收到了，就会发送 <code>ACK</code> 回复；</p><p><strong>第3次</strong>：这时 <code>主机B</code> 可能还在发送数据，不想关闭数据口，在发完<code>ACK</code>后继续把数据发送完了再发送<code>FIN</code>给 <code>主机A</code>。</p><p><strong>第4次</strong>：<code>主机A</code> 收到 <code>主机B</code> 发来的<code>FIN</code>，知道 <code>主机B</code> 的数据也发送完了，回复ACK。<code>主机A</code> 等待 2MSL（2倍报文最长存活时间）后没有收到 <code>主机B</code> 传来的任何消息，知道 <code>主机B</code> 已经收到自己的ACK了，<code>主机A</code> 就关闭连接，<code>主机B</code> 也关闭连接。</p><p><strong>问：A为什么等待2MSL?</strong> </p><p>在<code>A</code>发送出最后的 ACK 回复后，该 ACK 可能丢失。<code>B</code>如果没有收到 ACK，将不断重发 FIN。所以<code>A</code>不能立即关闭，必须确认<code>B</code>收到了该 ACK。<code>A</code>会在发送出 ACK 后进入<code>TIME_WAIT</code>状态并设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到 FIN，那么<code>A</code>会重发 ACK 并再次等待 2MSL。如果直到 2MSL<code>A</code>都没有再次收到 FIN，那么<code>A</code>推断 <code>B</code>已经成功接收自己的 ACK，则结束 TCP 连接。</p><h3 id="5-无状态"><a href="#5-无状态" class="headerlink" title="#5.无状态"></a>#5.无状态</h3><p>HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</p><h3 id="6-短-x2F-长连接"><a href="#6-短-x2F-长连接" class="headerlink" title="#6.短&#x2F;长连接"></a>#6.短&#x2F;长连接</h3><p>HTTP 是应用层协议，基于 TCP 这一传输层协议。TCP 连接在 IP层上安全、面向连接地传递数据包。在HTTP&#x2F;1.0中，HTTP 默认使用的是短连接。浏览器和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。如果客户端浏览器访问的某个HTML页面中包含有其他的Web资源，如Js、图像、CSS文件等，那么浏览器每遇到一个Web资源就会建立一次会话。从 HTTP&#x2F;1.1 起，浏览器开始默认使用长连接，用以保持连接特性。使用长连接时会在响应头加入这行代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span><span class="hljs-meta">keep</span>-alive<br></code></pre></td></tr></table></figure><p>使用长连接时，当一个网页打开完成后，客户端和服务器之间的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接，现在各个浏览器的高版本基本都是支持长连接。</p><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><p>短连接：对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p><p>长连接：可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。但连接一直不关闭的话，会存在一个问题，随着客户端连接越来越多，服务端可能会扛不住。</p><h4 id="数据发送完成？"><a href="#数据发送完成？" class="headerlink" title="数据发送完成？"></a>数据发送完成？</h4><p>短连接模式下，服务器通常在发送回所请求的数据之后就关闭连接。这样客户端读数据时会返回<code>EOF(-1)</code>，就知道数据已经接收完全了。但是长连接模式发送完数据后服务器不会自动断开连接，所以不能再使用返回<code>EOF(-1)</code>来判断。</p><ul><li><strong>Conent-Length</strong></li></ul><p>客户端向服务器请求一个资源时，服务器可以很清楚的知道内容大小，它通过消息首部中的<code>Content-length</code>字段告诉客户端总共需要接收多少数据，客户端可以根据这个值和已接收的值来判断数据是否接收完成。</p><ul><li><strong>Transfer-Encoding</strong></li></ul><p>对于边产生数据边发给客户端的动态页面，服务器需使用<code>Transfer-Encoding:chunked</code>的方式来代替<code>Content-Length</code>。</p><p>chunk编码将数据分成一块一块的发送，以一个标明长度为0的chunk标示结束。每个chunk分为头部和正文两部分，头部内容指定正文的字符总数和数量单位，正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF)隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。</p><p>Chunk编码的格式如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Chunked-Body = *chunk<br><span class="hljs-string">&quot;0&quot;</span> <span class="hljs-literal">CRLF</span><br>footer<br><span class="hljs-literal">CRLF</span><br>chunk = chunk-size [ chunk-ext ] <span class="hljs-literal">CRLF</span><br>chunk-data <span class="hljs-literal">CRLF</span><br><br>hex-no-<span class="hljs-literal">zero</span> = &lt;HEX excluding <span class="hljs-string">&quot;0&quot;</span>&gt;<br><br>chunk-size = hex-no-<span class="hljs-literal">zero</span> *HEX<br>chunk-ext = *( <span class="hljs-string">&quot;;&quot;</span> chunk-ext-name [ <span class="hljs-string">&quot;=&quot;</span> chunk-ext-<span class="hljs-built_in">value</span> ] )<br>chunk-ext-name = <span class="hljs-keyword">token</span><br>chunk-ext-val = <span class="hljs-keyword">token</span> | quoted-<span class="hljs-keyword">string</span><br>chunk-data = chunk-size(OCTET)<br><br>footer = *entity-header<br></code></pre></td></tr></table></figure><p>消息长度的总结：</p><ol><li>为了兼容HTTP&#x2F;1.0应用程序，HTTP&#x2F;1.1的请求消息体中须包含<code>Content-Length</code>字段；</li><li><code>content-length</code>字段对应的值须和消息体里面的长度完全匹配；</li><li>同时存在<code>Transfer-Encoding</code>和<code>Content-Length</code>字段，忽略<code>Content-Length</code>字段；</li><li>如果采用短连接，则可以直接通过服务器关闭连接来确定消息的传输长度。</li></ol><h3 id="7-HTTP头部"><a href="#7-HTTP头部" class="headerlink" title="#7.HTTP头部"></a>#7.HTTP头部</h3><p>HTTP协议采用了<code>请求/响应模型</code>。客户端向服务器发送一个请求，请求头包含：请求的方法、URI、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括：消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。</p><p>通常HTTP消息包括客户端向服务器的请求消息和服务器向客户端的响应消息。这两种类型的消息由一个起始行，一个或者多个头域，一个只是头域结束的空行和可选的消息体组成。HTTP的头域包括通用头，请求头，响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</p><h4 id="请求消息头"><a href="#请求消息头" class="headerlink" title="请求消息头"></a>请求消息头</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Host</span>：rss.sina.com.cn<br><span class="hljs-attribute">User</span>-Agent：Mozilla/<span class="hljs-number">5</span>、<span class="hljs-number">0</span> (Windows; U; Windows NT <span class="hljs-number">5</span>、<span class="hljs-number">1</span>; zh-CN; <br><span class="hljs-attribute">rv</span>:<span class="hljs-number">1</span>、<span class="hljs-number">8</span>、<span class="hljs-number">1</span>、<span class="hljs-number">14</span>) Gecko/<span class="hljs-number">20080404</span> Firefox/<span class="hljs-number">2</span>、<span class="hljs-number">0</span>、<span class="hljs-number">0</span>、<span class="hljs-number">14</span><br><span class="hljs-attribute">Accept</span>：text/xml,application/xml,application/xhtml+xml,text/html;<br><span class="hljs-attribute">q</span>=<span class="hljs-number">0</span>、<span class="hljs-number">9</span>,text/plain;q=<span class="hljs-number">0</span>、<span class="hljs-number">8</span>,image/png,*/*;q=<span class="hljs-number">0</span>、<span class="hljs-number">5</span><br><span class="hljs-attribute">Accept</span>-Language：zh-cn,zh;q=<span class="hljs-number">0</span>、<span class="hljs-number">5</span><br><span class="hljs-attribute">Accept</span>-Encoding：gzip,deflate<br><span class="hljs-attribute">Accept</span>-Charset：gb2312,utf-<span class="hljs-number">8</span>;q=<span class="hljs-number">0</span>、<span class="hljs-number">7</span>,*;q=<span class="hljs-number">0</span>、<span class="hljs-number">7</span><br><span class="hljs-attribute">Keep</span>-Alive：<span class="hljs-number">300</span><br><span class="hljs-attribute">Connection</span>：keep-alive<br><span class="hljs-attribute">Cookie</span>：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &amp;lt;-- Cookie<br><span class="hljs-attribute">If</span>-Modified-Since：Sun, <span class="hljs-number">01</span> Jun <span class="hljs-number">2008</span> <span class="hljs-number">12</span>:<span class="hljs-number">05</span>:<span class="hljs-number">30</span> GMT<br><span class="hljs-attribute">Cache</span>-Control：max-age=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="响应消息头"><a href="#响应消息头" class="headerlink" title="响应消息头"></a>响应消息头</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Status：OK - <span class="hljs-number">200</span> &amp;lt;<span class="hljs-comment">-- 响应状态码，表示 web 服务器处理的结果。</span><br><span class="hljs-type">Date</span>：Sun, <span class="hljs-number">01</span> Jun <span class="hljs-number">2008</span> <span class="hljs-number">12</span>:<span class="hljs-number">35</span>:<span class="hljs-number">47</span> GMT<br><span class="hljs-keyword">Server</span>：Apache/<span class="hljs-number">2</span>、<span class="hljs-number">0</span>、<span class="hljs-number">61</span> (Unix)<br>Last-Modified：Sun, <span class="hljs-number">01</span> Jun <span class="hljs-number">2008</span> <span class="hljs-number">12</span>:<span class="hljs-number">35</span>:<span class="hljs-number">30</span> GMT<br>Accept-Ranges：bytes<br>Content-Length：<span class="hljs-number">18616</span><br><span class="hljs-keyword">Cache</span>-Control：max-age=<span class="hljs-number">120</span><br>Expires：Sun, <span class="hljs-number">01</span> Jun <span class="hljs-number">2008</span> <span class="hljs-number">12</span>:<span class="hljs-number">37</span>:<span class="hljs-number">47</span> GMT<br>Content-<span class="hljs-keyword">Type</span>：application/<span class="hljs-type">xml</span><br>Age：<span class="hljs-number">2</span><br>X-<span class="hljs-keyword">Cache</span>：HIT from <span class="hljs-number">236</span><span class="hljs-number">-41</span>、D07071951、sina、com、cn &amp;lt;<br><span class="hljs-comment">-- 反向代理服务器使用的 HTTP 头部</span><br>Via：<span class="hljs-number">1.0</span> <span class="hljs-number">236</span><span class="hljs-number">-41.</span>D07071951.sina.com.cn:<span class="hljs-number">80</span> (squid/<span class="hljs-number">2.6</span>.STABLE13)<br><span class="hljs-keyword">Connection</span>：<span class="hljs-keyword">close</span><br></code></pre></td></tr></table></figure><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>用于指定请求和响应的HTTP内容的类型。如果未指定默认为text&#x2F;html。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">类型格式：<span class="hljs-keyword">type</span>/<span class="hljs-keyword">subtype</span>(;<span class="hljs-keyword">parameter</span>)? <span class="hljs-keyword">type</span><br><span class="hljs-keyword">type</span>，主类型，任意的字符串，如<span class="hljs-literal">text</span>，*代表所有；<br><span class="hljs-keyword">subtype</span>，子类型，任意的字符串，如html，*代表所有；<br><span class="hljs-keyword">parameter</span>，可选，一些参数，如Accept请求头的q参数， Content-<span class="hljs-keyword">Type</span>的 charset参数。<br></code></pre></td></tr></table></figure><p>常见的媒体格式类型如下：</p><ul><li>text&#x2F;html ： HTML格式</li><li>text&#x2F;plain ：纯文本格式</li><li>text&#x2F;xml ：  XML格式</li><li>image&#x2F;gif ：gif图片格式</li><li>image&#x2F;jpeg ：jpg图片格式</li><li>image&#x2F;png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application&#x2F;xhtml+xml ：XHTML格式</li><li>application&#x2F;xml     ： XML数据格式</li><li>application&#x2F;atom+xml  ：Atom XML聚合格式</li><li>application&#x2F;json    ： JSON数据格式</li><li>application&#x2F;pdf       ：pdf格式</li><li>application&#x2F;msword  ： Word文档格式</li><li>application&#x2F;<font color=#0000FF><strong>x-www-form-urlencoded</strong></font> ：表单默认的提交数据的格式（表单键值对）</li><li>application&#x2F;<font color=#0000FF><strong>octet-stream</strong></font> ：上传二进制数据（只能提交一个文件）</li><li><font color=#0000FF><strong>multipart&#x2F;form-data</strong></font> ：既可以上传表单键值对，也可以上传二进制数据（可传多个文件）</li></ul><h3 id="8-GET-与-POST"><a href="#8-GET-与-POST" class="headerlink" title="#8.GET 与 POST"></a>#8.GET 与 POST</h3><p>Http定义了与服务器交互的不同方法，最基本的方法有4种：</p><ul><li>GET：查询资源的信息；</li><li>POST：向服务器提交数据，通常是以表单的形式；</li><li>PUT：向服务器写入文档；</li><li>DELETE：删除资源。</li></ul><p>最常用的是 GET 和 POST：</p><h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><ul><li>GET一般用于查询资源信息，POST一般用于提交数据、更新资源信息。</li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>GET 请求的数据会附在 URL 之后，以?分割 URL 和传输数据；</li><li>POST 请求的数据被放在 HTTP 包的 body 中；</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，不能用来传递敏感信息；</li><li>GET 请求的URL可以设置成书签，POST不可以；</li><li>GET 请求的参数会被完整的保留在浏览历史记录中，POST 请求不会；</li><li>GET 请求 URL 中的参数有长度限制，POST 没有；</li></ul><h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><ul><li>GET 请求只产生一个 TCP 数据包，浏览器会把 Header 和 data 一并发送出去，服务器响应200；</li><li>POST 请求产生两个 TCP 数据包，浏览器先发送 Header，服务器响应 100 continue；浏览器再发送data，服务器响应 200。</li></ul><p><strong>注：</strong> 从本质上来说，GET 与 POST 都是 Http 协议中发送请求的方法，底层都是基于 TCP 的链接。技术上来讲如果你想，你可以给 GET 请求加上 request body，也可以给 POST 请求的URL加上参数。但一般我们不会这样做，因为上面所说的这些都是 Http 协议已经约定俗成的规则。</p><h3 id="9-Http-与-Https"><a href="#9-Http-与-Https" class="headerlink" title="#9.Http 与 Https"></a>#9.Http 与 Https</h3><p>Http的缺点：</p><ul><li>通信不加密，使用明文，内容可能会被窃听；</li><li>不验证通信方的身份，有可能遭遇伪装；</li><li>无法证明报文的完整性，所以有可能已遭篡改；</li></ul><p>Http的优点：</p><ul><li>传输速度快</li></ul><p><code>Https</code>并非是应用层的一种新协议，它只是<code>Http</code>通信接口部分用<code>SSL</code>或<code>TLS</code>代替而已，即添加了加密及认证机制。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">Https</span> = Http + 加密 + 认证 + 完整性保护<br></code></pre></td></tr></table></figure><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><p>全称 Secure Socket Layer，即安全套接层，是网景公司开发的一种安全协议，用以为网络通信提供<code>安全</code>及<code>数据完整性</code>。当前版本为3.0，被广泛地用于Web浏览器与服务器之间的<code>身份认证</code>和<code>加密数据传输</code>。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><h4 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h4><p>全称 Transport Layer Security，即安全传输层协议，是 SSL 的继任者，它是 IETF 将 SSL 进行标准化的成果。从技术上讲，TLS 1.0与 SSL 3.0的差异非常微小，具体内容可参考 <a href="https://baike.baidu.com/item/TLS/2979545?fr=aladdin">这里</a>~</p><h4 id="密钥加密"><a href="#密钥加密" class="headerlink" title="密钥加密"></a>密钥加密</h4><p>密钥加密使用一对非对称的密钥：私钥和公钥。私钥不能让其他任何人知道，而公钥则可以随意发布，任何人都可以获得。使用公钥加密方式时，发送密文的一方使用对方的公钥进行加密处理，对方收到被加密的信息后，再使用自己的私钥进行解密。这种方式相对比较安全，因为不需要发送用来解密的私钥，也不必担心密钥被攻击者窃听而盗走。</p><h4 id="Https请求流程"><a href="#Https请求流程" class="headerlink" title="Https请求流程"></a>Https请求流程</h4><ol><li>DNS Lookup；</li><li>TCP Handshake；</li><li>TLS或SSL Handshake；</li><li>TCP&#x2F;HTTP Request&#x2F;Response；</li></ol><p>Https 在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行 SSL 握手，握手过程中将确立双方加密传输数据的密码信息，过程描述如下：</p><p>1.浏览器将自己支持的一套加密规则发送给服务端。</p><p>2.服务端从中选出一组加密算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址、加密公钥、证书颁发机构等信息。</p><p>3.获得服务端证书之后浏览器要做以下工作：</p><ul><li>验证证书的合法性（证书的颁发机构是否合法，网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示；</li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密；</li><li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给服务端；</li></ul><p>4.服务端接收浏览器发来的数据之后要做以下的操作：</p><ul><li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致；</li><li>使用密码加密一段握手消息，发送给浏览器；</li></ul><p>5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p><h3 id="10-网络优化"><a href="#10-网络优化" class="headerlink" title="#10.网络优化"></a>#10.网络优化</h3><h4 id="10-1-网络检测"><a href="#10-1-网络检测" class="headerlink" title="10.1.网络检测"></a>10.1.网络检测</h4><p>检测用户所处的网络环境，2G&#x2F;3G&#x2F;4G&#x2F;Wi-Fi以及当前网速，动态应对：</p><ol><li>动态调整网络请求的并发数</li></ol><p>网络差时将任务的并发数置为更小值，或者串行；注意并发数不宜过大或者过小，并发数过大在网络差时会造成更大的拥堵和整体延时；并发数过小在网络差时会造成急切请求等普通请求的情况。</p><p>控制并发数可以从两个层面入手，一个是在发起时控制请求的执行数量；一个是设置网络连接本身的最大并发数；</p><ul><li>控制任务请求的并发数</li></ul><p>基于信号量、NSOperation或者GCD，控制任务的并发数量，比如AFN早期版本中的<code>AFHTTPRequestOperation</code>；</p><ul><li>HTTPMaximumConnectionsPerHost</li></ul><blockquote><p>The maximum number of simultaneous connections to make to a given host.</p></blockquote><p>This property determines the maximum number of simultaneous connections made to each host by tasks within sessions based on this configuration. This limit is per session, so if you use multiple sessions, your app as a whole may exceed this limit. Additionally, depending on your connection to the Internet, a session may use a lower limit than the one you specify. The default value is 6 in macOS, or 4 in iOS.</p><p>这是NSURLSessionConfiguration的一个属性，表示同一个服务器同时接受的最大连接并发数，默认情况下iOS支持最多4个并发；每个session对应着一个设置，如果配置N个session则主机同时可接受的最大并发数可能会超过你给单个session设置的限制。</p><ol start="2"><li>动态设置超时时间</li></ol><p>网络差时，将请求的超时时间置为更短，节省后面请求的等待时间；</p><ol start="3"><li>减少数据传输量</li></ol><p>将待传输的数据进行分割，分批或者压缩再传输；同时配合<code>AFN</code>库中提供的 throttle 方法:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs applescript">/**<br> Throttles request bandwidth <span class="hljs-keyword">by</span> limiting <span class="hljs-keyword">the</span> packet size <br> <span class="hljs-keyword">and</span> adding a <span class="hljs-built_in">delay</span> <span class="hljs-keyword">for</span> each chunk <span class="hljs-built_in">read</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> upload stream.<br><br> When uploading <span class="hljs-keyword">over</span> a <span class="hljs-number">3</span>G <span class="hljs-keyword">or</span> EDGE connection, requests may fail <span class="hljs-keyword">with</span> <span class="hljs-string">&quot;request body stream exhausted&quot;</span>. <br> Setting a maximum packet size <span class="hljs-keyword">and</span> <span class="hljs-built_in">delay</span> according <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> recommended values (`kAFUploadStream3GSuggestedPacketSize` <br> <span class="hljs-keyword">and</span> `kAFUploadStream3GSuggestedDelay`) lowers <span class="hljs-keyword">the</span> risk <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> input stream exceeding <span class="hljs-keyword">its</span> allocated bandwidth. <br> Unfortunately, there <span class="hljs-keyword">is</span> no definite way <span class="hljs-keyword">to</span> distinguish <span class="hljs-keyword">between</span> a <span class="hljs-number">3</span>G, EDGE, <span class="hljs-keyword">or</span> LTE connection <span class="hljs-keyword">over</span> `NSURLConnection`. <br> As such, <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> recommended <span class="hljs-keyword">that</span> you throttle bandwidth based solely <span class="hljs-keyword">on</span> network reachability. <br> Instead, you should consider checking <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&quot;request body stream exhausted&quot;</span> <span class="hljs-keyword">in</span> a failure block, <br> <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> retrying <span class="hljs-keyword">the</span> request <span class="hljs-keyword">with</span> throttled bandwidth.<br><br> @param numberOfBytes Maximum packet size, <span class="hljs-keyword">in</span> <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> bytes. The default packet size <span class="hljs-keyword">for</span> an input stream <span class="hljs-keyword">is</span> <span class="hljs-number">16</span>kb.<br> @param <span class="hljs-built_in">delay</span> Duration <span class="hljs-keyword">of</span> <span class="hljs-built_in">delay</span> each <span class="hljs-built_in">time</span> a packet <span class="hljs-keyword">is</span> <span class="hljs-built_in">read</span>. By default, no <span class="hljs-built_in">delay</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span>.<br> */<br>- (void)throttleBandwidthWithPacketSize:(NSUInteger)numberOfBytes<br>                                  <span class="hljs-built_in">delay</span>:(NSTimeInterval)<span class="hljs-built_in">delay</span>;<br></code></pre></td></tr></table></figure><ol start="4"><li>提供重发机制</li></ol><p>遭遇请求失败或超时等错误时，可自动尝试指定次数的重发。</p><ol start="5"><li>使用HTTP缓存</li></ol><p>结合实际情况，合理设置<code>NSURLRequestCachePolicy</code>缓存策略。</p><h4 id="10-2-DNS解析"><a href="#10-2-DNS解析" class="headerlink" title="10.2.DNS解析"></a>10.2.DNS解析</h4><p>应用内置服务器的IP列表，该列表可以在应用启动服务中下发更新。</p><h4 id="10-3-HTTP版本"><a href="#10-3-HTTP版本" class="headerlink" title="10.3.HTTP版本"></a>10.3.HTTP版本</h4><p>使用HTTP1.1及以上版本，自动开启<code>Connection: Keep-Alive</code>，省去TCP频繁三次握手的时间；</p><p>最近看到一篇 <a href="http://www.php230.com/weixin1457310207.html">文章</a>，里面讲到了 HTTP 2.0，而且 iOS 9 开始已经支持 HTTP 2.0，只是目前主流的还是 HTTP 1.1；另外，最近在 Github 上看到微信有一个网络基础组件开源库 <a href="https://github.com/Tencent/mars">Mars</a>，这两个点后面抽时间再继续研究一下~</p><hr><p>相关参考：</p><p>#<a href="https://www.cnblogs.com/Yfling/p/6670495.html">©Yfling-HTTPS加密原理</a></p><p>#<a href="https://www.jianshu.com/p/1d468ec8162f">©软件iOS开发-iOS网络层详解和优化</a></p><p>#<a href="http://www.php230.com/weixin1457310207.html">©偷师饿了么:怎样用HTTP&#x2F;2优化iOS APP网络层次架构</a></p><p>#<a href="https://www.cnblogs.com/huhuuu/p/3572485.html">©网络TCP建立连接为什么需要三次握手而结束要四次</a></p><p>#<a href="http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml">©51cto-GET与POST的区别</a></p><p>#<a href="https://blog.csdn.net/weixin_41648325/article/details/79412158">©Socket和Http之间的区别和概述</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>沙盒 &amp; 本地持久化方案</title>
    <link href="/2017/12/05/sandbox.html"/>
    <url>/2017/12/05/sandbox.html</url>
    
    <content type="html"><![CDATA[<h3 id="1、沙盒"><a href="#1、沙盒" class="headerlink" title="1、沙盒"></a>1、沙盒</h3><blockquote><p>iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”。</p></blockquote><p>沙盒的目录结构：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&quot;应用程序包&quot;<br><span class="hljs-bullet">-</span> Documents<br><span class="hljs-bullet">-</span> Library<br>  <span class="hljs-emphasis">*Caches</span><br><span class="hljs-emphasis">  *</span>Preferences<br><span class="hljs-bullet">-</span> tmp<br></code></pre></td></tr></table></figure><h4 id="1-1-”应用程序包”"><a href="#1-1-”应用程序包”" class="headerlink" title="1.1.”应用程序包”:"></a>1.1.”应用程序包”:</h4><p>这里存放的是应用程序的源文件，包括资源文件和可执行文件。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">String *path = [[<span class="hljs-built_in">NSBundle</span> mainBundle] bundlePath];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, path);<br></code></pre></td></tr></table></figure><h4 id="1-2-Documents"><a href="#1-2-Documents" class="headerlink" title="1.2.Documents:"></a>1.2.Documents:</h4><p>最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *path = <span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<br><span class="hljs-built_in">NSDocumentDirectory</span>,<br><span class="hljs-built_in">NSUserDomainMask</span>,<br><span class="hljs-literal">YES</span>).firstObject;<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,path);<br></code></pre></td></tr></table></figure><h4 id="1-3-Library-x2F-Caches"><a href="#1-3-Library-x2F-Caches" class="headerlink" title="1.3.Library&#x2F;Caches:"></a>1.3.Library&#x2F;Caches:</h4><p>iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *path = <span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<br><span class="hljs-built_in">NSCachesDirectory</span>,<br><span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>).firstObject;<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>,path);<br></code></pre></td></tr></table></figure><h4 id="1-4-Library-x2F-Preferences"><a href="#1-4-Library-x2F-Preferences" class="headerlink" title="1.4.Library&#x2F;Preferences:"></a>1.4.Library&#x2F;Preferences:</h4><p>iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。</p><h4 id="1-5-tmp"><a href="#1-5-tmp" class="headerlink" title="1.5.tmp:"></a>1.5.tmp:</h4><p>iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *path = <span class="hljs-built_in">NSTemporaryDirectory</span>();<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, path);<br></code></pre></td></tr></table></figure><hr><h3 id="2、本地持久化方案"><a href="#2、本地持久化方案" class="headerlink" title="2、本地持久化方案"></a>2、本地持久化方案</h3><h4 id="2-1-plist文件"><a href="#2-1-plist文件" class="headerlink" title="2.1.plist文件"></a>2.1.plist文件</h4><p>通过XML文件的方式保存数据，支持保存的数据类型有：</p><ol><li>NSArray;</li><li>NSMutableArray;</li><li>NSDictionary;</li><li>NSMutableDictionary;</li><li>NSData;</li><li>NSMutableData;</li><li>NSString;</li><li>NSMutableString;</li><li>NSNumber;</li><li>NSDate;</li></ol><p>plist读写数据示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *path = <span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<br><span class="hljs-built_in">NSDocumentDirectory</span>,<span class="hljs-built_in">NSUserDomainMask</span>,<span class="hljs-literal">YES</span>).firstObject;<br><br><span class="hljs-built_in">NSString</span> *fileName = [path stringByAppendingPathComponent:<span class="hljs-string">@&quot;nameXX.plist&quot;</span>];<br><br><span class="hljs-built_in">NSArray</span> *array = @[<span class="hljs-string">@&quot;1&quot;</span>, <span class="hljs-string">@&quot;2&quot;</span>, <span class="hljs-string">@&quot;3&quot;</span>];<br>[array writeToFile:fileName atomically:<span class="hljs-literal">YES</span>];<br><br><span class="hljs-built_in">NSArray</span> *result = [<span class="hljs-built_in">NSArray</span> arrayWithContentsOfFile:fileName];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, result);<br></code></pre></td></tr></table></figure><h4 id="2-2-KeyChain-钥匙串"><a href="#2-2-KeyChain-钥匙串" class="headerlink" title="2.2.KeyChain 钥匙串"></a>2.2.KeyChain 钥匙串</h4><p>信息存储到钥匙串中之后，在应用删除重新安装时，仍然能取出之前保存的值。可以使用第三方库UICKeyChainStore实现钥匙串存储操作（<a href="https://github.com/kishikawakatsumi/UICKeyChainStore">Github地址</a>）。</p><h4 id="2-3-preference（偏好设置）"><a href="#2-3-preference（偏好设置）" class="headerlink" title="2.3.preference（偏好设置）"></a>2.3.preference（偏好设置）</h4><p>用来保存应用程序的配置信息的。如果需要立即写入文件的就必须调用synchronize方法，否则系统会根据I&#x2F;O情况不定时刻地保存到文件中。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span><span class="hljs-number">1</span>.获得NSUserDefaults文件<br>NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];<br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>.向文件中写入内容<br>[userDefaults setObject:@<span class="hljs-string">&quot;AAA&quot;</span> forKey:@<span class="hljs-string">&quot;a&quot;</span>];<br><span class="hljs-regexp">//</span><span class="hljs-number">2.1</span>立即同步<br>[userDefaults synchronize];<br><br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>.读取文件<br>NSString *name = [userDefaults objectForKey:@<span class="hljs-string">&quot;a&quot;</span>];<br>NSLog(@<span class="hljs-string">&quot;%@&quot;</span>, name);<br></code></pre></td></tr></table></figure><h4 id="2-4-NSKeyedArchiver（归档）"><a href="#2-4-NSKeyedArchiver（归档）" class="headerlink" title="2.4.NSKeyedArchiver（归档）"></a>2.4.NSKeyedArchiver（归档）</h4><p>归档，只要遵循了 NSCoding 协议的对象都可以通过它实现序列化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSCoding</span>&gt;</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> age;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><span class="hljs-comment">//解档</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithCoder:(<span class="hljs-built_in">NSCoder</span> *)aDecoder<br>&#123;<br><span class="hljs-keyword">if</span> ([<span class="hljs-variable language_">super</span> init]) &#123;<br><span class="hljs-keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="hljs-string">@&quot;name&quot;</span>];<br><span class="hljs-keyword">self</span>.age = [aDecoder decodeIntegerForKey:<span class="hljs-string">@&quot;age&quot;</span>];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><span class="hljs-comment">//归档</span><br>- (<span class="hljs-type">void</span>)encodeWithCoder:(<span class="hljs-built_in">NSCoder</span> *)aCoder<br>&#123;<br>[aCoder encodeObject:<span class="hljs-keyword">self</span>.name forKey:<span class="hljs-string">@&quot;name&quot;</span>];<br>[aCoder encodeInteger:<span class="hljs-keyword">self</span>.age forKey:<span class="hljs-string">@&quot;age&quot;</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>存取示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSString</span> *file = [<span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span>(<br><span class="hljs-built_in">NSDocumentDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>).firstObject<br>stringByAppendingPathComponent:<span class="hljs-string">@&quot;person.data&quot;</span>];<br><span class="hljs-comment">//存</span><br>Person *person = [[Person alloc] init];<br>person.name = <span class="hljs-string">@&quot;III&quot;</span>;<br>person.age = <span class="hljs-number">20</span>;<br>[<span class="hljs-built_in">NSKeyedArchiver</span> archiveRootObject:person toFile:file];<br><span class="hljs-comment">//取</span><br>Person *newPerson = [<span class="hljs-built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:file];<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++%@&quot;</span>,newPerson.name);<br></code></pre></td></tr></table></figure><p>如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法;</p><h4 id="2-5-CoreData"><a href="#2-5-CoreData" class="headerlink" title="2.5.CoreData"></a>2.5.CoreData</h4><p>未完待续。。</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库：Core Data</title>
    <link href="/2017/12/02/coredata.html"/>
    <url>/2017/12/02/coredata.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://davidlii.nos-eastchina1.126.net/pic_CoreData_outline.png" alt="CoreData大纲"></p><h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一.简介"></a>一.简介</h3><p>Core Data 是一个<code>对象-关系映射</code>持久化方案，处于应用与持久化存储之间，可以将应用中的对象转化成数据，保存在SQLite文件等持久化存储中，也可以缓存临时数据。在单台设备上 Core Data 支持回滚重做，在多台设备间使用同一 iCloud 账户同步数据时，Core Data 会自动将结构映射到 CloudKit 中。</p><p>在<code>.xcdatamodeld</code>数据模型中，可以定义数据类型与关系、生成对应的类定义。Core Data 会自动管理数据对象并提供以下功能：</p><ul><li>持久化</li></ul><p>抽象化映射对象到持久化存储中的细节，让保存数据更加简单，你甚至不用写数据库管理代码。</p><p>持久化存储包括四种：SQLite, Binary, XML, In-Memory，其中 XML 在 iOS 中不可用。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_persistence.png" alt="从持久化存储中存-取数据"></p><ul><li>回滚&amp;重做</li></ul><p>Core Data 的回滚管理器会跟踪数据变化，支持单独、批量或者全部回滚数据。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_Undo.png" alt="摇晃设备回滚数据功能"></p><ul><li>在后台处理任务</li></ul><p>支持在后台处理会堵塞UI线程的任务，例如将JSON解析成对象。稍后你可以将结果缓存或保存起来，节省与服务器的数据交互次数。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_backgroundTask.png" alt="更新UI前在后台处理数据"></p><ul><li>视图同步</li></ul><p>为<code>table</code>与<code>collection</code>视图提供数据源，帮助处理视图与数据的同步。</p><ul><li>版本与迁移</li></ul><p>给<code>.xcdatamodeld</code>文件设置版本，支持在model变化后将数据迁移到最新版本。</p><h3 id="二-Model-模型"><a href="#二-Model-模型" class="headerlink" title="二.Model-模型"></a>二.Model-模型</h3><p><code>.xcdatamodeld</code>文件用来定义应用中数据对象的结构，包括数据对象的类型、属性、关系。可通过<code>新建文件</code>→<code>Data Model</code>手动创建，其默认文件名为<code>Model.xcdatamodeld</code>。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_entity.jpeg" alt=".xcdatamodeld文件"></p><h3 id="三-Entity-实体"><a href="#三-Entity-实体" class="headerlink" title="三.Entity-实体"></a>三.Entity-实体</h3><p><code>.xcdatamodeld</code>&#x3D;<code>库</code>，<code>Entity</code>&#x3D;<code>表</code>，Entity 描述的是一个对象，包括它的名字、属性、关系。在<code>.xcdatamodeld</code>编辑器侧边栏中表示为<code>Entity</code>，可配置的字段包括：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_entity_conf.jpeg" alt="实体配置面板"></p><h4 id="1-Entity-Name"><a href="#1-Entity-Name" class="headerlink" title="1.Entity Name"></a>1.Entity Name</h4><p>model文件中实体的名字。</p><h4 id="2-Abstract-Entity"><a href="#2-Abstract-Entity" class="headerlink" title="2.Abstract Entity"></a>2.Abstract Entity</h4><p>若实体只作为父类使用而不会被直接实例化，可勾选此复选框。默认未勾选，即创建具体的实体。</p><h4 id="3-Parent-Entity"><a href="#3-Parent-Entity" class="headerlink" title="3.Parent Entity"></a>3.Parent Entity</h4><p>当有多个属性相似的实体时，可在一个父实体中定义通用属性，然后让子实体继承这些属性。</p><h4 id="4-Class-Name"><a href="#4-Class-Name" class="headerlink" title="4.Class Name"></a>4.Class Name</h4><p>以实体为基础创建托管对象实例时所指定的类名，默认与实体名相同。</p><h4 id="5-Codegen"><a href="#5-Codegen" class="headerlink" title="5.Codegen"></a>5.Codegen</h4><p>在<code>.xcdatamodeld</code>编辑界面定义好实体后，还需要生成对应的托管对象类和属性文件，以便在实际开发中创建和使用实体的实例。这些文件可以手动生成，也可以让 Core Data 帮我们自动生成。我们需要做的是为<code>Codegen</code>选项指定不同的值。以下是选项值与具体场景的对应关系：</p><table><thead><tr><th align="left"><center>选项</center></th><th align="left"><center>场景</center></th></tr></thead><tbody><tr><td align="left">Class Definition</td><td align="left">由Core Data自动生成托管对象类和属性文件，且我们不会主动修改这些文件。托管对象类和属性文件在编译时被放到编译目录，而不会出现在工程列表中；</td></tr><tr><td align="left">Category&#x2F;Extension</td><td align="left">由Core Data自动生成托管对象类和属性文件，同时我们可自己生成分类，添加自己的业务逻辑或方法，以便能完全控制托管对象类的实现。</td></tr><tr><td align="left">Manual&#x2F;None</td><td align="left">Core Data 不会帮我们生成任何文件，由你自己手动维护类和属性。通过编辑面板中设置的<code>class name</code>来定位和关联这些文件。</td></tr></tbody></table><h4 id="6-Renaming-ID"><a href="#6-Renaming-ID" class="headerlink" title="6.Renaming ID"></a>6.Renaming ID</h4><p>给实体重命名后，需要将新model中实体的<code>renaming identifier</code>设置成原model中实体的名字。</p><h3 id="四-Attribute-属性"><a href="#四-Attribute-属性" class="headerlink" title="四.Attribute-属性"></a>四.Attribute-属性</h3><p>配置属性时至少需要指定属性名、类型、是否必须保存到存储中、保存时是否必须有值。</p><p>对于一些属性，你还可以选择是否使用纯量类型、属性的默认值、指定数据校验规则。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_attr_conf.jpeg" alt="属性配置面板"></p><h4 id="1-Type"><a href="#1-Type" class="headerlink" title="1.Type"></a>1.Type</h4><p>属性的可用数据类型如下所示：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_att_types.jpeg" alt="数据类型"></p><p>其中<code>transformable</code>用于保存我们自定义的类、数组及图片等非常规数据类型。</p><h4 id="2-Optional"><a href="#2-Optional" class="headerlink" title="2.Optional"></a>2.Optional</h4><p>属性默认为<code>Optional</code>，即保存到持久化存储时，属性不要求必须有值。Core Data 不推荐使用这个选项，因为SQL中对<code>Null</code>的比较与OC中对<code>nil</code>的比较机制完全不一样，在数据库中<code>NULL ≠ 0</code>，且<code>NULL ≠ 空字符串</code>，所以用SQL搜索数字<code>0</code>的结果与搜索NULL的结果并不相同。</p><h4 id="3-Default-Value"><a href="#3-Default-Value" class="headerlink" title="3.Default Value"></a>3.Default Value</h4><p>属性默认值，初始化实体时，该属性会被自动赋上此默认值。可勾掉<code>Optional</code>选项搭配使用。</p><h4 id="4-Transient"><a href="#4-Transient" class="headerlink" title="4.Transient"></a>4.Transient</h4><p>默认情况下，属性会被保存到持久化存储中，但<code>Transient</code>属性不会。<code>短暂的</code>属性适用于临时保存一些值的场景。Core Data 不会跟踪这种属性的变化，所以也就没法做回滚这种操作。</p><h4 id="5-Validation"><a href="#5-Validation" class="headerlink" title="5.Validation"></a>5.Validation</h4><p>设置校验规则，例如给数值类型设置最大值最小值，或者给字符串类型设置正则表达式。</p><h4 id="6-Renaming-ID-1"><a href="#6-Renaming-ID-1" class="headerlink" title="6.Renaming ID"></a>6.Renaming ID</h4><p>给属性重命名后，需要将新model中属性的<code>renaming identifier</code>设置成原model中属性的名字。</p><h3 id="五-Relationship-关系"><a href="#五-Relationship-关系" class="headerlink" title="五.Relationship-关系"></a>五.Relationship-关系</h3><p>设置关系时需要指定其名字、目标实体、删除规则、对1或对N类型，并且配置反相的关系。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_relation.jpeg" alt="关系配置"></p><h4 id="1-Destination"><a href="#1-Destination" class="headerlink" title="1.Destination"></a>1.Destination</h4><p>目标实体，例如一个<code>课程</code>对应多个<code>老师</code>时，在<code>课程</code>实体中可设置关系的目标实体为名<code>老师</code>。</p><h4 id="2-Inverse"><a href="#2-Inverse" class="headerlink" title="2.Inverse"></a>2.Inverse</h4><p>设置关系的另一半，因为在面板中只能从一个方向定义关系，这个选项是让两个关系组合起来成为一个完整的双向关系。这样 Core Data 才能在实体发生变化时在双方间传递这种变化。</p><h4 id="3-Delete-Rule"><a href="#3-Delete-Rule" class="headerlink" title="3.Delete Rule"></a>3.Delete Rule</h4><p>当源实体被删除时，关系的目标实体如何响应。</p><table><thead><tr><th align="left"><center>选项</center></th><th align="left"><center>删除规则</center></th></tr></thead><tbody><tr><td align="left">No Action</td><td align="left">删除源实体时，目标实体中保留关系的引用，由你手动更新</td></tr><tr><td align="left">Nullify</td><td align="left">删除源实体时，目标实体中的关系引用自动置空</td></tr><tr><td align="left">Cascade</td><td align="left">删除源实体时，同时删除关系中的所有目标实体</td></tr><tr><td align="left">Deny</td><td align="left">只在关系未指向任何目标实体时才删除源实体</td></tr></tbody></table><ul><li>No Action</li></ul><p>无操作，删除A后其关联的B没任何操作，不会将B中关联属性(A)指向nil。删除A后使用B的关联属性(A)，可能会导致其他问题，所以一般不推荐使用此配置。</p><ul><li>Nullify</li></ul><p>翻译为作废，默认选项，当A对象被删除时，B中指向的对象A会被置空，B本身不受影响，所以删除A不会删除B。例如，删除一个部门时，把员工对应的部门字段置为nil。</p><ul><li>Cascade</li></ul><p>级联，当A对象被删除时，A对象包含的对象B也会被删除。一般用在 1-N 的关系中，1 的一方被删除，则 N 的一方随之被全部级联删除。相反，在 N-1 的关系中，则一般不能使用级联关系，删除多的一方时一定不能直接级联删除一的一方。例如，删除了部门以后，所有的员工对象都要被删除。</p><ul><li>Deny</li></ul><p>拒绝，删除当前对象时，如果当前对象还指向其他关联对象，则当前对象不能被删除。例如，删除部门时，如果还有一个员工，删除操作就会被拒绝。</p><h4 id="4-Cardinality-Type"><a href="#4-Cardinality-Type" class="headerlink" title="4.Cardinality Type"></a>4.Cardinality Type</h4><p>关系分为<code>对1</code>和<code>对多</code>两种类型。</p><h4 id="5-Renaming-ID"><a href="#5-Renaming-ID" class="headerlink" title="5.Renaming ID"></a>5.Renaming ID</h4><p>给关系重命名后，需要将新model中关系的<code>renaming identifier</code>设置成原model中关系的名字。</p><h3 id="六-Core-Data-Stack"><a href="#六-Core-Data-Stack" class="headerlink" title="六.Core Data Stack"></a>六.Core Data Stack</h3><p>创建数据模型文件后需要设置相关类以便真正操作数据对象，这些类被称为<code>Core Data Stack</code>。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_stack.jpeg" alt="Core Data Stack"></p><h4 id="1-MOM"><a href="#1-MOM" class="headerlink" title="1.MOM"></a>1.MOM</h4><p>ManagedObjectModel，托管对象模型，对应着Xcode中的<code>.xcdatamodeld</code>文件，保存在工程或 framework 里，通过<code>URL</code>加载。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSManagedObjectModel</span> *)managedObjectModel &#123;<br>    <span class="hljs-keyword">if</span> (_managedObjectModel != <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _managedObjectModel;<br>    &#125;<br>    <span class="hljs-built_in">NSURL</span> *modelURL = [[<span class="hljs-built_in">NSBundle</span> mainBundle] URLForResource:<span class="hljs-string">@&quot;Model&quot;</span> withExtension:<span class="hljs-string">@&quot;momd&quot;</span>];<br>    _managedObjectModel = [[<span class="hljs-built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelURL];<br>    <span class="hljs-keyword">return</span> _managedObjectModel;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MOM</code>中包含了一个或多个<code>NSEntityDescription</code>对象，维护着<code>Entity</code>与对应的<code>managed object</code>间的映射关系。<code>MOM</code>支持使用预定义的<code>Fetch request</code>，以返回符合条件的数据对象。可以在<code>.xcdatamodeld</code>编辑面板中定义 fetch request 模板，也可以通过代码创建。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">NSManagedObjectModel</span> *model = [CoreDataStack shareInstance].managedObjectModel;<br><span class="hljs-attribute">NSFetchRequest</span> *request = [model fetchRequestTemplateForName:@<span class="hljs-string">&quot;Fetch1&quot;</span>];<br><span class="hljs-attribute">NSError</span> *<span class="hljs-literal">error</span>;<br><span class="hljs-attribute">NSArray</span> *matchArr = [self.viewContext executeFetchRequest:request <span class="hljs-literal">error</span>:&amp;<span class="hljs-literal">error</span>];<br></code></pre></td></tr></table></figure><h4 id="2-MOC"><a href="#2-MOC" class="headerlink" title="2.MOC"></a>2.MOC</h4><p>ManagedObjectContext，托管对象上下文，在<code>managed object</code>的生命周期中扮演者重要角色。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSManagedObjectContext</span> *)managedObjectContext &#123;<br>    <span class="hljs-keyword">if</span> (_managedObjectContext != <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _managedObjectContext;<br>    &#125;<br>    <span class="hljs-built_in">NSPersistentStoreCoordinator</span> *coordinator = [<span class="hljs-keyword">self</span> persistentStoreCoordinator];<br>    <span class="hljs-keyword">if</span> (!coordinator) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    _managedObjectContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    [_managedObjectContext setPersistentStoreCoordinator:coordinator];<br>    <span class="hljs-keyword">return</span> _managedObjectContext;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>跟踪变化</li></ul><p>所有的托管对象都必须在MOC中，而 MOC 位于RAM中。通过 MOC 你可以从持久化存储中返回托管对象，并且 MOC 会负责跟踪它们的变化，例如对托管对象的增删改、校验、反向关系的处理、回滚&#x2F;重做等。这些变化会先保存在内存中关联的 MOC 中，直到执行 save 操作时，Core Data 才会将此变化同步到持久化存储中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1.从数据库中删除</span><br><span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [Course fetchRequest];<br>Course *indexedCourse = _mDatasourceArr[index];<br><span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,indexedCourse.id];<br>[fetchRequest setPredicate:predicate];<br>    <br><span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br><span class="hljs-built_in">NSArray</span> *fetchedObjects = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:fetchRequest error:&amp;error];<br><span class="hljs-keyword">for</span> (Course *c <span class="hljs-keyword">in</span> fetchedObjects) &#123;<br>    [<span class="hljs-keyword">self</span>.viewContext deleteObject:c]; <span class="hljs-comment">// 还在内存中</span><br>&#125;<br>[<span class="hljs-keyword">self</span> save]; <span class="hljs-comment">// 写入持久化存储中</span><br></code></pre></td></tr></table></figure><ul><li>为什么要有MOC这一层呢？</li></ul><p>我们的数据对象需要保存到持久化存储中，而持久化存储一般在磁盘中，读写速度相对较慢，不应频繁地访问。MOC位于 RAM 中，读写速度相对较快，它可以快速访问内存中的托管对象，跟踪托管对象的频繁变化，提供完整的回滚和重做支持。开发者只需定期通过 MOC 调用<code>save</code>方法，将这些托管对象真正写入磁盘中。</p><h4 id="3-PSC"><a href="#3-PSC" class="headerlink" title="3.PSC"></a>3.PSC</h4><p>NSPersistentStoreCoordinator，是MOC与应用持久化存储之间的桥梁。MOC需要通过PSC访问MOM，PSC将注册在其下面的持久化存储集中展示，便于MOC一次性操作，而非一个个去操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (<span class="hljs-type">NSPersistentStoreCoordinator</span> <span class="hljs-operator">*</span>)persistentStoreCoordinator &#123;<br>    <span class="hljs-keyword">if</span> (_persistentStoreCoordinator <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>    &#125;<br>    _persistentStoreCoordinator <span class="hljs-operator">=</span> [[<span class="hljs-type">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="hljs-keyword">self</span> managedObjectModel]];<br>    <span class="hljs-type">NSURL</span> <span class="hljs-operator">*</span>storeURL <span class="hljs-operator">=</span> [[<span class="hljs-keyword">self</span> applicationDocumentsDirectory] <span class="hljs-type">URLByAppendingPathComponent</span>:@<span class="hljs-string">&quot;ASDF.sqlite&quot;</span>];<br>    <span class="hljs-type">NSError</span> <span class="hljs-operator">*</span>error <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 数据库做轻量迁移时 传入此options字典</span><br>    <span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span>options <span class="hljs-operator">=</span> @&#123;<span class="hljs-type">NSMigratePersistentStoresAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>, <br>                              <span class="hljs-type">NSInferMappingModelAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>&#125;;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>[_persistentStoreCoordinator addPersistentStoreWithType:<span class="hljs-type">NSSQLiteStoreType</span> <br>                                                   configuration:<span class="hljs-literal">nil</span> <br>                                                             URL:storeURL <br>                                                         options:options error:<span class="hljs-operator">&amp;</span>error]) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>&#125;<br></code></pre></td></tr></table></figure><p>PSC在私有串行队列上执行任务，如果有需要你也可以使用多个PSC以便在不同的队列上执行任务。</p><p>使用PSC可以增加或删除某个持久化存储，更改存储的类型或位置，查询存储的元数据，定义存储的迁移，定义两个对象是否源自于同一个存储等等。</p><h4 id="4-NSPersistentContainer"><a href="#4-NSPersistentContainer" class="headerlink" title="4.NSPersistentContainer"></a>4.NSPersistentContainer</h4><p>这是 iOS10 之后新出的一个封装了MOC、MOM、PSC的容器，用来简化 Core Data stack 的初始化和管理工作。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSPersistentContainer</span> *)persistentContainer<br>&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_persistentContainer == <span class="hljs-literal">nil</span>) &#123;<br>            _persistentContainer = [[<span class="hljs-built_in">NSPersistentContainer</span> alloc] initWithName:<span class="hljs-string">@&quot;Model&quot;</span>]; <span class="hljs-comment">// 只需指定model文件名</span><br>            [_persistentContainer loadPersistentStoresWithCompletionHandler:^(<span class="hljs-built_in">NSPersistentStoreDescription</span> *storeDescription, <span class="hljs-built_in">NSError</span> *error) &#123;<br>                <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">nil</span>) &#123;<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;error %@, %@&quot;</span>, error, error.userInfo);<br>                &#125;<br>            &#125;];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> _persistentContainer;<br>&#125;<br></code></pre></td></tr></table></figure><p>它提供了我们常用的三个 Stack 属性，通过 persistentContainer 对象调用即可：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSManagedObjectContext</span> *viewContext;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSManagedObjectModel</span> *managedObjectModel;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">readonly</span>) <span class="hljs-built_in">NSPersistentStoreCoordinator</span> *persistentStoreCoordinator;<br></code></pre></td></tr></table></figure><h3 id="七-托管对象"><a href="#七-托管对象" class="headerlink" title="七.托管对象"></a>七.托管对象</h3><p>定义好MOM、初始化 Core Data Stack 之后，就可以为持久化存储创建、保存数据对象了。</p><h4 id="1-MO"><a href="#1-MO" class="headerlink" title="1.MO"></a>1.MO</h4><p>NSManagedObject，表示持久化存储中保存的数据对象，它是所有MO对象的基类，是<code>Entity</code>在代码层面真正对应的类。在<code>.xcdatamodeld</code>编辑界面中，选中<code>Course</code>这个<code>Entity</code>，打开右侧的属性面板，在<code>Entity</code>栏下有个<code>Name</code>字段，它是<code>Entity</code>在<code>.xcdatamodeld</code>文件中的名字；而下方有个<code>Class</code>栏，这些是与此<code>Entity</code>绑定的MO子类信息，其中<code>Name</code>字段就是对应的MO子类名，一般与<code>Entity</code>同名，即<code>Course</code>。当然，你也可以根据自己的规范定义成别的名字。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Course</span> : <span class="hljs-title">NSManagedObject</span></span><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>通常<code>Entity</code>属性面板中<code>codegen</code>字段设置为<code>Class Definition</code>时，Core Data 会自动为我们生成此类定义，只是这个类不会出现在代码列表中，我们可在代码中导入其头文件直接使用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 1.导入MO实体头文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;Course+CoreDataClass.h&quot;</span></span><br><br><span class="hljs-comment">// 2.创建 NSManagedObject 对象</span><br>Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>c.id = index;<br>c.name = <span class="hljs-string">@&quot;英语&quot;</span>; <span class="hljs-comment">// 给实体的属性赋值</span><br><span class="hljs-built_in">NSManagedObjectContext</span> *context = <span class="hljs-keyword">self</span>.persistentContainer.viewContext;<br><span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-comment">// 3.保存到持久化存储中</span><br><span class="hljs-keyword">if</span> ([context hasChanges] &amp;&amp; ![context save:&amp;error]) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-NSEntityDescription"><a href="#2-NSEntityDescription" class="headerlink" title="2.NSEntityDescription"></a>2.NSEntityDescription</h4><p>通过上面MO的示例可以看到，使用MO时需要两个元素的配合：<code>NSEntityDescription</code>与<code>MOC</code>。</p><p>其中<code>NSEntityDescription</code>是对模型文件中<code>Entity</code>的描述，包括名字、属性、关系，及代码层面此<code>Entity</code>代表的MO实体类。我们在<code>.xcdatamodeld</code>编辑面板中定义<code>Entity</code>，而 Core Data 使用<code>NSEntityDescription</code>来匹配持久化存储中的<code>Managed Object</code>。</p><p>后者是管理MO的上下文，顾名思义，就是用来跟踪MO及其关系的变化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-comment">// 设置描述</span><br><span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [[<span class="hljs-built_in">NSFetchRequest</span> alloc] init];<br><span class="hljs-built_in">NSEntityDescription</span> *desription = [<span class="hljs-built_in">NSEntityDescription</span> entityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>[fetchRequest setEntity:desription];<br>    <br>Course *indexedCourse = _mDatasourceArr[index];<br><span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,indexedCourse.id];<br>[fetchRequest setPredicate:predicate];<br><br><span class="hljs-comment">// 根据描述查询 Managed Object</span><br><span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br><span class="hljs-built_in">NSArray</span> *fetchedObjects = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:fetchRequest error:&amp;error];<br><span class="hljs-keyword">for</span> (Course *c <span class="hljs-keyword">in</span> fetchedObjects) &#123;<br>    <span class="hljs-comment">// 删除 Managed Object</span><br>    [<span class="hljs-keyword">self</span>.viewContext deleteObject:c];<br>&#125;<br>[<span class="hljs-keyword">self</span> save];<br></code></pre></td></tr></table></figure><h3 id="八-增删改查"><a href="#八-增删改查" class="headerlink" title="八.增删改查"></a>八.增删改查</h3><h4 id="1-查询"><a href="#1-查询" class="headerlink" title="1.查询"></a>1.查询</h4><h5 id="1-1-结果类型"><a href="#1-1-结果类型" class="headerlink" title="1.1.结果类型"></a>1.1.结果类型</h5><p>MOC需通过<code>NSFetchRequest</code>执行查询操作，查询结果以数组形式返回，默认情况下数组中返回的是托管对象<code>MO</code>。当然你也可以通过 fetch 的<code>resultType</code>属性将数组中的对象指定为其他类型。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSFetchRequestResultType</span> resultType;<br></code></pre></td></tr></table></figure><p>Core Data 支持四种返回类型：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_OPTIONS</span>(<span class="hljs-type">NSUInteger</span>, <span class="hljs-type">NSFetchRequestResultType</span>) &#123;<br>    <span class="hljs-type">NSManagedObjectResultType</span>      = 0x00,<br>    <span class="hljs-type">NSManagedObjectIDResultType</span>    = 0x01,<br>    <span class="hljs-type">NSDictionaryResultType</span>         = 0x02,<br>    <span class="hljs-type">NSCountResultType</span>              = 0x04<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>NSDictionaryResultType</code>，返回字典类型的对象；</li><li><code>NSCountResultType</code>，返回请求结果的count数值；</li><li><code>NSManagedObjectResultType</code>，默认值，查询结果数组中的元素为MO对象；</li><li><code>NSManagedObjectIDResultType</code>，查询结果数组中的元素为NSManagedObjectID 对象，即MO对象的ID。这种类型的内存占用比较小，MOC可以继续通过ID对象获取对应的MO。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-built_in">NSManagedObjectID</span> *moID = objectIDs[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">NSManagedObject</span> *obj = [managedObjectContext existingObjectWithID:moID error:&amp;error];<br></code></pre></td></tr></table></figure><h5 id="1-2-Fault对象"><a href="#1-2-Fault对象" class="headerlink" title="1.2.Fault对象"></a>1.2.Fault对象</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">BOOL</span> returnsObjectsAsFaults;<br></code></pre></td></tr></table></figure><p>这是 Fetch 请求的一个属性，默认值是YES，表示让查询结果返回<code>Fault</code>(惰值)状态的托管对象。<code>Fault</code>对象是托管对象的占位对象，作为查询结果被保存在 MOC 中，而 MOC 位于内存中。为了节省内存开销，<code>Fault</code>对象的属性值暂时不会填充到对应字段上，而是先保存在持久化存储的<code>row cache</code>(行缓存)中。当访问或修改这些属性值时，Core Data 才去持久化存储的<code>行缓存</code>中取出属性值并填充到<code>Fault</code>对象中，使其成为完全体的托管对象。</p><p>这种设计减少了内存消耗，却有一定的性能开销，如果你想在 fetch 结果返回后立即访问其中MO对象的属性，则应该将这个属性的值置为<code>NO</code>。</p><p>另外，这个属性只在返回类型为<code>ObjectResultType</code>时有效，对<code>ObjectIDResultType</code>无效, 因为 object IDs 没有属性值，设置此属性没有意义。</p><h5 id="1-3-过滤条件"><a href="#1-3-过滤条件" class="headerlink" title="1.3.过滤条件"></a>1.3.过滤条件</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSPredicate</span> *predicate;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left"><center>运算符</center></th><th align="left"><center> 作用 </center></th><th align="left"><center> 示例 </center></th></tr></thead><tbody><tr><td align="left">&gt; 、&lt; 、&#x3D;&#x3D; 、&gt;&#x3D; 、&lt;&#x3D; 、!&#x3D;</td><td align="left">比较运算</td><td align="left">age &gt; 18</td></tr><tr><td align="left">IN</td><td align="left">被包含</td><td align="left">name IN {‘张三’,’李四’}</td></tr><tr><td align="left">BETWEEN</td><td align="left">在区间内</td><td align="left">age BETWEEN {18,80}</td></tr><tr><td align="left">BEGINSWITH</td><td align="left">开头是</td><td align="left">name BEGINSWITH ‘张’</td></tr><tr><td align="left">ENDSWITH</td><td align="left">结尾是</td><td align="left">name ENDSWITH ‘四’</td></tr><tr><td align="left">CONTAINS</td><td align="left">包含有</td><td align="left">name CONTAINS ‘四’</td></tr><tr><td align="left">LIKE</td><td align="left">通配符 *和?</td><td align="left">name LIKE ‘*四’</td></tr><tr><td align="left">MATCHES</td><td align="left">正则</td><td align="left">name MATCHES ‘(regex)’</td></tr></tbody></table><h5 id="1-4-排序规则"><a href="#1-4-排序规则" class="headerlink" title="1.4.排序规则"></a>1.4.排序规则</h5><p>返回数据的排序规则，这是个数组，即支持多重排序，按数组中的前后顺序先后执行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSSortDescriptor</span> *&gt; *sortDescriptors;<br></code></pre></td></tr></table></figure><h5 id="1-5-分页查询"><a href="#1-5-分页查询" class="headerlink" title="1.5.分页查询"></a>1.5.分页查询</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 总共查询的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchLimit;<br><span class="hljs-comment">// 每次查询返回的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchBatchSize;<br><span class="hljs-comment">// 分页查询的下标，从哪条开始查</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchOffset;<br></code></pre></td></tr></table></figure><h5 id="1-6-案例演示"><a href="#1-6-案例演示" class="headerlink" title="1.6.案例演示"></a>1.6.案例演示</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)loadDataAtPage:(<span class="hljs-built_in">NSUInteger</span>)page&#123;<br>    <span class="hljs-comment">// 1.设置请求</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br>    <span class="hljs-comment">/*相当于上面的代码</span><br><span class="hljs-comment">    NSFetchRequest * request = [[NSFetchRequest alloc] init];</span><br><span class="hljs-comment">    NSEntityDescription *desription = [NSEntityDescription entityForName:@&quot;Course&quot; inManagedObjectContext:self.viewContext];</span><br><span class="hljs-comment">    [request setEntity:desription];</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// 2.排序</span><br>    <span class="hljs-built_in">NSSortDescriptor</span> *descriptor = [<span class="hljs-built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="hljs-string">@&quot;id&quot;</span> ascending:<span class="hljs-literal">YES</span>];<br>    request.sortDescriptors = @[descriptor];<br>    <br>    <span class="hljs-comment">// 3.分页</span><br>    request.fetchOffset = (page - <span class="hljs-number">1</span>) * kLimiteSize;<br>    request.fetchLimit = kLimiteSize;<br>    <br>    <span class="hljs-comment">// 4.查询</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-修改"><a href="#2-修改" class="headerlink" title="2.修改"></a>2.修改</h4><p>先查询MO对象，再逐一修改其属性，最后由MOC执行save，保存到持久化存储中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)updateDataAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index&#123;<br>    <span class="hljs-comment">// 1.创建fetch</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br>    <span class="hljs-comment">// 2.设置过滤条件</span><br>    <span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,index];<br>    [request setPredicate:predicate];<br>    <span class="hljs-built_in">NSSortDescriptor</span> *descriptor = [<span class="hljs-built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="hljs-string">@&quot;id&quot;</span> ascending:<span class="hljs-literal">YES</span>];<br>    request.sortDescriptors = @[descriptor]; <span class="hljs-comment">// 排序</span><br>    <span class="hljs-comment">// 3.执行fetch</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>    <span class="hljs-built_in">NSInteger</span> count = matchArr.count;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        Course *c = matchArr[i];<br>        <span class="hljs-comment">//4.修改托管对象</span><br>        c.name = [c.name stringByAppendingString:<span class="hljs-string">@&quot;X&quot;</span>]; <span class="hljs-comment">//managed object对象，更新到内存中</span><br>    &#125;<br>    <span class="hljs-comment">// 5.同步到数据库</span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.viewContext hasChanges] &amp;&amp; ![<span class="hljs-keyword">self</span>.viewContext save:&amp;error]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h4><p>插入数据，要用到以下这个<code>NSEntityDescription</code>的静态方法来执行数据的创建工作：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSManagedObject</span> *)insertNewObjectForEntityForName:(<span class="hljs-built_in">NSString</span> *)entityName<br>                              inManagedObjectContext:(<span class="hljs-built_in">NSManagedObjectContext</span> *)context;<br></code></pre></td></tr></table></figure><p>这里的<code>name</code>参数是模型文件中<code>Entity</code>的名字，Core Data 根据<code>Entity</code>的结构来创建MO对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-comment">// 往数据库中插入数据</span><br>- (<span class="hljs-type">void</span>)insertData&#123;<br>    <span class="hljs-comment">// 1.在内存中创建MO实例并设置各字段</span><br>    int32_t index = (int32_t)<span class="hljs-keyword">self</span>.mDatasourceArr.count;<br>    Student *s1 = [[Student alloc] init];<br>    s1.sID = <span class="hljs-number">101</span>;<br>    s1.name = <span class="hljs-string">@&quot;学生甲&quot;</span>;<br>    <br>    Student *s2 = [[Student alloc] init];<br>    s2.sID = <span class="hljs-number">102</span>;<br>    s2.name = <span class="hljs-string">@&quot;学生乙&quot;</span>;<br>    <br>    Teacher *t = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Teacher&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>    t.id = index;<br>    t.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;老师%d&quot;</span>,index];<br>    t.avator = [<span class="hljs-built_in">UIImage</span> imageNamed:<span class="hljs-string">@&quot;1&quot;</span>];<br>    t.descript = <span class="hljs-string">@&quot;省级优秀教师&quot;</span>;<br>    <br>    Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.viewContext];<br>    c.id = index;<br>    c.name = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;课程%d&quot;</span>,index];<br>    c.url = <span class="hljs-string">@&quot;https://www.baidu.com&quot;</span>;<br>    c.teachers = [<span class="hljs-built_in">NSSet</span> setWithObject:t]; <span class="hljs-comment">// 1-&gt;N，直接设置course对应的关系“teachers”字段</span><br>    c.students = [<span class="hljs-built_in">NSSet</span> setWithObjects:s1, s2, <span class="hljs-literal">nil</span>]; <span class="hljs-comment">// 数组，transformable类型，数组中的元素student需要实现NSCoding协议</span><br><br>    <span class="hljs-comment">// 2.通过MOC执行保存操作，写入数据库</span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.viewContext hasChanges] &amp;&amp; ![<span class="hljs-keyword">self</span>.viewContext save:&amp;error]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h4><p>先查询MO对象，再通过MOC执行delete，删除这些MO，最后执行save同步到存储中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)removeDataAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index&#123;<br>    <span class="hljs-comment">// 1.设置查询目标实体及条件</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [Course fetchRequest];<br>    <span class="hljs-comment">/*相当于上面的代码</span><br><span class="hljs-comment">     NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];</span><br><span class="hljs-comment">     NSEntityDescription *desription = [NSEntityDescription entityForName:@&quot;Course&quot; inManagedObjectContext:self.viewContext];</span><br><span class="hljs-comment">     [fetchRequest setEntity:desription];</span><br><span class="hljs-comment">     */</span><br>    Course *indexedCourse = _mDatasourceArr[index];<br>    <span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id = %d&quot;</span>,indexedCourse.id];<br>    [fetchRequest setPredicate:predicate];<br><br>    <span class="hljs-comment">// 2.从数据库中查询MO    </span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-built_in">NSArray</span> *fetchedObjects = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:fetchRequest error:&amp;error];<br>    <span class="hljs-keyword">for</span> (Course *c <span class="hljs-keyword">in</span> fetchedObjects) &#123;<br>        <span class="hljs-comment">// 3.在内存中删除MO</span><br>        [<span class="hljs-keyword">self</span>.viewContext deleteObject:c];<br>    &#125;<br>    <span class="hljs-comment">// 4.在数据库中删除MO</span><br>    <span class="hljs-built_in">NSError</span> *error = <span class="hljs-literal">nil</span>;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-keyword">self</span>.viewContext hasChanges] &amp;&amp; ![<span class="hljs-keyword">self</span>.viewContext save:&amp;error]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;~~error %@, %@&quot;</span>, error, error.userInfo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="九-类型转换"><a href="#九-类型转换" class="headerlink" title="九.类型转换"></a>九.类型转换</h3><p>在定义Entity时，属性可以是以下类型：</p><ul><li>Integer</li><li>Float</li><li>Double</li><li>Decimal</li><li>Boolean</li><li>String</li><li>Date</li><li>Binary Data</li><li>UUID</li><li>URI</li><li>Transformable</li></ul><p>Core Data 不支持直接保存图片、音视频文件、颜色、数组、自定义类型等，这时可以将实体中对应的属性设置成 Binary Data 类型，再将这些文件或自定义类型转换成 Data，赋值给实体的属性，执行 save 保存到持久化存储中。读取属性时则反过来，将持久化存储中的 data 手动转换成对应的文件或自定义类型即可。</p><p>但是，每次都自己手动转换显然比较麻烦。这时可以这样做：</p><ol><li>将属性设置成<code>Transformable</code>类型；</li><li>提供一个继承自<code>NSValueTransformer</code>的子类，重写必须的方法；</li><li>在模型编辑窗口，设置属性的<code>Transformer</code>与<code>Custom Class</code>字段；</li><li>保存属性时，直接给属性赋值，Core Data 会通过我们指定的<code>NSValueTransformer</code>子类，自动执行数据转换，将属性中的值转换成 data，写入持久化存储；</li><li>读取属性时，从持久化存储中读取 data，由<code>NSValueTransformer</code>子类自动转换成对应类型；</li></ol><p>这里的<code>NSValueTransformer</code>是一个抽象类，支持单向或双向的类型转换。其内部已经封装好了数据类型转换所需的抽象方法，子类需要自己提供实现：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">+ (<span class="hljs-keyword">Class</span>)transformedValueClass;<br></code></pre></td></tr></table></figure><ul><li>转换后对象所属的类。</li></ul><p>例如将<code>Student</code>保存入库时，需要将<code>Student</code>对象转换成<code>Data</code>，这里就返回<code>Data</code>类型。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">- (<span class="hljs-literal">null</span>able id)transformedValue:(<span class="hljs-literal">null</span>able id)value;<br></code></pre></td></tr></table></figure><ul><li>被转换对象的值。</li></ul><p>例如保存<code>Student</code>类型时，需要将<code>Student</code>对象转换成<code>Data</code>，这里就返回转换之后 Data 的值。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> (BOOL)allowsReverseTransformation;<br></code></pre></td></tr></table></figure><ul><li>bool值，表示是否支持反向转换。</li></ul><p>例如将<code>Student</code>转成data入库后，读取时是否允许将data回转成<code>Student</code>。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">- (<span class="hljs-literal">null</span>able id)reverseTransformedValue:(<span class="hljs-literal">null</span>able id)value;<br></code></pre></td></tr></table></figure><ul><li>反向转换时，转换出来的对象的值。</li></ul><p>例如读取属性时，要将库中的<code>Data</code>转换成<code>Student</code>，这里就返回转换之后的<code>Student</code>实例。</p><hr><p>下面来看一些常见的类型转换怎么重写：</p><h4 id="1-颜色转Data"><a href="#1-颜色转Data" class="headerlink" title="1.颜色转Data"></a>1.颜色转Data</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 颜色转Data</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">RGBColorValueTransformer</span> : <span class="hljs-title">NSValueTransformer</span> </span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RGBColorValueTransformer</span></span><br><br><span class="hljs-comment">// 颜色转Data，这里返回 Data 类型</span><br>+ (Class)transformedValueClass &#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSData</span> <span class="hljs-keyword">class</span>];<br>&#125;<br> <br><span class="hljs-comment">// 颜色转Data后得到的data</span><br>- (<span class="hljs-type">id</span>)transformedValue:(<span class="hljs-type">id</span>)value &#123;<br>    <span class="hljs-built_in">UIColor</span>* color = value;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">CGFloat</span>* components = <span class="hljs-built_in">CGColorGetComponents</span>(color.CGColor);<br>    <span class="hljs-built_in">NSString</span>* colorAsString = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%f,%f,%f,%f&quot;</span>, components[<span class="hljs-number">0</span>], components[<span class="hljs-number">1</span>], components[<span class="hljs-number">2</span>], components[<span class="hljs-number">3</span>]];<br>    <span class="hljs-keyword">return</span> [colorAsString dataUsingEncoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>&#125;<br> <br><span class="hljs-comment">// Data反向转换成颜色时得到的颜色对象</span><br>- (<span class="hljs-type">id</span>)reverseTransformedValue:(<span class="hljs-type">id</span>)value &#123;<br>    <span class="hljs-built_in">NSString</span>* colorAsString = [[<span class="hljs-built_in">NSString</span> alloc] initWithData:value encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>    <span class="hljs-built_in">NSArray</span>* components = [colorAsString componentsSeparatedByString:<span class="hljs-string">@&quot;,&quot;</span>];<br>    <span class="hljs-built_in">CGFloat</span> r = [[components objectAtIndex:<span class="hljs-number">0</span>] floatValue];<br>    <span class="hljs-built_in">CGFloat</span> g = [[components objectAtIndex:<span class="hljs-number">1</span>] floatValue];<br>    <span class="hljs-built_in">CGFloat</span> b = [[components objectAtIndex:<span class="hljs-number">2</span>] floatValue];<br>    <span class="hljs-built_in">CGFloat</span> a = [[components objectAtIndex:<span class="hljs-number">3</span>] floatValue];<br> <br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">UIColor</span> colorWithRed:r green:g blue:b alpha:a];<br>&#125;<br><br><span class="hljs-comment">// 是否允许反向转换</span><br>+ (<span class="hljs-type">BOOL</span>)allowsReverseTransformation &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="2-图片转Data"><a href="#2-图片转Data" class="headerlink" title="2.图片转Data"></a>2.图片转Data</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 图片转Data</span><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">ImageToDataValueTransformer </span>: NSValueTransformer<br><span class="hljs-variable">@end</span><br><br><span class="hljs-variable">@implementation</span> ImageToDataValueTransformer<br><br><span class="hljs-comment">// 图片转Data时，data所属的类</span><br>+ (Class)transformedValueClass &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-attr">[NSData class]</span>;<br>&#125;<br><br><span class="hljs-comment">// 图片转Data后，得到的data</span><br><span class="hljs-selector-tag">-</span> (id)<span class="hljs-selector-tag">transformedValue</span>:(id)<span class="hljs-selector-tag">value</span> &#123;<br>    <span class="hljs-selector-tag">if</span> (value == nil) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">nil</span>;<br>    &#125;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">UIImagePNGRepresentation</span>(value);<br>&#125;<br><br><span class="hljs-comment">// data反向转成图片时，得到的图片对象</span><br><span class="hljs-selector-tag">-</span> (id)<span class="hljs-selector-tag">reverseTransformedValue</span>:(id)<span class="hljs-selector-tag">value</span> &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-attr">[UIImage imageWithData:(NSData *)value]</span>;<br>&#125;<br><br><span class="hljs-comment">// 是否允许反向转换</span><br>+ (BOOL)<span class="hljs-selector-tag">allowsReverseTransformation</span> &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">YES</span>;<br>&#125;<br><br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure><h4 id="3-数组转Data"><a href="#3-数组转Data" class="headerlink" title="3.数组转Data"></a>3.数组转Data</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 数组转Data</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ArrayToDataValueTransformer</span> : <span class="hljs-title">NSValueTransformer</span></span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ArrayToDataValueTransformer</span></span><br><br><span class="hljs-comment">// 数组转Data时，被转换的数组所属的类</span><br>+ (Class)transformedValueClass&#123;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSArray</span> <span class="hljs-keyword">class</span>];<br>&#125;<br><br><span class="hljs-comment">// 数组转换成Data时，得到的data</span><br>- (<span class="hljs-type">id</span>)transformedValue:(<span class="hljs-type">id</span>)value&#123;<br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSKeyedArchiver</span> archivedDataWithRootObject:value requiringSecureCoding:<span class="hljs-literal">YES</span> error:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><span class="hljs-comment">// data反过来转换成数组时，得到的数组对象</span><br>- (<span class="hljs-type">id</span>)reverseTransformedValue:(<span class="hljs-type">id</span>)value&#123;<br>    <span class="hljs-comment">// 指明转换成数组后，其中元素的类型</span><br>    <span class="hljs-built_in">NSSet</span> *unarchivedSet = [<span class="hljs-built_in">NSSet</span> setWithObjects:[MyClassA <span class="hljs-keyword">class</span>], [MyClassB <span class="hljs-keyword">class</span>], <span class="hljs-literal">nil</span>];<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSKeyedUnarchiver</span> unarchivedObjectOfClasses:unarchivedSet fromData:value error:<span class="hljs-literal">nil</span>];<br>&#125;<br><br><span class="hljs-comment">// 是否允许反向转换</span><br>+ (<span class="hljs-type">BOOL</span>)allowsReverseTransformation&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>注意，当被转换的是自定义类型时，需要这些自定义类型实现<code>NSSecureCoding </code>协议，重写<code>encodeWithCoder:</code>和<code>initWithCoder:</code>方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">MyClassA</span></span><br><br>- (<span class="hljs-type">void</span>)encodeWithCoder:(<span class="hljs-built_in">NSCoder</span> *)aCoder<br>&#123;<br>    [aCoder encodeObject:_property1 forKey:<span class="hljs-string">@&quot;property1&quot;</span>];<br>    [aCoder encodeObject:_property2 forKey:<span class="hljs-string">@&quot;property2&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-keyword">nullable</span> <span class="hljs-keyword">instancetype</span>)initWithCoder:(<span class="hljs-built_in">NSCoder</span> *)aDecoder<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init])<br>    &#123;<br>        _property1 = [aDecoder decodeObjectForKey:<span class="hljs-string">@&quot;property1&quot;</span>];<br>        _property2 = [aDecoder decodeObjectForKey:<span class="hljs-string">@&quot;property2&quot;</span>];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br><br>+ (<span class="hljs-type">BOOL</span>)supportsSecureCoding&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h3 id="十-性能优化"><a href="#十-性能优化" class="headerlink" title="十.性能优化"></a>十.性能优化</h3><p>IO操作通常是比较费性能的，而 Core Data 的底层就是对 sqlite 文件等持久化存储进行读写，大量的读写操作会阻塞线程或引发性能问题，所以要考虑内存、性能、线程、并发等问题。</p><h4 id="1-多MOC"><a href="#1-多MOC" class="headerlink" title="1.多MOC"></a>1.多MOC</h4><h5 id="1-1-并发"><a href="#1-1-并发" class="headerlink" title="1.1.并发"></a>1.1.并发</h5><p>为了缓解主线程的压力，对于一些不涉及到UI更新的数据库操作，通常是放到新开辟的一个或多个线程进行。需要注意的是，Core Data的MO与MOC不是线程安全的，对MO与MOC的操作不会上锁去保证操作的原子性，多个线程共用MOC时可能会出现数据混乱甚至闪退。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_n_thread_1_moc.png" alt="多个线程共用一个MOC"></p><p>错误示范：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 测试：多个线程中共用一个MOC可能会引起数据混乱或闪退</span><br>- (<span class="hljs-type">void</span>)testOptionsInMultiThread &#123;<br><br>    <span class="hljs-comment">// 1.共用一个MOC</span><br>    _sameContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _sameContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    <br>    <span class="hljs-comment">// 2.模拟测试数据</span><br>    <span class="hljs-built_in">NSMutableArray</span> *sectionData = [<span class="hljs-built_in">NSMutableArray</span> array];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-built_in">NSString</span> *descript = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;this is %d&quot;</span>,i];<br>        [sectionData addObject:@&#123;<span class="hljs-string">@&quot;id&quot;</span>: @(i), <span class="hljs-string">@&quot;name&quot;</span>: @(i), <span class="hljs-string">@&quot;descript&quot;</span>: descript&#125;];<br>    &#125;<br>    <span class="hljs-comment">// 3.异步线程A 插入数据</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSDictionary</span> *params <span class="hljs-keyword">in</span> sectionData) &#123;<br>            Section *section = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Section&quot;</span> inManagedObjectContext:_sameContext];<br>            <span class="hljs-type">int</span> idf = [params[<span class="hljs-string">@&quot;id&quot;</span>] intValue];<br>            section.id   = idf;<br>            section.name = idf;<br>            section.descript = params[<span class="hljs-string">@&quot;descript&quot;</span>];<br>            <span class="hljs-comment">// 模拟插入10条数据后，异步线程B执行更新操作</span><br>            <span class="hljs-keyword">if</span> (idf == <span class="hljs-number">10</span>) &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        [_sameContext save:<span class="hljs-literal">nil</span>];<br>    &#125;);<br>    <span class="hljs-comment">// 4.异步线程B 更新数据</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSFetchRequest</span> *fetchRequest = [[<span class="hljs-built_in">NSFetchRequest</span> alloc] initWithEntityName:<span class="hljs-string">@&quot;Section&quot;</span>];<br>        <span class="hljs-built_in">NSArray</span> *results = [_sameContext executeFetchRequest:fetchRequest error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">for</span> (Section *section <span class="hljs-keyword">in</span> results) &#123;<br>            <span class="hljs-type">int</span> i = arc4random();<br>            section.id = i;<br>            section.name = i;<br>            section.descript = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;this is %d&quot;</span>,i];<br>        &#125;<br>        [_sameContext save:<span class="hljs-literal">nil</span>];<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中<code>线程A</code>、<code>线程B</code>分别执行插入和更新操作。由于是共用一个MOC且是异步操作，<code>线程A</code>新增的MO可能在<code>线程B</code>中被提前执行了<code>save</code>，两种操作混在一起会产生闪退。</p><p>苹果推荐的是每个线程使用一个独立的MOC，这样MOC在自己所属的线程中管理自己监听的MO，不受其他MOC的影响，从而避免MOC保存前它监听的MO被其他MOC篡改或提前 save 的情况。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_n_thread_n_moc.png" alt="多个线程对应多个MOC"></p><p>创建多MOC时需要指定它的并发类型以便进行多线程管理，Core Data 提供了两个选择：</p><ol><li><code>Main</code>：MOC与主队列关联并且依赖应用的<code>event loop</code>；</li><li><code>Private</code>：MOC会创建并管理一个私有串行队列。</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 主MOC</span><br>_mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc]<br>                    initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br><span class="hljs-comment">// 私有队列MOC</span><br>_backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc]<br>                          initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br></code></pre></td></tr></table></figure><p>基于队列的多 MOC 需要搭配以下两个API使用：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[moc performBlock:]</span><br><span class="hljs-string">[moc performBlockAndWait:]</span><br></code></pre></td></tr></table></figure><p>前者是异步操作，被调用后立刻返回；</p><p>后者是同步操作，会堵塞线程直到任务完成才返回。</p><p>对于更新UI或其他需要在主线程中执行的操作，推荐使用<code>Main</code>主队列MOC。</p><p>对于一些耗时的任务，推荐使用<code>Private</code>私有队列MOC+异步block执行。</p><h5 id="1-2-同PSC"><a href="#1-2-同PSC" class="headerlink" title="1.2.同PSC"></a>1.2.同PSC</h5><p>示例1：多MOC使用同一个PSC</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_n_moc_1_psc.png" alt="多MOC使用同一个PSC"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)initMulMOCWithOnePSC<br>&#123;<br>    <span class="hljs-comment">// 主队列使用的MOC</span><br>    _mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _mainContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    <br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    <br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onUpdate:) name:<span class="hljs-built_in">NSManagedObjectContextDidSaveNotification</span> object:_mainContext];<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onUpdate:) name:<span class="hljs-built_in">NSManagedObjectContextDidSaveNotification</span> object:_backgroudnContext];<br>    <br>    <span class="hljs-comment">// 主MOC增加实体</span><br>    Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.mainContext];<br>    c.id = <span class="hljs-number">1</span>;<br>    c.name =<span class="hljs-string">@&quot;A1&quot;</span>;<br>    [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br><br>    <span class="hljs-comment">// 子MOC增加实体    </span><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 子MOC插入实体</span><br>        Course *c2 = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.backgroudnContext];<br>        c2.id = <span class="hljs-number">2</span>;<br>        c2.name =<span class="hljs-string">@&quot;A2&quot;</span>;<br>        <span class="hljs-comment">// 子MOC执行save</span><br>        [<span class="hljs-keyword">self</span>.backgroudnContext save:<span class="hljs-literal">nil</span>];<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// 监听save通知，合并来自其他MOC的修改</span><br>- (<span class="hljs-type">void</span>)onUpdate:(<span class="hljs-built_in">NSNotification</span> *)notification&#123;<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++通知所在线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <br>    <span class="hljs-comment">// 区分通知中context是哪个，将其中的变化合并到别的context中</span><br>    <span class="hljs-built_in">NSManagedObjectContext</span> *context = notification.object;<br>    <span class="hljs-keyword">if</span> ([context isEqual:_mainContext]) &#123;<br>        [_backgroudnContext performBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++_backgroudnContext performBlock 所在线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>            [_backgroudnContext mergeChangesFromContextDidSaveNotification:notification];<br>        &#125;];<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([context isEqual:_backgroudnContext])&#123;<br>        [_mainContext performBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++_mainContext performBlock 所在线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>            [_mainContext mergeChangesFromContextDidSaveNotification:notification];<br>        &#125;];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不要在一个线程上创建MO再把它传给另一个线程，可通过MOC使用MO的<code>ID</code>查询对应的MO；或者监听<code>NSManagedObjectContextDidSaveNotification</code>通知，在回调里合并来自其他MOC的修改。</p><p>这种方案的问题在于，需要在不同的MOC间监听通知，手动同步来自其他MOC的修改，稍显麻烦。</p><h5 id="1-3-父MOC"><a href="#1-3-父MOC" class="headerlink" title="1.3.父MOC"></a>1.3.父MOC</h5><p>MOC都有对应的父存储，通过父存储可以返回代表托管对象的数据，也可以提交修改之后的托管对象。在 iOS5 之前，父存储只能是<code>persistent store coordinator</code>，而 iOS5 之后父存储可以是另一个MOC了。但无论如何，最终MOC的根源必须是一个<code>PSC</code>，通过<code>PSC</code>提供MOM并分发增删改查等请求到不同的持久化存储中。</p><p><code>父MOC</code>这种模式适用于在子线程处理耗时任务的场景。例如，将<code>主线程</code>对应的MOC设置为<code>子线程</code>MOC的父存储，那么在<code>子MOC</code>中保存对MO的修改时，这些修改会被推送到<code>父MOC</code>中，最终<code>子线程MOC</code>的 fetch 与 save 操作都会通过<code>主线程MOC</code>代为执行。与<code>同PSC</code>方案相比，此方案里某一个MOC的改动不需要用通知去告知其他MOC同步了，省事不少。</p><p>注意：保存对子MOC中数据的修改时，切记先在子MOC中执行 save，再在父MOC中执行 save。</p><p>示例2：子MOC使用 parent context</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_parent_child_moc.png" alt="父子MOC"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)initMulMocWithParentMoc<br>&#123;<br>    <span class="hljs-comment">// 主队列使用的MOC</span><br>    _mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _mainContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_mainContext];    <br><br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_backgroudnContext];    <br><br>    <span class="hljs-comment">// 在父MOC中增加一个实体</span><br>    Course *c = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.mainContext];<br>    c.id = <span class="hljs-number">1</span>;<br>    c.name =<span class="hljs-string">@&quot;A1&quot;</span>;<br>    [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br><br>    <span class="hljs-comment">// 在子MOC中执行perform</span><br>    [<span class="hljs-keyword">self</span>.backgroudnContext performBlock:^&#123;<br><br>        <span class="hljs-comment">// 在子MOC中增加一个实体</span><br>        Course *c2 = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.backgroudnContext];<br>        c2.id = <span class="hljs-number">2</span>;<br>        c2.name =<span class="hljs-string">@&quot;A2&quot;</span>;<br><br>        <span class="hljs-comment">// 先在子MOC中执行 save</span><br>        [<span class="hljs-keyword">self</span>.backgroudnContext save:<span class="hljs-literal">nil</span>];<br>        <br>        [<span class="hljs-keyword">self</span>.mainContext performBlock:^&#123;<br>            <span class="hljs-comment">// 再在父MOC中执行 save，否则backgroudnContext所做修改不会被持久化</span><br>            [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br>        &#125;];<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// 监听通知，将新创建的MO的临时ID转换成永久ID</span><br>- (<span class="hljs-type">void</span>)onContextWillSave:(<span class="hljs-built_in">NSNotification</span> *)notification&#123;<br>    <span class="hljs-built_in">NSManagedObjectContext</span> *moc = notification.object;<br>    <span class="hljs-built_in">NSSet</span> *insertMO = moc.insertedObjects;<br>    <span class="hljs-keyword">if</span> (insertMO.count) &#123;<br>        <span class="hljs-type">BOOL</span> succeed = [moc obtainPermanentIDsForObjects:insertMO.allObjects error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">if</span> (!succeed) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Error occured!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>必要时可以使用三MOC，其中：</p><ul><li><code>Private MOC</code>用于执行耗时操作；</li><li><code>Main MOC</code>用于与UI协作；</li><li><code>Root MOC</code>用于在后台保存所有子MOC提交的修改。</li></ul><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_3moc.png" alt="三MOC方案"></p><p>示例3：使用三MOC</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)init3MocWithParentMoc<br>&#123;<br>    <span class="hljs-comment">// 根MOC，保存子MOC提交的修改</span><br>    _rootContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _rootContext.persistentStoreCoordinator = <span class="hljs-keyword">self</span>.persistentStoreCoordinator;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_rootContext];<br>    <br>    <span class="hljs-comment">// 主队列使用的MOC</span><br>    _mainContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSMainQueueConcurrencyType</span>];<br>    _mainContext.parentContext = _rootContext;<br>    <br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext;<br>    [[<span class="hljs-built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onContextWillSave:) name:<span class="hljs-built_in">NSManagedObjectContextWillSaveNotification</span> object:_backgroudnContext];<br><br>    <span class="hljs-comment">// 在子MOC中执行perform</span><br>    [<span class="hljs-keyword">self</span>.backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.在子MOC中增加一个实体</span><br>        Course *c2 = [<span class="hljs-built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="hljs-string">@&quot;Course&quot;</span> inManagedObjectContext:<span class="hljs-keyword">self</span>.backgroudnContext];<br>        c2.id = <span class="hljs-number">2</span>;<br>        c2.name =<span class="hljs-string">@&quot;A2&quot;</span>;<br><br>        <span class="hljs-comment">// 2.先在子MOC中执行 save</span><br>        [<span class="hljs-keyword">self</span>.backgroudnContext save:<span class="hljs-literal">nil</span>];<br>        <br>        [<span class="hljs-keyword">self</span>.mainContext performBlock:^&#123;<br>            <span class="hljs-comment">// 3.再在父MOC中执行 save</span><br>            [<span class="hljs-keyword">self</span>.mainContext save:<span class="hljs-literal">nil</span>];<br>            <br>            [<span class="hljs-keyword">self</span>.rootContext performBlock:^&#123;<br>                <span class="hljs-comment">// 4.最后在rootMOC中执行 save，保存子MOC提交的修改</span><br>                [<span class="hljs-keyword">self</span>.rootContext save:<span class="hljs-literal">nil</span>];<br>            &#125;];<br>        &#125;];<br>    &#125;];<br>&#125;<br><br><span class="hljs-comment">// 监听通知，将新创建的MO的临时ID转换成永久ID</span><br>- (<span class="hljs-type">void</span>)onContextWillSave:(<span class="hljs-built_in">NSNotification</span> *)notification&#123;<br>    <span class="hljs-built_in">NSManagedObjectContext</span> *moc = notification.object;<br>    <span class="hljs-built_in">NSSet</span> *insertMO = moc.insertedObjects;<br>    <span class="hljs-keyword">if</span> (insertMO.count) &#123;<br>        <span class="hljs-type">BOOL</span> succeed = [moc obtainPermanentIDsForObjects:insertMO.allObjects error:<span class="hljs-literal">nil</span>];<br>        <span class="hljs-keyword">if</span> (!succeed) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Error occured!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用多MOC时需要注意：MO在实例化时会被赋予一个临时ID，这个ID在当前MOC范围内是唯一的。但在提交对MOC的修改时，要将临时ID转换成全局ID，所以需要监听MOC即将保存的通知，以转换永久ID。</p><h5 id="1-4-通知"><a href="#1-4-通知" class="headerlink" title="1.4.通知"></a>1.4.通知</h5><p>MOC会在不同的时机发送不同的通知，注册通知时需要区分MOC，一是因为我们自己会定义不同的MOC，二是系统本身也会使用 Core Data 并发送通知。我们只关心从自己定义的特定MOC中收到的通知，所以在注册通知时需要做区分，可参考上面的👆🏻<code>示例1</code>。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">[[NSNotificationCenter defaultCenter] addObserver:self<br>                                      selector:@selector(&lt;#Selector name#&gt;)<br>                                      name:NSManagedObjectContextDidSaveNotification<br>                                      object:&lt;#A managed object context#&gt;];<br><br></code></pre></td></tr></table></figure><h4 id="2-批量操作"><a href="#2-批量操作" class="headerlink" title="2.批量操作"></a>2.批量操作</h4><h5 id="2-1-一般流程"><a href="#2-1-一般流程" class="headerlink" title="2.1.一般流程"></a>2.1.一般流程</h5><p>先来看一次普通查询或修改对象属性值操作的执行流程：</p><ol><li>执行查询时，MOC 将<code>fetchRequest</code>传递给 PSC；</li><li>PSC 将 fetch 请求转换成对应的<code>NSPersistentStoreRequest</code>，并执行自己的<code>excute</code>方法，将 fetch 与 MOC 发送给持久化存储(NSPersistentStore)；</li><li>持久化存储将<code>NSPersistentStoreRequest</code>转换成 SQL 语句，交给 SQLite 执行；</li><li>SQLite 将符合条件的数据返回给持久化存储，持久化存储将其保存在<code>行缓存</code>(row cache)中；</li><li>持久化存储将获取到的数据实例化成托管对象，交给PSC。此时 fetch.returnsObjectsAsFaults 的默认值为YES，所以这些对象暂时还是惰值形态(<code>Fault</code>)的，其属性值尚未填充，而是暂时被保存在了持久化存储的<code>行缓存</code>中；</li><li>PSC将这些<code>Fault</code>形态的托管对象以数组的形式返回给MOC；</li><li>访问或修改这些托管对象时，MOC会检查它们是否为<code>Fault</code>形态。如果是，则MOC 向 PSC 发起填充请求；</li><li>PSC 向持久化存储请求与当前对象关联的数据；</li><li>持久化存储在它的<code>行缓存</code>中查找并返回数据，交给MOC；</li><li>MOC将返回的数据填充到<code>Fault</code>形态的托管对象中，使其成为完全体的托管对象；</li><li>执行 save 时 MOC 发送<code>NSManagedObjectContextWillSaveNotification</code>通知；</li><li>创建一个持久化存储请求(NSSaveChangesRequest)，调用PSC的 excute 方法，将请求发送给持久化存储；</li><li>持久化存储对比请求中的数据与自己<code>行缓存</code>中的数据，检测是否有冲突并按照设置的合并策略处理冲突；</li><li>持久化存储将<code>NSSaveChangesRequest</code>转换成 SQL 语句交给 SQLite 执行更新；</li><li>持久化存储更新自己的<code>行缓存</code>；</li><li>MOC 发送<code>NSManagedObjectContextDidSaveNotification</code>通知；</li></ol><p>可以看到，整个过程所需的步骤还是挺多的~</p><h5 id="2-2-批量操作"><a href="#2-2-批量操作" class="headerlink" title="2.2.批量操作"></a>2.2.批量操作</h5><p>前面介绍的增、删、改，都是先从持久化存储中读取数据对象到内存中，再通过 MOC 逐一对这些对象执行增删改，最后执行 save 将数据再次保存到持久化存储中。在涉及到大批量数据的操作时，这种方式效率低、费内存，可能会遇到性能问题。为此，Core Data 提供了<code>批量操作</code>功能。</p><p><code>批量操作</code>是直接在持久化存储中操作 MO 对象，不需要先查询 MO 对象，效率高；不需查询 MO 也就无需将它们加载到内存中，节省了内存开销。这个功能需要用到<code>NSBatchxxxRequest</code>系列类，并且这些类只支持 SQLite 类型的持久化存储，因为它是在持久化存储的 SQL 层面直接操作这些对象。也正是因为发生在 SQL 层面，所以 MOC 不会自动合并这种操作，也不会发送相关通知，需要我们自己通过 MOC 的 merge 静态方法，同步增删改内存中对应的 MO 对象。为此，需要将批量操作的返回值设置成<code>NSManagedObjectID</code>，即被操作对象的ID，再用这些ID更新 MOC 即可。</p><p>需要注意的是，在执行批量操作时，最好是放到一个私有 MOC 中进行。</p><h5 id="2-3-批量修改"><a href="#2-3-批量修改" class="headerlink" title="2.3.批量修改"></a>2.3.批量修改</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)batchUpdate&#123;<br><br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.设置修改的实体</span><br>        <span class="hljs-built_in">NSBatchUpdateRequest</span> *request = [<span class="hljs-built_in">NSBatchUpdateRequest</span> batchUpdateRequestWithEntityName:<span class="hljs-string">@&quot;Course&quot;</span>];<br>        <span class="hljs-built_in">NSPredicate</span> *predicate= [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id &gt; 0&quot;</span>];<br>        [request setPredicate:predicate];<br>        <span class="hljs-comment">// 2.设置修改的字段</span><br>        request.propertiesToUpdate = @&#123;<span class="hljs-string">@&quot;name&quot;</span>:<span class="hljs-string">@&quot;课程S&quot;</span>,<span class="hljs-string">@&quot;url&quot;</span>:<span class="hljs-string">@&quot;www.xxx.com&quot;</span>&#125;;<br>        request.resultType = <span class="hljs-built_in">NSUpdatedObjectIDsResultType</span>;<br>    <br>        <span class="hljs-comment">// 3.执行批量修改</span><br>        <span class="hljs-built_in">NSError</span> *error;<br>        <span class="hljs-built_in">NSBatchUpdateResult</span> *batchResult = [<span class="hljs-keyword">self</span>.viewContext executeRequest:request error:&amp;error];<br>        <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSManagedObjectID</span>*&gt; *updatedObjectIDs = batchResult.result;<br>    <br>        <span class="hljs-comment">// 同步数据的变化到MOC中 方式1（推荐）</span><br>        <span class="hljs-built_in">NSDictionary</span> *updatedDict = @&#123;<span class="hljs-built_in">NSUpdatedObjectsKey</span> : updatedObjectIDs&#125;;<br>        [<span class="hljs-built_in">NSManagedObjectContext</span> mergeChangesFromRemoteContextSave:updatedDict intoContexts:@[<span class="hljs-keyword">self</span>.viewContext]];<br>    <br>        <span class="hljs-comment">// 同步数据的变化到MOC中 方式2</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        [updatedObjectIDs enumerateObjectsUsingBlock:^(NSManagedObjectID *objID, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="hljs-comment">            NSManagedObject *obj = [self.viewContext objectWithID:objID];</span><br><span class="hljs-comment">            if (![obj isFault]) &#123;</span><br><span class="hljs-comment">                [self.viewContext refreshObject:obj mergeChanges:YES];</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;];*/</span><br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-批量删除"><a href="#2-4-批量删除" class="headerlink" title="2.4.批量删除"></a>2.4.批量删除</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)batchDelete&#123;<br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.创建fetch</span><br>        <span class="hljs-built_in">NSFetchRequest</span> *fetch = [Course fetchRequest];<br>        <span class="hljs-comment">// 2.设置过滤条件</span><br>        fetch.predicate = [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;id &gt; 0&quot;</span>];<br><br>        <span class="hljs-comment">// 3.创建删除request</span><br>        <span class="hljs-built_in">NSBatchDeleteRequest</span> *delReqest = [[<span class="hljs-built_in">NSBatchDeleteRequest</span> alloc] initWithFetchRequest:fetch];<br>        delReqest.resultType = <span class="hljs-built_in">NSBatchDeleteResultTypeObjectIDs</span>;<br><br>        <span class="hljs-comment">// 4.开始批量删除</span><br>        <span class="hljs-built_in">NSError</span> *error;<br>        <span class="hljs-built_in">NSBatchDeleteResult</span> *deleteResult = [<span class="hljs-keyword">self</span>.viewContext executeRequest:delReqest error:&amp;error];<br>        <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSManagedObjectID</span>*&gt; *deletedObjectIDs = deleteResult.result;<br><br>        <span class="hljs-comment">// 5.同步更新到MOC</span><br>        <span class="hljs-built_in">NSDictionary</span> *deletedDict = @&#123;<span class="hljs-built_in">NSDeletedObjectsKey</span> : deletedObjectIDs&#125;;<br>        [<span class="hljs-built_in">NSManagedObjectContext</span> mergeChangesFromRemoteContextSave:deletedDict intoContexts:@[<span class="hljs-keyword">self</span>.viewContext]];<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-批量插入"><a href="#2-5-批量插入" class="headerlink" title="2.5.批量插入"></a>2.5.批量插入</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)batchInser&#123;<br>    <span class="hljs-comment">// 私有队列MOC，处理耗时任务</span><br>    _backgroudnContext = [[<span class="hljs-built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="hljs-built_in">NSPrivateQueueConcurrencyType</span>];<br>    _backgroudnContext.parentContext = _mainContext; <span class="hljs-comment">// 设置 parent store</span><br><br>    [_backgroudnContext performBlock:^&#123;<br>        <span class="hljs-comment">// 1.创建由实体Map组成的数组</span><br>        <span class="hljs-built_in">NSArray</span> *sectionsArr = @[@&#123;<span class="hljs-string">@&quot;name&quot;</span>:@(<span class="hljs-number">001</span>),<span class="hljs-string">@&quot;id&quot;</span>:@(<span class="hljs-number">1</span>),<span class="hljs-string">@&quot;descript&quot;</span>:<span class="hljs-string">@&quot;Section 1&quot;</span>&#125;,<br>                                 @&#123;<span class="hljs-string">@&quot;name&quot;</span>:@(<span class="hljs-number">002</span>),<span class="hljs-string">@&quot;id&quot;</span>:@(<span class="hljs-number">2</span>),<span class="hljs-string">@&quot;descript&quot;</span>:<span class="hljs-string">@&quot;Section 2&quot;</span>&#125;,<br>                                 @&#123;<span class="hljs-string">@&quot;name&quot;</span>:@(<span class="hljs-number">003</span>),<span class="hljs-string">@&quot;id&quot;</span>:@(<span class="hljs-number">3</span>),<span class="hljs-string">@&quot;descript&quot;</span>:<span class="hljs-string">@&quot;Section 3&quot;</span>&#125;];<br>        <span class="hljs-comment">// 2.创建插入请求</span><br>        <span class="hljs-built_in">NSBatchInsertRequest</span> *request = [[<span class="hljs-built_in">NSBatchInsertRequest</span> alloc] initWithEntityName:<span class="hljs-string">@&quot;Section&quot;</span> objects:sectionsArr];<br>        request.resultType = <span class="hljs-built_in">NSUpdatedObjectIDsResultType</span>;<br>    <br>        <span class="hljs-comment">// 3.执行批量插入</span><br>        <span class="hljs-built_in">NSError</span> *error;<br>        <span class="hljs-built_in">NSBatchInsertResult</span> *batchResult = [<span class="hljs-keyword">self</span>.viewContext executeRequest:request error:&amp;error];<br>        <span class="hljs-built_in">NSArray</span>&lt;<span class="hljs-built_in">NSManagedObjectID</span>*&gt; *insertedObjectIDs = batchResult.result;<br>    <br>        <span class="hljs-comment">// 4.同步数据的变化到MOC中</span><br>        <span class="hljs-built_in">NSDictionary</span> *updatedDict = @&#123;<span class="hljs-built_in">NSInsertedObjectsKey</span> : insertedObjectIDs&#125;;<br>        [<span class="hljs-built_in">NSManagedObjectContext</span> mergeChangesFromRemoteContextSave:updatedDict intoContexts:@[<span class="hljs-keyword">self</span>.viewContext]];<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>需要指出的是，虽然批量操作比普通增删改操作的效率高很多，但它的代价是放弃了很多细节的处理，比如批量操作不支持校验、不会发送通知、无法处理 Entity 间的关系等。</p><h4 id="3-减少内存消耗"><a href="#3-减少内存消耗" class="headerlink" title="3.减少内存消耗"></a>3.减少内存消耗</h4><h5 id="3-1-分页查询"><a href="#3-1-分页查询" class="headerlink" title="3.1.分页查询"></a>3.1.分页查询</h5><p>查询时最好是限制总量和每页的数量，防止所有结果一次性加载到内存中；</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 总共查询的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchLimit;<br><span class="hljs-comment">// 每次查询返回的数量</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchBatchSize;<br><span class="hljs-comment">// 分页查询的下标，从哪条开始查</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-built_in">NSUInteger</span> fetchOffset;<br><span class="hljs-comment">// 返回Fault对象，其属性值在行缓存中，默认值YES</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>) <span class="hljs-type">BOOL</span> returnsObjectsAsFaults;<br></code></pre></td></tr></table></figure><p>案例演示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)loadDataAtPage:(<span class="hljs-built_in">NSUInteger</span>)page&#123;<br>    <span class="hljs-comment">// 1.设置请求</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br><br>    <span class="hljs-comment">// 2.排序</span><br>    <span class="hljs-built_in">NSSortDescriptor</span> *descriptor = [<span class="hljs-built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="hljs-string">@&quot;id&quot;</span> ascending:<span class="hljs-literal">YES</span>];<br>    request.sortDescriptors = @[descriptor];<br>    <br>    <span class="hljs-comment">// 3.分页</span><br>    request.fetchOffset = (page - <span class="hljs-number">1</span>) * kLimiteSize;<br>    request.fetchLimit = kLimiteSize;<br>    <br>    <span class="hljs-comment">// 4.查询</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-2-fault对象"><a href="#3-2-fault对象" class="headerlink" title="3.2.fault对象"></a>3.2.fault对象</h5><ul><li>返回fault</li></ul><p>查询后不会立刻访问其属性值时，可设置 fetch 请求返回<code>fault</code>对象，以节省内存；</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)faultMO&#123;<br>    <span class="hljs-comment">// 1.设置请求</span><br>    <span class="hljs-built_in">NSFetchRequest</span> *request = [Course fetchRequest];<br>    request.returnsObjectsAsFaults = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-comment">// 2.查询</span><br>    <span class="hljs-built_in">NSError</span> *error;<br>    <span class="hljs-built_in">NSArray</span> *matchArr = [<span class="hljs-keyword">self</span>.viewContext executeFetchRequest:request error:&amp;error];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重置成fault</li></ul><p>不再需要的托管对象，让 MOC 调用下面的方法，清除对象的属性值，将其还原成<code>fault</code>状态。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>refreshObject:<span class="hljs-params">(NSManagedObject *)</span>object <br>         mergeChanges:<span class="hljs-params">(BOOL)</span>flag;<br></code></pre></td></tr></table></figure><p>其中<code>flag</code>参数为NO时，MOC会丢弃未保存的修改，当前托管对象变成<code>fault</code>对象；</p><p>当<code>flag</code>为YES时，MOC会从持久化存储或缓存中重新加载MO的属性值，再更新成本地修改的值。</p><h5 id="3-3-重置所有MO"><a href="#3-3-重置所有MO" class="headerlink" title="3.3.重置所有MO"></a>3.3.重置所有MO</h5><p>调用MOC的<code>reset</code>方法，可以将MOC中所有的MO都清除。此时原来跟MOC关联的MO都会失效，你需要重置它们的引用，并重新执行 fetch。</p><h5 id="3-4-遍历与销毁MO"><a href="#3-4-遍历与销毁MO" class="headerlink" title="3.4.遍历与销毁MO"></a>3.4.遍历与销毁MO</h5><p>当遍历大量托管对象时，需要使用<code>autorelease pool</code>来确保临时MO尽快销毁。</p><h5 id="3-5-不查询属性值"><a href="#3-5-不查询属性值" class="headerlink" title="3.5.不查询属性值"></a>3.5.不查询属性值</h5><p>执行 Fetch 时，Core Data 默认会查询对象的ID和属性值，填充行缓存，用ID创建<code>fault</code>对象并返回。如果你确定只想查询托管对象，而不会访问其属性，可设置<code>fetch.includesPropertyValues = NO</code>，此时 Core Data 只会查询对象的 ID 并返回<code>fault</code>对象，而不会查询属性值，也不会填充行缓存，这样就又省去了一部分内存开销。</p><p>当然，如果<code>includesPropertyValues=NO</code>而你又访问了<code>fault</code>对象的属性，那么 Core Data 在空的行缓存中查询不到数据，就会去持久化存储中重新查询并填充到<code>fault</code>对象中。</p><p>如果<code>includesPropertyValues=YES</code>而<code>resultType</code>是<code>managedObjectIDResultType</code>类型，那么还是会查询属性，这会造成不必要的性能开销。因为返回值是 ID 类型，没有属性字段，这些被查询出来的属性根本就没有机会被展示到应用里。</p><h4 id="4-BLOBs-二进制大文件"><a href="#4-BLOBs-二进制大文件" class="headerlink" title="4.BLOBs-二进制大文件"></a>4.BLOBs-二进制大文件</h4><p>Binary Large Data Objects，指二进制大数据对象，例如图片、音频等。使用Core Data 保存这种对象时，需要选择 SQLite 作为持久化存储。因为其他存储要求将整个对象都加载到内存中，并且写入存储是原子性的，这会导致它们处理 BLOBs 的效率相对不高。</p><p>BLOB 通常是 Entity 的属性，例如<code>员工</code>实体的<code>头像</code>属性。可以为 BLOB 创建一个单独的<code>照片</code>实体，在它与<code>员工</code>实体间设置<code>1对1</code>的<code>关系</code>，以替代原<code>员工</code>实体中的<code>头像</code>属性。这样做可以充分利用<code>Fault</code>对象节省内存的特点，查询员工的照片<code>关系</code>字段时，Core Data 暂时不会将关系属性值(即二进制的照片数据)加载到内存中，只有真正访问或修改此属性时，才填充到<code>fault</code>对象中。</p><p>更好的做法是将 BLOBs 保存到文件系统里，将其 URL 或路径保存在数据库中，需要用到时再通过 URL 或路径加载此文件。</p><h3 id="十一-合并冲突"><a href="#十一-合并冲突" class="headerlink" title="十一.合并冲突"></a>十一.合并冲突</h3><p>应用中一般会存在多个MOC，它们使用同一份持久化存储，执行不同任务以便优化性能。每个 MOC 都能独立执行 save 保存对托管对象的修改，其他 MOC 需要合并这些修改，以保证各处托管对象状态的一致性。当 MOC 合并对托管对象的修改时，如果另一个 MOC 也修改了同一个属性并且值不相同，就产生了冲突。这时就需要根据 MOC 的合并策略属性来处理冲突：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">@<span class="hljs-keyword">property</span> (strong) <span class="hljs-built_in">id</span> mergePolicy;<br></code></pre></td></tr></table></figure><p>以下是各个策略及其对应的处理：</p><table><thead><tr><th align="left"><center>合并策略</center></th><th align="left"><center>说明</center></th></tr></thead><tbody><tr><td align="left">NSErrorMergePolicy</td><td align="left">默认的合并策略，产生冲突时返回错误；</td></tr><tr><td align="left">NSMergeByPropertyStoreTrumpMergePolicy</td><td align="left">只合并产生冲突的属性，用外部修改覆盖当前修改，其他未产生冲突的属性保持不变；</td></tr><tr><td align="left">NSMergeByPropertyObjectTrumpMergePolicy</td><td align="left">只合并产生冲突的属性，用当前修改覆盖外部修改，其他未产生冲突的属性保持不变；</td></tr><tr><td align="left">NSOverwriteMergePolicy</td><td align="left">将当前MOC的托管对象写入持久化存储；</td></tr><tr><td align="left">NSRollbackMergePolicy</td><td align="left">丢弃冲突中所有的修改，保持持久化存储中的版本不变；</td></tr></tbody></table><h3 id="十二-数据迁移"><a href="#十二-数据迁移" class="headerlink" title="十二.数据迁移"></a>十二.数据迁移</h3><p><code>MOM</code>用来描述持久化存储中数据的结构，Core Data 中只能使用 MOM 打开持久化存储，改变 MOM 中的任何一部分都会导致它与之前版本的存储产生冲突。例如在<code>.xcdatamodel</code>中增加新实体，修改实体的名字，增删属性等，那么老版本的持久化存储就不能使用了。需要通过<code>数据迁移</code>，将老版本存储中的数据迁移到新版本中。为了让 Core Data 知道如何迁移数据，有时我们需要主动提供一些信息，例如，创建一个<code>mapping model</code>映射文件。对于简单的变化，可以使用<code>轻量级迁移</code>功能。</p><p>使用轻量级迁移功能时，Core Data 会根据前后<code>MOM</code>的不同，自动推断出一个<code>mapping model</code>，无需我们自己创建。轻量级迁移在我们项目的初期可能会非常有用，因为这一时期我们可能会经常性的改动模型文件，而又不希望频繁重新生成测试数据。当然，这些<code>小的</code>改动只能是以下这些操作：</p><ul><li>增、删、重命名属性；</li><li>给属性设置默认值；</li><li>不可选属性变可选；</li><li>可选属性变不可选并设置默认值；</li><li>增、删、重命关系；</li><li>修改关系成对1或对多、排序或不排序；</li><li>增、删、重命名实体；</li><li>创建新的父实体或子实体；</li><li>在实体继承树上将属性移到别的实体中；</li><li>将实体移出继承树；</li></ul><h4 id="1-建新model"><a href="#1-建新model" class="headerlink" title="1.建新model"></a>1.建新model</h4><p>做数据迁移时既需要新版本model文件，也需要新版本model文件，新版model文件设置方法如下：</p><ul><li>Xcode 中选中<code>.xcdatamodeld</code>文件；</li><li><code>Editor</code> -&gt; <code>add model version</code>；</li><li>设置新版本文件名和它基于哪个版本；</li><li>创建新模型文件；</li><li>设置新<code>xcdatamodel</code>作为当前版本；</li></ul><p>这样，就可以在新版本的模型文件中修改 Entity 了。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_cd_entity.jpeg" alt="新建Model 2.xcdatamodel文件"></p><h4 id="2-修改Entity"><a href="#2-修改Entity" class="headerlink" title="2.修改Entity"></a>2.修改Entity</h4><p>重命名属性时，需要在设置面板中将目标版本属性的<code>Renaming ID</code>字段设置成原属性的名字。例如可以在版本2中将属性<code>name</code>重命名成<code>name2</code>，设置<code>name2</code>的<code>Renaming ID</code>为<code>name</code>；然后在版本3中可以继续将<code>name</code>重命名成<code>name3</code>，同样将<code>name3</code>的<code>Renaming ID</code>设置为<code>name</code>。这样 Core Data 就能从版本1推断出到版本2，或者从版本1到版本3的<code>mapping model</code>，以此完成数据迁移。</p><p>重命名实体或关系时，也是同样的步骤，设置目标实体&#x2F;关系的<code>Renaming ID</code>字段。</p><h4 id="3-设置options"><a href="#3-设置options" class="headerlink" title="3.设置options"></a>3.设置options</h4><p>修改实体后，还要在添加持久化存储时将<code>options</code>字典中自动迁移和自动推断的值设置为<code>YES</code>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (<span class="hljs-type">NSPersistentStoreCoordinator</span> <span class="hljs-operator">*</span>)persistentStoreCoordinator &#123;<br>    <span class="hljs-keyword">if</span> (_persistentStoreCoordinator <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>    &#125;<br>    _persistentStoreCoordinator <span class="hljs-operator">=</span> [[<span class="hljs-type">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="hljs-keyword">self</span> managedObjectModel]];<br>    <span class="hljs-type">NSURL</span> <span class="hljs-operator">*</span>storeURL <span class="hljs-operator">=</span> [[<span class="hljs-keyword">self</span> applicationDocumentsDirectory] <span class="hljs-type">URLByAppendingPathComponent</span>:@<span class="hljs-string">&quot;ASDF.sqlite&quot;</span>];<br>    <span class="hljs-type">NSError</span> <span class="hljs-operator">*</span>error <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>;<br>    <span class="hljs-comment">// 数据库做轻量迁移时 传入此options字典</span><br>    <span class="hljs-type">NSDictionary</span> <span class="hljs-operator">*</span>options <span class="hljs-operator">=</span> @&#123;<span class="hljs-type">NSMigratePersistentStoresAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>, <br>                              <span class="hljs-type">NSInferMappingModelAutomaticallyOption</span>: <span class="hljs-meta">@YES</span>&#125;;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>[_persistentStoreCoordinator addPersistentStoreWithType:<span class="hljs-type">NSSQLiteStoreType</span> <br>                                                   configuration:<span class="hljs-literal">nil</span> <br>                                                             URL:storeURL <br>                                                         options:options error:<span class="hljs-operator">&amp;</span>error]) &#123; &#125;<br>    <span class="hljs-keyword">return</span> _persistentStoreCoordinator;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，轻量级迁移就完成了，用户升级版本后启动时就不会因数据版本问题闪退了。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/FaultingandUniquing.html#//apple_ref/doc/uid/TP40001075-CH18-SW1">©Fault</a><br>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/Performance.html#//apple_ref/doc/uid/TP40001075-CH25-SW1">©性能</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FAQ-常见问题</title>
    <link href="/2017/11/24/faq.html"/>
    <url>/2017/11/24/faq.html</url>
    
    <content type="html"><![CDATA[<h3 id="1、VC的生命周期"><a href="#1、VC的生命周期" class="headerlink" title="1、VC的生命周期"></a>1、VC的生命周期</h3><ul><li>-initWithCoder: &#x2F;&#x2F;VC初始化</li><li>-initWithNibName:bundle:</li><li>-loadView &#x2F;&#x2F;从nib载入视图或返回一个自定义视图</li><li>-viewDidLoad &#x2F;&#x2F;视图载入完成并开始进一步的设置</li><li>-viewWillAppear: &#x2F;&#x2F;视图即将出现在屏幕上</li><li>-updateViewConstraints &#x2F;&#x2F;更新约束</li><li>-viewWillLayoutSubviews &#x2F;&#x2F;视图布局</li><li>-viewDidLayoutSubviews</li><li>-viewDidAppear: &#x2F;&#x2F;视图已展示在屏幕上</li><li>-viewWillDisappear:&#x2F;&#x2F;视图从屏幕上移除</li><li>-viewDidDisappear:</li><li>-dealloc</li></ul><p>通过<code>addChildViewController</code>将子VC添加到父VC容器中后，子VC与父VC的生命周期会同步进行，如：父VC的<code>-viewDidAppear</code>等触发时子VC的也会触发。</p><p>VC的生命周期是根据其<code>self.view</code>所处的状态而定的：在父VC中第一次访问子VC的<code>.view</code>属性时会先调用子VC中的<code>-loadView</code>，随后子VC中的<code>-viewDidLoad</code>也会触发，以便做进一步的设置；如果<code>.view</code>属性没被添加到一个已经展示的视图上，则其所属VC的<code>-viewWillAppear</code>不会调用。</p><h3 id="2、VC跳转时生命周期调用顺序"><a href="#2、VC跳转时生命周期调用顺序" class="headerlink" title="2、VC跳转时生命周期调用顺序"></a>2、VC跳转时生命周期调用顺序</h3><ul><li>情形1：由 A push 到 B 时：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-attr">[B viewDidLoad]</span><br>-<span class="hljs-selector-attr">[A viewWillDisappear:]</span><br>-<span class="hljs-selector-attr">[B viewWillAppear:]</span><br>-<span class="hljs-selector-attr">[A viewDidDisappear:]</span><br>-<span class="hljs-selector-attr">[B viewDidAppear:]</span><br></code></pre></td></tr></table></figure><ul><li>情形2：由 A present 到 B 时：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-attr">[B viewDidLoad]</span><br>-<span class="hljs-selector-attr">[A viewWillDisappear:]</span><br>-<span class="hljs-selector-attr">[B viewWillAppear:]</span><br>-<span class="hljs-selector-attr">[B viewDidAppear:]</span><br>-<span class="hljs-selector-attr">[A viewDidDisappear:]</span><br></code></pre></td></tr></table></figure><h3 id="3、宏定义使用错误案例"><a href="#3、宏定义使用错误案例" class="headerlink" title="3、宏定义使用错误案例"></a>3、宏定义使用错误案例</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MATH_MAX(a,b) a &gt; b ? a : b</span><br><br>- (<span class="hljs-type">void</span>)defineExmple<br>&#123;<br>    <span class="hljs-comment">//case1</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result: %d\n&quot;</span>,<span class="hljs-built_in">MATH_MAX</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<span class="hljs-comment">//结果：result: 2</span><br>    <span class="hljs-comment">//case2</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;largest: %d\n&quot;</span>, <span class="hljs-built_in">MATH_MAX</span>(i++,<span class="hljs-number">0</span>));<span class="hljs-comment">//结果：largest: 2</span><br>    <span class="hljs-comment">//case3</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;now i value = %d\n&quot;</span>, i);<span class="hljs-comment">//结果：now i value = 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果都不是设想的值？这里涉及到编译器对“#”开头的行、自定义宏等宏的处理逻辑。</p><p>宏定义是在预编译阶段把宏的内容拷贝的源代码的相应位置，所以case1中<code>MATH_MAX(a,b)+1</code>就展开为<code>a&gt;b?a:b+1</code>，冒号后面变成了<code>b+1</code>。。这就跟设计之初的愿望相违背了~</p><p>同理，case2和case3在编译时，会变成：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">printf</span>(<span class="hljs-string">&quot;largest: %d\n&quot;</span>, i++ &gt; <span class="hljs-number">0</span> ? i++ : <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这里i做了两次++运算，显然也不是设想之初的结果。</p><p>#修改case1：</p><p>宏定义部分应该加上括号：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#define</span> MATH_MAX(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>) (<span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">b</span> ? <span class="hljs-selector-tag">a</span> : b)<br></code></pre></td></tr></table></figure><p>#修改case2和case3：</p><p>不要在需要预处理的代码中加入内联代码逻辑。</p><h3 id="4、指针-地址"><a href="#4、指针-地址" class="headerlink" title="4、指针\地址"></a>4、指针\地址</h3><p><code>一般变量</code>存放的是数据本身；<br><code>指针变量</code>存放的是数据的地址。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a = <span class="hljs-number">68</span>;<br>long *p = NULL;<br>p = &amp;a;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++a的值:%d \n++&amp;a:%p \n++p保存的指针:%p \n++*p的值:%d \n++变量p的地址:%p&quot;</span>,<span class="hljs-params">a</span>,&amp;<span class="hljs-params">a</span>,<span class="hljs-params">p</span>,<span class="hljs-operator">*</span><span class="hljs-params">p</span>,&amp;<span class="hljs-params">p</span>)</span>;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++</span><span class="hljs-comment">a的值:68</span> <br><span class="hljs-literal">++</span><span class="hljs-comment">&amp;a:0x7ffee43cec64</span> <br><span class="hljs-literal">++</span><span class="hljs-comment">p保存的指针:0x7ffee43cec64</span> <br><span class="hljs-literal">++</span><span class="hljs-comment">*p的值:68</span> <br><span class="hljs-literal">++</span><span class="hljs-comment">变量p的地址:0x7ffee43cec58</span><br></code></pre></td></tr></table></figure><p><code>*</code>是指针的标识，表示接下来的变量是一个<code>指针变量</code>；<code>&amp;</code>用来取变量的地址。</p><p>上面的示例中，<code>a</code>是一般变量，保存数值<code>68</code>；而<code>a</code>作为变量，系统会为其分配一个地址<code>0x7ffee43cec64</code>；<code>p</code>是初始值为空的指针变量，随后指向<code>&amp;a</code>，即变量<code>p</code>保存的是变量<code>a</code>的地址（<code>0x7ffee43cec64</code>）；<code>p</code>作为指针变量，其保存的指针所指向的值为 68，变量<code>p</code>自己的内存地址为<code>0x7ffee43cec58</code>。</p><h3 id="5、NULL、nil、Nil、NSNull"><a href="#5、NULL、nil、Nil、NSNull" class="headerlink" title="5、NULL、nil、Nil、NSNull"></a>5、NULL、nil、Nil、NSNull</h3><p>1、前三者<code>NULL</code>、<code>nil</code>、<code>Nil</code>从本质上来讲都是<code>(void *)0</code>：</p><ul><li>NULL，表示C类型的指针为空；</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">long *p <span class="hljs-operator">=</span> NULL<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>nil，表示OC中对象的指针为空；</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">NSObject *obj <span class="hljs-operator">=</span> nil<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>Nil，表示OC中类类型变量的值为空；</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Class</span> <span class="hljs-keyword">class</span> = <span class="hljs-keyword">Nil</span>;<br></code></pre></td></tr></table></figure><p>2、<code>NSNull</code>与以上三者不同，它是一个OC类，用于创建空对象：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSNull</span> *nsnullObj = [<span class="hljs-built_in">NSNull</span> null]; <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">NSArray</span> *aArr = @[@(<span class="hljs-number">1</span>),nsnullObj];<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSObject</span> *item <span class="hljs-keyword">in</span> aArr) &#123;<br>    <span class="hljs-keyword">if</span> ([item isEqual:[<span class="hljs-built_in">NSNull</span> null]]) &#123; <span class="hljs-comment">// 2</span><br>        nsnullObj = <span class="hljs-literal">nil</span>; <span class="hljs-comment">// 3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中1处即为刚创建的空对象<code>nsnullObj</code>,它的内存地址如下：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_nsnullObj.png" alt="nsnullObj"></p><p>示例中3处将空对象置为nil后，其内存地址如下：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_po_nsnullObj_nil.png" alt="pic_nsnullObj_nil"></p><p>所以可以看出<code>NSNull</code>仍然是一个对象，只是此对象中什么都没有而已~</p><h3 id="6、对象的比较-x3D-x3D-与isEqual"><a href="#6、对象的比较-x3D-x3D-与isEqual" class="headerlink" title="6、对象的比较&#x3D;&#x3D;与isEqual"></a>6、对象的比较&#x3D;&#x3D;与isEqual</h3><ul><li>&#x3D;&#x3D;</li></ul><p>比较的是<code>值</code>。</p><p><code>基本数据类型</code>比较数值，数值相等即为真；<br><code>指针变量</code>比较变量内保存的<code>地址</code>，地址相同，即指向同一个数据对象，返回真。</p><p>#示例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)test&#123;<br>    <span class="hljs-built_in">NSString</span> *A = <span class="hljs-string">@&quot;Hello&quot;</span>; <span class="hljs-comment">//常量区</span><br>    <span class="hljs-built_in">NSString</span> *B = <span class="hljs-string">@&quot;Hello&quot;</span>; <span class="hljs-comment">//常量区</span><br>    <span class="hljs-built_in">NSString</span> *C = [[<span class="hljs-built_in">NSString</span> alloc] initWithString:<span class="hljs-string">@&quot;Hello&quot;</span>]; <span class="hljs-comment">//常量区</span><br>    <span class="hljs-built_in">NSString</span> *D = [[<span class="hljs-built_in">NSString</span> alloc] initWithString:<span class="hljs-string">@&quot;Hello&quot;</span>]; <span class="hljs-comment">//常量区</span><br>    <span class="hljs-built_in">NSString</span> *E = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Hello&quot;</span>]; <span class="hljs-comment">//堆区</span><br>    <span class="hljs-built_in">NSString</span> *F = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;Hello&quot;</span>]; <span class="hljs-comment">//堆区</span><br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A:%p&quot;</span>,A); <span class="hljs-comment">//打印A对象保存的指针</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;B:%p&quot;</span>,B);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;C:%p&quot;</span>,C);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;D:%p&quot;</span>,D);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;E:%p&quot;</span>,E);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;F:%p&quot;</span>,F);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A==B:%d&quot;</span>,A==B); <span class="hljs-comment">// 检测AB变量内保存的地址是否相同</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;C==D:%d&quot;</span>,C==D);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;E==F:%d&quot;</span>,E==F);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A==C:%d&quot;</span>,A==C);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A==E:%d&quot;</span>,A==E);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;C==E:%d&quot;</span>,C==E);<br><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A isEqual: B : %d&quot;</span>,[A isEqual:B]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A isEqual: C : %d&quot;</span>,[A isEqual:C]);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;A isEqual: E : %d&quot;</span>,[A isEqual:E]);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>:<span class="hljs-number">0</span>x1015870e8<br><span class="hljs-attribute">B</span>:<span class="hljs-number">0</span>x1015870e8<br><span class="hljs-attribute">C</span>:<span class="hljs-number">0</span>x1015870e8<br><span class="hljs-attribute">D</span>:<span class="hljs-number">0</span>x1015870e8 // ABCD都指向常量区的同一个对象@<span class="hljs-string">&quot;Hello&quot;</span><br><span class="hljs-attribute">E</span>:<span class="hljs-number">0</span>xf538015112db6b7d<br><span class="hljs-attribute">F</span>:<span class="hljs-number">0</span>xf538015112db6b7d<br><span class="hljs-attribute">A</span>==B:<span class="hljs-number">1</span> //指针相等返回真<br><span class="hljs-attribute">C</span>==D:<span class="hljs-number">1</span><br><span class="hljs-attribute">E</span>==F:<span class="hljs-number">1</span><br><span class="hljs-attribute">A</span>==C:<span class="hljs-number">1</span><br><span class="hljs-attribute">A</span>==E:<span class="hljs-number">0</span> //指针不同返回假<br><span class="hljs-attribute">C</span>==E:<span class="hljs-number">0</span><br><span class="hljs-attribute">A</span> isEqual: B : <span class="hljs-number">1</span><br><span class="hljs-attribute">A</span> isEqual: C : <span class="hljs-number">1</span><br><span class="hljs-attribute">A</span> isEqual: E : <span class="hljs-number">1</span> //重写了isEqual方法，指针不同字符串相同即返回真<br></code></pre></td></tr></table></figure><ul><li>isEqual:</li></ul><blockquote><p>This method defines what it means for instances to be equal. </p></blockquote><p><code>isEqual:</code>默认情况下，效果与<code>==</code>一样，两个对象指向的<code>地址</code>相同时才返回真。</p><p>有时在创建子类时，需要你自己重写此方法的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)isEqual:(<span class="hljs-type">id</span>)obj &#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">self</span>)&#123; <span class="hljs-comment">//先比较指针</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!obj || ![obj isKindOfClass:[<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>]])&#123; <span class="hljs-comment">//再比较类型</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> isEqualToUser:obj]; <span class="hljs-comment">//再比较自定义的属性</span><br>&#125;<br> <br>- (<span class="hljs-type">BOOL</span>)isEqualToUser:(User *)aUser &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> == aUser)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br> &#125;<br> <span class="hljs-keyword">if</span> (![(<span class="hljs-type">id</span>)[<span class="hljs-keyword">self</span> name] isEqual:[aUser name]])&#123; <span class="hljs-comment">//比较属性</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>    &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>实际上<code>NSString</code>就重写了此方法的实现，只要两个字符串对象中的值相同即返回真，参考<code>示例1</code>。</p><blockquote><p>If two objects are equal, they must have the same hash value. This last point is particularly important if you define isEqual: in a subclass and intend to put instances of that subclass into a collection. Make sure you also define hash in your subclass.</p></blockquote><p>两个对象相等时，它们的<code>hash</code>值一定相等，所以你往往也需要重写<code>hash</code>方法~</p><h3 id="7、集合与对象的引用关系"><a href="#7、集合与对象的引用关系" class="headerlink" title="7、集合与对象的引用关系"></a>7、集合与对象的引用关系</h3><p>常用的集合容器<code>NSArray</code>、<code>NSDictionary</code>、<code>NSSet</code>都是<code>强引用容器</code>，这些容器会强引用其内部的对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//Xcode中禁用ARC以便使用引用计数</span><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-built_in">NSObject</span> *obj = [[[<span class="hljs-built_in">NSObject</span> alloc] init] autorelease];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++1.obj:%p ++&amp;obj:%p ++obj.rc:%lu&quot;</span>,obj,&amp;obj,obj.retainCount);<br>        <br>        <span class="hljs-built_in">NSMutableArray</span> *array = [<span class="hljs-built_in">NSMutableArray</span> arrayWithCapacity:<span class="hljs-number">1</span>];<br>        [array addObject:obj];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++2.obj.rc:%lu&quot;</span>,obj.retainCount);<br>        <br>        [array removeAllObjects];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++3.obj.rc:%lu&quot;</span>,obj.retainCount);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">++<span class="hljs-number">1</span><span class="hljs-selector-class">.obj</span>:<span class="hljs-number">0</span>x600002449230 ++&amp;obj:<span class="hljs-number">0</span>x7ffee57fac60 ++obj<span class="hljs-selector-class">.rc</span>:<span class="hljs-number">1</span><br>++++<span class="hljs-number">2</span><span class="hljs-selector-class">.obj</span><span class="hljs-selector-class">.rc</span>:<span class="hljs-number">2</span><br>++++<span class="hljs-number">3</span><span class="hljs-selector-class">.obj</span><span class="hljs-selector-class">.rc</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>当对象被添加到集合中时，其引用计数会 +1；对象被移出集合时，其引用计数 -1。所以，实践中我们需要注意这种强引用关系及其可能引起的对象释放问题~</p><p>那么，怎么实现弱引用容器呢？</p><ul><li>方案1：使用 NSValue 提供的两个类方法类存取对象：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//保存对象时</span><br>NSValue *value = [NSValue valueWithNonretainedObject:myObj];<br><span class="hljs-string">[array addObject:value]</span>;<br><br><span class="hljs-comment">//读取对象时</span><br>value = [<span class="hljs-built_in">array</span> objectAtIndex:x];<br>myObj = [value pointerValue];<br></code></pre></td></tr></table></figure><p>#示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//Person.m</span><br>@implementation Person<br>-(void)dealloc&#123;<br>    <span class="hljs-literal">[<span class="hljs-identifier">super</span> <span class="hljs-identifier">dealloc</span>]</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++PERSON IS DEALLOCED~&quot;</span>)</span>;<br>&#125;<br>@<span class="hljs-keyword">end</span><br><br><span class="hljs-comment">//调用</span><br>- (BOOL)application:(UIApplication *)application<br>didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>&#123;<br>    @autoreleasepool &#123;<br>        Person *obj = <span class="hljs-literal">[[[P<span class="hljs-identifier">erson</span> <span class="hljs-identifier">alloc</span>]</span> init] autorelease];<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++1.obj:%p ++&amp;obj:%p ++obj.rc:%lu&quot;</span>,<span class="hljs-params">obj</span>,&amp;<span class="hljs-params">obj</span>,<span class="hljs-params">obj</span>.<span class="hljs-params">retainCount</span>)</span>;<br>        <br>        NSMutableArray *<span class="hljs-built_in">array</span> = <span class="hljs-literal">[NSM<span class="hljs-identifier">utableArray</span> <span class="hljs-identifier">arrayWithCapacity</span>:<span class="hljs-number">1</span>]</span>;<br>        NSValue *value = <span class="hljs-literal">[NSV<span class="hljs-identifier">alue</span> <span class="hljs-identifier">valueWithNonretainedObject</span>:<span class="hljs-identifier">obj</span>]</span>;<br>        <span class="hljs-literal">[<span class="hljs-identifier">array</span> <span class="hljs-identifier">addObject</span>:<span class="hljs-identifier">value</span>]</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++2.obj.rc:%lu&quot;</span>,<span class="hljs-params">obj</span>.<span class="hljs-params">retainCount</span>)</span>;<br>        <br>        <span class="hljs-keyword">for</span> (NSValue *valueN <span class="hljs-keyword">in</span> <span class="hljs-built_in">array</span>) &#123;<br>            Person<span class="hljs-operator"> * </span>objN = <span class="hljs-literal">[<span class="hljs-identifier">valueN</span> <span class="hljs-identifier">pointerValue</span>]</span>;<br>            <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++3.objN:%p ++&amp;objN:%p ++objN.rc:%lu&quot;</span>,<span class="hljs-params">objN</span>,&amp;<span class="hljs-params">objN</span>,<span class="hljs-params">objN</span>.<span class="hljs-params">retainCount</span>)</span>;<br>        &#125;<br>        <br>        obj = nil;<br>        <br>        <span class="hljs-keyword">for</span> (NSValue *valueN <span class="hljs-keyword">in</span> <span class="hljs-built_in">array</span>) &#123;<br>            Person<span class="hljs-operator"> * </span>objN = <span class="hljs-literal">[<span class="hljs-identifier">valueN</span> <span class="hljs-identifier">pointerValue</span>]</span>;<br>            <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++4.objN:%p ++&amp;objN:%p ++objN.rc:%lu&quot;</span>,<span class="hljs-params">objN</span>,&amp;<span class="hljs-params">objN</span>,<span class="hljs-params">objN</span>.<span class="hljs-params">retainCount</span>)</span>;<br>        &#125;<br>        <span class="hljs-literal">[<span class="hljs-identifier">array</span> <span class="hljs-identifier">removeAllObjects</span>]</span>;<br>        <br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++5.obj:%@ ++&amp;obj:%p ++obj.rc:%lu&quot;</span>,<span class="hljs-params">obj</span>,&amp;<span class="hljs-params">obj</span>,<span class="hljs-params">obj</span>.<span class="hljs-params">retainCount</span>)</span>;<br>    &#125;<br>    <br>    return YES;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">obj:0x60000323c9c0</span> <span class="hljs-literal">++</span><span class="hljs-comment">&amp;obj:0x7ffeeb5fec60</span> <span class="hljs-literal">++</span><span class="hljs-comment">obj</span><span class="hljs-string">.</span><span class="hljs-comment">rc:1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">2</span><span class="hljs-string">.</span><span class="hljs-comment">obj</span><span class="hljs-string">.</span><span class="hljs-comment">rc:1</span><br><span class="hljs-literal">++</span><span class="hljs-comment">3</span><span class="hljs-string">.</span><span class="hljs-comment">objN:0x60000323c9c0</span> <span class="hljs-literal">++</span><span class="hljs-comment">&amp;objN:0x7ffeeb5fec00</span> <span class="hljs-literal">++</span><span class="hljs-comment">objN</span><span class="hljs-string">.</span><span class="hljs-comment">rc:1</span><br><span class="hljs-literal">++</span><span class="hljs-comment">4</span><span class="hljs-string">.</span><span class="hljs-comment">objN:0x60000323c9c0</span> <span class="hljs-literal">++</span><span class="hljs-comment">&amp;objN:0x7ffeeb5febb0</span> <span class="hljs-literal">++</span><span class="hljs-comment">objN</span><span class="hljs-string">.</span><span class="hljs-comment">rc:1</span><br><span class="hljs-literal">++</span><span class="hljs-comment">5</span><span class="hljs-string">.</span><span class="hljs-comment">obj:(null)</span> <span class="hljs-literal">++</span><span class="hljs-comment">&amp;obj:0x7ffeeb5fec60</span> <span class="hljs-literal">++</span><span class="hljs-comment">obj</span><span class="hljs-string">.</span><span class="hljs-comment">rc:0</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">PERSON IS DEALLOCED~</span><br></code></pre></td></tr></table></figure><p>通过<code>NSValue</code>包装<code>obj</code>之后，即使添加到数组，<code>obj</code>的引用计数也不会增加，且当在数组外部将<code>obj</code>置为 nil 之后，<code>obj</code>对象会自动销毁。</p><h3 id="8、静态变量、静态常量"><a href="#8、静态变量、静态常量" class="headerlink" title="8、静态变量、静态常量"></a>8、静态变量、静态常量</h3><ul><li><strong>static</strong></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *aStaticString;<br></code></pre></td></tr></table></figure><p>修饰<code>局部变量</code>时，静态局部变量的作用范围为该函数体。它的值在编译期就会确定下来，并被存储到全局变量区。因此静态局部变量只会生成一份内存、只会初始化一次并供所有对象使用；静态局部变量的生命周期和程序相同，直到程序结束这个局部变量才会销毁。</p><p>修饰<code>全局变量</code>时，静态全局变量的作用域仅限于当前文件（.m），它也是被存储到全局变量区，生命周期与程序相同，程序结束时才会销毁。使用静态全局变量能避免在同一个文件中重复定义全局变量。</p><p>static 强调的是静态，变量只创建一次，直到程序结束才销毁。静态变量的值是可以更新的，并且只要某个对象对静态变量做了修改，所有的对象都能访问更新后的值。</p><ul><li><strong>const</strong></li></ul><p><code>const</code>修饰的是常量，强调的是变量的值不可变。常量在第一次赋值之后不能再修改。</p><p>在 OC 中一般是结合<code>static</code>使用，示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//用法1</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> * <span class="hljs-keyword">const</span> s1;<br><span class="hljs-comment">//用法2</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">NSString</span> * s2;<br><span class="hljs-comment">//用法3</span><br><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> <span class="hljs-keyword">const</span> * s3;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    s1 = <span class="hljs-string">@&quot;A&quot;</span>;<span class="hljs-comment">//编译时会报错</span><br>    s2 = <span class="hljs-string">@&quot;B&quot;</span>;<span class="hljs-comment">//编译正常</span><br>    s3 = <span class="hljs-string">@&quot;C&quot;</span>;<span class="hljs-comment">//编译正常</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中，<code>用法2</code>和<code>3</code>实质上是一样的。<code>用法1</code>和<code>2</code>的区别，用英语表达会更直观一些：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> * <span class="hljs-keyword">const</span> s1;<br></code></pre></td></tr></table></figure><p><code>指针常量</code>，A constant pointer (not modifiable) to an NSString object (its value can be modified)。这里的<code>s1</code>是一个字符串对象的指针，因此 const 修饰的是指针，即指针为常量不能修改，但指针指向的值是可以修改的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">NSString</span> * s2;<br></code></pre></td></tr></table></figure><p><code>常量指针</code>，A modifiable pointer to a constant NSString object (its value can’t be modified)。这里<code>s2</code>和<code>s3</code>是指针，<code>*s2</code>和<code>*s3</code>是指针指向的值，const 修饰的是值，即值不可变，但字符串对象可以修改其指针，重新取别的值。</p><h3 id="9、分类与扩展"><a href="#9、分类与扩展" class="headerlink" title="9、分类与扩展"></a>9、分类与扩展</h3><p><strong>代码组织形式上</strong>：</p><p>扩展通常是定义在原类的<code>m</code>文件中；而分类既可以定义在原类的<code>h</code>和<code>m</code>文件中，又可以存在于单独的<code>h</code>和<code>m</code>文件中，分类组织的方式不同导入的方式也会不同。从命名上来看，扩展相当于未命名的分类。</p><p><strong>方法定义上</strong>：</p><p>分类和扩展中都可以定义方法以达到扩展现有类的方法列表之目的，不同的是扩展中定义的方法必须在原类的<code>m</code>文件中提供实现；分类中定义的方法则不依赖于原类的实现文件，而是在自己的<code>@implementation</code>中提供实现，也就是说分类可以在不知道原类具体实现的情况下对原类进行扩展。另外，分类中可以重写原类的方法，重写后实例就不能访问原来的方法了。</p><p><strong>成员变量定义上</strong>：</p><p>扩展中可以定义成员变量，并且这些变量只对本类可见；分类中则不能定义成员变量，因为分类与原类的内存空间相互独立，原类初始化后实例大小已确定，不能再添加成员变量。</p><p><strong>属性定义上</strong>：</p><p>分类和扩展都可以定义属性，不同的是扩展中的属性会由编译器自动提供存取器；而分类中虽然定义了属性，编译器却不会为其提供存取器，需要我们自己通过<code>对象绑定机制</code>主动实现。</p><h3 id="10、URL缓存策略"><a href="#10、URL缓存策略" class="headerlink" title="10、URL缓存策略"></a>10、URL缓存策略</h3><p>NSURLRequestCachePolicy 用来指定网络请求的缓存策略，具体的枚举和作用如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">NSURLRequestUseProtocolCachePolicy</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>默认缓存策略，当客户端发起一个请求时，首先检查本地是否有缓存(NSCachedURLResponse)。如果没有缓存，则直接从服务器处获取；如果有缓存，则继续检查缓存是否过期（通过Cache-Control:max-age或者Expires）。如果没有过期，则直接使用缓存数据；如果缓存过期了，则向服务器发起一个请求，服务器会对比它保存的资源的 Last-Modified 或者 Etags 字段(二者都存在的情况下下如果有一个不同则认为缓存已过期)，如果不同则返回新数据，否则返回 304 Not Modified 并继续使用缓存数据（客户端可以再使用”max-age”秒缓存数据）。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">NSURLRequestReloadIgnoringLocalCacheData</span> <span class="hljs-operator">=</span> NSURLRequestReloadIgnoringCacheData <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>不使用缓存，直接从服务器请求原始数据。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">NSURLRequestReturnCacheDataElseLoad</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>无论缓存是否过期，有缓存则使用缓存，否则重新请求原始数据。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">NSURLRequestReturnCacheDataDontLoad</span> = <span class="hljs-number">3</span>, <br></code></pre></td></tr></table></figure><p>有缓存则使用缓存，无论缓存是否过期；无缓存则视为失败，不会重新请求原始数据，类似于离线模式。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">NSURLRequestReloadIgnoringLocalAndRemoteCacheData</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> //Unimplemented<br></code></pre></td></tr></table></figure><p>本地缓存、代理和其他中介都要忽视他们的缓存，直接加载源数据。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">NSURLRequestReloadRevalidatingCacheData</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span> //Unimplemented<br></code></pre></td></tr></table></figure><p>向服务器发送一个请求，如果服务器确认缓存有效，则继续使用缓存，否则从源段加载数据。</p><p>使用缓存的目的是为了降低对网络连接的依赖，减少对相同 URL 的多次请求，提高应用的响应速度。这里所说的缓存是指对 URL 请求响应体(NSCachedURLResponse)的缓存。iOS 中响应的缓存是通过 <a href="https://developer.apple.com/documentation/foundation/urlcache">NSURLCache</a> 来实现的，它会将<code>NSURLRequest</code>与<code>NSCachedURLResponse</code>进行映射，并保存在内存和磁盘中。你甚至可以指定两片缓存的容量大小和存储路径。</p><hr><p>相关参考：</p><p>#<a href="https://stackoverflow.com/questions/22953091/difference-between-nsstring-const-and-const-nsstring">©Stack Overflow</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FAQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>atomic线程安全吗？</title>
    <link href="/2017/11/24/atomic.html"/>
    <url>/2017/11/24/atomic.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是线程安全？"><a href="#1-什么是线程安全？" class="headerlink" title="1.什么是线程安全？"></a>1.什么是线程安全？</h3><blockquote><p>线程安全，是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p></blockquote><h3 id="2-atomic与nonatomic的区别"><a href="#2-atomic与nonatomic的区别" class="headerlink" title="2.atomic与nonatomic的区别"></a>2.atomic与nonatomic的区别</h3><p>atomic 与 nonatomic 的本质区别在于<code>getter</code>、<code>setter</code>方法实现上的不同：</p><p>#示例1：nonatomic属性的实现</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//@property(nonatomic, retain) NSMutableArray *mutArr;</span><br>- (NSMutableArray *)mutArr <br>&#123;<br>    <span class="hljs-keyword">return</span> _mutArr;<br>&#125;<br><br>- (void)setMutArr:<span class="hljs-type"></span>(NSMutableArray *)<span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> <br>&#123;<br>    [<span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> retain];<br>    [_mutArr release];<br>    _mutArr = <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>#示例2：atomic属性的实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//@property(retain) NSMutableArray *mutArr;</span><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mutArr <br>&#123;<br>    <span class="hljs-keyword">@synchronized</span>(<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">return</span> _mutArr;<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)setMutArr:(<span class="hljs-built_in">NSMutableArray</span> *)newArr<br>&#123;<br>    <span class="hljs-keyword">@synchronized</span>(<span class="hljs-keyword">self</span>) &#123;<br>      [_mutArr release];<br>      _mutArr = [newArr <span class="hljs-keyword">retain</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>nonatomic 修饰的对象不保证<code>setter</code>和<code>getter</code>的完整性，多线程访问它时可能会返回未初始化的对象。nonatomic 比 atomic 快，但它不是线程安全的。</p><p>atomic 修饰的对象会保证<code>setter</code>和<code>getter</code>的完整性，任何线程对其访问都可以得到一个完整的初始化后的对象。例如有多个线程同时调用<code>setter</code>，不会出现某个线程执行完<code>setter</code>全部语句之前，另一个线程开始执行<code>setter</code>情况，相当于函数头尾加了锁一样。</p><h3 id="3-atomic与真正的线程安全"><a href="#3-atomic与真正的线程安全" class="headerlink" title="3.atomic与真正的线程安全"></a>3.atomic与真正的线程安全</h3><p>atomic 只保证了属性的存取方法是完整的，但并不保证整个属性”对象”是线程安全的，因为别的线程还能进行其他操作。比如，<code>线程A</code>执行 <code>[self.mutArr addObject:obj];</code>，同一时间<code>线程B</code>执行<code>self.mutArr[index]</code>就不是线程安全的。多个线程同时调用<code>setter</code>和<code>getter</code>时获得的对象值可能会不一样，甚至发生崩溃。想要绝对的线程安全就要用到线程的同步机制，比如使用<code>NSLock</code>、<code>@synchronized</code>等加锁。</p><p>#示例3：数据同步（加锁）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (atomic, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *mArr;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">self</span>.mArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObjects:<span class="hljs-string">@&quot;1&quot;</span>,<span class="hljs-string">@&quot;2&quot;</span>,<span class="hljs-string">@&quot;3&quot;</span>,<span class="hljs-string">@&quot;4&quot;</span>, <span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-built_in">NSOperationQueue</span> * queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    queue.maxConcurrentOperationCount = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">//NSLock *aLock = [[NSLock alloc] init];</span><br>    <br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-built_in">NSBlockOperation</span> * operation1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>        <span class="hljs-comment">//[aLock lock];</span><br>        <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">NSString</span> * str <span class="hljs-keyword">in</span> strongSelf.mArr)&#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1读数据:%@&quot;</span>,str);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//[aLock unlock];</span><br>    &#125;];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> * operation2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>        <span class="hljs-comment">//[aLock lock];</span><br>        <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSInteger</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                <span class="hljs-built_in">NSString</span> *str = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;%@%ld&quot;</span>,<span class="hljs-string">@&quot;字符串&quot;</span>,i];<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++2写数据:%@&quot;</span>,str);<br>                [strongSelf.mArr addObject:str];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//[aLock unlock];</span><br>    &#125;];<br><br>    <span class="hljs-built_in">NSBlockOperation</span> * operation3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>        <span class="hljs-comment">//[aLock lock];</span><br>        <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">NSString</span> * str <span class="hljs-keyword">in</span> strongSelf.mArr)&#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3读数据:%@&quot;</span>,str);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//[aLock unlock];</span><br>    &#125;];<br>    <br>    [queue addOperation:operation1];<br>    [queue addOperation:operation2];<br>    [queue addOperation:operation3];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例中，数组被定义为 atomic 的属性，但是在不加锁的情况下，会出现崩溃，报错“Collection &lt;__NSArrayM: 0x60000024a8f0&gt; was mutated while being enumerated.”，说明 atomic 对象并不是线程安全的。示例中提供了两种数据同步的方式，一种是使用<code>NSLock</code>进行加锁，另一种是使用<code>@synchronized</code>加锁，两种都可以保证数组对象的线程安全。</p><p>综上，在无需考虑多线程的情况下使用 nonatomic，它能让编译器少生成一些加锁的代码，提高读写效率。在多线程环境下使用 atomic，同时配合加锁，防止产生该变量读写等操作的同步问题。</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-Native交互</title>
    <link href="/2017/11/23/js-native.html"/>
    <url>/2017/11/23/js-native.html</url>
    
    <content type="html"><![CDATA[<p>移动开发中经常会用到网页，例如活动信息展示并响应网页中的Click事件。这个交互的过程就涉及到js与OC或Swift的相互调用，这里OC或Swift就统称为Native，即原生应用。本文总结了三种最常见的js-Native交互实现方案并附上代码。</p><p>场景：点击网页按钮，跳转到Native支付页面，在网页中显示支付结果。</p><h3 id="一-拦截URL"><a href="#一-拦截URL" class="headerlink" title="一.拦截URL"></a>一.拦截URL</h3><h4 id="1-Native-gt-js"><a href="#1-Native-gt-js" class="headerlink" title="1.Native-&gt;js"></a>1.Native-&gt;js</h4><p>Native调用js主要是通过<code>stringByEvaluatingJavaScriptFromString</code>方法。</p><ul><li>代码：</li></ul><p>这是本地<code>pay.html</code>网页代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--显示native调用js后的结果--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>pay result: <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//js方法，供native调    native-&gt;h5</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">payResult</span>(<span class="hljs-params">result</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;pay result: &#x27;</span> + result;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Native中加载HTML并调用其定义的js方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DKUIWebViewController</span> ()&lt;<span class="hljs-title">UIWebViewDelegate</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIWebView</span> *mUIWebview;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DKUIWebViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">//加载本地网页</span><br>    <span class="hljs-built_in">NSString</span> *path = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@&quot;pay&quot;</span> ofType:<span class="hljs-string">@&quot;html&quot;</span>];<br>    <span class="hljs-built_in">NSURLRequest</span> *request = [<span class="hljs-built_in">NSURLRequest</span> requestWithURL:<br>                             [<span class="hljs-built_in">NSURL</span> fileURLWithPath:path]];<br>    [_mUIWebview loadRequest:request];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> -mark UIWebviewDelegate</span><br>-(<span class="hljs-type">void</span>)webViewDidFinishLoad:(<span class="hljs-built_in">UIWebView</span> *)webView&#123;<br>    <span class="hljs-comment">//native调用js 显示支付结果</span><br>    [_mUIWebview stringByEvaluatingJavaScriptFromString:<span class="hljs-string">@&quot;payResult(&#x27;succeed&#x27;)&quot;</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="2-js-gt-Native"><a href="#2-js-gt-Native" class="headerlink" title="2.js-&gt;Native"></a>2.js-&gt;Native</h4><p>在<code>shouldStartLoadWithRequest:</code>回调中监听<code>a</code>标签跳转事件。</p><ul><li>代码：</li></ul><p>修改本地<code>pay.html</code>代码，加入<code>a</code>标签跳转：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--定义a标签，跳转特殊url供native监听 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;router://pay&quot;</span>&gt;</span>pay<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-comment">&lt;!--显示native调用js后的结果--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>pay result: <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//js方法，供native调    native-&gt;h5</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">payResult</span>(<span class="hljs-params">result</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;pay result: &#x27;</span> + result;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Native网页中监听<code>a</code>标签事件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> -mark UIWebviewDelegate</span><br>- (<span class="hljs-type">BOOL</span>)webView:(<span class="hljs-built_in">UIWebView</span> *)webView<br>shouldStartLoadWithRequest:(<span class="hljs-built_in">NSURLRequest</span> *)request<br> navigationType:(<span class="hljs-built_in">UIWebViewNavigationType</span>)navigationType<br>&#123;<br>    <span class="hljs-comment">//拦截请求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">UIWebViewNavigationTypeLinkClicked</span> == navigationType) &#123;<br>        <span class="hljs-keyword">if</span> ([request.URL.absoluteString rangeOfString:<span class="hljs-string">@&quot;router://pay&quot;</span>].location != <span class="hljs-built_in">NSNotFound</span>) &#123;<br>            <span class="hljs-comment">//native处理逻辑</span><br><br>            DKPayController *controller = [[DKPayController alloc] init];<br>            [<span class="hljs-keyword">self</span>.navigationController pushViewController:controller animated:<span class="hljs-literal">YES</span>];<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>点击网页中<code>a</code>标签，Native中监听到<code>router://pay</code>跳转请求后，本地跳转到支付页面。</p><h3 id="二-JavaScriptCore"><a href="#二-JavaScriptCore" class="headerlink" title="二.JavaScriptCore"></a>二.JavaScriptCore</h3><p>往网页中传入一个<code>javaScriptContext</code>对象，利用它作为<code>bridge</code>中介实现js与Native的交互。注意：这只适用于<code>UIWebView</code>。</p><h4 id="1-JSExport"><a href="#1-JSExport" class="headerlink" title="1.JSExport"></a>1.JSExport</h4><p><code>JSExport</code>是<code>JavaScriptCore</code>库提供的一个协议，此协议中可定义一些接口，供js调用。</p><h4 id="2-js-gt-Native-1"><a href="#2-js-gt-Native-1" class="headerlink" title="2.js-&gt;Native"></a>2.js-&gt;Native</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span><br><br><span class="hljs-comment">//声明一个协议，继承并扩展JSExport协议</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">JSOCExportProtocol</span> &lt;<span class="hljs-title">JSExport</span>&gt;</span><br><span class="hljs-comment">//声明属性</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-comment">//声明供js回调的OC方法</span><br>- (<span class="hljs-type">void</span>)pay;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//实现JSExport协议，这就是注册JSContext时传递的对象</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JSOCHelper</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">JSOCExportProtocol</span>&gt;</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithSource:(<span class="hljs-built_in">UIViewController</span>*)viewController;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;JSOCHelper.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">JSOCHelper</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-built_in">UIViewController</span> *viewController;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">JSOCHelper</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithSource:(<span class="hljs-built_in">UIViewController</span> *)viewController<br>&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.viewController = viewController;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -JSExport Delegate methods</span><br>- (<span class="hljs-type">void</span>)pay&#123;<br>    <span class="hljs-comment">//调用self.viewController的协议方法</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++JS call OC: Go to Pay !&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>上面是自定义的JSOCHelper类，其中的<code>JSOCExportProtocol</code>协议实现了<code>JSExport</code>协议，在这里定义了一些供js调用的接口并提供对应的实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;JSOCHelper.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DKUIWebViewController</span> ()&lt;<span class="hljs-title">UIWebViewDelegate</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIWebView</span> *mUIWebview;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) JSContext *jsContext;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DKUIWebViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    <span class="hljs-comment">//加载本地网页</span><br>    <span class="hljs-built_in">NSString</span> *path = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@&quot;pay&quot;</span> ofType:<span class="hljs-string">@&quot;html&quot;</span>];<br>    <span class="hljs-built_in">NSURLRequest</span> *request = [<span class="hljs-built_in">NSURLRequest</span> requestWithURL:<br>                             [<span class="hljs-built_in">NSURL</span> fileURLWithPath:path]];<br>    [_mUIWebview loadRequest:request];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> -mark UIWebviewDelegate</span><br>-(<span class="hljs-type">void</span>)webViewDidFinishLoad:(<span class="hljs-built_in">UIWebView</span> *)webView<br>&#123;<br>    <span class="hljs-comment">//获取JavaScriptContext对象</span><br>    _jsContext = [webView valueForKeyPath:<span class="hljs-string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];<br>    <span class="hljs-comment">//为JavaScriptContext注入Bridge对象</span><br>    _jsContext[<span class="hljs-string">@&quot;jsbridge&quot;</span>] = [[JSOCHelper alloc] initWithSource:<span class="hljs-keyword">self</span>];<br>    <br>    <span class="hljs-comment">//往js中注入新的login函数，block为其对应的OC回调</span><br>    _jsContext[<span class="hljs-string">@&quot;login&quot;</span>] = ^(<span class="hljs-type">id</span> data,<span class="hljs-built_in">NSString</span> *error)&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++++js call jsContext block, data:%@,error:%@&quot;</span>,data,error);<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>上面是Native部分的代码，主要是在合适的时机往web中注入一个<code>jsbridge</code>对象，后面点击网页中的按钮时，js可通过这个对象直接调用Native函数。</p><p>你也可以往这个<code>jsbridge</code>中绑定新的<code>js方法</code>和与其对应的Native<code>回调</code>，后面Native调用此js方法时会自动触发与其绑定的回调。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--支付按钮--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pay&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;pay()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-comment">&lt;!--显示native调用js后的结果--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>pay result: <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//调用Native的方法   js-&gt;native</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        jsbridge.<span class="hljs-title function_">pay</span>();</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">//js方法，供native调    native-&gt;js</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">payResult</span>(<span class="hljs-params">result</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;pay result: &#x27;</span> + result;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是新的<code>pay.html</code>网页，增加了一个按钮，用来调用Native的方法。</p><p>点击网页中的<code>pay</code>按钮，js即会通过我们在<code>webViewDidFinishLoad</code>中早先传入的jsbridge对象，直接调用Native的<code>pay</code>方法，即JSOCHelper中定义好的协议方法。</p><h4 id="3-Native-gt-js"><a href="#3-Native-gt-js" class="headerlink" title="3.Native-&gt;js"></a>3.Native-&gt;js</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DKUIWebViewController</span> ()&lt;<span class="hljs-title">UIWebViewDelegate</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">UIWebView</span> *mUIWebview;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) JSContext *jsContext;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DKUIWebViewController</span></span><br><br>...<br><br>- (<span class="hljs-type">void</span>)nativeCallJS&#123;<br>    <span class="hljs-comment">//native调用js</span><br>    <span class="hljs-comment">//方法1</span><br>    JSValue *jsFunc = _jsContext[<span class="hljs-string">@&quot;login&quot;</span>];<span class="hljs-comment">//调用上面注册的block</span><br>    [jsFunc callWithArguments:@[<span class="hljs-string">@&quot;data&quot;</span>,<span class="hljs-string">@&quot;call by JSValue Error info&quot;</span>]];<br>    <span class="hljs-comment">//方法2</span><br>    [_jsContext evaluateScript:<span class="hljs-string">@&quot;login(&#x27;data&#x27;,&#x27;call by [jsContext evaluateScript:] Error info&#x27;)&quot;</span>];<span class="hljs-comment">//native调用JS中定义的登录方法</span><br>    <span class="hljs-comment">//方法3</span><br>    <span class="hljs-built_in">NSString</span> *jsFuncScript = <span class="hljs-string">@&quot;login(&#x27;data&#x27;,&#x27;Error info~&#x27;)&quot;</span>;<br>    [_mUIWebview stringByEvaluatingJavaScriptFromString:jsFuncScript];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>前两个是<code>JavaScriptCore</code>提供的接口，<code>方法3</code>是我们最熟悉的webview调用js的方法。</p><h3 id="三-WKWebView"><a href="#三-WKWebView" class="headerlink" title="三.WKWebView"></a>三.WKWebView</h3><h4 id="1-WKScriptMessageHandler"><a href="#1-WKScriptMessageHandler" class="headerlink" title="1.WKScriptMessageHandler"></a>1.WKScriptMessageHandler</h4><p>这是<code>WKWebView</code>中用来进行js与Native交互的主要媒介，我们需要往web中注入一个或多个<code>MessageHandler</code>对象处理不同的来自js对Native的调用。</p><p>它是一个协议并且只有一个代理方法。我们需要定义一个类实现此协议及其代理函数，通过区分每个<code>handler</code>的名字来调用与之对应的Native函数。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//.h文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;WebKit/WebKit.h&gt;</span></span><br><br><span class="hljs-comment">//宏定义WKScriptMessage对象的名字</span><br><span class="hljs-built_in">UIKIT_EXTERN</span> <span class="hljs-built_in">NSString</span> * <span class="hljs-keyword">const</span> <span class="hljs-built_in">WK_MethodName</span>;<br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DKWKScriptMessageHandler</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">WKScriptMessageHandler</span>&gt;</span><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//.m文件</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DKWKScriptMessageHandler.h&quot;</span></span><br><span class="hljs-built_in">NSString</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">WK_MethodName</span> = <span class="hljs-string">@&quot;pay&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DKWKScriptMessageHandler</span></span><br><br><span class="hljs-comment">//实现代理，js调用native时会回调到这里</span><br>- (<span class="hljs-type">void</span>)userContentController:(<span class="hljs-built_in">WKUserContentController</span> *)userContentController<br>      didReceiveScriptMessage:(<span class="hljs-built_in">WKScriptMessage</span> *)message &#123;<br><br>    <span class="hljs-comment">//可以定义多个message handler处理来自js的不同任务，这里需要区分其名字</span><br>    <span class="hljs-keyword">if</span> ([message.name isEqualToString:<span class="hljs-built_in">WK_MethodName</span>]) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++WK Script message:%@&quot;</span>,message.body);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h4 id="2-js-gt-Native-2"><a href="#2-js-gt-Native-2" class="headerlink" title="2.js-&gt;Native"></a>2.js-&gt;Native</h4><p>先看网页端的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--支付按钮--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;pay&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;pay()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br><span class="hljs-comment">&lt;!--显示native调用js后的结果--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span>pay result: <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br> <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">//调用Native的方法   js-&gt;native</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">webkit</span>.<span class="hljs-property">messageHandlers</span>.<span class="hljs-property">pay</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;￥100&#x27;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-comment">//js方法，供native调    native-&gt;js</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">payResult</span>(<span class="hljs-params">result</span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;result&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;pay result: &#x27;</span> + result;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>第10行，js通过<code>window.webkit.messageHandlers</code>获取处理交互的媒介：<code>messageHandlers</code>。从其采用复数形式可知，Native在与js交互时可能会注册多个<code>messageHandler</code>；</p><p><code>.pay</code>是指定具体的<code>messageHandler</code>：</p><p><code>postMessage(&#39;￥100&#39;)</code>是向<code>handler</code>发送消息和传递参数；</p><p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p><p>再来看Native端的代码，往web中注入多个<code>MessageHandler</code>对象来处理不同任务：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;WebKit/WebKit.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DKWKScriptMessageHandler.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">DKWKWebViewController</span> ()&lt;<span class="hljs-title">WKNavigationDelegate</span>,<span class="hljs-title">WKUIDelegate</span>&gt;</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">weak</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">IBOutlet</span> <span class="hljs-built_in">WKWebView</span> *mWKWebview;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) DKWKScriptMessageHandler *mScriptMessHandler;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DKWKWebViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    _mWKWebview.navigationDelegate = <span class="hljs-keyword">self</span>;<br>    _mWKWebview.UIDelegate = <span class="hljs-keyword">self</span>;<br>    <br>    <span class="hljs-comment">//向webview注入MessHandler（可以注册多个MessHandler）</span><br>    _mScriptMessHandler = [DKWKScriptMessageHandler new];<br>    [_mWKWebview.configuration.userContentController addScriptMessageHandler:_mScriptMessHandler name:<span class="hljs-built_in">WK_MethodName</span>];<br>    <span class="hljs-comment">//加载本地网页</span><br>    <span class="hljs-built_in">NSString</span> *path = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@&quot;jsbridge_pay&quot;</span> ofType:<span class="hljs-string">@&quot;html&quot;</span>];<br>    <span class="hljs-built_in">NSURLRequest</span> *request = [<span class="hljs-built_in">NSURLRequest</span> requestWithURL:<br>                             [<span class="hljs-built_in">NSURL</span> fileURLWithPath:path]];<br>    [_mWKWebview loadRequest:request];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)viewDidDisappear:(<span class="hljs-type">BOOL</span>)animated&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidDisappear:animated];<br>    [<span class="hljs-keyword">self</span> removeMessageHandler];<br>&#125;<br><br>-(<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++DKWKWebViewController dealloced~&quot;</span>);<br>    [_mWKWebview.configuration.userContentController removeScriptMessageHandlerForName:<span class="hljs-built_in">WK_MethodName</span>];<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> -mark BUSINESS</span><br>- (<span class="hljs-type">void</span>)removeMessageHandler &#123;<br>    <span class="hljs-comment">//离开时调用 否则会造成内存泄漏</span><br>    _mScriptMessHandler = <span class="hljs-literal">nil</span>;<br>    [_mWKWebview.configuration.userContentController removeScriptMessageHandlerForName:<span class="hljs-built_in">WK_MethodName</span>];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>此时点击网页上的<code>pay</code>按钮，即会触发js方法<code>pay()</code>并调用其中的<code>window.webkit.messageHandlers.pay.postMessage(&#39;￥100&#39;);</code>，接着<code>DKWKScriptMessageHandler</code>的代理函数被触发，通过区分不同<code>handler</code>的名字来调用不同的Native函数处理本地业务逻辑。</p><h4 id="3-Native-gt-js-1"><a href="#3-Native-gt-js-1" class="headerlink" title="3.Native-&gt;js"></a>3.Native-&gt;js</h4><p>WK中Native调js很简单，与UIWebview类似，只不过多了回调block：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DKWKWebViewController</span></span><br>...<br><br>- (<span class="hljs-type">void</span>)nativeCallJs&#123;<br>    <span class="hljs-comment">//native调用js中定义的函数</span><br>    <span class="hljs-built_in">NSString</span> *jsFuncScript = <span class="hljs-string">@&quot;payResult(&#x27;Succeed&#x27;)&quot;</span>;<br>    [_mWKWebview evaluateJavaScript:jsFuncScript completionHandler:^(<span class="hljs-type">id</span> _Nullable data, <span class="hljs-built_in">NSError</span> * _Nullable error) &#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++WKWebview执行js：%@&quot;</span>,jsFuncScript);<br>    &#125;];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><h3 id="四-结尾"><a href="#四-结尾" class="headerlink" title="四.结尾"></a>四.结尾</h3><p>以上三者是直接利用系统提供的API来实现js与Native的交互，每种方法都有自己的局限：</p><p>拦截URL的做法最笨，只适合少量<code>a</code>标签或重定向跳转场景；</p><p>JavaScriptCore只适用于UIWebView，而WKScriptMessageHandler又只适用于WKWebView；</p><p>所以看起来急需一种整合方案，Github上有类似 WebViewJavascriptBridge 这种开源库，待我后续研究研究~</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八大锁</title>
    <link href="/2017/11/21/lock.html"/>
    <url>/2017/11/21/lock.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>临界资源：</p><ul><li>在进程层面，一次仅允许一个进程使用的资源称为临界资源，如打印机等物理设备；</li><li>在线程层面，多线程环境中一次仅允许一个线程使用的变量等就是临界资源；</li></ul><p>临界区：</p><p>一个访问共享资源的程序代码片段就是临界区。当有线程进入临界区时，其他线程须保持等待。</p><p>锁：</p><p>是一种强行限制资源访问的同步机制，在并发控制中保证互斥的要求，用来防止多线程环境中对临界资源的脏读或者脏写。从某种角度而言，锁也可以看作是临界资源，线程获取到该锁对象之后才能执行里面的代码。</p><h3 id="2-锁的分类"><a href="#2-锁的分类" class="headerlink" title="2.锁的分类"></a>2.锁的分类</h3><ul><li>Mutex 互斥锁</li><li>Spin lock 自旋锁</li><li>Condition Variable 条件变量</li><li>Read&#x2F;Write lock 读写锁</li></ul><h4 id="2-1-互斥锁"><a href="#2-1-互斥锁" class="headerlink" title="2.1.互斥锁"></a>2.1.互斥锁</h4><p>属于<code>sleep-waiting</code>类型，在申请上锁时如果锁已经被别的单元持有，则会让该线程睡眠，待锁释放时被唤醒。但线程的休眠和唤醒需要大量的CPU指令，因此需要花费一些时间。</p><h4 id="2-2-自旋锁"><a href="#2-2-自旋锁" class="headerlink" title="2.2.自旋锁"></a>2.2.自旋锁</h4><p>属于<code>busy-waiting</code>类型，在申请上锁时如果锁已经被别的单元保持，并不是睡眠等待唤醒，而是循环检测保持者是否释放了锁。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。相对的，由于自旋锁一直占用CPU，所以如果长时间不能获得锁，则会降低CPU的使用效率。此锁比较适用于锁的持有者保存时间较短的情况下。</p><p>场景举例：</p><p>互斥锁：在某双核心的机器上有AB两个线程，分别运行在<code>核心0</code>与<code>核心1</code>上。若线程A想要通过<code>pthread_mutex_lock</code>去得到一个临界区的锁，而这个锁此时正被线程B所持有，则线程A就会被阻塞，<code>核心0</code>会切换上下文，将线程A置于等待队列中不再占用<code>核心0</code>，此时<code>核心0</code>就可以运行其他的任务，例如另一个线程C的任务。</p><p>自旋锁：如果线程A是使用<code>pthread_spin_lock</code>操作去请求锁，那么线程A就会一直在<code>核心0</code>上忙等待并不停的请求锁，直到得到这个锁为止。</p><h4 id="2-3-读写锁"><a href="#2-3-读写锁" class="headerlink" title="2.3.读写锁"></a>2.3.读写锁</h4><p>高级别锁，区分读和写：</p><ul><li>一个读写锁允许多个线程同时读某共享资源；</li><li>写操作具有排他性，写入数据时不允许其他线程对共享资源进行读或写。</li></ul><p>读写锁适用于大量读少量写的环境，其效率相对普通的互斥锁和自旋锁要慢一个数量级。</p><h3 id="3-八大锁"><a href="#3-八大锁" class="headerlink" title="3.八大锁"></a>3.八大锁</h3><p>按照性能排序，从高到低：</p><ol><li>OSSpinLock</li><li>dispatch_semaphore</li><li>pthread_mutex</li><li>NSLock</li><li>NSCondition</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ol><h3 id="4-自旋锁"><a href="#4-自旋锁" class="headerlink" title="4.自旋锁"></a>4.自旋锁</h3><h4 id="4-1-OSSpinLock"><a href="#4-1-OSSpinLock" class="headerlink" title="4.1.OSSpinLock"></a>4.1.OSSpinLock</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//需要导入：#import &lt;libkern/OSAtomic.h&gt;</span><br><span class="hljs-comment">//OSSpinLock 自旋锁</span><br>- (void)OSSpinLock<br>&#123;<br>    __block OSSpinLock oslock = OS_SPINLOCK_INIT;<br>    <span class="hljs-comment">//线程1</span><br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程1 上锁&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockLock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        sleep(<span class="hljs-number">4</span>);<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程1执行任务....&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockUnlock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程1 解锁&quot;</span>)</span>;<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程2</span><br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程2 上锁&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockLock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程2执行任务....&quot;</span>)</span>;<br>        <span class="hljs-constructor">OSSpinLockUnlock(&amp;<span class="hljs-params">oslock</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++线程2 解锁&quot;</span>)</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 解锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 解锁</span><br></code></pre></td></tr></table></figure><p><strong>ps：</strong>此自旋锁存在优先级反转问题，iOS10 之后苹果推出了<code>os_unfair_lock</code>来替代它。</p><p>关于优先级反转问题，<a href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC/4945202">百度百科</a> 有更详细的介绍：</p><blockquote><p>优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。</p></blockquote><blockquote><p>例如：有优先级为A、B和C三个任务，优先级A&gt;B&gt;C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。</p></blockquote><h4 id="4-2-os-unfair-lock"><a href="#4-2-os-unfair-lock" class="headerlink" title="4.2.os_unfair_lock"></a>4.2.os_unfair_lock</h4><p><code>OSSpinLock</code>自旋锁存在优先级反转的问题，iOS10.0之后被废弃，由os_unfair_lock（不公平的锁）代替。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">os_unfair_lock_t unfairLock;<br>unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);<br>os<span class="hljs-constructor">_unfair_lock_lock(<span class="hljs-params">unfairLock</span>)</span>;<br>os<span class="hljs-constructor">_unfair_lock_unlock(<span class="hljs-params">unfairLock</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-互斥锁"><a href="#5-互斥锁" class="headerlink" title="5.互斥锁"></a>5.互斥锁</h3><h4 id="5-1-pthread-mutex"><a href="#5-1-pthread-mutex" class="headerlink" title="5.1.pthread_mutex"></a>5.1.pthread_mutex</h4><p>pthread_mutex 是 C 语言下多线程加互斥锁的方式，需要 <code>#import &lt;pthread.h&gt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss">- (void)pthread_mutex_Test<br>&#123;<br>    static pthread_mutex_t pLock;<br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;pLock, NULL);<br>    <span class="hljs-comment">//线程1</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">1</span> 上锁&quot;);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pLock);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">1</span> 执行任务....&quot;);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pLock);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">1</span> 解锁&quot;);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程2</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">2</span> 上锁&quot;);<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;pLock);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">2</span> 执行任务....&quot;);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;pLock);<br>        <span class="hljs-built_in">NSLog</span>(@&quot;++++线程<span class="hljs-number">2</span> 解锁&quot;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 解锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 解锁</span><br></code></pre></td></tr></table></figure><p><strong>使用案例：开源图片下载和缓存框架PINRemoteImage</strong>。</p><h4 id="5-2-NSLock"><a href="#5-2-NSLock" class="headerlink" title="5.2.NSLock"></a>5.2.NSLock</h4><p>NSLock 遵循 NSLocking 协议的互斥锁，通过<code>lock</code>与<code>unlock</code>配合使用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSLock</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSLocking</span>&gt;</span><br>&#123;<br><span class="hljs-keyword">@private</span><br><span class="hljs-type">void</span> *_priv;<br>&#125;<br>- (<span class="hljs-type">BOOL</span>)tryLock;<br>- (<span class="hljs-type">BOOL</span>)lockBeforeDate:(<span class="hljs-built_in">NSDate</span> *)limit;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>互斥锁会使得线程阻塞，阻塞的过程又分两个阶段，第一阶段是会先空转，可以理解成跑一个 while 循环，不断地去申请加锁，在空转一定时间之后，线程会进入 <code>waiting</code> 状态，此时线程就不占用CPU资源了，等锁可用的时候，这个线程会立即被唤醒。</p><p><code>tryLock</code> 则不会阻塞线程，如果获取锁成功则返回YES，获取失败则返回NO。这个方法无论如何都会立即返回，在拿不到锁时不会一直在那等待。</p><p><code>lockBeforeDate:</code> 方法会在所指定 Date 之前尝试加锁，会阻塞线程。</p><p><strong>ps:</strong> 如果使用 NSLock 连续锁定两次，则会造成死锁。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)nslockTest<br>&#123;<br>    <span class="hljs-built_in">NSLock</span> *nslock = [<span class="hljs-built_in">NSLock</span> new];<br>    <span class="hljs-comment">//线程1</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程1 上锁&quot;</span>);<br>        [nslock lock];<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程1执行任务....&quot;</span>);<br>        [nslock unlock];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程1 解锁&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程2</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2 上锁&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">BOOL</span> succed = [nslock tryLock];<br>        <span class="hljs-keyword">if</span> (succed) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2上锁成功&quot;</span>);<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2执行任务....&quot;</span>);<br>            [nslock unlock];<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2 解锁&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程2上锁失败&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-comment">//线程3</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程3 上锁&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        [nslock lock];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程3执行任务....&quot;</span>);<br>        [nslock unlock];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++线程3 解锁&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">线程2 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程3 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 上锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程2上锁失败</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程1 解锁</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程3执行任务</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程3 解锁</span><br></code></pre></td></tr></table></figure><p><strong>使用案例：AFNetworking</strong>。</p><h4 id="5-3-NSRecursiveLock"><a href="#5-3-NSRecursiveLock" class="headerlink" title="5.3.NSRecursiveLock"></a>5.3.NSRecursiveLock</h4><p>与NSLock不同，递归锁可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。只有当所有的锁被释放之后，其他线程才可以获得锁。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)recursivelock<br>&#123;<br>    NSLock *<span class="hljs-keyword">lock</span> = [NSLock <span class="hljs-built_in">new</span>];<br>    //NSRecursiveLock *<span class="hljs-keyword">lock</span> = [NSRecursiveLock <span class="hljs-built_in">new</span>];<br>    <br>    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <br>       static <span class="hljs-type">void</span> (^RecursiveBlock)(<span class="hljs-type">int</span>);<br>       <br>       RecursiveBlock = ^(<span class="hljs-type">int</span> <span class="hljs-keyword">value</span>) &#123;<br>           [<span class="hljs-keyword">lock</span> <span class="hljs-keyword">lock</span>];<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &gt; <span class="hljs-number">0</span>) &#123;<br>               NSLog(@&quot;++++循环：%d&quot;, <span class="hljs-keyword">value</span>);<br>               sleep(<span class="hljs-number">1</span>);<br>               RecursiveBlock(<span class="hljs-keyword">value</span> - <span class="hljs-number">1</span>);<br>           &#125;<br>           [<span class="hljs-keyword">lock</span> unlock];<br>       &#125;;<br>       RecursiveBlock(<span class="hljs-number">5</span>);<br>   &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面就是一个死锁的情况，RecursiveBlock被递归的调用，从第二次开始，由于锁已经被使用且没有被解锁，所以需要等待解锁，造成死锁。运行后的日志就可以看出：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">循环：5</span><br></code></pre></td></tr></table></figure><p>这种情况下，如果把上片代码第二行注释取消，把NSLock替换为NSRecursiveLock，使用递归锁，则不会出现死锁。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">循环：5</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：4</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：3</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">循环：1</span><br></code></pre></td></tr></table></figure><p><strong>使用案例：PINRemoteImage</strong>。</p><h4 id="5-4-synchronized"><a href="#5-4-synchronized" class="headerlink" title="5.4.@synchronized"></a>5.4.@synchronized</h4><p><code>@synchronized(obj)</code>的作用是根据给定对象，自动创建一个互斥锁，块中的代码执行完后才会释放锁。相比于使用<code>NSLock</code>等创建锁对象、加锁和解锁来说，@synchronized 用着更方便。但它也是这几个锁里效率最低的，因为一般我们会将<code>self</code>等作为代码块的加锁对象，这会造成其他共用此锁的同步块的阻塞。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *mArr;<br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableDictionary</span> *mDic;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br><span class="hljs-keyword">@synthesize</span> mArr = _mArr;<br><span class="hljs-keyword">@synthesize</span> mDic = _mDic;<br><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!_mArr) &#123;<br>            _mArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        &#125;<br>        <span class="hljs-keyword">return</span> _mArr;<br>    &#125;<br>&#125;<br>- (<span class="hljs-type">void</span>)setMArr:(<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _mArr = mArr;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++mArr updated~&quot;</span>);<br>        sleep(<span class="hljs-number">5</span>);<span class="hljs-comment">//模拟延时</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++mArr block released~&quot;</span>);<br>    &#125;<br>&#125;<br>-(<span class="hljs-built_in">NSMutableDictionary</span> *)mDic&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!_mDic) &#123;<br>            _mDic = [<span class="hljs-built_in">NSMutableDictionary</span> dictionary];<br>        &#125;<br>        <span class="hljs-keyword">return</span> _mDic;<br>    &#125;<br>&#125;<br>-(<span class="hljs-type">void</span>)setMDic:(<span class="hljs-built_in">NSMutableDictionary</span> *)mDic&#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _mDic = mDic;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++mDic updated~&quot;</span>);<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++111&quot;</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++222&quot;</span>);<br>        <span class="hljs-keyword">self</span>.mArr = [<span class="hljs-built_in">NSMutableArray</span> arrayWithObject:@(<span class="hljs-number">0</span>)];<br>        <span class="hljs-keyword">self</span>.mDic = [<span class="hljs-built_in">NSMutableDictionary</span> dictionaryWithObject:<span class="hljs-string">@&quot;v1&quot;</span> forKey:<span class="hljs-string">@&quot;k&quot;</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++333&quot;</span>);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">111</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">222</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">mArr updated~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">mArr block released~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">mDic updated~</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">333</span><br></code></pre></td></tr></table></figure><p>本示例中，数组属性<code>mArr</code>的存取器中都使用了<code>@synchronized(self)</code>来加锁，保证了数组读写的原子性，但字典属性<code>mDic</code>的存取函数中也使用了<code>@synchronized(self)</code>，且加锁对象也是<code>self</code>，这就会导致在访问<code>mArr</code>的同时访问<code>mDic</code>时后者会被阻塞，造成没必要的等待。实际上，这种方式的效果与属性修饰符<code>atomic</code>一样，都存在效率的问题~</p><h3 id="6-条件锁"><a href="#6-条件锁" class="headerlink" title="6.条件锁"></a>6.条件锁</h3><h4 id="6-1-NSCondition"><a href="#6-1-NSCondition" class="headerlink" title="6.1.NSCondition"></a>6.1.NSCondition</h4><p>NSCondition 扮演着两个角色：</p><blockquote><p>A condition object acts as both a lock and a checkpoint in a given thread. The lock protects your code while it tests the condition and performs the task triggered by the condition. The checkpoint behavior requires that the condition be true before the thread proceeds with its task. While the condition is not true, the thread blocks. It remains blocked until another thread signals the condition object.</p></blockquote><p><strong>角色1：锁</strong></p><p>NSCondition 实现了<code>NSLocking</code>协议，与<code>NSLock</code>一样可用来处理线程同步问题。</p><p><strong>角色2：检查点</strong></p><p>检查当前线程是否满足某个条件：条件不满足时线程会阻塞，直到另一个线程向该条件发送通知。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSCondition</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSLocking</span>&gt; </span>&#123;<br><br>- (<span class="hljs-type">void</span>)wait;<br>- (<span class="hljs-type">BOOL</span>)waitUntilDate:(<span class="hljs-built_in">NSDate</span> *)limit;<br>- (<span class="hljs-type">void</span>)signal;<br>- (<span class="hljs-type">void</span>)broadcast;<br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>NSCondition 提供了 wait 和 signal 接口，接口命名与信号量类似。</p><p>场景：开启两个线程，线程A下载图片，线程B对图片做解码操作。</p><ul><li>线程B的要求是：如果没有图片则自动阻塞；</li><li>当线程A下载完成后，则满足了线程B的需求，发送信号给B线程让其继续处理图片。</li></ul><p>这样的场景就是生产者消费者模式（收发同步问题）。</p><p>原理：</p><ul><li>消费者取得锁，取产品，如果没有，则wait，直到有线程唤醒它去消费产品；</li><li>生产者制造产品，首先也要取得锁，然后生产，再发signal，唤醒wait的消费者。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp">- (<span class="hljs-keyword">void</span>)nsConditonTest<br>&#123;<br>    NSCondition *condition = [[NSCondition alloc] <span class="hljs-keyword">init</span>];<br>    NSMutableArray *products = [NSMutableArray array];<br>    <span class="hljs-comment">// 线程1，消费者</span><br>    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            [<span class="hljs-meta">condition lock</span>];<br>            <span class="hljs-keyword">if</span> ([products count] == <span class="hljs-number">0</span>) &#123;<br>                NSLog(<span class="hljs-string">@&quot;+++等待商品..&quot;</span>);<br>                [<span class="hljs-meta">condition wait</span>]; <span class="hljs-comment">//不满足条件 阻塞线程</span><br>            &#125;<br>            [<span class="hljs-meta">products removeObjectAtIndex:0</span>];<br>            NSLog(<span class="hljs-string">@&quot;+++成功消费1个商品&quot;</span>);<br>            [<span class="hljs-meta">condition unlock</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 线程2，生产者</span><br>    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>            [<span class="hljs-meta">condition lock</span>];<br>            [<span class="hljs-meta">products addObject:[[NSObject alloc</span>] <span class="hljs-keyword">init</span>]];<br>            NSLog(<span class="hljs-string">@&quot;+++生产一个商品，现总量:%zi&quot;</span>,products.count);<br>            [<span class="hljs-meta">condition signal</span>]; <span class="hljs-comment">//满足条件，通知其他线程</span><br>            [<span class="hljs-meta">condition unlock</span>];<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">等待商品</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">生产一个商品，现总量:1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">成功消费1个商品</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">等待商品</span><span class="hljs-string">.</span><span class="hljs-string">.</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">生产一个商品，现总量:1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">成功消费1个商品</span><br></code></pre></td></tr></table></figure><p><strong>使用案例：PINRemoteImage</strong>。</p><h4 id="6-2-NSConditionLock"><a href="#6-2-NSConditionLock" class="headerlink" title="6.2.NSConditionLock"></a>6.2.NSConditionLock</h4><p>相比于 NSLock 多了个 condition 参数，可以理解为一个条件标识。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)conditionlock&#123;<br><span class="hljs-comment">//初始锁对象 条件=0</span><br><span class="hljs-built_in">NSConditionLock</span> *contidionlock = [[<span class="hljs-built_in">NSConditionLock</span> alloc] initWithCondition:<span class="hljs-number">0</span>];<br><span class="hljs-comment">//线程1</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-keyword">if</span>([contidionlock tryLockWhenCondition:<span class="hljs-number">0</span>])&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行线程1&quot;</span>);<br>        [contidionlock unlockWithCondition:<span class="hljs-number">1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++上锁失败&quot;</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//线程2</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    [contidionlock lockWhenCondition:<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行线程2&quot;</span>);<br>    [contidionlock unlockWithCondition:<span class="hljs-number">2</span>];<br>&#125;);<br><br><span class="hljs-comment">//线程3</span><br><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    [contidionlock lockWhenCondition:<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行线程3&quot;</span>);<br>    [contidionlock unlockWithCondition:<span class="hljs-number">3</span>];<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">执行线程1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行线程3</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行线程2</span><br></code></pre></td></tr></table></figure><p>上片代码中，初始化 NSConditionLock 对象时，标识设置为0；运行后：</p><ul><li>线程1执行 <code>tryLockWhenCondition:</code>时，传入标识“0”，所以 线程1 加锁成功。</li><li>线程1执行 <code>unlockWithCondition:</code>时，<code>condition</code>由 0 被修改为 1。</li><li>因为<code>condition</code>修改为了 1，线程3 符合条件并成功上锁，之后线程3将<code>condition</code> 修改为3。</li><li>最后线程2执行。</li></ul><p>从上面的结果可以发现，NSConditionLock 还可以实现任务之间的依赖。</p><p><strong>使用案例：PINRemoteImage</strong>。</p><h4 id="6-3-dispatch-semaphore"><a href="#6-3-dispatch-semaphore" class="headerlink" title="6.3.dispatch_semaphore"></a>6.3.dispatch_semaphore</h4><p>信号量：是一种用来控制资源是否可访问的数量标识，0表示没有可用信号量，&gt;&#x3D;1表是有可用信号量。在进入一段临界区代码之前，线程须获取一个信号量；临界区代码段执行完成后，该线程须释放信号量。在无可用信号量时，其它想进入该临界区的线程必须等待前面的线程释放信号量。</p><p>经典的停车场案例：</p><ul><li>信号量的值相当于剩余车位的数量；</li><li><code>dispatch_semaphore_wait</code>相当于来了一辆车；</li><li><code>dispatch_semaphore_signal</code>相当于走了一辆车；</li></ul><p>停车位的剩余数目在初始化时就已经指明了（<code>dispatch_semaphore_create(value:Int)）</code>），调用一次<code>dispatch_semaphore_signal</code>，剩余的车位就增加一个；调用一次<code>dispatch_semaphore_wait</code>剩余车位就减少一个；当剩余车位为0时，再来车（即调用<code>dispatch_semaphore_wait</code>）就只能等待。有耐心的车主会一直等下去，没耐心的车主在等待“一段时间”之后就会离开。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建信号量，参数：信号量的初值，如果小于<span class="hljs-number">0</span>则会返回NULL<br>dispatch_semaphore_create（信号量值）<br><br><span class="hljs-regexp">//</span>减少信号量，时间：DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER<br>dispatch_semaphore_wait（信号量，等待时间）<br><br><span class="hljs-regexp">//</span>释放信号量<br>dispatch_semaphore_signal(信号量)<br></code></pre></td></tr></table></figure><p>#示例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)Segmaphore<br>&#123;<br>    <span class="hljs-comment">//初始信号量</span><br>    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> quene = dispatch_queue_create(<span class="hljs-string">&quot;com.M.D&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <br>    <span class="hljs-comment">//任务1</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务1&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务1&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//任务2</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务2&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务2&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>    <br>    <span class="hljs-comment">//任务3</span><br>    <span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务3&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务3&quot;</span>);<br>        dispatch_semaphore_signal(semaphore);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务3</span><br></code></pre></td></tr></table></figure><p><strong>使用案例：AFN、GPUImage</strong>。</p><h3 id="7-读写锁"><a href="#7-读写锁" class="headerlink" title="7.读写锁"></a>7.读写锁</h3><p>一个读写锁其读是可并发的，写是排他的，因此实现读写锁可以使用具有类似特性的GCD<code>栅栏</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ASDLockTool</span> ()</span><br><span class="hljs-comment">// 读写锁示范</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">dispatch_queue_t</span> mQueue;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ASDLockTool</span></span><br><br><span class="hljs-keyword">@synthesize</span> name = _name;<br><br>- (<span class="hljs-keyword">instancetype</span>)init &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        _mQueue = dispatch_queue_create(<span class="hljs-string">&quot;mQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br><span class="hljs-comment">// getter 需要同步，因为要立刻返回属性的值</span><br>- (<span class="hljs-built_in">NSString</span> *)name&#123;<br>    __block <span class="hljs-built_in">NSString</span> *bName;<br>    <span class="hljs-built_in">dispatch_sync</span>(_mQueue, ^&#123;<br>        bName = _name;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> bName;<br>&#125;<br><br><span class="hljs-comment">// setter 需要排他性，写时不允许其他写操作或者读操作，所以使用栅栏</span><br>- (<span class="hljs-type">void</span>)setName:(<span class="hljs-built_in">NSString</span> *)name&#123;<br>    dispatch_barrier_async(_mQueue, ^&#123;<br>        _name = name;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>因为getter需要立刻返回当前属性的值，所以对于属性的读操作使用了“同步+并发队列”；而写操作是排他的，所以使用了“异步栅栏+并发队列”，这样就能保证写入时其他操作都自动等待。</p><hr><p>相关参考：</p><p>#<a href="https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC/4945202">©百度百科-优先级反转</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSOperation</title>
    <link href="/2017/11/17/nsoperation.html"/>
    <url>/2017/11/17/nsoperation.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>iOS2 时 OS X 与 iOS 的程序都普遍采用 NSOperation 来编写线程代码，而之后出现的 GCD 技术大体是依照前者的原则来实现的。随着 GCD 的普及，在iOS4 与 OS X 10.6 以后，OperationQueue 的底层都是用 GCD 来实现的。</p></blockquote><h3 id="1-与-GCD-的对比"><a href="#1-与-GCD-的对比" class="headerlink" title="1.与 GCD 的对比"></a>1.与 GCD 的对比</h3><h4 id="1-1-GCD-的特点："><a href="#1-1-GCD-的特点：" class="headerlink" title="1.1.GCD 的特点："></a>1.1.GCD 的特点：</h4><p>GCD 是面向过程的，它是由 C 语言构成的 API，一般与 block 结合使用，简洁高效；</p><h4 id="1-2-NSOperation的特点："><a href="#1-2-NSOperation的特点：" class="headerlink" title="1.2.NSOperation的特点："></a>1.2.NSOperation的特点：</h4><p><strong>面向对象：</strong> NSOperation 是面向对象的，拥有更多的函数可用；它能被继承，可以方便地重写其部分方法以实现特殊功能；也可以根据需求定义不同的子类，从而提高代码的复用率；</p><p><strong>任务顺序可控制：</strong> NSOperation 能够设置依赖关系或任务优先级，方便的让处于同一个并行队列中的多个任务按照我们指定的顺序依次执行；GCD 中只能区分不同任务队列的优先级；</p><p><strong>属性可监测：</strong> NSOperation 提供了部分属性，可通过 KVO 监听这些属性以确定任务是否完成或取消。这让我们能比 GCD 更加有效的掌任务进度和状态；</p><h3 id="2-NSOperation"><a href="#2-NSOperation" class="headerlink" title="2.NSOperation"></a>2.NSOperation</h3><p>NSOperation 是个基类不能直接使，可以使用它的子类：NSInvocationOperation 和 NSBlockOperation。当然你也可以自定义一个基于 NSOperation 的子类。</p><h4 id="2-1-子类"><a href="#2-1-子类" class="headerlink" title="2.1.子类"></a>2.1.子类</h4><p>#示例1（NSInvocationOperation）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)operationGo<br>&#123;<br>    <span class="hljs-comment">//invocation Operation</span><br>    <span class="hljs-type">NSInvocationOperation</span> <span class="hljs-operator">*</span>invocOperation <span class="hljs-operator">=</span> [[<span class="hljs-type">NSInvocationOperation</span> alloc] <br>    initWithTarget:<span class="hljs-keyword">self</span> <br>    selector:<span class="hljs-meta">@selector</span>(operationAction) <br>    object:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-comment">//执行结束后调用的Block</span><br>    [invocOperation setCompletionBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++invocation Finished&quot;</span>);<br>    &#125;];<br>    [invocOperation start];<br>&#125;<br><br><span class="hljs-operator">-</span> (void)operationAction<br>&#123;<br>    <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++execute invocation，</span><br><span class="hljs-string">    <span class="hljs-subst">\n</span>++++线程:%@&quot;</span>,[<span class="hljs-type">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">execute invocation，</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">线程:</span>&lt;<span class="hljs-comment">NSThread: 0x600000065f80</span>&gt;<span class="hljs-comment">&#123;number = 1</span><span class="hljs-string">,</span> <span class="hljs-comment">name = main&#125;</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">invocation Finished</span><br></code></pre></td></tr></table></figure><p>#示例2（NSBlockOperation）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)blockOperationGo<br>&#123;<br>    <span class="hljs-comment">//block Operation</span><br>    <span class="hljs-type">NSBlockOperation</span> <span class="hljs-operator">*</span>blockOperation <span class="hljs-operator">=</span> [<span class="hljs-type">NSBlockOperation</span> blockOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++execute block，<span class="hljs-subst">\n</span>++++线程:%@&quot;</span>,[<span class="hljs-type">NSThread</span> currentThread]);<br>    &#125;];<br>    [blockOperation addExecutionBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++added block, <span class="hljs-subst">\n</span>++++线程:%@&quot;</span>,[<span class="hljs-type">NSThread</span> currentThread]);<br>    &#125;];<br>    [blockOperation setCompletionBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++block Finished&quot;</span>);<br>    &#125;];<br>    [blockOperation start];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">++++added <span class="hljs-keyword">block</span>,<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x60400027c4c0&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++execute <span class="hljs-keyword">block</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x604000078080&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">name</span> = main&#125;<br>++++<span class="hljs-keyword">block</span> Finished<br></code></pre></td></tr></table></figure><p>从上述示例及其输出结果中可以看到：</p><p>NSOperation 的俩子类在单独使用时都没有开辟新线程的能力，任务会在<code>当前线程</code>中同步地执行。</p><p>NSBlockOperation 使用<code>addExecutionBlock</code>添加任务时，这些任务可在新线程中并发地执行。</p><h4 id="2-2-状态"><a href="#2-2-状态" class="headerlink" title="2.2.状态"></a>2.2.状态</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">BOOL executing<span class="hljs-comment">;</span><br>BOOL finished<span class="hljs-comment">;</span><br>BOOL asynchronous<span class="hljs-comment">;</span><br>BOOL ready<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>isReady</li></ul><p>表示这个 operation 是否已做好准备去执行。&#x3D;NO 表示它依赖的相关 operation 尚未完成。</p><ul><li>isExecuting</li></ul><p>表示当前 operation 中的任务是否正在执行。</p><ul><li>isFinished</li></ul><p>&#x3D; YES 时表示当任务已完成或者已被取消。只有此属性为YES时 operation 才会从队列中出列。</p><ul><li>isCancelled</li></ul><p>当前 operation 是否被取消了。在自定义子类的任务开始前，需要在 start 方法中检查此属性。当 &#x3D; YES 时应该立刻退出，同时将 finished属性设置为YES，executing 属性设置为 NO。</p><ul><li>isAsynchronous</li></ul><p>表示 operation 在当前线程是异步还是同步执行，默认值为NO。执行异步 operation 时必须重写此属性并返回 YES。</p><p>注意：NSOperationQueue 是通过 KVO 观察 NSOperation 的状态变化，来自动管理 NSOperation 的执行。重写 start 方法时，我们必须自己维护 isExecuting、isFinished 的值并正确的发送相关 KVO 通知。</p><h4 id="2-3-优先级"><a href="#2-3-优先级" class="headerlink" title="2.3.优先级"></a>2.3.优先级</h4><p>NSOperation的优先级可以由其属性<code>queuePriority</code>指定：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_ENUM</span>(<span class="hljs-type">NSInteger</span>, <span class="hljs-type">NSOperationQueuePriority</span>) &#123;<br>    <span class="hljs-type">NSOperationQueuePriorityVeryLow</span> = -8L,<br>    <span class="hljs-type">NSOperationQueuePriorityLow</span> = -4L,<br>    <span class="hljs-type">NSOperationQueuePriorityNormal</span> = 0,<br>    <span class="hljs-type">NSOperationQueuePriorityHigh</span> = 4,<br>    <span class="hljs-type">NSOperationQueuePriorityVeryHigh</span> = 8<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：与GCD中<code>队列</code>的优先级不一样，这个属性是队列中 Operation 即<code>任务</code>的优先级：</p><blockquote><p>The execution priority of the operation in an operation queue.</p></blockquote><p>从这点来说，Operation 比GCD的功能更丰富，因为GCD只能给队列设置优先级，队列中的任务之间没法单独设置优先级。并且GCD只能给<code>GlobalQueue</code>设置优先级，其他队列想要设置优先级，需要通过下面这种方式进行：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dispatch_queue_t serialQueue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;com.xx.xx&quot;</span>,DISPATCH_QUEUE_SERIAL)</span>;<br><br>dispatch_queue_t globalQueue = dispatch<span class="hljs-constructor">_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0)</span>;<br><br><span class="hljs-comment">//第一个参数是目标队列，第二个参数是参考队列（全局队列）；</span><br>dispatch<span class="hljs-constructor">_set_target_queue(<span class="hljs-params">serialQueue</span>, <span class="hljs-params">globalQueue</span>)</span>;<br></code></pre></td></tr></table></figure><p>对于此<code>queuePriority</code>有三点需要说明：</p><ul><li>优先级决定了各 operation 之间的开始顺序；</li><li>优先级只针对同一队列中的 operation，不同队列中的任务之间比较优先级无意义；</li><li>优先级只针对并发队列，对于并发数为 1 的串行队列来说无意义。</li></ul><p>理论上来说优先级高的先执行，但实际测试中发现，通过这个属性标记的任务，其开始的顺序并不一定按照我们指定的优先级来：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)operationPriority&#123;<br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++1&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++2&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++3&quot;</span>);<br>    &#125;];<br>    <br>    op1.queuePriority = <span class="hljs-built_in">NSOperationQueuePriorityNormal</span>;<br>    op2.queuePriority = <span class="hljs-built_in">NSOperationQueuePriorityVeryHigh</span>;<br>    op3.queuePriority = <span class="hljs-built_in">NSOperationQueuePriorityVeryLow</span>;<br>    <br>    <span class="hljs-built_in">NSOperationQueue</span> *aQueue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    [aQueue addOperations:@[op1,op2,op3] waitUntilFinished:<span class="hljs-literal">NO</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">2</span><br></code></pre></td></tr></table></figure><p>三个任务实际执行时并未按照我们指定的<code>2-&gt;1-&gt;3</code>的顺序来。</p><p>决定任务开始顺序的不仅是优先级，还要看任务是否处在<code>isReady</code>状态：</p><blockquote><p>The readiness of operations is determined by their dependencies on other operations and potentially by custom conditions that you define. The NSOperation class manages dependencies on other operations and reports the readiness of the receiver based on those dependencies.</p></blockquote><blockquote><p>By default, an operation object that has dependencies is not considered ready until all of its dependent operation objects have finished executing. Once the last dependent operation finishes, however, the operation object becomes ready and able to execute.</p></blockquote><p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1412992-ready?language=objc">官文</a>中说<code>ready</code>是根据当前任务“是否有依赖任务及该任务是否已完成”而定的。示例中的三个任务之间是并发且没有依赖关系的，所以按理它们被加入队列后，是否处在就绪状态是由队列或线程池状况来决定的，至于最终设置了优先级但失效了的问题，这不是我们能控制的了。</p><p>鉴于此，为了更精确控制任务优先级，还是推荐使用接下来介绍的<code>qualityOfService</code>服务质量属性来指定任务优先级。这里只是说更精确的控制，不是说服务质量能完全保证任务按指定顺序执行，下面会具体介绍。</p><h4 id="2-4-服务质量"><a href="#2-4-服务质量" class="headerlink" title="2.4.服务质量"></a>2.4.服务质量</h4><p><code>qualityOfService</code>，这是在iOS 8后推出的新属性，通过设置服务质量来决定任务在队列中的优先级，NSOperation和NSOperationQueue都有这个属性。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">NS_ENUM</span>(<span class="hljs-type">NSInteger</span>, <span class="hljs-type">NSQualityOfService</span>) &#123;<br>    <span class="hljs-type">NSQualityOfServiceUserInteractive</span> = 0x21,<br>    <span class="hljs-type">NSQualityOfServiceUserInitiated</span> = 0x19,<br>    <span class="hljs-type">NSQualityOfServiceUtility</span> = 0x11,<br>    <span class="hljs-type">NSQualityOfServiceBackground</span> = 0x09,<br>    <span class="hljs-type">NSQualityOfServiceDefault</span> = -1<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>UserInteractive</strong></li></ul><blockquote><p>Used for work directly involved in providing an interactive UI. For example, processing control events or drawing to the screen.</p></blockquote><p>用于涉及到UI交互的场景，例如处理点击事件或绘制图片到屏幕上。</p><ul><li><strong>UserInitiated</strong></li></ul><blockquote><p>Used for performing work that has been explicitly requested by the user, and for which results must be immediately presented in order to allow for further user interaction. For example, loading an email after a user has selected it in a message list.</p></blockquote><p>用于用户触发的、需要立刻返回结果的任务，例如用户点击邮件列表后立刻加载邮件内容。</p><ul><li><strong>Default</strong></li></ul><blockquote><p>Indicates no explicit quality of service information. Whenever possible, an appropriate quality of service is determined from available sources. Otherwise, some quality of service level between NSQualityOfServiceUserInteractive and NSQualityOfServiceUtility is used.</p></blockquote><p>默认值，表示未指明服务质量，系统会根据当前可用资源的状况，使用介于<code>UserInteractive</code>和<code>Utility</code>之间的某个优先级。</p><ul><li><strong>Utility</strong></li></ul><blockquote><p>Used for performing work which the user is unlikely to be immediately waiting for the results. This work may have been requested by the user or initiated automatically, and often operates at user-visible timescales using a non-modal progress indicator. For example, periodic content updates or bulk file operations, such as media import.</p></blockquote><p>用于不需要立刻返回结果的任务，比如周期性的更新内容，或者导入媒体文件。</p><ul><li><strong>Background</strong></li></ul><blockquote><p>Used for work that is not user initiated or visible. In general, a user is unaware that this work is even happening. For example, pre-fetching content, search indexing, backups, or syncing of data with external systems.</p></blockquote><p>后台任务，优先级最低，用于非用户触发的、不可见的任务，比如发起的网络请求、检索结果、同步数据。</p><p><strong>一般来说</strong>，服务质量对应的优先级排序是：UserInteractive &gt; UserInitiated &gt; Default &gt; Utility &gt; Background。</p><p>#示例：服务质量决定优先级</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    [<span class="hljs-keyword">self</span> operationServiceQuality];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)operationServiceQuality&#123;<br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++1&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++2&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++3&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op4 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++4&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op5 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++5&quot;</span>);<br>    &#125;];<br>    <br>    op1.qualityOfService = <span class="hljs-built_in">NSQualityOfServiceUserInitiated</span>;<br>    op2.qualityOfService = <span class="hljs-built_in">NSQualityOfServiceDefault</span>;<br>    op3.qualityOfService = <span class="hljs-built_in">NSQualityOfServiceUserInteractive</span>;<br>    op4.qualityOfService = <span class="hljs-built_in">NSQualityOfServiceUtility</span>;<br>    op5.qualityOfService = <span class="hljs-built_in">NSQualityOfServiceBackground</span>;<br>    <br>    <span class="hljs-built_in">NSOperationQueue</span> *aQueue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    [aQueue addOperations:@[op1,op2,op3,op4,op5] waitUntilFinished:<span class="hljs-literal">NO</span>];<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">4</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">5</span><br></code></pre></td></tr></table></figure><p><strong>但是</strong>，多次运行同样一段代码之后，会得到这样的日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">4</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">5</span><br></code></pre></td></tr></table></figure><p>和这样的日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">5</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">4</span><br></code></pre></td></tr></table></figure><p><strong>结论：</strong>服务质量也不能保证任务的执行顺序。</p><p>那咋办呢？为了精确控制任务的顺序，还是建议使用依赖关系，或者将任务放到最大并发数&#x3D;1的串行队列中。</p><h3 id="3-NSOperationQueue"><a href="#3-NSOperationQueue" class="headerlink" title="3.NSOperationQueue"></a>3.NSOperationQueue</h3><p>NSOperation 单独使用时不具备开启新线程的能力，只有配合 NSOperationQueue 才能开辟新线程执行任务。NSOperation 相当于GCD中<code>block</code>内的任务，而 NSOperationQueue 则相当于GCD中的队列。将任务加入到队列中后，系统会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作，不需要再手动调用start。</p><h4 id="3-1-两种队列"><a href="#3-1-两种队列" class="headerlink" title="3.1.两种队列"></a>3.1.两种队列</h4><ul><li>主队列：（任务会在主线程执行）</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">NSOperationQueue *mainQueue <span class="hljs-operator">=</span> [NSOperationQueue mainQueue]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>其他队列：（任务会放到子线程中执行）。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">NSOperationQueue</span> <span class="hljs-operator">*</span>queue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br></code></pre></td></tr></table></figure><h4 id="3-2-添加任务"><a href="#3-2-添加任务" class="headerlink" title="3.2.添加任务"></a>3.2.添加任务</h4><p>#示例3：-addOperation:(NSOperation *)op;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC">- (<span class="hljs-type">void</span>)addOperation<br>&#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    <br>    <span class="hljs-built_in">NSInvocationOperation</span> *op1 = [[<span class="hljs-built_in">NSInvocationOperation</span> alloc] <br>    initWithTarget:<span class="hljs-keyword">self</span> <br>    selector:<span class="hljs-keyword">@selector</span>(run) <br>    object:<span class="hljs-literal">nil</span>];<br>    <br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> <br>    blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行block任务，</span><br><span class="hljs-string">        \n++++线程:%@&quot;</span>, <br>        [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    <br>    [queue addOperation:op1];<br>    [queue addOperation:op2];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)run<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行invocation operation任务，</span><br><span class="hljs-string">    \n++++线程:%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程调用之后，输出日志：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">++++执行<span class="hljs-keyword">block</span>任务，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x604000268cc0&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++执行invocation operation任务，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x604000268c80&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">4</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br></code></pre></td></tr></table></figure><p>#示例4：-addOperationWithBlock:(void (^)(void))block;</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)addBlockOperation<br>&#123;<br>    <span class="hljs-type">NSOperationQueue</span> <span class="hljs-operator">*</span>queue <span class="hljs-operator">=</span> [[<span class="hljs-type">NSOperationQueue</span> alloc] <span class="hljs-keyword">init</span>];<br>    <span class="hljs-comment">//最大并发数</span><br>    <span class="hljs-comment">//queue.maxConcurrentOperationCount = 1;</span><br>    <span class="hljs-comment">//queue.maxConcurrentOperationCount = 2;</span><br>    <br>    [queue addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++执行block任务1，</span><br><span class="hljs-string">        <span class="hljs-subst">\n</span>++++线程:%@&quot;</span>, [<span class="hljs-type">NSThread</span> currentThread]);<br>    &#125;];<br>    <br>    [queue addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++执行block任务2，</span><br><span class="hljs-string">        <span class="hljs-subst">\n</span>++++线程:%@&quot;</span>, [<span class="hljs-type">NSThread</span> currentThread]);<br>    &#125;];<br>    <br>    [queue addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++执行block任务3，</span><br><span class="hljs-string">        <span class="hljs-subst">\n</span>++++线程:%@&quot;</span>, [<span class="hljs-type">NSThread</span> currentThread]);<br>    &#125;];<br>    <br>    [queue addOperationWithBlock:<span class="hljs-operator">^</span>&#123;<br>        <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;++++执行block任务4，</span><br><span class="hljs-string">        <span class="hljs-subst">\n</span>++++线程:%@&quot;</span>, [<span class="hljs-type">NSThread</span> currentThread]);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>主线程调用之后，输出日志：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">3</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x60000046c180&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">4</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x60000046c1c0&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">5</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">1</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x60400026a000&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">4</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">2</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x60400026a280&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">6</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br></code></pre></td></tr></table></figure><p>与 NSOperationQueue 结合后，任务都在不同子线程里并发执行，具备了开启新线程的能力。</p><h4 id="3-3-并发数"><a href="#3-3-并发数" class="headerlink" title="3.3.并发数"></a>3.3.并发数</h4><ul><li>-1，默认值，表示不进行限制，默认为并发执行；</li><li>&#x3D;0，阻塞、都不执行；</li><li>&#x3D;1，串行；</li><li>&gt;1，并发；</li></ul><p>上面#示例4中，如果让 maxConcurrentOperationCount &#x3D; 1，则队列为串行，输出日志如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs fortran">++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">1</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x604000272240&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">2</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x604000272240&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">3</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x604000272240&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br>++++执行<span class="hljs-keyword">block</span>任务<span class="hljs-number">4</span>，<br>++++线程:&lt;NSThread: <span class="hljs-number">0</span>x604000272240&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">name</span> = (null)&#125;<br></code></pre></td></tr></table></figure><p>可以看出，队列中的任务按照串行的方式在执行。不设置或者&#x3D;2时，任务会并发执行，开启线程数量是由系统决定的，不需要我们来管理。</p><h4 id="3-4-依赖关系"><a href="#3-4-依赖关系" class="headerlink" title="3.4.依赖关系"></a>3.4.依赖关系</h4><p>#示例5：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)dependenceGo<br>&#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op1&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op2&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op3&quot;</span>);<br>    &#125;];<br>    <br>    [op1 addDependency:op2];<br>    [op2 addDependency:op3];<br>    <br>    [queue addOperation:op1];<br>    [queue addOperation:op2];<br>    [queue addOperation:op3];<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">执行op3</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行op2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行op1</span><br></code></pre></td></tr></table></figure><p>不添加依赖时，3个任务会并发执行，先后顺序不定。添加依赖后，3个任务按照设定倒序执行。</p><h4 id="3-5-取消任务"><a href="#3-5-取消任务" class="headerlink" title="3.5.取消任务"></a>3.5.取消任务</h4><ul><li>取消单个任务</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">- (<span class="hljs-keyword">void</span>)cancel;<span class="hljs-comment">//NSOperation的方法 取消单个任务。</span><br></code></pre></td></tr></table></figure><p>作用：<code>建议</code>operation对象停止执行它包含着的任务。</p><blockquote><p>Advises the operation object that it should stop executing its task.</p></blockquote><p>此方法并不会强制任务对象停止执行，它只是更新对象中的标记位来反映任务状态的变化。</p><ul><li>如果任务已经完成，则取消对它没有影响；</li><li>如果任务在某个队列中但尚未开始执行，则执行取消操作时任务会从队列中移除；</li><li>如果任务尚未加入队列中，则执行取消操作会让任务立刻被标记为finished；</li></ul><blockquote><p>This method does not force your operation code to stop. Instead, it updates the object’s internal flags to reflect the change in state. If the operation has already finished executing, this method has no effect. Canceling an operation that is currently in an operation queue, but not yet executing, makes it possible to remove the operation from the queue sooner than usual.<br>In macOS 10.6 and later, if an operation is in a queue but waiting on unfinished dependent operations, those operations are subsequently ignored. Because it is already cancelled, this behavior allows the operation queue to call the operation’s start method sooner and clear the object out of the queue. If you cancel an operation that is not in a queue, this method immediately marks the object as finished. In each case, marking the object as ready or finished results in the generation of the appropriate KVO notifications.<br>In versions of macOS prior to 10.6, an operation object remains in the queue until all of its dependencies are removed through the normal processes. Thus, the operation must wait until all of its dependent operations finish executing or are themselves cancelled and have their start method called.<br>For more information on what you must do in your operation objects to support cancellation, see Responding to the Cancel Command.</p></blockquote><p>在macOS10.6之前此取消方法并不会立刻将当前operation移出队列，而是要待到它所依赖的其他operation全部执行完，或者都被取消并且执行完它们的start方法后。而在macOS10.6之后，取消一个operation时会自动忽略它所依赖的其他operation，并且队列会提前调用当前operation的start方法，随后将其移出队列。注意：这句话隐含的意思是，即使operation被取消了，其start方法仍会被调用。所以我们在重写operation的start方法时，要注意检测当前任务的<code>isCancelled</code>属性，如果任务已经被取消则应立刻返回，不再继续后续操作。</p><ul><li>取消所有任务</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">- (<span class="hljs-keyword">void</span>)cancelAllOperations;<span class="hljs-comment">//NSOperationQueue的方法，取消队列中的所有任务。</span><br></code></pre></td></tr></table></figure><p>作用：取消队列中所有的operation，包括尚未执行和已执行的operation。</p><blockquote><p>This method calls the cancel method on all operations currently in the queue.<br>Canceling the operations does not automatically remove them from the queue or stop those that are currently executing. For operations that are queued and waiting execution, the queue must still attempt to execute the operation before recognizing that it is canceled and moving it to the finished state. For operations that are already executing, the operation object itself must check for cancellation and stop what it is doing so that it can move to the finished state. In both cases, a finished (or canceled) operation is still given a chance to execute its completion block before it is removed from the queue.</p></blockquote><p>此方法会调用队列中所有operation的<code>cancel</code>方法，但不会停止正在执行中的operation，也不会立刻将这些任务移出队列。对尚未执行的任务，队列仍然会去尝试执行它们，即前面提到的继续执行<code>start</code>方法，直到检测到任务被取消并且其状态为finished。对于正在执行中的任务，其内部必须检查<code>isCancelled</code>属性是否为YES，如果是则需要立刻停止后续操作。这两种情况下，被取消或状态为finished的operation没有被立刻停止和移出队列，从而让它们还有机会执行自己的完成回调。</p><h4 id="3-6-暂停-x2F-恢复"><a href="#3-6-暂停-x2F-恢复" class="headerlink" title="3.6.暂停&#x2F;恢复"></a>3.6.暂停&#x2F;恢复</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)setSuspended:(<span class="hljs-type">BOOL</span>)b; <span class="hljs-comment">// NSOperationQueue中的方法</span><br></code></pre></td></tr></table></figure><p>作用：暂停或恢复当前队列中所有的任务。</p><blockquote><p>When the value of this property is NO, the queue actively starts operations that are in the queue and ready to execute. Setting this property to YES prevents the queue from starting any queued operations, but already executing operations continue to execute. You may continue to add operations to a queue that is suspended but those operations are not scheduled for execution until you change this property to NO.<br>Operations are removed from the queue only when they finish executing. However, in order to finish executing, an operation must first be started. Because a suspended queue does not start any new operations, it does not remove any operations (including cancelled operations) that are currently queued and not executing.<br>You may monitor changes to the value of this property using Key-value observing. Configure an observer to monitor the suspended key path of the operation queue.<br>The default value of this property is NO.</p></blockquote><p>该字段是队列的属性：</p><ul><li>值为NO时，队列会启动队已准备就绪的任务；</li><li>值为YES时，会阻止启动队列中的任务；</li><li>已经在执行的任务会继续执行；</li><li>往已经暂停的队列中添新加任务时，这些任务也会被暂停，直到暂停状态被置为NO；</li></ul><p>Operation只有在finished状态时才会从队列中出列，想让任务finished，须先启动此任务；而暂停状态的队列并不会启动任何新的任务，所以队列也就不会移除任何任务，包括已经被cancel的任务。</p><p>对应场景：一个已经被暂停的队列中有N个任务，其中任务A还在排队中尚未开始执行，此时对任务A执行cancel方法，则任务A不会出列。因为此时队列在暂停状态，任务A又没开始执行，所以其start方法也就不会被调用，isFinished状态也就还不是YES，因此也就不会出列~</p><p><strong>小结</strong>：对于上面三个方法，可以这么简单的理解：Operation必须跑起来才能更新和检测自己的isCanceled及isFinished状态，从而决定自己是不是该取消和出列。</p><h3 id="4-实现Group任务"><a href="#4-实现Group任务" class="headerlink" title="4.实现Group任务"></a>4.实现Group任务</h3><p>GCD中提供了<code>dispatch_group</code>以便将多个任务组合在一起，同时可以在这些任务执行完成后通过<code>dispatch_group_notify</code>的回调执行某些任务。NSOperation并没有<code>Group</code>相关字眼的接口，但是我们仍然可以在NSOperation已有接口的基础上变相实现此功能。</p><h4 id="4-1-依赖关系"><a href="#4-1-依赖关系" class="headerlink" title="4.1.依赖关系"></a>4.1.依赖关系</h4><p>思路：给封装了最后任务的 Operation 设置依赖关系，使其依赖于前面的所有任务。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)monitorGroupTasks<br>&#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op1&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op2&quot;</span>);<br>    &#125;];<br>    <span class="hljs-built_in">NSBlockOperation</span> *op3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op3&quot;</span>);<br>    &#125;];<br>    <br>    <span class="hljs-comment">//最后需要执行的UI任务</span><br>    <span class="hljs-built_in">NSBlockOperation</span> *finOp = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        [[<span class="hljs-built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++最后执行UI任务~&quot;</span>);<br>        &#125;];<br>    &#125;];<br>    <br>    <span class="hljs-comment">//添加依赖，让finOp依赖于Grop中的所有任务</span><br>    [finOp addDependency:op1];<br>    [finOp addDependency:op2];<br>    [finOp addDependency:op3];<br>    <br>    [queue addOperations:@[finOp,op3,op2,op1] waitUntilFinished:<span class="hljs-literal">NO</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">执行op2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行op1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">执行op3</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">最后执行UI任务~</span><br></code></pre></td></tr></table></figure><h4 id="4-2-completionBlock"><a href="#4-2-completionBlock" class="headerlink" title="4.2.completionBlock"></a>4.2.completionBlock</h4><p>思路：NSBlockOperation中的<code>addExecutionBlock</code>接口可以给<code>operation</code>添加额外任务并在异步线程中执行。同时NSOperation提供了<code>completionBlock</code>属性，可以利用它来在所有任务执行完成后再执行某个特殊任务。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)monitorGroupTasks<br>&#123;<br>    <span class="hljs-built_in">NSBlockOperation</span> *blockOpration = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op1，线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    [blockOpration addExecutionBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op2，线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    [blockOpration addExecutionBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行op3，线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    &#125;];<br>    <br>    <span class="hljs-comment">//最后需要执行的UI任务</span><br>    [blockOpration setCompletionBlock:^&#123;<br>        [[<span class="hljs-built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++最后执行UI任务~，线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>        &#125;];<br>    &#125;];<br><br>    <span class="hljs-comment">//开启任务</span><br>    <span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    [queue addOperation:blockOpration];<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">++++执行op1，线程:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003594d40</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++执行op3，线程:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x6000035d9c80</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 5, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++执行op2，线程:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x6000035eeb40</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 4, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++最后执行UI任务~，线程:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x6000035f5dc0</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><br></code></pre></td></tr></table></figure><h3 id="5-自定义NSOperation"><a href="#5-自定义NSOperation" class="headerlink" title="5.自定义NSOperation"></a>5.自定义NSOperation</h3><p>自定义时，需要重写 NSOperation 的<code>start</code>或<code>main</code>方法。</p><h4 id="5-1-重写main"><a href="#5-1-重写main" class="headerlink" title="5.1.重写main"></a>5.1.重写main</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">- (void)main<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1407732-main?language=objc">Performs the receiver’s non-concurrent task</a>，执行非并发任务时重写此函数。</p><p>NSOperation 默认是非并发的，在不加入 Queue 的情况下，通过调用 <code>-(void)start</code> 对象方法在当前线程执行任务时， 会一直阻塞当前线程，直到任务完成。<code>-(void)main</code>方法默认情况下不做任何事，执行完成后属性<code>isExecuting</code>会被置为 NO， 属性<code>isFinished</code>被置为 YES。我们可以重写此方法以实现自定义的任务。重写时不能调用<code>super</code>，也不需要手动创建 autorelease pool，因为系统已自动帮你实现。</p><p>#示例6：自定义非并发 NSOperation</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lua">- (void)main<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.isCancelled) <span class="hljs-keyword">return</span>;<br>    NSData *imageData = <span class="hljs-string">[[NSData alloc] initWithContentsOfURL:</span><br><span class="hljs-string">    [NSURL URLWithString:_mUrlStr]]</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.isCancelled) &#123;<br>        imageData = <span class="hljs-literal">nil</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">self</span>.isCancelled) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> ([_delegate respondsToSelector:@selector(downloadFinishedWithData:)]) &#123;<br>        [_delegate downloadFinishedWithData:imageData];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-重写start"><a href="#5-2-重写start" class="headerlink" title="5.2.重写start"></a>5.2.重写start</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- (<span class="hljs-type">void</span>)<span class="hljs-keyword">start</span>;<br></code></pre></td></tr></table></figure><p><a href="https://developer.apple.com/documentation/foundation/nsoperation/1416837-start?language=objc">Begins the execution of the operation</a>，If you are implementing a concurrent operation, you must override this method and use it to initiate your operation。</p><p>执行并发任务时“必须”重写此方法。</p><p>在没有被重写时，<code>start</code>方法的默认实现里会更新当前任务的执行状态，之后调用<code>-main</code>函数。此方法也会做一些检查，以确保当前任务能正常执行：如果任务已被取消或已完成，则<code>-start</code>方法直接返回并且不会再调用<code>-main</code>方法；如果任务正在执行或者尚未准备就绪，则会抛出异常；</p><blockquote><p>An operation is not considered ready to execute if it is still dependent on other operations that have not yet finished.</p></blockquote><p>重写<code>start</code>方法时不能调用<code>super</code>函数，需要及时更新 isExecuting 和 isFinished 属性，并发出对应的 KVO 通知，因为在并发情况下系统不知道任务什么时候完成。自定义时，我们一般会将任务定义为异步执行，也就是说<code>start</code>函数返回了任务不一定就是完成了。 这个要你自己来控制，只有将 isFinished 置为 YES 时，operation 才算完成，才能出列和销毁。</p><h4 id="5-3-自定义示例"><a href="#5-3-自定义示例" class="headerlink" title="5.3.自定义示例"></a>5.3.自定义示例</h4><p>#示例7：自定义NSOperation子类</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//NetOperation.h</span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;UIKit/UIKit.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@class</span> <span class="hljs-title">NetOperation</span>;</span><br><span class="hljs-comment">//代理协议</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">NetOperationDelegate</span>&lt;<span class="hljs-title">NSObject</span>&gt;</span><br>- (<span class="hljs-type">void</span>)downloadFinishedWithData:(<span class="hljs-type">id</span>)data;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NetOperation</span> : <span class="hljs-title">NSOperation</span></span><br>- (<span class="hljs-keyword">instancetype</span>)initWithUrl:(<span class="hljs-built_in">NSString</span> *)url <br>delegate:(<span class="hljs-type">id</span>&lt;NetOperationDelegate&gt;)delegate;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//NetOperation.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;NetOperation.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NetOperation</span>()</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *mUrlStr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-type">id</span>&lt;NetOperationDelegate&gt;delegate;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSURLSessionDownloadTask</span> *dataTask;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NetOperation</span></span><br><span class="hljs-comment">//因为父类的属性是readonly的，重载时如果需要setter的话则需要手动合成。</span><br><span class="hljs-keyword">@synthesize</span> finished = _finished, executing = _executing;<br><br><span class="hljs-comment">// 这里需要实现KVO相关的方法，NSOperationQueue是通过KVO来判断任务状态的</span><br><br>- (<span class="hljs-type">void</span>)setFinished:(<span class="hljs-type">BOOL</span>)finished &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;isFinished&quot;</span>];<br>    _finished = finished;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;isFinished&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)setExecuting:(<span class="hljs-type">BOOL</span>)executing &#123;<br>    [<span class="hljs-keyword">self</span> willChangeValueForKey:<span class="hljs-string">@&quot;isExecuting&quot;</span>];<br>    _executing = executing;<br>    [<span class="hljs-keyword">self</span> didChangeValueForKey:<span class="hljs-string">@&quot;isExecuting&quot;</span>];<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)isAsynchronous&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithUrl:(<span class="hljs-built_in">NSString</span> *)url<br>delegate:(<span class="hljs-type">id</span>&lt;NetOperationDelegate&gt;)delegate&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        _delegate = delegate;<br>        _mUrlStr = url;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    _delegate = <span class="hljs-literal">nil</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -重载start方法 实现业务需求</span><br>- (<span class="hljs-type">void</span>)start &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.isCancelled) &#123;<br>            <span class="hljs-keyword">self</span>.finished = <span class="hljs-literal">YES</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">self</span>.executing = <span class="hljs-literal">YES</span>;<br>        [<span class="hljs-keyword">self</span> main];<br>    &#125;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)cancel &#123;<br>    <span class="hljs-keyword">@synchronized</span> (<span class="hljs-keyword">self</span>) &#123;<br>        [<span class="hljs-variable language_">super</span> cancel];<br>        <span class="hljs-comment">// 如果正在执行中则表示已经start过，可以将isFinished设为yes</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.isExecuting) &#123;<br>            <span class="hljs-keyword">self</span>.finished = <span class="hljs-literal">YES</span>;<br>            <span class="hljs-keyword">self</span>.executing = <span class="hljs-literal">NO</span>;<br>        &#125;<br>        [_dataTask cancel];<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -BUSINESS</span><br>-(<span class="hljs-type">void</span>)main&#123;<br>    <span class="hljs-built_in">NSURLSession</span> *session = [<span class="hljs-built_in">NSURLSession</span> sharedSession];<br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>    _dataTask = [session downloadTaskWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:_mUrlStr]<br>    completionHandler:^(<span class="hljs-built_in">NSURL</span> *location,<span class="hljs-built_in">NSURLResponse</span> *response, <span class="hljs-built_in">NSError</span> *error) &#123;<br>        <span class="hljs-keyword">if</span> (!error) &#123;<br>            __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(weakSelf) strongSelf = weakSelf;<br>            <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfFile:location.path];<br>            strongSelf.finished = <span class="hljs-literal">YES</span>;<br>            strongSelf.executing = <span class="hljs-literal">NO</span>;<br>            <span class="hljs-keyword">if</span> ([strongSelf.delegate respondsToSelector:<span class="hljs-keyword">@selector</span>(downloadFinishedWithData:)]) &#123;<br>                [strongSelf.delegate downloadFinishedWithData:data];<br>            &#125;<br>        &#125;<br>    &#125;];<br>    <span class="hljs-comment">//开始任务</span><br>    [_dataTask resume];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>导入头文件，创建并执行任务。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">-(<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application <br>willFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSOperationQueue</span> *aQueue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc] init];<br>    NetOperation *anOperation = [[NetOperation alloc] initWithUrl:<span class="hljs-string">@&quot;xxx&quot;</span> delegate:<span class="hljs-keyword">self</span>];<br>    [aQueue addOperation:anOperation];<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)downloadFinishedWithData:(<span class="hljs-type">id</span>)data<br>&#123;<br>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];<br>    [[<span class="hljs-built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++++Reqest Finished!&quot;</span>);<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>本示例只是最简单的自定义，更复杂的可以参考AFN和SD中Operation相关的类~</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW9">©Apple-Operation Queues</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCD</title>
    <link href="/2017/11/08/gcd.html"/>
    <url>/2017/11/08/gcd.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p><code>GCD</code>是在<code>线程池模式</code>基础上开发的一套多核编程的较新的解决方案：</p><ul><li>底层由C语言实现，API使用时简洁明了；</li><li>为多核处理器而设计，会自动利用更多的CPU内核进行运算，执行效率高；</li><li>自动管理线程生命周期，无需手写线程管理的代码，只需告诉它我们想要执行的任务。</li></ul><h3 id="2-同步与异步"><a href="#2-同步与异步" class="headerlink" title="2.同步与异步"></a>2.同步与异步</h3><p>同步和异步是将任务以 block 形式提交到指定队列中时所使用的两种方式。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dispatch<span class="hljs-constructor">_sync(<span class="hljs-params">dispatch_queue_t</span> <span class="hljs-params">queue</span>, <span class="hljs-params">dispatch_block_t</span> <span class="hljs-params">block</span>)</span>;<br></code></pre></td></tr></table></figure><p><code>dispatch_sync</code>用于同步地执行任务。函数会一直等到 blcok 执行完才返回，这会阻塞当前线程。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dispatch<span class="hljs-constructor">_async(<span class="hljs-params">dispatch_queue_t</span> <span class="hljs-params">queue</span>, <span class="hljs-params">dispatch_block_t</span> <span class="hljs-params">block</span>)</span>;<br></code></pre></td></tr></table></figure><p><code>dispatch_async</code>用于异步地执行任务。函数在提交完任务后不等待 block 执行完就立刻返回了，不会阻塞当前线程。</p><h3 id="3-队列"><a href="#3-队列" class="headerlink" title="3.队列"></a>3.队列</h3><h4 id="1-串行与并发队列"><a href="#1-串行与并发队列" class="headerlink" title="1.串行与并发队列"></a>1.串行与并发队列</h4><p>当有多个任务时，可以将它们放在队列中执行，队列分为串行和并发两种：</p><p><strong>串行队列</strong>：任务是按照FIFO的顺序执行的，先提交的任务先执行，后提交的任务须等前一个任务执行完成才能开始。对于不同的串行队列，系统会为它们创建不同的线程来执行任务。</p><p><strong>并发队列</strong>：任务也是按照FIFO的顺序执行，不同的是，任务不是必须等到前一个执行完才开始，同一时间可能会有多个任务在执行。GCD 会动态分配多条线程来执行这些任务，具体几条线程取决于当前内存状况和线程池中线程数等因素。</p><p>#<strong>特殊的串行队列：</strong> main_queue</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>主队列本身是系统提供的一种特殊的串行队列<br><span class="hljs-regexp">//</span>放在主队列中的任务都会在主线程中执行<br>dispatch_queue_t mainQueue   = dispatch_get_main_queue();<br></code></pre></td></tr></table></figure><p>#<strong>特殊的并发队列：</strong> global_queue</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>全局队列是系统提供的一种特殊并发队列<br><span class="hljs-regexp">//</span>第一个参数指定queue的优先级,分为HIGH\DEFAULT\LOW\BACKGROUND四种;<br><span class="hljs-regexp">//</span>第二个参数，目前只能为<span class="hljs-number">0</span>或NULL;<br>dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_ PRIORITY_DEFAULT,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h4 id="2-任务-队列-的组合"><a href="#2-任务-队列-的组合" class="headerlink" title="2.任务+队列 的组合"></a>2.任务+队列 的组合</h4><table><thead><tr><th>.</th><th>并发队列</th><th>串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步</td><td>不能开启新线程,串行执行任务</td><td>不能开启新线程,串行执行任务</td><td>不能开启新线程,串行执行任务</td></tr><tr><td>异步</td><td>可以开启新线程,并发执行任务</td><td>可以开启新线程,串行执行任务</td><td>不能开启新线程,串行执行任务</td></tr></tbody></table><p>注释：不能开启新线程，就要继续在当前线程中运行。</p><p>#示例3.2.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;concurrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <span class="hljs-built_in">dispatch_sync</span>(concurrentQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动后输出结果为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">+++Thread:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x6000000dca40</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml">,main?:1</span><br></code></pre></td></tr></table></figure><p>分析：示例中向并发队列<code>concurrentQueue</code>中同步的提交了一个打印日志的任务，虽然并发队列具有开辟新线程的能力，但是结合上<code>dispatch_sync</code>之后，就不行了，任务会继续运行在当前的主线程上。输出结果中“name &#x3D; main” 且 “main?:1”也印证了这一点。</p><p>再注意：可以开启新线程，也不一定就真的会开辟新线程执行新的任务，系统要根据线程池中的状况来决定是开辟新线程，还是继续在当前空闲的线程上执行任务。</p><p>#示例3.2.2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;concurrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <span class="hljs-comment">//step.1</span><br>    <span class="hljs-built_in">dispatch_async</span>(concurrentQueue, ^&#123;<span class="hljs-comment">//具有开启新线程的能力</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread1:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>        <span class="hljs-comment">//step.2</span><br>        <span class="hljs-built_in">dispatch_async</span>(concurrentQueue, ^&#123;<span class="hljs-comment">//具有开启新线程的能力</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread2:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>            <span class="hljs-comment">//step.3</span><br>            <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Thread3:%@,main?:%d&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSThread</span> isMainThread]);<br>            &#125;);<br>        &#125;);<br>        <span class="hljs-comment">//step.4</span><br><span class="hljs-comment">//        for (int i = 0; i&lt; 0xffffffff; i++)&#123;//for循环很多次，模拟大量运算</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后日志为：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">+++Thread1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003bd5500</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003bd5500</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread3:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003bb1900</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml">,main?:1</span><br></code></pre></td></tr></table></figure><p><code>step1</code>处，异步+并发，已具备开启新线程的能力，从日志来看 Thread1 “main?:0”，已经不在主线程，开启了新线程；</p><p><code>step2</code>处，异步+并发，也具备开启新线程的能力，从日志来看线程 Thread2 的内存地址与 step1 时一样，说明继续运行在当前线程上，并没有开辟新线程~</p><p>不过，如果把<code>step4</code>处的注释去掉，模拟一次复杂运算，则输出结果就不一样了：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">+++Thread1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600000c98ec0</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600000cab140</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 4, name = (null)&#125;</span><span class="language-xml">,main?:0</span><br><span class="language-xml">+++Thread3:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600000cfd900</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml">,main?:1</span><br></code></pre></td></tr></table></figure><p><code>Thread2</code>与<code>Thread1</code>的地址已经不一样了。这是因为<code>Thread1</code>中有大量运算，<code>Thread2</code>要开启一个新线程执行任务。</p><p>所以，同&#x2F;异步 + 串&#x2F;并行的组合，只是说明了任务所在队列，任务的提交方式和是否具备开辟新线程的能力。<strong>当具备开辟新线程的能力时，是否真的开辟新线程要由线程池的状况来确定</strong>。</p><h4 id="3-死锁问题"><a href="#3-死锁问题" class="headerlink" title="3.死锁问题"></a>3.死锁问题</h4><p>在当前<code>串行</code>队列中再<code>同步</code>地提交一个新任务到队列中会造成死锁！</p><p>#示例3.3.1：</p><p>主队列中使用“同步+主队列”的组合，造成死锁的场景：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br>    <span class="hljs-comment">//step.1</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务开始&quot;</span>);<br>    <span class="hljs-built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();<br>    <br>    <span class="hljs-comment">//step.2</span><br>    <span class="hljs-built_in">dispatch_sync</span>(mainQueue, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++处理任务4&quot;</span>);<br>        <span class="hljs-comment">//do something</span><br>    &#125;);<br><br>    <span class="hljs-comment">//step.3</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务结束&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码行后，只会输出“++++任务开始”，并卡死在<code>dispatch_sync</code>这一行。这是因为：<code>viewDidAppear</code>是在主队列中，这是一个串行队列，里面的任务按照FIFO的顺序依次执行。整个代码块中大的任务顺序为123，但是执行到 step2 时，同步地向主队列中追加了一个任务4，因此任务顺序变为1234。<code>dispatch_sync</code>提交任务的特点是会阻塞当前线程，并立刻开始执行其中的任务。问题就来了，主线程本来要按顺序执行1、2、3，结果执行到 2 时被强行阻塞，并被要求立刻去执行任务4。而串行队列中任务4位于3之后，不能在3尚未执行时先执行4。所以形成一种局面：执行到step2时，串行主队列在等待任务4完成，任务4又在等待主队列完成任务3，从而形成了死锁问题。</p><p>#示例3.3.2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//当前在主线程</span><br><span class="hljs-built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="hljs-string">&quot;seria&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><span class="hljs-built_in">dispatch_async</span>(serialQueue, ^&#123;<span class="hljs-comment">//block1</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_sync</span>(serialQueue, ^&#123;<span class="hljs-comment">// block2</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>&#125;);<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br></code></pre></td></tr></table></figure><p>上述示例中会先打印日志“4”，后打印“1”，之后在 <code>dispatch_sync</code> 这一行卡死。这其实与示例1 类似：因为 block1 是异步执行，所以函数立刻返回并打印“4”；但是 block1 内任务是在一个串行队列中，执行到<code>dispatch_sync</code>处时线程被阻塞，并被要求立刻在当前串行队列中再执行追加到尾部的新任务 block2。这当然也行不通，因为当前线程已被block2阻塞，block2又在等待队列先完成任务3。这样也造成了相互等待的情况，形成了死锁。</p><h4 id="4-线程间的通信"><a href="#4-线程间的通信" class="headerlink" title="4.线程间的通信"></a>4.线程间的通信</h4><p>通常为了避免UI阻塞，我们可以在异步线程中做一些耗时的任务，完成后回到主线程中更新UI。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>    <span class="hljs-comment">//图片的网络路径</span><br>    <span class="hljs-built_in">NSURL</span> *url = [<span class="hljs-built_in">NSURL</span> URLWithString:<span class="hljs-string">@&quot;xxx.jpg&quot;</span>];<br>    <span class="hljs-comment">//加载图片</span><br>    <span class="hljs-built_in">NSData</span> *data = [<span class="hljs-built_in">NSData</span> dataWithContentsOfURL:url];<br>    <span class="hljs-comment">//生成图片</span><br>    <span class="hljs-built_in">UIImage</span> *image = [<span class="hljs-built_in">UIImage</span> imageWithData:data];<br><br>    <span class="hljs-comment">//回到主线程，刷新UI，显示图片。</span><br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>        [<span class="hljs-keyword">self</span>.imageView setImage:image];<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>例子在主线程中调用，dispatch_async配合全局并发队列，开辟了一个新线程用来加载图片资源；加载完成后再通过dispatch_get_main_queue返回到主队列中更新视图。因为主队列默认在主线程中，所以更新视图的任务会在主线程中进行。</p><h4 id="5-线程与队列"><a href="#5-线程与队列" class="headerlink" title="5.线程与队列"></a>5.线程与队列</h4><p><code>线程</code>和<code>队列</code>是两个不同的概念~</p><p><code>队列</code>是一种任务组织方式，任务被以 block 的形式提交到<code>队列</code>中，并最终在某个线程上执行，具体在哪个线程上执行是由<code>队列类型</code>和<code>提交任务时的方式</code>决定的。如#3.2小节中列出的那样，如果是<code>同步</code>的方式提交任务，则任务会继续在当前线程上执行；如果是<code>异步+并发队列</code>的方式提交的任务，那么内核会根据系统资源创建新线程来执行任务。</p><p><code>线程</code>是 CPU 调度和分派任务的基本单位，一个<code>线程</code>中可以执行多个<code>队列</code>中的任务。线程是可以重复利用的，这由线程池和系统资源状况来决定。</p><p><code>主线程</code>不等于<code>主队列</code>。主线程只有一个，主线程上既可以执行<code>主队列</code>中的任务，也可以执行<code>全局并发队列</code>或你<code>自定义队列</code>中的任务。</p><p>#示例：主线程执行非主队列的任务</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++1.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    <br>    <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<span class="hljs-comment">//同步的提交任务，模拟任务还在当前线程执行</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++2.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>主队列</code>的任务一定在<code>主线程</code>中执行，全局并发队列或自定义队列中的任务可以在<code>子线程</code>中执行。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++1.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    <br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<span class="hljs-comment">//虽然异步提交主队列中的任务，但任务还是在主线程中执行</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++2.主线程？:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> isMainThread] ? <span class="hljs-string">@&quot;YES&quot;</span> : <span class="hljs-string">@&quot;NO&quot;</span> );<span class="hljs-comment">//YES</span><br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很多跟 UI 相关的操作，一般都会放到<code>main_queue</code>主队列中进行，比如常见的<code>AFN</code>从子线程回到主队列更新图片。这是因为<code>UIKit</code>本身不是线程安全的，这些操作需要在系统提供的<code>主队列</code>这么一个<code>串行队列</code>中进行，保证操作的顺序和完整性。</p><h3 id="4-栅栏"><a href="#4-栅栏" class="headerlink" title="4.栅栏"></a>4.栅栏</h3><h4 id="1-dispatch-barrier-async"><a href="#1-dispatch-barrier-async" class="headerlink" title="1.dispatch_barrier_async"></a>1.dispatch_barrier_async</h4><p><strong>作用：</strong>让队列中排在它前面任务先执行完毕，再执行自己，最后再执行后续任务。</p><p><strong>场景：</strong>向并发队列中加入5个异步任务：1、2、3、4、5。由于是异步+并发，所以任务实际执行时并不一定按照 12345 的顺序来。如果我们要求执行完任务 3 之后才能执行任务 4 和 5，此时就可以使用<code>栅栏</code>这个功能。</p><p>#示例4.1：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- (void)barrier&#123;<br>    <span class="hljs-comment">//自定义并发队列</span><br>    dispatch_queue_t cQueue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;Name1&quot;</span>,DISPATCH_QUEUE_CONCURRENT)</span>;<br>    <br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务1:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务2:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务3栅栏:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++1&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务4:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++2&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务5:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">++++<span class="hljs-number">1</span><br>++++<span class="hljs-number">2</span><br>++++任务<span class="hljs-number">2</span>:&lt;NSThread: <span class="hljs-number">0x600003453f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">4</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">1</span>:&lt;NSThread: <span class="hljs-number">0x600003455f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">3</span>栅栏:&lt;NSThread: <span class="hljs-number">0x600003455f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">4</span>:&lt;NSThread: <span class="hljs-number">0x600003455f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">5</span>:&lt;NSThread: <span class="hljs-number">0x600003453f00</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">4</span>, name = (<span class="hljs-literal">null</span>)&#125;<br></code></pre></td></tr></table></figure><p>从日志来看，任务的执行顺序正常：</p><ul><li>栅栏之前的任务1和2先执行;</li><li>随后是栅栏本身的任务3;</li><li>最后是栅栏之后的任务4和5。</li></ul><p>注意：栅栏只是用来控制同一并发队列中栅栏前后任务的整体执行顺序；至于栅栏前面的任务与后面的任务它们具体在哪个线程执行，这不是栅栏能决定的。</p><p>结合日志中任务所在线程的内存地址来看：</p><ul><li>栅栏之前的<code>任务1</code>和<code>任务2</code>并没在同一个线程中执行；</li><li>栅栏之后的<code>任务4</code>和<code>任务5</code>也没有在同一个线程中执行；</li><li>甚至栅栏前的<code>任务1</code>和栅栏<code>任务3</code>及栅栏之后的<code>任务4</code>使用了同一个线程；</li></ul><p>所以，栅栏后的任务具体是在哪个线程上执行，还是要看这些任务的提交方式和队列类型，之后交给线程池来决定。</p><p>但是，如果任务都是通过栅栏提交的，那么栅栏就能保证它们按照来时的顺序先后执行，且是在同一线程上：</p><p>#示例4.2：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">- (void)barrier2&#123;<br>    <span class="hljs-comment">//自定义并发队列</span><br>    dispatch_queue_t cQueue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;Name1&quot;</span>,DISPATCH_QUEUE_CONCURRENT)</span>;<br>    <br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务1:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务2:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务3栅栏:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++1&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123; <span class="hljs-comment">//注意，这里换成了栅栏，不仅仅是异步了</span><br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务4:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++2&quot;</span>)</span>;<br>    dispatch<span class="hljs-constructor">_barrier_async(<span class="hljs-params">cQueue</span>, ^()</span>&#123; <span class="hljs-comment">// 这里也是</span><br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++任务5:%@&quot;</span>,[NSThread <span class="hljs-params">currentThread</span>])</span>;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">++++<span class="hljs-number">1</span><br>++++<span class="hljs-number">2</span><br>++++任务<span class="hljs-number">1</span>:&lt;NSThread: <span class="hljs-number">0x60000132cb80</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">5</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">2</span>:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">3</span>栅栏:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">4</span>:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br>++++任务<span class="hljs-number">5</span>:&lt;NSThread: <span class="hljs-number">0x60000132a840</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">6</span>, name = (<span class="hljs-literal">null</span>)&#125;<br></code></pre></td></tr></table></figure><p>可以看到，提交到栅栏中的任务3、4、5是按照提交时的顺序执行的，且在同一个线程中。</p><p>另外，该函数需要同<code>dispatch_queue_create()</code>生成的并发队列一起用。如果示例4.1中换成全局队列则效果如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3栅栏</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务4</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务5</span><br></code></pre></td></tr></table></figure><p>任务1、2在栅栏3之后执行了，<strong>栅栏并未起效！！！</strong>，所以实际中须注意这一点~</p><h4 id="2-dispatch-barrier-sync"><a href="#2-dispatch-barrier-sync" class="headerlink" title="2.dispatch_barrier_sync"></a>2.dispatch_barrier_sync</h4><p>将示例4.1中栅栏替换为<code>dispatch_barrier_sync</code>后，日志如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3栅栏</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务4</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务5</span><br></code></pre></td></tr></table></figure><p>对比日志，两种情况下：</p><p>1、任务都是按照栅栏3之前的先执行，再是3本身，最后是45；</p><p>2、“++++数字”日志都是按照12的顺序执行，只是在异步栅栏中“++++数字” 与 “++++任务x”的打印了顺序不同。</p><p><strong>两者的区别：</strong></p><p>1、同步栅栏：将栅栏任务插入队列时，需等待栅栏任务结束后，才会继续插入并执行被写在它后面的任务；</p><p>2、异步栅栏：将栅栏任务插入队列后，不会等待栅栏任务结束，而是继续把后续任务插入队列中，栅栏任务结束后才执行后面的任务；</p><p>3、栅栏不论异步还是同步，都只会给自己并发队列中的任务设置栅栏，不会阻碍主线程的代码。</p><h3 id="5-延时：dispatch-after"><a href="#5-延时：dispatch-after" class="headerlink" title="5.延时：dispatch_after"></a>5.延时：dispatch_after</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">dispatch_after</span>(<br>dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">2.0</span> * NSEC_PER_SEC)),<br><span class="hljs-built_in">dispatch_get_main_queue</span>(), ^&#123;<br>    <span class="hljs-comment">//2秒后的延时任务 do something</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-dispatch-once"><a href="#6-dispatch-once" class="headerlink" title="6.dispatch_once"></a>6.dispatch_once</h3><p><strong>作用：</strong>广泛使用在单例中，用以保证初始化方法中的任务只执行一次。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">static</span> ASDFSingleton *mSingleton = <span class="hljs-literal">nil</span>;<br><br><span class="hljs-comment">// 声明单例的方式1：</span><br>+ (<span class="hljs-keyword">instancetype</span>)shareInstance<br>&#123;<br>    <span class="hljs-keyword">return</span> [[<span class="hljs-keyword">self</span> alloc] init];<br>&#125;<br><br><span class="hljs-comment">//防止外部通过alloc或new的方式错误的创建了实例对象</span><br>+ (<span class="hljs-keyword">instancetype</span>)allocWithZone:(<span class="hljs-keyword">struct</span> _NSZone *)zone&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">dispatch_once_t</span> onceToken;<br>    <span class="hljs-built_in">dispatch_once</span>(&amp;onceToken, ^&#123;<br>        mSingleton = [<span class="hljs-variable language_">super</span> allocWithZone:zone];<br>    &#125;);<br>    <span class="hljs-keyword">return</span> mSingleton;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-dispatch-apply"><a href="#7-dispatch-apply" class="headerlink" title="7.dispatch_apply"></a>7.dispatch_apply</h3><p>作用：按指定的次数将任务追加到指定的队列中，并等到全部的处理执行结束。</p><p>#示例7.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 并发队列</span><br><span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;Name&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><span class="hljs-built_in">NSArray</span> *array = @[<span class="hljs-string">@&quot;a&quot;</span>, <span class="hljs-string">@&quot;b&quot;</span>, <span class="hljs-string">@&quot;c&quot;</span>, <span class="hljs-string">@&quot;d&quot;</span>, <span class="hljs-string">@&quot;e&quot;</span>, <span class="hljs-string">@&quot;f&quot;</span>, <span class="hljs-string">@&quot;g&quot;</span>, <span class="hljs-string">@&quot;h&quot;</span>, <span class="hljs-string">@&quot;i&quot;</span>, <span class="hljs-string">@&quot;j&quot;</span>];<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++开始&quot;</span>);<br><br>dispatch_apply([array count], concurrentQueue, ^(size_t index) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%zu,%@,ON:%@&quot;</span>, index, [array objectAtIndex:index], [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++结束&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">++++开始<br>++<span class="hljs-number">1</span>,b,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">0</span>,a,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++<span class="hljs-number">2</span>,c,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">3</span>,d,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++<span class="hljs-number">4</span>,e,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x600001055700</span>&gt;&#123;number = <span class="hljs-number">5</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">5</span>,f,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">7</span>,h,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x600001055700</span>&gt;&#123;number = <span class="hljs-number">5</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">6</span>,g,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++<span class="hljs-number">8</span>,i,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x6000010407c0</span>&gt;&#123;number = <span class="hljs-number">4</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++<span class="hljs-number">9</span>,j,<span class="hljs-keyword">ON</span>:&lt;NSThread: <span class="hljs-number">0x60000100d980</span>&gt;&#123;number = <span class="hljs-number">1</span>, <span class="hljs-type">name</span> = main&#125;<br>++++结束<br></code></pre></td></tr></table></figure><p>多运行几次，可以从日志中发现：</p><ul><li>打印的索引值并非完全按照 0~9 的升序排列；</li><li>遍历元素的操作并非都在同一个线程中；</li></ul><p>如果希望索引值完全按照 0~9 的升序排列，可以使用串行队列，这样就类似于<code>for</code>循环了。</p><p>#示例7.2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 串行队列</span><br><span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;Name&quot;</span>,DISPATCH_QUEUE_SERIAL);<br><span class="hljs-built_in">NSArray</span> *array = @[<span class="hljs-string">@&quot;a&quot;</span>, <span class="hljs-string">@&quot;b&quot;</span>, <span class="hljs-string">@&quot;c&quot;</span>, <span class="hljs-string">@&quot;d&quot;</span>, <span class="hljs-string">@&quot;e&quot;</span>, <span class="hljs-string">@&quot;f&quot;</span>, <span class="hljs-string">@&quot;g&quot;</span>, <span class="hljs-string">@&quot;h&quot;</span>, <span class="hljs-string">@&quot;i&quot;</span>, <span class="hljs-string">@&quot;j&quot;</span>];<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++开始&quot;</span>);<br><br>dispatch_apply([array count], concurrentQueue, ^(size_t index) &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++%zu,%@,ON:%@&quot;</span>, index, [array objectAtIndex:index], [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++结束&quot;</span>);<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">++++开始</span><br><span class="language-xml">++0,a,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++1,b,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++2,c,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++3,d,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++4,e,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++5,f,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++6,g,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++7,h,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++8,i,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++9,j,ON:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600001999600</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++结束</span><br></code></pre></td></tr></table></figure><p>不论使用串行还是并发队列，<code>dispatch_apply</code>函数都不会立刻返回，它会阻塞当前线程并在循环完成后再继续执行后续代码。所以可以推测它使用了同步的方式提交遍历元素的任务，这一点类似于<code>for</code>循环。</p><h3 id="8-任务组"><a href="#8-任务组" class="headerlink" title="8.任务组"></a>8.任务组</h3><h4 id="1-dispatch-group"><a href="#1-dispatch-group" class="headerlink" title="1.dispatch_group"></a>1.dispatch_group</h4><p><strong>场景：</strong>在并发队列的N个任务执行完毕后，继续执行某任务。</p><p>#示例8.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//自定义的并发队列1</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue1 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">//自定义的并发队列2</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue2 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue2&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t dispatchGroup = dispatch_group_create();<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++1:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br><br><span class="hljs-comment">//并发队列1上执行任务1</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">888</span> == i) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//并发队列1上执行任务2</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-comment">//并发队列2上执行任务3</span><br>dispatch_group_async(dispatchGroup, dispatchQueue2, ^()&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(dispatchGroup,dispatch_get_main_queue(), ^()&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务完成:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++稍等一哈:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br><span class="hljs-built_in">dispatch_async</span>(dispatchQueue2, ^&#123;<br>    dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++哈~终于等到你:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;);<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++2:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">++++1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++稍等一哈:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务1:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003164780</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 5, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务3:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003153cc0</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 6, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务2:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003176480</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 3, name = (null)&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++任务完成:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x60000313a800</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 1, name = main&#125;</span><span class="language-xml"></span><br><span class="language-xml">++++哈~终于等到你:<span class="hljs-tag">&lt;<span class="hljs-name">NSThread:</span> <span class="hljs-attr">0x600003176880</span>&gt;</span></span><span class="hljs-template-variable">&#123;number = 4, name = (null)&#125;</span><br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>1、一个Group可以和多个queue关联。</p><p>2、如果提交到队列中的与Group关联起来的任务全都执行完毕，则会调用dispatch_group_notify并且dispatch_group_wait会停止等待；</p><p>3、假设一个队列中有2个任务，只有第二个与Group进行了关联，则只要第二个任务完成，不论第一个任务是否已完成，都会收到dispatch_group_notify通知。</p><p>4、dispatch_group_wait会阻塞当前线程，直到任务全部完成或等待时间超过设置的超时时间，所以不能在主线程调用。</p><h4 id="2-dispatch-group-enter"><a href="#2-dispatch-group-enter" class="headerlink" title="2.dispatch_group_enter"></a>2.dispatch_group_enter</h4><p><code>dispatch_group_enter</code>+<code>dispatch_group_leave</code>成对用，作用与<code>dispatch_group_async</code>类似:</p><p>#示例8.2.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//自定义的并发队列</span><br><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t group = dispatch_group_create();<br><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++1&quot;</span>);<br><br><span class="hljs-comment">//并发队列上执行任务1</span><br>dispatch_group_enter(group);<br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">888</span> == i) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1&quot;</span>);<br>        &#125;<br>    &#125;<br>    dispatch_group_leave(group);<br>&#125;);<br><br><span class="hljs-comment">//并发队列上执行任务2</span><br>dispatch_group_enter(group);<br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2&quot;</span>);<br>    dispatch_group_leave(group);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(group, dispatch_get_main_queue(), ^()&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务完成&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>与 dispatch_group_async 的区别（线程同步问题）:</strong></p><p>如果 <code>dispatch_group_async</code> 里执行的是异步代码，<code>dispatch_group_notify</code> 会直接触发而不会等待异步任务完成；而 <code>dispatch_group_enter</code>、和 <code>dispatch_group_leave</code> 则不会有这个问题，它们只需要在任务开始前 <code>enter</code> 结束后 <code>leave</code> 即可达到线程同步的效果。</p><p>#示例8.2.2：<code>dispatch_group_async</code> 执行异步任务时的效果：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//自定义的并发队列1</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue1 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">//自定义的并发队列2</span><br><span class="hljs-built_in">dispatch_queue_t</span> dispatchQueue2 = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue2&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t dispatchGroup = dispatch_group_create();<br><br><span class="hljs-comment">//并发队列1上执行任务1</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatchQueue2, ^&#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">5</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1&quot;</span>);<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">//并发队列1上执行任务2</span><br>dispatch_group_async(dispatchGroup, dispatchQueue1, ^()&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatchQueue2, ^&#123;<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">8</span>];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2&quot;</span>);<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(dispatchGroup,dispatch_get_main_queue(), ^()&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务完成&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出日志为:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务完成</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br></code></pre></td></tr></table></figure><p><code>notify</code>在任务开始时就触发了~</p><p>#示例8.2.3：<code>dispatch_group_enter</code> 与 <code>leave</code> 执行异步任务时的效果：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//自定义的并发队列</span><br>dispatch_queue_t queue = dispatch_queue_create(<span class="hljs-string">&quot;concurrentQueue1&quot;</span>,DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_group_t <span class="hljs-keyword">group</span> = dispatch_group_create();<br><br>dispatch_group_enter(<span class="hljs-keyword">group</span>);<br>dispatch_async(queue, ^&#123;<br>    [<span class="hljs-meta">NSThread sleepForTimeInterval:5</span>];<br>    NSLog(<span class="hljs-string">@&quot;++++任务1&quot;</span>);<br>    dispatch_group_leave(<span class="hljs-keyword">group</span>);<br>&#125;);<br><br><span class="hljs-comment">//并发队列1上执行任务2</span><br>dispatch_group_enter(<span class="hljs-keyword">group</span>);<br>dispatch_async(queue, ^&#123;<br>    [<span class="hljs-meta">NSThread sleepForTimeInterval:8</span>];<br>    NSLog(<span class="hljs-string">@&quot;++++任务2&quot;</span>);<br>    dispatch_group_leave(<span class="hljs-keyword">group</span>);<br>&#125;);<br><br><span class="hljs-comment">//任务执行完成</span><br>dispatch_group_notify(<span class="hljs-keyword">group</span>,dispatch_get_main_queue(), ^()&#123;<br>    NSLog(<span class="hljs-string">@&quot;++++任务完成&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>日志:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务完成</span><br></code></pre></td></tr></table></figure><p><code>notify</code> 在任务结束时才触发!</p><h4 id="3-其他方案"><a href="#3-其他方案" class="headerlink" title="3.其他方案"></a>3.其他方案</h4><p>通过组合GCD已有的其他API，等效实现<code>dispatch_group</code>的功能：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs OBJECTIVEC"><span class="hljs-comment">// 需要执行的任务总数</span><br><span class="hljs-built_in">NSUInteger</span> totalTasks = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 当前已经完成的任务数量</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-built_in">NSUInteger</span> completedTasks = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 最大并发数</span><br><span class="hljs-built_in">NSUInteger</span> maxConcurrentTasks = <span class="hljs-number">3</span>;<br><br><span class="hljs-comment">// 创建一个串行队列，用于等待所有任务完成后执行接下来的任务</span><br><span class="hljs-built_in">dispatch_queue_t</span> completionQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.example.completion&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><br><span class="hljs-comment">// 创建一个并发队列，用于执行耗时任务</span><br><span class="hljs-built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.example.concurrent&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">// 定义一个任务完成的回调函数</span><br><span class="hljs-type">void</span> (^taskCompletionBlock)(<span class="hljs-type">void</span>) = ^&#123;<br>    <span class="hljs-comment">// 原子操作，累加已完成任务数</span><br>    <span class="hljs-built_in">NSUInteger</span> count = OSAtomicIncrement64(&amp;completedTasks);<br>    <span class="hljs-keyword">if</span> (count == totalTasks) &#123;<br>        <span class="hljs-comment">// 所有任务都已完成，执行接下来的任务</span><br>        <span class="hljs-built_in">dispatch_async</span>(completionQueue, ^&#123;<br>            <span class="hljs-comment">// 在这里执行接下来的任务</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;所有任务都已完成&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 循环提交所有任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSUInteger</span> i = <span class="hljs-number">0</span>; i &lt; totalTasks; i++) &#123;<br>    <span class="hljs-built_in">dispatch_async</span>(concurrentQueue, ^&#123;<br>        <span class="hljs-comment">// 在这里执行耗时任务，比如网络请求</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务 %lu 开始执行&quot;</span>, i);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.0</span>]; <span class="hljs-comment">// 模拟耗时操作</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;任务 %lu 完成&quot;</span>, i);<br>        taskCompletionBlock(); <span class="hljs-comment">// 调用任务完成的回调函数</span><br>    &#125;);<br>    <span class="hljs-keyword">if</span> (i % maxConcurrentTasks == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当前并发任务已达到最大并发数，等待所有并发任务完成后再继续提交</span><br>        dispatch_barrier_sync(concurrentQueue, ^&#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-挂起-x2F-恢复："><a href="#9-挂起-x2F-恢复：" class="headerlink" title="9.挂起&#x2F;恢复："></a>9.挂起&#x2F;恢复：</h3><p><code>dispatch_suspend</code>-挂起，<code>dispatch_resume</code>-恢复，可以暂停、恢复队列上的任务。但<code>suspend</code>并不保证能立即停止队列上已经在运行的 block。</p><p>#示例9.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="hljs-string">&quot;Queue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br><br><span class="hljs-comment">//提交第一个任务，延时5秒输出日志</span><br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++第1个任务 延时5秒咯&quot;</span>);<br>&#125;);<br><span class="hljs-comment">//提交第二个任务，延时5秒输出日志</span><br><span class="hljs-built_in">dispatch_async</span>(queue, ^&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++第2个任务 延时5秒咯&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">//延时1秒</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++延时1秒&quot;</span>);<br>sleep(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//挂起队列</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++挂起队列&quot;</span>);<br>dispatch_suspend(queue);<br><br><span class="hljs-comment">//延时10秒</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++延时10秒&quot;</span>);<br>sleep(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//恢复队列</span><br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++恢复队列&quot;</span>);<br>dispatch_resume(queue);<br></code></pre></td></tr></table></figure><p>日志:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">11</span>.<span class="hljs-number">187713</span> ++++延时<span class="hljs-number">1</span>秒<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">12</span>.<span class="hljs-number">189074</span> ++++挂起队列<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">12</span>.<span class="hljs-number">189450</span> ++++延时<span class="hljs-number">10</span>秒<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">16</span>.<span class="hljs-number">193140</span> ++++第<span class="hljs-number">1</span>个任务 延时<span class="hljs-number">5</span>秒咯<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">22</span>.<span class="hljs-number">190424</span> ++++恢复队列<br><span class="hljs-attribute">12</span>:<span class="hljs-number">58</span>:<span class="hljs-number">27</span>.<span class="hljs-number">192363</span> ++++第<span class="hljs-number">2</span>个任务 延时<span class="hljs-number">5</span>秒咯<br></code></pre></td></tr></table></figure><p>可以看出，在<code>dispatch_suspend</code>挂起队列后，第一个 block 还是在运行，并且正常输出。</p><h3 id="10-dispatch-set-target-queue"><a href="#10-dispatch-set-target-queue" class="headerlink" title="10.dispatch_set_target_queue"></a>10.dispatch_set_target_queue</h3><h4 id="1-设置队列优先级"><a href="#1-设置队列优先级" class="headerlink" title="1.设置队列优先级"></a>1.设置队列优先级</h4><p>我们自己创建的队列使用的是默认优先级，而系统提供的全局队列则可以指定优先级，通过<code>dispatch_set_target_queue</code>方法我们可以让自定义队列的优先级与全局队列保持一致，从而达到修改自定义队列优先级的目的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">dispatch_queue_t serialQueue = dispatch<span class="hljs-constructor">_queue_create(<span class="hljs-string">&quot;com.xx.xx&quot;</span>,DISPATCH_QUEUE_SERIAL)</span>;<br><br>dispatch_queue_t globalQueue = dispatch<span class="hljs-constructor">_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0)</span>;<br><br><span class="hljs-comment">//第一个参数是目标队列，第二个参数是参考队列（全局队列）；</span><br>dispatch<span class="hljs-constructor">_set_target_queue(<span class="hljs-params">serialQueue</span>, <span class="hljs-params">globalQueue</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-任务调度"><a href="#2-任务调度" class="headerlink" title="2.任务调度"></a>2.任务调度</h4><p>修改队列中任务的目标队列，把需要执行的任务对象指定到目标队列中去处理。</p><p>#示例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)seriaQues&#123;<br>    <span class="hljs-comment">//三个串行队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">&quot;queue2&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue3 = dispatch_queue_create(<span class="hljs-string">&quot;queue3&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue2, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue3, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3结束&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务2开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1结束</span><br></code></pre></td></tr></table></figure><p>多个串行队列异步执行时，block中各任务是并发执行的，它们之间开始和结束的顺序是不确定的。如果想让这些任务按照先后顺序一个个执行，则可以使用<code>dispatch_set_target_queue</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)seriaMultQue&#123;<br>    <span class="hljs-comment">//三个串行队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="hljs-string">&quot;queue2&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <span class="hljs-built_in">dispatch_queue_t</span> queue3 = dispatch_queue_create(<span class="hljs-string">&quot;queue3&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-comment">//目标队列</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="hljs-string">&quot;targetQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    <br>    <span class="hljs-comment">//将三个串行队列合并到目标串行队列中</span><br>    dispatch_set_target_queue(queue1, targetQueue);<br>    dispatch_set_target_queue(queue2, targetQueue);<br>    dispatch_set_target_queue(queue3, targetQueue);<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">3.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务1结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue2, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">2.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务2结束&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_async</span>(queue3, ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3开始&quot;</span>);<br>        [<span class="hljs-built_in">NSThread</span> sleepForTimeInterval:<span class="hljs-number">1.</span>f];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++任务3结束&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">任务1开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务1结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务2结束</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3开始</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">任务3结束</span><br></code></pre></td></tr></table></figure><p>原先相互之间并发执行的三个任务，现在有序执行了~</p><p>另外，执行这个操作后，<code>queue1</code>上已在执行的任务会继续在<code>queue1</code>执行，尚未执行的任务会在<code>targetQueue</code>上执行。</p><h3 id="11-设置队列标志"><a href="#11-设置队列标志" class="headerlink" title="11.设置队列标志"></a>11.设置队列标志</h3><p>作用：<code>dispatch_queue_set_specific</code>用来向指定队列里面设置一个标识，配合<code>dispatch_get_specific</code>使用。</p><p>#示例11.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">void</span> *key = <span class="hljs-string">&quot;queueKey&quot;</span>;<br>    <span class="hljs-type">void</span> *context = <span class="hljs-string">&quot;myQueueContext&quot;</span>;<br>    <br>    <span class="hljs-built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="hljs-string">&quot;queue1&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    dispatch_queue_set_specific(queue1, key,context, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-keyword">if</span> (dispatch_get_specific(key)) &#123;<br>        <span class="hljs-comment">//当前队列是主队列，不是queue1，所以取不到key对应的值。</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++主队列++queue1？：YES&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++主队列++queue1？：NO&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dispatch_async</span>(queue1, ^&#123;<br>        <span class="hljs-keyword">if</span> (dispatch_get_specific(key)) &#123;<br>            <span class="hljs-comment">//当前队列是queue1，所以能取到specificKey对应的值。</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++异步串行队列++queue1？：YES&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++异步串行队列++queue1？：NO&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">主队列</span><span class="hljs-literal">++</span><span class="hljs-comment">queue1？：NO</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">异步串行队列</span><span class="hljs-literal">++</span><span class="hljs-comment">queue1？：YES</span><br></code></pre></td></tr></table></figure><h3 id="12-dispatch-block-cancel"><a href="#12-dispatch-block-cancel" class="headerlink" title="12.dispatch_block_cancel"></a>12.dispatch_block_cancel</h3><p>作用：取消单个任务。</p><p>这个任务必须是用<code>dispatch_block_create</code>创建<code>dispatch_block_t</code>。再者，此方法只对尚未执行的block有效，对正在执行中的任务无效。</p><p>#示例12.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//取消任务3</span><br><span class="hljs-built_in">dispatch_queue_t</span> conQueue = dispatch_queue_create(<span class="hljs-string">&quot;com.xxx.queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br>dispatch_block_t block1 = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>    sleep(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++block1&quot;</span>);<br>&#125;);<br><br>dispatch_block_t block2 = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++block2&quot;</span>);<br>&#125;);<br><br>dispatch_block_t block3 = dispatch_block_create(<span class="hljs-number">0</span>, ^&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++block3&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">dispatch_async</span>(conQueue, block1);<br><span class="hljs-built_in">dispatch_async</span>(conQueue, block2);<br><span class="hljs-built_in">dispatch_async</span>(conQueue, block3);<br>dispatch_block_cancel(block3);<br></code></pre></td></tr></table></figure><p>日志:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">++++</span><span class="hljs-comment">block2</span><br><span class="hljs-literal">++++</span><span class="hljs-comment">block1</span><br></code></pre></td></tr></table></figure><h3 id="13-dispatch-semaphore"><a href="#13-dispatch-semaphore" class="headerlink" title="13.dispatch_semaphore"></a>13.dispatch_semaphore</h3><p>信号量：就是一种可用来控制访问资源的数量的标识。当一个线程在进入一段关键代码之前，线程须获取一个信号量，一旦该关键代码段执行完成，那么该线程须释放其持有的信号量。其它想进入该关键代码段的线程须等待可用信号量，如果没有可用信号量，则需等待前面的线程释放信号量。</p><p>有一个经典的停车场的例子：信号量的值就相当于剩余车位的数目，<code>dispatch_semaphore_wait</code>就相当于来了一辆车，<code>dispatch_semaphore_signal</code>就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create(value:Int)）），调用一次<code>dispatch_semaphore_signal</code>，剩余的车位就增加一个；调用一次<code>dispatch_semaphore_wait</code>剩余车位就减少一个；当剩余车位为0时，再来车（即调用<code>dispatch_semaphore_wait</code>）就只能等待。有耐心的车主会一直等下去，没耐心的车主在等待“一段时间”之后就会离开。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建信号量，参数：信号量的初值，如果小于<span class="hljs-number">0</span>则会返回NULL<br>dispatch_semaphore_create（信号量值）<br><br><span class="hljs-regexp">//</span>减少信号量，时间：DISPATCH_TIME_NOW、DISPATCH_TIME_FOREVER<br>dispatch_semaphore_wait（信号量，等待时间）<br><br><span class="hljs-regexp">//</span>释放信号量<br>dispatch_semaphore_signal(信号量)<br></code></pre></td></tr></table></figure><p>#示例13.1：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>semaphore&#123;<br>    dispatch_queue_t mQueue = dispatch_queue_create<span class="hljs-params">(<span class="hljs-string">&quot;concurrentQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT)</span>;<br>    dispatch_semaphore_t semaphore = dispatch_semaphore_create<span class="hljs-params">(<span class="hljs-number">0</span>)</span>;<br>    <br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++1&quot;</span>)</span>;<br>    dispatch_async<span class="hljs-params">(mQueue, ^&#123;</span><br><span class="hljs-params">        sleep(<span class="hljs-number">2</span>);</span><br><span class="hljs-params">        NSLog(@<span class="hljs-string">&quot;+++first task&quot;</span>);</span><br><span class="hljs-params">        dispatch_semaphore_signal(semaphore);</span><br><span class="hljs-params">    &#125;)</span>;<br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++2&quot;</span>)</span>;<br>    dispatch_semaphore_wait<span class="hljs-params">(semaphore, DISPATCH_TIME_FOREVER)</span>;<br>    <br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++3&quot;</span>)</span>;<br>    dispatch_async<span class="hljs-params">(mQueue, ^&#123;</span><br><span class="hljs-params">        sleep(<span class="hljs-number">2</span>);</span><br><span class="hljs-params">        NSLog(@<span class="hljs-string">&quot;+++second task&quot;</span>);</span><br><span class="hljs-params">        dispatch_semaphore_signal(semaphore);</span><br><span class="hljs-params">    &#125;)</span>;<br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++4&quot;</span>)</span>;<br>    dispatch_semaphore_wait<span class="hljs-params">(semaphore, DISPATCH_TIME_FOREVER)</span>;<br><br>    NSLog<span class="hljs-params">(@<span class="hljs-string">&quot;+++5&quot;</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">59</span> +++<span class="hljs-number">1</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">18</span>:<span class="hljs-number">59</span> +++<span class="hljs-number">2</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">01</span> +++first task<br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">01</span> +++<span class="hljs-number">3</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">01</span> +++<span class="hljs-number">4</span><br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">03</span> +++second task<br><span class="hljs-attribute">13</span>:<span class="hljs-number">19</span>:<span class="hljs-number">03</span> +++<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>示例中创建了初始值&#x3D;0的信号量，随后开始了两个异步打印数字的任务。从日志来看，“+++first task” 在”+++3” 之前，而“+++5”是最后才打印的，这是因为信号量&#x3D;0时<code>dispatch_semaphore_wait()</code>处自动阻塞了当前线程，两个打印任务执行完之后<code>dispatch_semaphore_signal()</code>使信号量&#x3D;1，当前线程才得以继续执行。</p><p>#示例13.2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//初始信号量</span><br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">dispatch_queue_t</span> quene = dispatch_queue_create(<span class="hljs-string">&quot;com.M.D&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br><br><span class="hljs-comment">//任务1</span><br><span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务1&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务1&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br><br><span class="hljs-comment">//任务2</span><br><span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务2&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务2&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br><br><span class="hljs-comment">//任务3</span><br><span class="hljs-built_in">dispatch_async</span>(quene, ^&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++任务3&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++完成任务3&quot;</span>);<br>    dispatch_semaphore_signal(semaphore);<br>&#125;);<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务3</span><br></code></pre></td></tr></table></figure><p><strong>ps</strong>，信号量的使用只保证了并发场景下每次只有一个线程执行任务，并不能保证任务的执行顺序，再运行一次后日志如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++</span><span class="hljs-comment">任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务1</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务3</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">任务2</span><br><span class="hljs-literal">+++</span><span class="hljs-comment">完成任务2</span><br></code></pre></td></tr></table></figure><h3 id="14-GCD倒计时"><a href="#14-GCD倒计时" class="headerlink" title="14.GCD倒计时"></a>14.GCD倒计时</h3><p>#示例14.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//@property (strong, nonatomic) dispatch_source_t aTimer;</span><br><br>- (<span class="hljs-type">void</span>) GCDTimer<br>&#123;<br>    __block <span class="hljs-type">int</span> timeout = <span class="hljs-number">60</span>; <span class="hljs-comment">//倒计时时间</span><br>    <span class="hljs-built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br>    <br>    _aTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,queue);<br>    <br>    dispatch_source_set_timer(_aTimer,dispatch_walltime(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>),<span class="hljs-number">1.0</span>*<span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//每秒执行</span><br>    <br>    dispatch_source_set_event_handler(_aTimer, ^&#123;<br>        <span class="hljs-keyword">if</span>(timeout&lt;=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//倒计时结束，关闭</span><br>            dispatch_source_cancel(_aTimer);<br>            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                <span class="hljs-comment">//设置界面的按钮显示 根据自己需求设置</span><br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;<br>                <span class="hljs-comment">//设置界面的按钮显示 根据自己需求设置</span><br>            &#125;);<br>            timeout--;<br>        &#125;<br>    &#125;);<br>    dispatch_resume(_aTimer);<br>&#125;<br></code></pre></td></tr></table></figure><p>GCD定时器并不是由NSTimer或者CFRunLoopTimer实现的，无需加入到RunloopMode中，所以不会出现因RunloopMode切换而失效的问题。</p><h3 id="15-GCD读写锁"><a href="#15-GCD读写锁" class="headerlink" title="15.GCD读写锁"></a>15.GCD读写锁</h3><p>为了保证数据访问或者方法调用时的线程安全，一般我们可以使用<code>锁</code>来实现同步机制，比如<code>@synchronized()</code>和<code>NSLock</code>等。但是，频繁的上锁、释放锁的操作会降低执行效率。所以我们可以考虑使用<code>dispatch_barrier_async</code>，通过 GCD 对任务的调度来达到相同的效果。</p><p>思路：<code>dispatch_barrier_async</code>能确保在其之前提交到队列的任务先执行，然后执行它自己提交的任务，最后执行其后提交的任务。利用这个特点，我们可以将数据的读写操作放入一个并发队列中，写数据的任务通过<code>栅栏</code>提交到队列中，读数据的任务则可以同步的提交到队列中。这样就能保证执行写操作时，读操作或其他写操作都被阻塞，而执行读操作时，写操作被阻塞，将读写分开从而避免数据的污染。</p><p>#示例15.1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSMutableArray</span> *mArr;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">dispatch_queue_t</span> mPropertyConcurrentQueue;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br><span class="hljs-keyword">@synthesize</span> mArr = _mArr;<br><br>- (<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    __block <span class="hljs-built_in">NSMutableArray</span> *tmpArr;<br>    <span class="hljs-built_in">dispatch_sync</span>(_mPropertyConcurrentQueue, ^&#123;<span class="hljs-comment">//并发队列+同步=串行，不能使用dispatch_async，会直接返回</span><br>        tmpArr = _mArr;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> tmpArr;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)setMArr:(<span class="hljs-built_in">NSMutableArray</span> *)mArr&#123;<br>    dispatch_barrier_async(_mPropertyConcurrentQueue, ^&#123;<br>        _mArr = mArr;<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//使用自己创建的并发队列，不能使用系统的dispatch_get_global_queue，上面章节中有讲到这一点</span><br>    _mPropertyConcurrentQueue = dispatch_queue_create(<span class="hljs-string">&quot;readWriteQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-built_in">dispatch_queue_t</span> tmpQueue = dispatch_queue_create(<span class="hljs-string">&quot;1&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br>            <span class="hljs-keyword">if</span> ((i % <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">dispatch_async</span>(tmpQueue, ^&#123;<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++Reset array,thread:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>                    <span class="hljs-keyword">self</span>.mArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br>                &#125;);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">dispatch_async</span>(tmpQueue, ^&#123;<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++Add num:%d,thread:%@&quot;</span>,i,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>                    [<span class="hljs-keyword">self</span>.mArr addObject:@(i)];<br>                &#125;);<br>            &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSThread</title>
    <link href="/2017/11/07/nsthread.html"/>
    <url>/2017/11/07/nsthread.html</url>
    
    <content type="html"><![CDATA[<h3 id="1、进程-amp-线程"><a href="#1、进程-amp-线程" class="headerlink" title="1、进程 &amp; 线程"></a>1、进程 &amp; 线程</h3><p>#定义与划分尺度：</p><ul><li>程序的一次执行过程就是进程，它是系统进行资源分配和调度的一个独立单位。</li><li>线程是进程的一个实体，是进程内的一个执行单元，一个进程至少有一个线程。</li></ul><p>#地址空间：</p><ul><li>进程有自己独立的虚拟地址空间，而线程共享进程的地址空间。</li></ul><p>#拥有的资源：</p><ul><li>进程是资源分配和拥有的单位；同一个进程内的线程共享进程资源。</li></ul><p>#执行单位：</p><ul><li>线程是CPU调度和分派的基本单位，而进程不是。</li></ul><p>#并发：</p><ul><li>二者均可并发执行（打开多个应用为进程并发；多线程同时执行下载任务为线程并发）。</li></ul><h3 id="2、并发-amp-并行"><a href="#2、并发-amp-并行" class="headerlink" title="2、并发 &amp; 并行"></a>2、并发 &amp; 并行</h3><p>1、场景：</p><p>并发，一个处理器同时处理多个任务。 </p><p>并行，多个处理器或多核的处理器同时处理多个不同的任务。</p><p>2、概念区分：</p><p><strong>并发</strong>(Concurrency)：在同一时刻只能有一条指令执行，但多个指令被快速的轮换执行，使得在宏观上具有多个线程同时执行的效果，但在微观上并不是同时执行的。</p><p><strong>并行</strong>(Parallel)：在同一时刻，有多条指令在多个处理器上同时执行，无论从微观还是从宏观来看，二者都是一起执行的。</p><h3 id="3、多线程"><a href="#3、多线程" class="headerlink" title="3、多线程"></a>3、多线程</h3><p><strong>为什么要有多线程？</strong></p><p>iOS应用中主线程用来处理界面更新、响应用户触摸事件等。在主线程中执行大量耗时操作会造成主线程阻塞，进而出现卡顿现象以致影响使用和用户体验。故需要将这种耗时操作放到其他的线程中执行。所以多线程编程是防止主线程堵塞，增加运行效率的最佳方法。</p><p><strong>为什么不无限制的开辟N条新线程呢？</strong></p><ul><li>首先，线程的创建需要开销，占用一定得内存空间；</li><li>其次，有N条线程时处理器需要在多条线程之间频繁调度，这也需要大量开销；</li><li>最后，N条线程时还需要考虑到这些线程之间的通信和资源共享等问题。</li></ul><p><strong>有哪些多线程解决方案？</strong></p><p>iOS支持多个层次的多线程编程，层次越高的抽象程度越高，使用也越方便，也是苹果最推荐使用的方法。根据抽象程度由低到高列出如下：</p><ul><li><strong>NSThread ：</strong></li></ul><p>是三种方法里面相对轻量级的，需要自己管理线程的生命周期、同步、加锁问题，这会导致一定的性能开销。</p><ul><li><strong>NSOperation：</strong></li></ul><p>是基于OC实现的，它以面向对象的方式封装了需要执行的操作，不必关心线程管理、同步等问题。NSOperation 是一个抽象基类，iOS提供了两种默认实现：NSInvocationOperation 和 NSBlockOperation，也可以自定义 NSOperation。</p><ul><li><strong>Grand Central Dispatch(简称GCD，iOS4才开始支持)：</strong></li></ul><p>提供了一些新特性、运行库来支持多核并行编程，它的关注点更高：如何在多个CPU上提升效率。</p><h3 id="4、NSThread"><a href="#4、NSThread" class="headerlink" title="4、NSThread"></a>4、NSThread</h3><h4 id="4-1-生命周期"><a href="#4-1-生命周期" class="headerlink" title="4.1.生命周期"></a>4.1.生命周期</h4><p>#创建</p><ul><li>实例方法：创建后需要手动调用start函数来启动线程；</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(instancetype)</span>initWithTarget:<span class="hljs-params">(id)</span>target <br>selector:<span class="hljs-params">(SEL)</span>selector <br>object:<span class="hljs-params">(id)</span>argument;<br><br>- <span class="hljs-params">(instancetype)</span>initWithBlock:<span class="hljs-params">(void (^)</span><span class="hljs-params">(void)</span>)block ;<br></code></pre></td></tr></table></figure><p>第一种实例化方法中，参数selector会在刚创建的线程对象执行<code>start</code>方法之后被调用，且是在当前新线程中调用。</p><ul><li>类方法：自动启动线程，无需手动调用start函数。</li></ul><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-operator">+</span> (<span class="hljs-keyword">void</span>)detachNewThreadWithBlock<span class="hljs-operator">:</span>(<span class="hljs-keyword">void</span> (<span class="hljs-operator">^</span>)(<span class="hljs-keyword">void</span>))block ;<br><br><span class="hljs-operator">+</span> (<span class="hljs-keyword">void</span>)detachNewThreadSelector<span class="hljs-operator">:</span>(SEL)selector <br>toTarget<span class="hljs-operator">:</span>(<span class="hljs-built_in">id</span>)target <br>withObject<span class="hljs-operator">:</span>(<span class="hljs-built_in">id</span>)argument;<br></code></pre></td></tr></table></figure><ul><li>分类创建：NSObject(NSThreadPerformAdditions)</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(void)</span>performSelectorInBackground:<span class="hljs-params">(SEL)</span>aSelector <br>withObject:<span class="hljs-params">(id)</span>arg;<br></code></pre></td></tr></table></figure><p>#就绪</p><ul><li>将线程放进可调度线程池,等待被CPU调度:</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[threadObj start]</span>；<span class="hljs-comment">//注意：同一个线程对象不能连续调用start方法！</span><br></code></pre></td></tr></table></figure><p>#运行</p><ul><li>CPU负责调度线程池中处于”就绪状态”的线程。</li></ul><p>#阻塞</p><ul><li>正在运行的线程,可以用休眠或者锁来阻塞线程的执行。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-type">void</span>)sleepUntilDate:(<span class="hljs-built_in">NSDate</span> *)date;<br>+ (<span class="hljs-type">void</span>)sleepForTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti;<br></code></pre></td></tr></table></figure><ul><li>互斥锁</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">@synchronized</span>(<span class="hljs-keyword">self</span>)<br></code></pre></td></tr></table></figure><p>#死亡</p><p>一般情况下（不考虑引用、runloop），线程执行完任务后会自动销毁。也可以在满足某条件后调用exit方法，强制线程退出。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[NSThread <span class="hljs-keyword">exit</span>];<br></code></pre></td></tr></table></figure><h4 id="4-2-线程间通信"><a href="#4-2-线程间通信" class="headerlink" title="4.2.线程间通信"></a>4.2.线程间通信</h4><ul><li>指定当前线程执行操作</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[<span class="hljs-keyword">self</span> <span class="hljs-symbol">performSelector:</span><span class="hljs-variable">@selector</span>(run)];<br>[<span class="hljs-keyword">self</span> <span class="hljs-symbol">performSelector:</span><span class="hljs-variable">@selector</span>(run) <span class="hljs-symbol">withObject:</span><span class="hljs-literal">nil</span>];<br>[<span class="hljs-keyword">self</span> <span class="hljs-symbol">performSelector:</span><span class="hljs-variable">@selector</span>(run) <span class="hljs-symbol">withObject:</span><span class="hljs-literal">nil</span> <span class="hljs-symbol">afterDelay:</span><span class="hljs-number">5.0</span>];<br></code></pre></td></tr></table></figure><ul><li>在主线程指定其他线程执行操作</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(run) onThread:newThread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>]; <br>[<span class="hljs-keyword">self</span> performSelectorInBackground:<span class="hljs-keyword">@selector</span>(run) withObject:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure><ul><li>在其他线程中指定主线程执行操作</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[<span class="hljs-keyword">self</span> performSelectorOnMainThread:<span class="hljs-keyword">@selector</span>(run) withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br></code></pre></td></tr></table></figure><h4 id="4-3-线程同步"><a href="#4-3-线程同步" class="headerlink" title="4.3.线程同步"></a>4.3.线程同步</h4><p>多个线程同时读写同一份共享资源时，可能会引起冲突。<code>线程同步</code>是指在一定时间内只允许某一个线程访问某个资源。OC 中实现线程加锁有 NSLock 和 @synchronized 等方式。</p><ul><li>NSLock 创建锁对象、加锁和解锁:</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">NSLock * <span class="hljs-keyword">lock</span> = [[NSLock alloc]init];<br>  <br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>    [<span class="hljs-keyword">lock</span> <span class="hljs-keyword">lock</span>];<br>    // <span class="hljs-keyword">do</span> <span class="hljs-keyword">work</span><br>    [<span class="hljs-keyword">lock</span> unlock];<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>@synchronized()指令对一段代码进行加锁。它需要一个参数，该参数可以是任何的OC对象，包括self。这个对象就是互斥信号量。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@synchronized</span>(<span class="hljs-variable language_">self</span>)  &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">do</span> work<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5、线程保活"><a href="#5、线程保活" class="headerlink" title="5、线程保活"></a>5、线程保活</h3><p>默认情况下，子线程在执行完任务之后，会自动销毁。如果想复用此线程或者继续在此线程上执行其他任务，则需要让此线程一直活着而不被销毁；</p><p>思路：给子线程所在runloop添加事件源，如端口或自定义source，保证此runloop不退出。需要停止子线程时，停止线程所在runloop即可~</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 自定义线程</span><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">HelThread </span>: NSThread<br><span class="hljs-variable">@end</span><br><br><br><span class="hljs-comment">// 线程生命周期管理类</span><br><span class="hljs-variable">@interface</span> <span class="hljs-attribute">HelThreadHelper </span>: NSObject<br><br><span class="hljs-comment">/// 线程初始化</span><br><span class="hljs-comment">/// @param name 线程名</span><br><span class="hljs-built_in">-</span>(instancetype)<span class="hljs-attribute">initWithName</span>:(NSString*)name;<br><br><span class="hljs-comment">/// 开启线程</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">start</span>;<br><br><span class="hljs-comment">/// 停止当前线程</span><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">stop</span>;<br><br><span class="hljs-comment">/// 获取线程</span><br><span class="hljs-selector-tag">-</span>(NSThread *)<span class="hljs-selector-tag">getThread</span>;<br><br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;HelThreadHelper.h&quot;</span></span><br><br><span class="hljs-comment">//MAKR: -HelThread</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HelThread</span></span><br><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++THREAD IS DEALLOCED~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">//MAKR: -HelThreadHelper</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">HelThreadHelper</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) HelThread *mThread;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSCondition</span> *mConditionLock;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">HelThreadHelper</span></span><br><br><span class="hljs-comment">//MARK: -APIs</span><br>-(<span class="hljs-keyword">instancetype</span>)initWithName:(<span class="hljs-built_in">NSString</span>*)name&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _mConditionLock = [[<span class="hljs-built_in">NSCondition</span> alloc] init];<br>        _mThread = [[HelThread alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onThreadInit:) object:<span class="hljs-literal">nil</span>];<br>        _mThread.name = name;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)start&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++call Start:%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    [_mConditionLock lock];<br>    [_mThread start];<br>    [_mConditionLock wait]; <span class="hljs-comment">// 防止多线程环境下onThreadInit中尚未设置runloop就开始在_mThread上执行任务的情况</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++runloop Set finised~&quot;</span>);<br>    [_mConditionLock unlock];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)stop&#123;<br>    <span class="hljs-comment">// 回到所在线程 停止其runloop</span><br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(finish) onThread:_mThread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br>-(<span class="hljs-built_in">NSThread</span> *)getThread&#123;<br>    <span class="hljs-keyword">return</span> _mThread;<br>&#125;<br><br><span class="hljs-comment">//MARK: -Self Business</span><br>- (<span class="hljs-type">void</span>)onThreadInit:(<span class="hljs-type">id</span>)obj&#123;<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop Start:%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <br>    <span class="hljs-comment">// 线程保活</span><br>    <span class="hljs-built_in">CFRunLoopSourceContext</span> context = &#123;<span class="hljs-number">0</span>&#125;;<br>    context.perform = DoNothingRunLoopCallback;<br>    <br>    <span class="hljs-built_in">CFRunLoopSourceRef</span> source = <span class="hljs-built_in">CFRunLoopSourceCreate</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;context);<br>    <span class="hljs-built_in">CFRunLoopAddSource</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopCommonModes);<br>    <br>    [_mConditionLock lock];<br>    [_mConditionLock signal]; <span class="hljs-comment">// 线程创建和设置已完成，告诉调用者可以在_mThread上执行任务了</span><br>    [_mConditionLock unlock];<br>    <br>    <span class="hljs-comment">// 开启runloop，开始处理任务</span><br>    <span class="hljs-built_in">CFRunLoopRun</span>(); <span class="hljs-comment">// 开启循环，在被停止前会一直运行在这一行，不执行后面一行代码</span><br>    <br>    <span class="hljs-comment">// runloop已被停止 执行清理任务</span><br>    <span class="hljs-built_in">CFRunLoopRemoveSource</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopCommonModes);<br>    <span class="hljs-built_in">CFRelease</span>(source);<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop stop:%@&quot;</span>, [<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)finish&#123;<br>    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>()); <span class="hljs-comment">// 结束runloop</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> DoNothingRunLoopCallback(<span class="hljs-type">void</span> *info)&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop 回调~&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;HelThreadHelper.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ViewController</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) HelThreadHelper *mHelper;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ViewController</span></span><br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [<span class="hljs-variable language_">super</span> viewDidLoad];<br>    _mHelper = [[HelThreadHelper alloc] initWithName:<span class="hljs-string">@&quot;com.Hel.MyThread&quot;</span>];<br>    [_mHelper start];<br>&#125;<br><br><span class="hljs-comment">// 触发任务</span><br>- (<span class="hljs-keyword">IBAction</span>)onClick:(<span class="hljs-type">id</span>)sender &#123;<br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(onSel:)<br>      onThread:[_mHelper getThread]<br>    withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">NO</span>];<br>&#125;<br><br><span class="hljs-comment">// 结束线程</span><br>- (<span class="hljs-keyword">IBAction</span>)onStop:(<span class="hljs-type">id</span>)sender &#123;<br>    [_mHelper stop];<br>    _mHelper = <span class="hljs-literal">nil</span>; <span class="hljs-comment">// _mHelper置为nil后，其中被强引用的_mThread线程才会销毁</span><br>&#125;<br><br>- (<span class="hljs-type">void</span>)onSel:(<span class="hljs-type">id</span>)obj&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++call onSel: THREAD:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure><p>分别点击开始和结束按钮，执行任务和结束线程：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">+++<span class="hljs-keyword">call</span> Start:&lt;NSThread: <span class="hljs-number">0</span>x600003000040&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">name</span> = main&#125;<br>+++runloop Start:&lt;HelThread: <span class="hljs-number">0</span>x6000030602c0&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">5</span>, <span class="hljs-keyword">name</span> = com.Hel.MyThread&#125;<br>++runloop Set finised~<br>+++<span class="hljs-keyword">call</span> onSel: THREAD:&lt;HelThread: <span class="hljs-number">0</span>x6000030602c0&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">5</span>, <span class="hljs-keyword">name</span> = com.Hel.MyThread&#125;<br>+++runloop <span class="hljs-keyword">stop</span>:&lt;HelThread: <span class="hljs-number">0</span>x6000030602c0&gt;&#123;<span class="hljs-keyword">number</span> = <span class="hljs-number">5</span>, <span class="hljs-keyword">name</span> = com.Hel.MyThread&#125;<br>++++THREAD IS DEALLOCED~<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runloop</title>
    <link href="/2017/09/09/runloop.html"/>
    <url>/2017/09/09/runloop.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://davidlii.nos-eastchina1.126.net/pic_runloop_outline.png" alt="Runloop大纲"></p><h2 id="1-Runloop"><a href="#1-Runloop" class="headerlink" title="1.Runloop"></a>1.Runloop</h2><blockquote><p>Run loops are part of the fundamental infrastructure associated with threads.A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events.The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p></blockquote><p><code>Runloop</code>是处理事件的循环，与线程紧密相关。启动后所在线程相当于一直处在<code>do-while</code>循环中，从而避免没事做被系统自动回收；此时要销毁这个线程必须停止这个 Runloop。</p><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><ol><li>保持程序的持续运行；</li><li>处理App中的各种事件(如触摸事件、定时器事件、Selector事件)；</li><li>使线程有任务时执行任务，无任务时休眠，以节省CPU资源，提高程序性能；</li></ol><h3 id="2-与线程的关系"><a href="#2-与线程的关系" class="headerlink" title="2.与线程的关系"></a>2.与线程的关系</h3><p>每个线程都有相关的 Runloop 对象，Cocoa与CF框架都提供了接口帮助管理线程的Runloop，无须我们显式的创建这些对象。</p><ul><li><strong>主线程</strong></li></ul><p>在程序启动的过程中，系统会自动在<code>主线程</code>上设置并启动了一个 Runloop。具体入口是在 main 文件中的如下代码中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;AppDelegate.h&quot;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[]) &#123;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">UIApplicationMain</span>(argc, argv, <span class="hljs-literal">nil</span>, <span class="hljs-built_in">NSStringFromClass</span>([AppDelegate <span class="hljs-keyword">class</span>]));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>UIApplicationMain()</code>内部为主线程启动了一个runloop。应用能在无任何操作时休眠，监听到输入事件时立马响应，就是因为有这个runloop在一直监听和响应这些事件。</p><ul><li><strong>其他线程</strong></li></ul><p>除主线程外，其他线程的runloop默认都是没有开启的，只在第一次获取时才会自动创建，并在线程结束时销毁。因此，这些线程在执行任务时是一条直线类型，从起点到终点，执行完任务后线程就会销毁掉。如果想让子线程保活并继续执行任务，则可自行配置并启动其runloop。</p><p>#示例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//自定义ASDFThread</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ASDFThread</span> : <span class="hljs-title">NSThread</span></span><br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ASDFThread</span></span><br><br>- (<span class="hljs-type">void</span>)dealloc&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++THREAD IS DEALLOCED~&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">//AppDelegate 在自定义线程中执行任务</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ASDFThread.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    ASDFThread *th = [[ASDFThread alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onHandleEvent) object:<span class="hljs-literal">nil</span>];<br>    [th start];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)onHandleEvent&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++当前线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">++++当前线程:&lt;ASDFThread: <span class="hljs-number">0x600003575e80</span>&gt;&#123;number = <span class="hljs-number">3</span>, <span class="hljs-type">name</span> = (<span class="hljs-keyword">null</span>)&#125;<br>++++THREAD <span class="hljs-keyword">IS</span> DEALLOCED~<br></code></pre></td></tr></table></figure><p>可以看到，自定义的 ASDFThread 线程对象在执行完任务之后，自动销毁了。</p><p>如果要线程执行完任务后，仍不销毁以便复用，则可以在当前线程中开启 Runloop：</p><p>#示例2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)onHandleEvent&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++当前线程:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    <span class="hljs-comment">//开启runloop</span><br>    <span class="hljs-built_in">CFRunLoopSourceContext</span> context = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">CFRunLoopSourceRef</span> source = <span class="hljs-built_in">CFRunLoopSourceCreate</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, &amp;context);<br>    <span class="hljs-built_in">CFRunLoopAddSource</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopCommonModes);<br>    <span class="hljs-built_in">CFRunLoopRun</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>往子线程所在RunLoop中加入一个<code>source</code>并启动Runloop，线程执行完任务后不再自动销毁。</p><h2 id="2-RunLoopMode"><a href="#2-RunLoopMode" class="headerlink" title="2.RunLoopMode"></a>2.RunLoopMode</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">struct</span> __CFRunLoopMode &#123;<br>    <span class="hljs-comment">//Mode的名字</span><br>    <span class="hljs-built_in">CFStringRef</span> _name;<br>    <span class="hljs-comment">//事件源</span><br>    <span class="hljs-built_in">CFMutableSetRef</span> _sources0;<br>    <span class="hljs-built_in">CFMutableSetRef</span> _sources1;<br>    <span class="hljs-comment">//观察者</span><br>    <span class="hljs-built_in">CFMutableArrayRef</span> _observers;<br>    <span class="hljs-comment">//计时器</span><br>    <span class="hljs-built_in">CFMutableArrayRef</span> _timers;<br>&#125;;<br></code></pre></td></tr></table></figure><p>RunLoopMode本质上是个结构体，其中包含了与之对应的<code>事件类型</code>、<code>观察者</code>和<code>计时器</code>等。</p><p>Runloop对象可以和若干个<code>mode</code>关联起来。但同一时间 Runloop 只能运行在一种模式下；</p><p>运行过程中，只有指定模式下的输入源才会被监听以及收到当前Runloop进度的通知。</p><p>需要切换Mode时，要先退出当前RunLoop，再选择一个Mode进入；切换Mode不会导致程序退出。</p><h3 id="1-具体模式"><a href="#1-具体模式" class="headerlink" title="1.具体模式"></a>1.具体模式</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">NSDefaultRunLoopMode</span><br>或<br>KCFRunLoopDefaultMode<br></code></pre></td></tr></table></figure><p>应用默认的运行模式；</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">UITrackingRunLoopMode</span><br></code></pre></td></tr></table></figure><p>界面跟踪模式，用以在拖动界面时限制其他事件的进入，滑动时主线程的RunLoop会从<code>Default</code>模式切换到<code>Tracking</code>模式；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">NSRunLoopCommonModes</span><br>或<br>KCFRunLoopCommonModes<br></code></pre></td></tr></table></figure><p>这是个可配置的模式集合而非一个真正的模式，默认包括了<code>Default</code>和<code>EventTracking</code>模式。将<code>输入源</code>与该模式关联，实质是将<code>输入源</code>与该组中的每个模式进行了关联。</p><h3 id="2-场景：定时器失效"><a href="#2-场景：定时器失效" class="headerlink" title="2.场景：定时器失效"></a>2.场景：定时器失效</h3><p>通过<code>scheduled</code>方式创建的<code>Timer</code>默认使用<code>DefaultMode</code>，而拖拽滚动 Scrollview 时 Runloop 处于<code>TrackingMode</code>。由于 Runloop 一次只能运行在一种 Mode 下，所以滚动过程中主线程Runloop无法处理注册在其<code>DefaultMode</code>下的定时器事件，因此定时器也就不会触发。</p><p><strong>解决方案：</strong></p><h4 id="方案1-CommonMode"><a href="#方案1-CommonMode" class="headerlink" title="方案1: CommonMode"></a>方案1: CommonMode</h4><p>将定时器标记为<code>common</code>模式。</p><p>思路：定时器默认被加入到当前线程Runloop的<code>DefaultMode</code>中，被标记为<code>common</code>后会自动与<code>common</code>模式中的<code>Tracking</code>模式进行关联。而滑动时Runloop处在<code>Tracking</code>模式下，所以计时器事件能正常响应。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSTimer</span> *aTimer = [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span><br>                                                       target:<span class="hljs-keyword">self</span><br>                                                     selector:<span class="hljs-keyword">@selector</span>(repeat:)<br>                                                     userInfo:<span class="hljs-literal">nil</span><br>                                                      repeats:<span class="hljs-literal">true</span>];<br>[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addTimer:aTimer forMode:<span class="hljs-built_in">NSRunLoopCommonModes</span>];<br></code></pre></td></tr></table></figure><h4 id="方案2-子线程"><a href="#方案2-子线程" class="headerlink" title="方案2: 子线程"></a>方案2: 子线程</h4><p>将定时器放入子线程中并开启此线程的RunLoop：</p><p>思路：滑动操作发生在主线程，定时器所在的线程是子线程，所以两者互不影响。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">dispatch_async</span>(<span class="hljs-title function_ invoke__">dispatch_get_global_queue</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        [NSTimer <span class="hljs-attr">scheduledTimerWithTimeInterval</span>:<span class="hljs-number">1</span><br>                                         <span class="hljs-attr">target</span>:<span class="hljs-built_in">self</span><br>                                       <span class="hljs-attr">selector</span>:@<span class="hljs-title function_ invoke__">selector</span>(<span class="hljs-attr">aSelector</span>:)<br>                                       <span class="hljs-attr">userInfo</span>:nil <span class="hljs-attr">repeats</span>:<span class="hljs-literal">true</span>];<br>        [[NSRunLoop currentRunLoop] run];<br>    &#125;);<br></code></pre></td></tr></table></figure><p>需要注意的是，子线程中使用定时器，一定要主动开启子线程的RunLoop，否则定时器不会触发。</p><h4 id="方案3-GCD-timer"><a href="#方案3-GCD-timer" class="headerlink" title="方案3: GCD timer"></a>方案3: GCD timer</h4><p>使用GCD提供的定时器API:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;GCDTimerTest.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">GCDTimerTest</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">dispatch_queue_t</span> seriaqueue;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) dispatch_source_t timer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">GCDTimerTest</span></span><br><br>- (<span class="hljs-type">void</span>)gcd_timer&#123;<br>    _seriaqueue = dispatch_queue_create(<span class="hljs-string">&quot;xx&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) wself = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-built_in">dispatch_async</span>(_seriaqueue, ^&#123;<br>        __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(wself) sself = wself;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop before timer:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>        sself.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, sself.seriaqueue);<br>        dispatch_source_set_timer(sself.timer, DISPATCH_TIME_NOW, <span class="hljs-number">1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>);<br>        dispatch_source_set_event_handler(sself.timer, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行计时任务&quot;</span>);<br>            <span class="hljs-comment">//dispatch_source_cancel(sself.timer);</span><br>        &#125;);<br>        dispatch_resume(sself.timer);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop after timer:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>GCD定时器不是RunLoop的源，不受Mode切换的影响，可参考<code>#3.2定时源-特殊定时器</code>章节的解析。</p><h2 id="3-事件来源"><a href="#3-事件来源" class="headerlink" title="3.事件来源"></a>3.事件来源</h2><p>Runloop中有了事件源才会有事做，才不会退出循环。事件源分两大类：<code>输入源</code>和<code>定时源</code>。</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_runloop.jpg" alt="image"></p><h3 id="1-输入源"><a href="#1-输入源" class="headerlink" title="1.输入源"></a>1.输入源</h3><p>输入源事件分为<code>source0</code>和<code>source1</code>两种:</p><ul><li>source0：需要手动唤醒runloop，如触摸、滑动事件、performSelector:onThread:；</li><li>source1：具备唤醒runloop的能力，如基于Port的线程间通信、系统事件捕捉(mach_msg)；</li></ul><h4 id="1-自定义的输入源"><a href="#1-自定义的输入源" class="headerlink" title="1.自定义的输入源"></a>1.自定义的输入源</h4><p><code>Source0</code>类型，它并不能主动触发事件。使用时要先调用<code>CFRunLoopSourceSignal()</code>，将其标记为待处理。然后看当前Runloop是否在休眠中，如果是则手动调用<code>CFRunLoopWakeUp()</code>来唤醒RunLoop，让其处理这个事件。</p><p>#示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void source<span class="hljs-constructor">Performor(<span class="hljs-params">void</span><span class="hljs-operator">*</span> <span class="hljs-params">info</span>)</span><br>&#123;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;处理自定义输入源事件&quot;</span>)</span>;<br>&#125;<br><br>- (void)customInputsource<br>&#123;<br>    dispatch<span class="hljs-constructor">_async(<span class="hljs-params">dispatch_get_global_queue</span>(0, 0)</span>, ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;开启线程.......&quot;</span>)</span>;<br>        _mRunLoopRef = <span class="hljs-constructor">CFRunLoopGetCurrent()</span>;<br>        <br>        <span class="hljs-comment">//创建CFRunLoopSourceContext对象</span><br>        CFRunLoopSourceContext mContext;<br>        bzero(&amp;mContext, sizeof(mContext));<br>        <br>        <span class="hljs-comment">//给context对象绑定一个函数</span><br>        mContext.perform = sourcePerformor;<br>        mContext.info = <span class="hljs-string">&quot;information&quot;</span>;<br>        <br>        <span class="hljs-comment">//创建CFRunLoopSourceRef对象</span><br>        _mSourceRef = <span class="hljs-constructor">CFRunLoopSourceCreate(NULL, 0, &amp;<span class="hljs-params">mContext</span>)</span>;<br>        <br>        <span class="hljs-comment">//将source添加到当前RunLoop中</span><br>        <span class="hljs-constructor">CFRunLoopAddSource(<span class="hljs-params">_mRunLoopRef</span>, <span class="hljs-params">_mSourceRef</span>, <span class="hljs-params">kCFRunLoopDefaultMode</span>)</span>;<br>        <br>        <span class="hljs-comment">//开启Runloop</span><br>        <span class="hljs-constructor">CFRunLoopRunInMode(<span class="hljs-params">kCFRunLoopDefaultMode</span>, 10000, YES)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;线程结束.......&quot;</span>)</span>;<br>    &#125;);<br>    <br>    <span class="hljs-comment">//2秒后执行</span><br>    dispatch<span class="hljs-constructor">_after(<span class="hljs-params">dispatch_time</span>(DISPATCH_TIME_NOW, (<span class="hljs-params">int64_t</span>)</span>(<span class="hljs-number">2</span><span class="hljs-operator"> * </span>NSEC_PER_SEC)),<br>                   dispatch<span class="hljs-constructor">_get_main_queue()</span>, ^&#123;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">CFRunLoopIsWaiting(<span class="hljs-params">_mRunLoopRef</span>)</span>) &#123;<br>            <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;RunLoop正在等待事件输入+++&quot;</span>)</span>;<br>            <span class="hljs-comment">//添加输入事件</span><br>            <span class="hljs-constructor">CFRunLoopSourceSignal(<span class="hljs-params">_mSourceRef</span>)</span>; <br>            <span class="hljs-comment">//唤醒线程，线程唤醒后发现由事件需要处理，于是立即处理事件</span><br>            <span class="hljs-constructor">CFRunLoopWakeUp(<span class="hljs-params">_mRunLoopRef</span>)</span>; <span class="hljs-comment">// 在主线程中唤醒其他子线程的runloop。</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;RunLoop正在处理事件+++&quot;</span>)</span>;<br>            <span class="hljs-comment">//添加输入事件，当前正在处理一个事件，当前事件处理完成后，立即处理当前新输入的事件</span><br>            <span class="hljs-constructor">CFRunLoopSourceSignal(<span class="hljs-params">_mSourceRef</span>)</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行后，输出日志：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span>:<span class="hljs-number">32</span>:<span class="hljs-number">21</span>.<span class="hljs-number">497879</span>+<span class="hljs-number">0800</span>  开启线程.......<br><span class="hljs-attribute">00</span>:<span class="hljs-number">32</span>:<span class="hljs-number">24</span>.<span class="hljs-number">663180</span>+<span class="hljs-number">0800</span>  RunLoop正在等待事件输入+++<br><span class="hljs-attribute">00</span>:<span class="hljs-number">32</span>:<span class="hljs-number">24</span>.<span class="hljs-number">663498</span>+<span class="hljs-number">0800</span>  处理自定义输入源事件<br><span class="hljs-attribute">00</span>:<span class="hljs-number">32</span>:<span class="hljs-number">24</span>.<span class="hljs-number">663881</span>+<span class="hljs-number">0800</span>  线程结束.......<br></code></pre></td></tr></table></figure><h4 id="2-Perform-Selector"><a href="#2-Perform-Selector" class="headerlink" title="2.Perform Selector"></a>2.Perform Selector</h4><p><code>Source0</code>类型，是 Cocoa 提供的一种自定义的源，允许你在任何线程上执行一个selector。下面列举了<code>NSObject</code>分类中定义的三种<code>performSelector</code>方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs erlang">@interface NSObject (NSThreadPerformAdditions)<br><br>- <span class="hljs-params">(void)</span>performSelectorOnMainThread:<span class="hljs-params">(SEL)</span>aSelector <br>withObject:<span class="hljs-params">(id)</span>arg <br>waitUntilDone:<span class="hljs-params">(BOOL)</span>wait <br>modes:<span class="hljs-params">(NSArray&lt;NSString *&gt; *)</span>array;<br><br>- <span class="hljs-params">(void)</span>performSelectorOnMainThread:<span class="hljs-params">(SEL)</span>aSelector <br>withObject:<span class="hljs-params">(id)</span>arg <br>waitUntilDone:<span class="hljs-params">(BOOL)</span>wait;<br>// equivalent to the first method with kCFRunLoopCommonModes<br><br>- <span class="hljs-params">(void)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector <br>onThread:<span class="hljs-params">(NSThread *)</span>thr <br>withObject:<span class="hljs-params">(id)</span>arg <br>waitUntilDone:<span class="hljs-params">(BOOL)</span>wait <br>modes:<span class="hljs-params">(NSArray&lt;NSString *&gt; *)</span>array;<br><br>- <span class="hljs-params">(void)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector <br>onThread:<span class="hljs-params">(NSThread *)</span>thr <br>withObject:<span class="hljs-params">(id)</span>arg <br>waitUntilDone:<span class="hljs-params">(BOOL)</span>wait;<br>// equivalent to the first method with kCFRunLoopCommonModes<br><br>- <span class="hljs-params">(void)</span>performSelectorInBackground:<span class="hljs-params">(SEL)</span>aSelector <br>withObject:<span class="hljs-params">(id)</span>arg;<br><br>@end<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>OnMainThread</code> 是在主线程上执行任务；</li><li><code>onThread</code> 是在你指定的线程中执行任务，可以是主线程也可以是子线程；</li><li><code>InBackground</code> 则是在由系统自动分配的一个子线程中执行任务；</li><li><code>withObject</code> 是 selector 方法的参数；</li><li><code>waitUntilDone</code> 表示 <code>performSelector</code> 所处的线程是否等 <code>selector</code> 中的任务执行完再继续执行下一行；</li></ul><p>#示例：</p><ul><li>自定义的子线程工具类</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ASDFThreadHelper</span> : <span class="hljs-title">NSObject</span></span><br><br>-(<span class="hljs-built_in">NSThread</span> *)getThread;<br>- (<span class="hljs-type">void</span>)finish;<br>-(<span class="hljs-keyword">instancetype</span>)initWithName:(<span class="hljs-built_in">NSString</span>*)name;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ASDFThreadHelper</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSThread</span> *thread;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ASDFThreadHelper</span></span><br><br>-(<span class="hljs-keyword">instancetype</span>)initWithName:(<span class="hljs-built_in">NSString</span>*)name&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init]) &#123;<br>        _thread = [[<span class="hljs-built_in">NSThread</span> alloc] initWithTarget:<span class="hljs-keyword">self</span> selector:<span class="hljs-keyword">@selector</span>(onThreadInit:) object:<span class="hljs-literal">nil</span>];<br>        _thread.name = name;<br>        [_thread start];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>-(<span class="hljs-built_in">NSThread</span> *)getThread&#123;<br>    <span class="hljs-keyword">return</span> _thread;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)onThreadInit:(<span class="hljs-type">id</span>)obj&#123;<br>    <span class="hljs-comment">//因为是子线程，所以需要启动其runloop，不然子线程启动后就立刻退出，performselector时会崩溃</span><br>    <span class="hljs-built_in">CFRunLoopRun</span>();<br>&#125;<br><br>- (<span class="hljs-type">void</span>)start&#123;<br>    [_thread start];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)finish&#123;<br>    <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li>调用performSelector</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span>()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) ASDFThreadHelper *threadHelper;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++before:%ld&quot;</span>,(<span class="hljs-type">long</span>)<span class="hljs-built_in">CFGetRetainCount</span>((__bridge <span class="hljs-built_in">CFTypeRef</span>)(<span class="hljs-keyword">self</span>)));<br>    _threadHelper = [[ASDFThreadHelper alloc] initWithName:<span class="hljs-string">@&quot;asdf&quot;</span>];<br>    <br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(onSelector:)<br>                 onThread:[_threadHelper getThread]<br>               withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br>    <br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++after:%ld&quot;</span>,(<span class="hljs-type">long</span>)<span class="hljs-built_in">CFGetRetainCount</span>((__bridge <span class="hljs-built_in">CFTypeRef</span>)(<span class="hljs-keyword">self</span>)));<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>-(<span class="hljs-type">void</span>)onSelector:(<span class="hljs-type">id</span>)obj&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++excute:%ld,thread:%@,&quot;</span>,<br>          (<span class="hljs-type">long</span>)<span class="hljs-built_in">CFGetRetainCount</span>((__bridge <span class="hljs-built_in">CFTypeRef</span>)(<span class="hljs-keyword">self</span>)),[<span class="hljs-built_in">NSThread</span> currentThread]);<br>    [_threadHelper finish];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>输出日志</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">+++<span class="hljs-keyword">before</span>:<span class="hljs-number">1</span><br>+++excute:<span class="hljs-number">2</span>,thread:&lt;NSThread: <span class="hljs-number">0x600001850c40</span>&gt;&#123;<span class="hljs-built_in">number</span> = <span class="hljs-number">3</span>, <span class="hljs-built_in">name</span> = asdf&#125;,<br>+++<span class="hljs-keyword">after</span>:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>从日志来看：</p><ul><li>selector 会在我们指定的子线程中执行任务；</li><li>如果 <code>waitUntilDone=YES</code>，执行到 [self perform..onThread..] 时，主线程会等待 selector 执行完之后才继续执行下一行；</li><li>给 selector 指定的线程一定要有效，不能是已经退出的，所以我们需要在工具类中将子线程中的 runloop 启动起来；</li></ul><h4 id="3-基于端口的输入源"><a href="#3-基于端口的输入源" class="headerlink" title="3.基于端口的输入源"></a>3.基于端口的输入源</h4><p><code>Source1</code>类型，能主动唤醒线程的RunLoop。</p><p>内核中进程间的通信通过在两个端口之间传递消息来实现，Source1 监听的正是这些端口。你也可以手动创建端口，以实现不同线程间的通信。</p><p>#示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">-</span> (void)runloopPortTest<br>&#123;<br>    <span class="hljs-comment">//创建端口</span><br>    <span class="hljs-type">NSPort</span> <span class="hljs-operator">*</span><span class="hljs-type">PORT1</span> <span class="hljs-operator">=</span> [<span class="hljs-type">NSMachPort</span> new];<br>    <span class="hljs-type">NSPort</span> <span class="hljs-operator">*</span><span class="hljs-type">PORT2</span> <span class="hljs-operator">=</span> [<span class="hljs-type">NSMachPort</span> port];<br><br>    <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;<span class="hljs-subst">\n</span>PORT1:%@ <span class="hljs-subst">\n</span>PORT2:%@&quot;</span>,<span class="hljs-type">PORT1</span>, <span class="hljs-type">PORT2</span>);<br><br>    <span class="hljs-comment">//设置端口的代理</span><br>    <span class="hljs-type">PORT1</span>.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>;<br>    <span class="hljs-type">PORT2</span>.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>;<br><br>    <span class="hljs-comment">//给主线程runloop加一个端口</span><br>    [[<span class="hljs-type">NSRunLoop</span> currentRunLoop] addPort:<span class="hljs-type">PORT1</span> forMode:<span class="hljs-type">NSDefaultRunLoopMode</span>];<br><br>    <span class="hljs-comment">//给子线程添加端口并启动其runloop</span><br>    dispatch_async(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-operator">^</span>&#123;<br>        [[<span class="hljs-type">NSRunLoop</span> currentRunLoop] addPort:<span class="hljs-type">PORT2</span> forMode:<span class="hljs-type">NSDefaultRunLoopMode</span>];<br>        [[<span class="hljs-type">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-type">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-type">NSDate</span> distantFuture]];<br>    &#125;);<br><br>    <span class="hljs-comment">//component参数数组中只能包含两种类型的数据：一种是NSPort的子类，一种是NSData的子类；</span><br>    <span class="hljs-type">NSString</span> <span class="hljs-operator">*</span><span class="hljs-type">STR</span> <span class="hljs-operator">=</span> @<span class="hljs-string">&quot;III&quot;</span>;<br>    <span class="hljs-type">NSData</span>   <span class="hljs-operator">*</span>data <span class="hljs-operator">=</span> [<span class="hljs-type">STR</span> dataUsingEncoding:<span class="hljs-type">NSUTF8StringEncoding</span>];<br>    <span class="hljs-type">NSMutableArray</span> <span class="hljs-operator">*</span>array <span class="hljs-operator">=</span> [<span class="hljs-type">NSMutableArray</span> arrayWithArray:@[<span class="hljs-type">PORT1</span>,data]];<br><br>    <span class="hljs-comment">//2秒后向PORT2发送消息</span><br>    dispatch_after(dispatch_time(<span class="hljs-type">DISPATCH_TIME_NOW</span>, (int64_t)(<span class="hljs-number">2</span> <span class="hljs-operator">*</span> <span class="hljs-type">NSEC_PER_SEC</span>)), <br>                                    dispatch_get_main_queue(), <span class="hljs-operator">^</span>&#123;<br>        [<span class="hljs-type">PORT2</span> sendBeforeDate:[<span class="hljs-type">NSDate</span> date] msgid:<span class="hljs-number">101</span> components:array from:<span class="hljs-type">PORT1</span> reserved:<span class="hljs-number">0</span>];<br>    &#125;);<br>&#125;<br><br>#pragma mark <span class="hljs-operator">-</span><span class="hljs-type">NSPortDelegate</span><br><span class="hljs-operator">-</span> (void)handlePortMessage:(<span class="hljs-type">NSMessagePort</span><span class="hljs-operator">*</span>)message&#123;<br>    <span class="hljs-comment">//1. 消息id</span><br>    <span class="hljs-type">NSUInteger</span> msgId <span class="hljs-operator">=</span> [[message valueForKeyPath:@<span class="hljs-string">&quot;msgid&quot;</span>] integerValue];<br>    <span class="hljs-comment">//2. 当前主线程的port</span><br>    <span class="hljs-type">NSPort</span> <span class="hljs-operator">*</span>localPort <span class="hljs-operator">=</span> [message valueForKeyPath:@<span class="hljs-string">&quot;localPort&quot;</span>];<br>    <span class="hljs-comment">//3. 接收到消息的port（来自其他线程）</span><br>    <span class="hljs-type">NSPort</span> <span class="hljs-operator">*</span>remotePort <span class="hljs-operator">=</span> [message valueForKeyPath:@<span class="hljs-string">&quot;remotePort&quot;</span>];<br><br>    <span class="hljs-type">NSLog</span>(@<span class="hljs-string">&quot;<span class="hljs-subst">\n</span>执行端口代理回调：<span class="hljs-subst">\n</span>端口ID = %lu <span class="hljs-subst">\n</span>localPort:%@ </span><br><span class="hljs-string">    <span class="hljs-subst">\n</span>remotePort:%@&quot;</span>,(unsigned long)msgId, localPort, remotePort);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">101</span> <span class="hljs-operator">==</span> msgId)&#123;<br>        <span class="hljs-comment">//向子线的port发送消息</span><br>        [remotePort sendBeforeDate:[<span class="hljs-type">NSDate</span> date] msgid:<span class="hljs-number">102</span> components:<span class="hljs-literal">nil</span> from:localPort reserved:<span class="hljs-number">0</span>];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-number">102</span> <span class="hljs-operator">==</span> msgId)&#123;<br>    <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">19</span>:<span class="hljs-number">30:24.335</span><br>PORT1:&lt;NSMachPort: <span class="hljs-number">0</span>x6<span class="hljs-number">00000549d70</span>&gt;<br>PORT2:&lt;NSMachPort: <span class="hljs-number">0</span>x6<span class="hljs-number">00000340370</span>&gt;<br><span class="hljs-number">19</span>:<span class="hljs-number">30:26.337</span><br>执行端口代理回调：<br>端口ID = <span class="hljs-number">101</span><br>localPort:&lt;NSMachPort: <span class="hljs-number">0</span>x6<span class="hljs-number">00000340370</span>&gt;<br>remotePort:&lt;NSMachPort: <span class="hljs-number">0</span>x6<span class="hljs-number">00000549d70</span>&gt;<br><span class="hljs-number">19</span>:<span class="hljs-number">30:26.337</span><br>执行端口代理回调：<br>端口ID = <span class="hljs-number">102</span><br>localPort:&lt;NSMachPort: <span class="hljs-number">0</span>x6<span class="hljs-number">00000549d70</span>&gt;<br>remotePort:&lt;NSMachPort: <span class="hljs-number">0</span>x6<span class="hljs-number">00000340370</span>&gt;<br></code></pre></td></tr></table></figure><p>示例中两个线程间互相发送了一条消息。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(BOOL)</span>sendBeforeDate:<span class="hljs-params">(NSDate *)</span>limitDate<br>                 msgid:<span class="hljs-params">(NSUInteger)</span>msgID<br>            components:<span class="hljs-params">(NSMutableArray *)</span>components<br>                  from:<span class="hljs-params">(NSPort *)</span>receivePort<br>              reserved:<span class="hljs-params">(NSUInteger)</span>headerSpaceReserved;<br></code></pre></td></tr></table></figure><p>上面方法中，参数components数组中只能传NSPort、NSData类型的数据，所以除了NSPort对象外，其他数据需要先转成NSData类型。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@protocol</span> NSPortDelegate &lt;NSObject&gt;<br><span class="hljs-variable">@optional</span><br><br>- (void)<span class="hljs-attribute">handlePortMessage</span>:(NSPortMessage *)message;<br><span class="hljs-comment">// This is the delegate method that subclasses should send</span><br><span class="hljs-comment">// to their delegates, unless the subclass has something</span><br><span class="hljs-comment">// more specific that it wants to try to send first</span><br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure><p>消息回调之后，通过上面的代理接收，其中的 NSMessagePort 类型只能用 <code>KVC</code> 的方式取值。</p><h3 id="2-定时源"><a href="#2-定时源" class="headerlink" title="2.定时源"></a>2.定时源</h3><p>定时器的作用是：在预设的时间点或重复的时间间隔，触发某个操作。</p><h4 id="1-CFRunLoopTimer"><a href="#1-CFRunLoopTimer" class="headerlink" title="1.CFRunLoopTimer"></a>1.CFRunLoopTimer</h4><p>这是<code>Core Foundation</code>框架中的使用的定时器，使用方式如下面的示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-type">void</span> onScheduleTimer()&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++&quot;</span>);<br>&#125;<br>- (<span class="hljs-type">void</span>)runloop_timer&#123;<br>    <span class="hljs-built_in">CFRunLoopRef</span> runLoop = <span class="hljs-built_in">CFRunLoopGetCurrent</span>();<br>    <span class="hljs-built_in">CFRunLoopTimerContext</span> context = &#123;<span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-built_in">CFRunLoopTimerRef</span> aTimerRef = <span class="hljs-built_in">CFRunLoopTimerCreate</span>(<br>    kCFAllocatorDefault,<br>    <span class="hljs-number">1</span>, <span class="hljs-comment">//fireDate</span><br>    <span class="hljs-number">1</span>, <span class="hljs-comment">//interval</span><br>    <span class="hljs-number">0</span>, <span class="hljs-comment">//flags</span><br>    <span class="hljs-number">0</span>,<br>    &amp;onScheduleTimer, <span class="hljs-comment">//CFRunLoopTimerCallBack 回调函数</span><br>    &amp;context);<br>    <span class="hljs-built_in">CFRunLoopAddTimer</span>(runLoop, aTimerRef, kCFRunLoopCommonModes);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-NSTimer"><a href="#2-NSTimer" class="headerlink" title="2.NSTimer"></a>2.NSTimer</h4><p>这是Cocoa框架中经常使用都的的定时器，其创建方式有以下几种：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti <br>target:(<span class="hljs-type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="hljs-type">id</span>)userInfo repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)interval <br>repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti <br>invocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithFireDate:(<span class="hljs-built_in">NSDate</span> *)date <br>interval:(<span class="hljs-built_in">NSTimeInterval</span>)interval repeats:(<span class="hljs-type">BOOL</span>)repeats block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithFireDate:(<span class="hljs-built_in">NSDate</span> *)date <br>interval:(<span class="hljs-built_in">NSTimeInterval</span>)ti target:(<span class="hljs-type">id</span>)t selector:(SEL)s userInfo:(<span class="hljs-keyword">nullable</span> <span class="hljs-type">id</span>)ui repeats:(<span class="hljs-type">BOOL</span>)rep;<br></code></pre></td></tr></table></figure><p>这五种方式创建的<code>NSTimer</code>需通过”[[NSRunLoop currentRunLoop] addTimer:forMode:]”手动加入到 Runloop 中并指定模式才能正常开始。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti<br>target:(<span class="hljs-type">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="hljs-type">id</span>)userInfo repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)interval<br>repeats:(<span class="hljs-type">BOOL</span>)repeats <br>block:(<span class="hljs-type">void</span> (^)(<span class="hljs-built_in">NSTimer</span> *timer))block;<br><br>+ (<span class="hljs-built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="hljs-built_in">NSTimeInterval</span>)ti <br>invocation:(<span class="hljs-built_in">NSInvocation</span> *)invocation <br>repeats:(<span class="hljs-type">BOOL</span>)yesOrNo;<br></code></pre></td></tr></table></figure><p>以上三种方式会自动创建一个<code>NSTimer</code>对象并以<code>DefaultMode</code>加入到 Runloop 中。</p><p>NSTimer从本质上来说，就是一个<code>CFRunLoopTimerRef</code>。</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    _seriaqueue = dispatch_queue_create(<span class="hljs-string">&quot;disafsdfa&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    [<span class="hljs-keyword">self</span> nstimer];<br>&#125;<br>- (<span class="hljs-type">void</span>)nstimer&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(_seriaqueue, ^&#123;<br>        <span class="hljs-comment">//开始定时器之前</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop before timer:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>        [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">2</span> repeats:<span class="hljs-literal">NO</span> block:^(<span class="hljs-built_in">NSTimer</span> * _Nonnull timer) &#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行定时任务&quot;</span>);<br>            <span class="hljs-built_in">CFRunLoopStop</span>(<span class="hljs-built_in">CFRunLoopGetCurrent</span>());<br>        &#125;];<br>        <span class="hljs-comment">// 开始定时器之后</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop after timer:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>        <span class="hljs-built_in">CFRunLoopRun</span>();<br>        <span class="hljs-comment">// 定时任务完成</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop exit:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>日志(有删减，保留了主要内容)：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">//开始定时器之前</span><br>+++runloop before timer:&lt;CFRunLoop <span class="hljs-number">0x600002f88500</span>&gt;&#123;<br>modes = &lt;CFBasicHash <span class="hljs-number">0x600001ddc7b0</span> [<span class="hljs-number">0x10388eb48</span>]&gt;&#123;type = mutable <span class="hljs-keyword">set</span>, count <span class="hljs-comment">= 1,</span><br>entries <span class="hljs-comment">=&gt;</span><br>    2 : &lt;CFRunLoopMode <span class="hljs-comment">0x600002888f70&gt;&#123;name = kCFRunLoopDefaultMode</span><br>    sources0 <span class="hljs-comment">= (null),</span><br>    sources1 <span class="hljs-comment">= (null),</span><br>    observers <span class="hljs-comment">= (null),</span><br>    timers <span class="hljs-comment">= (null)</span> // 注意这里此时为空<br>&#125;<br><span class="hljs-comment">// 开始定时器之后</span><br>+++runloop <span class="hljs-comment">after timer:&lt;CFRunLoop 0x600002f88500&gt;&#123;</span><br>modes <span class="hljs-comment">= &lt;CFBasicHash 0x600001ddc7b0 [0x10388eb48]&gt;&#123;type = mutable set, count = 1,</span><br>entries <span class="hljs-comment">=&gt;</span><br>    2 : &lt;CFRunLoopMode <span class="hljs-comment">0x600002888f70&gt;&#123;name = kCFRunLoopDefaultMode,</span><br>    sources0 <span class="hljs-comment">= (null),</span><br>    sources1 <span class="hljs-comment">= (null),</span><br>    observers <span class="hljs-comment">= (null),</span><br>    timers <span class="hljs-comment">= &lt;CFArray 0x600003784ae0&gt;&#123;</span> //此时数组中有了<span class="hljs-comment">CFRunLoopTimer</span>对象<br>    type <span class="hljs-comment">= mutable-small,</span> <br>    count <span class="hljs-comment">= 1,</span> <br>    values <span class="hljs-comment">= (</span><br>    0 : &lt;CFRunLoopTimer <span class="hljs-comment">0x60000268f000&gt;&#123;valid = Yes, firing = No, interval = 0, tolerance = 0,</span> <br>    next <span class="hljs-comment">fire date = 594361769 (1.99719393 @ 11234440222906),</span> <br>    callout <span class="hljs-comment">= (NSTimer) [_NSTimerBlockTarget fire:]</span><br>)&#125;<br>++++执行定时任务<br><br><span class="hljs-comment">// 定时任务完成</span><br>+++runloop <span class="hljs-comment">exit:&lt;CFRunLoop 0x600002f88500&gt;&#123;</span><br>modes <span class="hljs-comment">= &lt;CFBasicHash 0x600001ddc7b0&gt;&#123;type = mutable set, count = 1,</span><br>entries <span class="hljs-comment">=&gt;</span><br>    2 : &lt;CFRunLoopMode <span class="hljs-comment">0x600002888f70&gt;&#123;name = kCFRunLoopDefaultMode,</span><br>    sources0 <span class="hljs-comment">= (null),</span><br>    sources1 <span class="hljs-comment">= (null),</span><br>    observers <span class="hljs-comment">= (null),</span><br>    <span class="hljs-comment">// 此时任务已完成，runloop退出，数组中values又为空了</span><br>    timers <span class="hljs-comment">= &lt;CFArray 0x600003784ae0 [0x10388eb48]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只看日志中“timers &#x3D;”部分，定时器开始后，其所在的runloop中多出了一个<code>CFRunLoopTimer</code>对象。就是说<code>NSTimer</code>的底层是由<code>CFRunLoopTimer</code>来实现的。</p><h5 id="1-内存泄露"><a href="#1-内存泄露" class="headerlink" title="1.内存泄露"></a>1.内存泄露</h5><p>在页面中启动了NSTimer，离开界面前如果NSTimer没执行完，则界面无法释放，即使把这个NSTimer对象置为nil，或者使用weakSelf。这是因为NSTimer对象会<code>强引用</code>它的Target。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs OC">@interface DKTimerController ()<br>@property (nonatomic, strong) NSTimer *aTimer;<br>@end<br><br>- (void)viewDidLoad&#123;<br>    // 1.使用self 会泄露<br>    //_aTimer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(handleTimer) userInfo:nil repeats:YES];<br><br>    // 2.使用weakself 会泄露<br>    __weak typeof(self) weakSelf = self;<br>    _aTimer = [NSTimer timerWithTimeInterval:1 target:weakSelf selector:@selector(handleTimer) userInfo:nil repeats:YES];<br>    [[NSRunLoop currentRunLoop] addTimer:_aTimer forMode:NSRunLoopCommonModes];<br>&#125;<br><br>- (void)handleTimer&#123;<br>    NSLog(@&quot;++++go timer&quot;);<br>&#125;<br><br>-(void)dealloc&#123;<br>    [_aTimer invalidate]; // 不会释放，放在这里无效<br>    NSLog(@&quot;++++dealloced&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="1-invalidate"><a href="#1-invalidate" class="headerlink" title="1.invalidate"></a>1.invalidate</h6><p>方法1：在适当的时机将NSTimer置为<code>invalidate</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs OC">- (void)viewWillDisappear:(BOOL)animated&#123;<br>    [_aTimer invalidate]; //置为invalidate<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="2-block-timer"><a href="#2-block-timer" class="headerlink" title="2.block timer"></a>2.block timer</h6><p>方法2：使用 weakself+block timer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs OC">- (void)viewDidLoad&#123;<br>    // 1.使用self<br>    __weak typeof(self) weakself = self;<br>    _aTimer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;<br>        __strong typeof(weakself)strogself = weakself;<br>        [strogself handleTimer];<br>    &#125;];<br>&#125;<br><br>- (void)dealloc&#123;<br>    [_aTimer invalidate]; //会执行dealloc<br>    NSLog(@&quot;++++dealloced&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-NSProxy"><a href="#3-NSProxy" class="headerlink" title="3.NSProxy"></a>3.NSProxy</h6><p>方法3：使用NSProxy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs OC">@interface DKTimerProxy : NSProxy<br>+ (instancetype)proxyWithTarget:(id)target;<br>@property (weak, nonatomic) id target;<br>@end<br><br>@implementation DKTimerProxy<br><br>+ (instancetype)proxyWithTarget:(id)target&#123;<br>    DKTimerProxy *proxy = [DKTimerProxy alloc];<br>    proxy.target = target;<br>    return proxy;<br>&#125;<br><br>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123;<br>    return [self.target methodSignatureForSelector:sel];<br>&#125;<br><br>- (void)forwardInvocation:(NSInvocation *)invocation&#123;<br>    [invocation invokeWithTarget:self.target];<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs OC">#import &quot;DKTimerProxy.h&quot;<br><br>@interface DKTimerController ()<br>@property (nonatomic, strong) NSTimer *aTimer;<br>@end<br><br>@implementation DKTimerController<br><br>- (void)viewDidLoad&#123;<br>    DKTimerProxy *proxy = [DKTimerProxy proxyWithTarget:self];<br>    _aTimer = [NSTimer timerWithTimeInterval:1 target:proxy selector:@selector(handleTimer) userInfo:nil repeats:YES];<br>    [[NSRunLoop currentRunLoop] addTimer:_aTimer forMode:NSRunLoopCommonModes];<br>&#125;<br><br>- (void)handleTimer&#123;<br>    NSLog(@&quot;++++go timer&quot;);<br>&#125;<br><br>-(void)dealloc&#123;<br>    [_aTimer invalidate];<br>    NSLog(@&quot;++++dealloced&quot;);<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>VC强引用了timer，而timer将proxy作为Target从而强引用proxy；VC中创建局部变量proxy，它弱引用了VC；这样就打破了<code>强引用</code>循环。proxy中调用timer的selector时查无对应的实现，会走消息转发流程，将方法的调用转发给VC。</p><h5 id="2-实时性"><a href="#2-实时性" class="headerlink" title="2.实时性"></a>2.实时性</h5><p>定时器可以产生基于时间的通知，但它并不是一种real-time的机制。</p><ol><li>如果子线程的 Runloop 根本没有运行，那么定时器也不会触发；</li><li>定时器也和 Runloop 的 mode 相关。如果定时器所在的模式当前未被 Runloop 监视，那么定时器将不会触发；</li><li>重复类型的定时器，添加到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。比如t，t + 5，t + 10。。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。</li></ol><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;Timer-Runloop.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Timer_Runloop</span></span><br><br>- (<span class="hljs-type">void</span>)scheduleTimer<br>&#123;<br>    <span class="hljs-comment">//创建timer 间隔1秒</span><br>    [<span class="hljs-built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="hljs-number">1</span><br>                                     target:<span class="hljs-keyword">self</span><br>                                   selector:<span class="hljs-keyword">@selector</span>(onScheduleTimer)<br>                                   userInfo:<span class="hljs-literal">nil</span> repeats:<span class="hljs-literal">YES</span>];<br>    <span class="hljs-comment">//在第3秒的时 模拟一个复杂运算</span><br>    [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(onMassTasks) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">3</span>];<br>&#125;<br><br>- (<span class="hljs-type">void</span>)onScheduleTimer<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++1秒重复定时执行++++&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)onMassTasks<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++开始处理复杂运算+++&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">0xffffffff</span>; i++)&#123;<br>    &#125;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++++复杂运算完成++++++&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用之后输入日志：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">10</span>.<span class="hljs-number">952360</span> ++++<span class="hljs-number">1</span>秒重复定时执行++++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">11</span>.<span class="hljs-number">952263</span> ++++<span class="hljs-number">1</span>秒重复定时执行++++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">12</span>.<span class="hljs-number">952284</span> ++++<span class="hljs-number">1</span>秒重复定时执行++++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">12</span>.<span class="hljs-number">952628</span> +++开始处理复杂运算+++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">24</span>.<span class="hljs-number">104517</span> ++++++复杂运算完成++++++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">24</span>.<span class="hljs-number">104825</span> ++++<span class="hljs-number">1</span>秒重复定时执行++++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">24</span>.<span class="hljs-number">952362</span> ++++<span class="hljs-number">1</span>秒重复定时执行++++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">25</span>.<span class="hljs-number">951624</span> ++++<span class="hljs-number">1</span>秒重复定时执行++++<br><span class="hljs-attribute">20</span>:<span class="hljs-number">30</span>:<span class="hljs-number">26</span>.<span class="hljs-number">951637</span> ++++<span class="hljs-number">1</span>秒重复定时执行++++<br></code></pre></td></tr></table></figure><p>从日志可以看到：当线程空闲的时候定时器的消息触发还是比较准确的，但是在30分12秒开始线程一直忙着做大量运算，直到30分24秒该运算才结束，这时候定时器回调才触发。这个线程繁忙的过程超过了一个周期，但是定时器并没有连着触发两次消息，而是只触发了一次。也就是说繁忙期间的几次回调都跳过了，繁忙过后立刻执行了一次回调，之后又正常1秒执行一次回调。</p><h4 id="3-特殊的定时器"><a href="#3-特殊的定时器" class="headerlink" title="3.特殊的定时器"></a>3.特殊的定时器</h4><h5 id="1-delay"><a href="#1-delay" class="headerlink" title="1.delay"></a>1.delay</h5><p><code>NSTimer</code>是最常见的定时器，除此之外<code>NSObject</code>的分类中还定义了一些特殊的定时器:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs erlang">@interface NSObject (NSDelayedPerforming)<br><br>//延时<br>- <span class="hljs-params">(void)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector <br>withObject:<span class="hljs-params">(id)</span>anArgument <br>afterDelay:<span class="hljs-params">(NSTimeInterval)</span>delay <br>inModes:<span class="hljs-params">(NSArray&lt;NSRunLoopMode&gt; *)</span>modes;<br><br>- <span class="hljs-params">(void)</span>performSelector:<span class="hljs-params">(SEL)</span>aSelector <br>withObject:<span class="hljs-params">(id)</span>anArgument <br>afterDelay:<span class="hljs-params">(NSTimeInterval)</span>delay;<br><br>//取消延时<br>+ <span class="hljs-params">(void)</span>cancelPreviousPerformRequestsWithTarget:<span class="hljs-params">(id)</span>aTarget <br>selector:<span class="hljs-params">(SEL)</span>aSelector <br>object:<span class="hljs-params">(nullable id)</span>anArgument;<br><br>+ <span class="hljs-params">(void)</span>cancelPreviousPerformRequestsWithTarget:<span class="hljs-params">(id)</span>aTarget;<br><br>@end<br></code></pre></td></tr></table></figure><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">-(<span class="hljs-type">void</span>)onSelector:(<span class="hljs-type">id</span>)obj&#123;<br>    <span class="hljs-comment">// 延时任务结束</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++thread:%@,++runloop:%@&quot;</span>,[<span class="hljs-built_in">NSThread</span> currentThread],[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>&#125;<br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-comment">// 延时任务开始前</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>        [<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(onSelector:) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 添加延时任务后</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++check timers:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>        <span class="hljs-built_in">CFRunLoopRun</span>();<span class="hljs-comment">//启动子线程的runloop</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志(有删减，保留了主要内容)：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 延时任务开始前</span><br>+++runloop:&lt;CFRunLoop <span class="hljs-number">0x60000222c700</span>&gt;&#123;<br>。。。<br>modes = &lt;CFBasicHash <span class="hljs-number">0x600001062dc0</span>&gt;&#123;type = mutable <span class="hljs-keyword">set</span>, count <span class="hljs-comment">= 1,</span><br>entries <span class="hljs-comment">=&gt;</span><br>    2 : &lt;CFRunLoopMode <span class="hljs-comment">0x60000252d040&gt;&#123;name = kCFRunLoopDefaultMode,</span> <br>    port <span class="hljs-comment">set = 0x6107,</span> <br>    queue <span class="hljs-comment">= 0x600003026380,</span> <br>    source <span class="hljs-comment">= 0x600003026b80 (not fired), timer port = 0x9d03,</span> <br>    sources0 <span class="hljs-comment">= (null),</span><br>    sources1 <span class="hljs-comment">= (null),</span><br>    observers <span class="hljs-comment">= (null),</span><br>    timers <span class="hljs-comment">= (null),</span>// 注意这一行，此时<span class="hljs-comment">timers</span>数组是空的！！！！<br>&#125;<br><br><span class="hljs-comment">// 添加延时任务后</span><br>++++check <span class="hljs-comment">timers:&lt;CFRunLoop 0x60000222c700]&gt;&#123;</span><br>。。。<br>modes <span class="hljs-comment">= &lt;CFBasicHash 0x600001062dc0&gt;&#123;type = mutable set, count = 1,</span><br>entries <span class="hljs-comment">=&gt;</span><br>    2 : &lt;CFRunLoopMode <span class="hljs-comment">0x60000252d040&gt;&#123;name = kCFRunLoopDefaultMode,</span> <br>    port <span class="hljs-comment">set = 0x6107,</span> <br>    queue <span class="hljs-comment">= 0x600003026380,</span> <br>    source <span class="hljs-comment">= 0x600003026b80 (not fired), timer port = 0x9d03,</span> <br>    sources0 <span class="hljs-comment">= (null),</span><br>    sources1 <span class="hljs-comment">= (null),</span><br>    observers <span class="hljs-comment">= (null),</span><br>    <span class="hljs-comment">// 注意，这里timers数组中values是有值的，是一个CFRunLoopTimer对象！！！</span><br>    timers <span class="hljs-comment">= &lt;CFArray 0x600003a2f000 [0x10eb3db48]&gt;&#123;</span><br>    type <span class="hljs-comment">= mutable-small, count = 1, values = (</span><br>    0 : &lt;CFRunLoopTimer <span class="hljs-comment">0x600002b2e340]&gt;&#123;valid = Yes,</span> <br>    firing <span class="hljs-comment">= No, interval = 0, tolerance = 0, next fire date = 594358054</span> <br>)&#125;<br><br><span class="hljs-comment">// 延时任务结束</span><br>+++thread:&lt;NSThread:&gt;&#123;number <span class="hljs-comment">= 5, name = (null)&#125;,++runloop:&lt;CFRunLoop 0x60000222c700</span><br>。。。<br>entries <span class="hljs-comment">=&gt;</span><br>    2 : &lt;CFRunLoopMode <span class="hljs-comment">0x60000252d040&gt;&#123;name = kCFRunLoopDefaultMode,</span> <br>    port <span class="hljs-comment">set = 0x6107,</span> <br>    queue <span class="hljs-comment">= 0x600003026380,</span> <br>    source <span class="hljs-comment">= 0x600003026b80 (not fired), timer port = 0x9d03,</span> <br>    sources0 <span class="hljs-comment">= (null),</span><br>    sources1 <span class="hljs-comment">= (null),</span><br>    observers <span class="hljs-comment">= (null),</span><br>    <span class="hljs-comment">// 注意，这里timers数组中又为空了</span><br>    timers <span class="hljs-comment">= &lt;CFArray&gt;&#123;type = mutable-small, count = 0, values = ()&#125;,</span><br>&#125;<br></code></pre></td></tr></table></figure><p>日志显示，在调用<code>perform..afterDelay</code>后，子线程 runloop 的 CFRunLoopMode 的<code>timers</code>数组中有了一个<code>CFRunLoopTimer</code>对象！它就是系统为延时操作创建的一个定时器；延时操作完成之后，此定时器对象又自动从timers数组中移除。</p><p>同时，如果在调用<code>-onSelector:</code>时打断点，可得到如下的堆栈信息：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_perform_afterDelay.png" alt="pic_perform_afterDelay"></p><p>从堆栈上也可以看到，<strong>延时操作的本质是运行时在当前线程的 runloop 中添加了一个“定时源”</strong>~</p><p>需要注意的是：<strong>在子线程中使用这种延时执行方法时，如果不主动启动子线程的 runloop，那么 selector 是不会执行的</strong>。这也就是前面提到的“如果子线程的 Runloop 根本没有运行，那么定时器也不会触发”，实际的开发中一定要注意这一点。</p><p>另外：这两个方法都只是将<code>selector</code>的调用延迟某个时间长度，并不影响调用方法时所处的线程，即在A线程调用这两个<code>performSelector</code>，延迟后的<code>selector</code>还是在A线程中执行。</p><h5 id="2-GCD定时器"><a href="#2-GCD定时器" class="headerlink" title="2.GCD定时器"></a>2.GCD定时器</h5><p>首先要说明的是，GCD的定时器与上面三种不同，它<strong>不是runloop的源!</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;GCDTimerTest.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">GCDTimerTest</span> ()</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">dispatch_queue_t</span> seriaqueue;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) dispatch_source_t timer;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">GCDTimerTest</span></span><br><br>- (<span class="hljs-type">void</span>)gcd_timer&#123;<br>    _seriaqueue = dispatch_queue_create(<span class="hljs-string">&quot;xx&quot;</span>, DISPATCH_QUEUE_SERIAL);<br>    __<span class="hljs-keyword">weak</span> <span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">self</span>) wself = <span class="hljs-keyword">self</span>;<br>    <span class="hljs-built_in">dispatch_async</span>(_seriaqueue, ^&#123;<br>        __<span class="hljs-keyword">strong</span> <span class="hljs-keyword">typeof</span>(wself) sself = wself;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop before timer:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>        sself.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, sself.seriaqueue);<br>        dispatch_source_set_timer(sself.timer, DISPATCH_TIME_NOW, <span class="hljs-number">1</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>, <span class="hljs-number">0</span> * <span class="hljs-built_in">NSEC_PER_SEC</span>);<br>        dispatch_source_set_event_handler(sself.timer, ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++执行计时任务&quot;</span>);<br>            <span class="hljs-comment">//dispatch_source_cancel(sself.timer);</span><br>        &#125;);<br>        dispatch_resume(sself.timer);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++runloop after timer:%@&quot;</span>,[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop]);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">+++runloop <span class="hljs-keyword">before</span> timer:&lt;CFRunLoop<br>common mode items = (<span class="hljs-keyword">null</span>),<br>modes = &lt;CFBasicHash <span class="hljs-number">0x600001b71dd0</span>&gt;&#123;<br>entries =&gt;<br>    <span class="hljs-number">2</span> : &lt;CFRunLoopMode <span class="hljs-number">0x600002e2a8a0</span>&gt;&#123;<br>    <span class="hljs-type">name</span> = kCFRunLoopDefaultMode, <br>    source = <span class="hljs-number">0x600003b25900</span> (<span class="hljs-keyword">not</span> fired), <br>    timer port = <span class="hljs-number">0x5f03</span>, <br>    sources0 = (<span class="hljs-keyword">null</span>),<br>    sources1 = (<span class="hljs-keyword">null</span>),<br>    observers = (<span class="hljs-keyword">null</span>),<br>    timers = (<span class="hljs-keyword">null</span>),<br>&#125;<br>// 开始GCD定时器之后<br>+++runloop <span class="hljs-keyword">after</span> timer:&lt;CFRunLoop <span class="hljs-number">0x600002928200</span>&#123;<br>modes = &lt;CFBasicHash <span class="hljs-number">0x600001b71dd0</span><br>entries =&gt;<br>    <span class="hljs-number">2</span> : &lt;CFRunLoopMode <span class="hljs-number">0x600002e2a8a0</span>&gt;&#123;<br>    <span class="hljs-type">name</span> = kCFRunLoopDefaultMode,<br>    sources0 = (<span class="hljs-keyword">null</span>),<br>    sources1 = (<span class="hljs-keyword">null</span>),<br>    observers = (<span class="hljs-keyword">null</span>),<br>    timers = (<span class="hljs-keyword">null</span>),<br>&#125;<br>++++执行计时任务<br></code></pre></td></tr></table></figure><p>日志中可以看到，开启GCD定时器之后，当前runloop的timers中也并未增加新的定时源~</p><p>所以，GCD定时器并不是由<code>CFRunLoopTimer</code>实现的，也不需要加入到runloopMode中，<strong>不受runloop模式切换的影响</strong>，甚至在切换到后台时，它依然能正常运行。</p><h2 id="4-观察者"><a href="#4-观察者" class="headerlink" title="4.观察者"></a>4.观察者</h2><p>Runloop在处理输入事件的同时，在其运行的特定阶段还会触发通知。我们可以使用 CF 的方法，注册观察者来接收通知并在某个特定时期处理一些事情。</p><p>Runloop可以被观察的状态包括以下阶段：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* Run Loop Observer Activities */</span><br>typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;<br>kCFRunLoopEntry = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">0</span>),         <span class="hljs-regexp">//</span>runloop进入时；<br>kCFRunLoopBeforeTimers = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">1</span>),  <span class="hljs-regexp">//</span>将要处理Timer时;<br>kCFRunLoopBeforeSources = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-regexp">//</span>将要处理Source0时；<br>kCFRunLoopBeforeWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">5</span>), <span class="hljs-regexp">//</span>将要进入睡眠时；<br>kCFRunLoopAfterWaiting = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">6</span>),  <span class="hljs-regexp">//</span>将要被唤醒时；<br>kCFRunLoopExit = (<span class="hljs-number">1</span>UL &lt;&lt; <span class="hljs-number">7</span>),          <span class="hljs-regexp">//</span>runloop即将退出时；<br>kCFRunLoopAllActivities = <span class="hljs-number">0</span>x0FFFFFFFU<br>&#125;;<br></code></pre></td></tr></table></figure><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)runloopReturnTest<br>&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <br>        <span class="hljs-built_in">NSRunLoop</span> *mRunloop = [<span class="hljs-built_in">NSRunLoop</span> currentRunLoop];<br>        <br>        <span class="hljs-comment">// 创建一个观察者.</span><br>        <span class="hljs-built_in">CFRunLoopObserverRef</span> observer = <span class="hljs-built_in">CFRunLoopObserverCreateWithHandler</span>(<br>                                             kCFAllocatorDefault,<br>                                             kCFRunLoopAllActivities,<br>                                             <span class="hljs-literal">YES</span>, <span class="hljs-number">0</span>,<br>                                             ^(<span class="hljs-built_in">CFRunLoopObserverRef</span> observer, <span class="hljs-built_in">CFRunLoopActivity</span> activity)&#123;<br>            <span class="hljs-keyword">switch</span> (activity) &#123;<br>                <span class="hljs-keyword">case</span> kCFRunLoopEntry:<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;observer： kCFRunLoopEntry...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                    <br>                <span class="hljs-keyword">case</span> kCFRunLoopBeforeTimers:<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;observer： kCFRunLoopBeforeTimers...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                    <br>                <span class="hljs-keyword">case</span> kCFRunLoopBeforeSources:<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;observer： kCFRunLoopBeforeSources...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                    <br>                <span class="hljs-keyword">case</span> kCFRunLoopBeforeWaiting:<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;observer： kCFRunLoopBeforeWaiting...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                    <br>                <span class="hljs-keyword">case</span> kCFRunLoopAfterWaiting:<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;observer： kCFRunLoopAfterWaiting...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                    <br>                <span class="hljs-keyword">case</span> kCFRunLoopExit:<br>                    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;observer： kCFRunLoopExit...&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                    <br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">if</span> (observer)&#123;<br>            <span class="hljs-comment">//把观察者附加到runloop上</span><br>            <span class="hljs-built_in">CFRunLoopRef</span> cfLoop = [mRunloop getCFRunLoop];<br>            <span class="hljs-built_in">CFRunLoopAddObserver</span>(cfLoop, observer, kCFRunLoopDefaultMode);<br>        &#125;<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;This thread starting.......&quot;</span>);<br>        <br>        <span class="hljs-comment">//新增计时器源并加入runloop</span><br>        <span class="hljs-built_in">NSTimer</span> *timer = [<span class="hljs-built_in">NSTimer</span> timerWithTimeInterval:<span class="hljs-number">5</span><br>                                                 target:<span class="hljs-keyword">self</span><br>                                               selector:<span class="hljs-keyword">@selector</span>(onHandleTask:)<br>                                               userInfo:<span class="hljs-literal">nil</span><br>                                                repeats:<span class="hljs-literal">NO</span>];<br>        [mRunloop addTimer:timer forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>        <br>        <span class="hljs-comment">//最后一个参数：是否处理完事件返回，结束runLoop</span><br>        SInt32 result = <span class="hljs-built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="hljs-number">100</span>, <span class="hljs-literal">YES</span>);<br>        <br>        <span class="hljs-keyword">switch</span> (result) &#123;<br>            <span class="hljs-keyword">case</span> kCFRunLoopRunFinished:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunFinished&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> kCFRunLoopRunStopped:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunStopped&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-keyword">case</span> kCFRunLoopRunTimedOut:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunTimedOut&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-keyword">case</span> kCFRunLoopRunHandledSource:<br>                <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;kCFRunLoopRunHandledSource&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>                <br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;This thread end.......&quot;</span>);<br>    &#125;);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)onHandleTask:(<span class="hljs-built_in">NSTimer</span> *)timer&#123;<br>    [timer invalidate];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;timer Fired...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的示例中，先往当前子线程的 runloop 中添加了一个观察者，监听并打印各个阶段的状态；随后往 runloop 中添加了一个定时器。执行到<code>CFRunLoopRunInMode</code>时，程序卡在这一行。5秒后计时器触发，计时器<code>invalidate</code>后，Runloop 中没有了任何事件源，所以退出并返回了result值，程序继续向下运行，输出日志如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">10</span>.<span class="hljs-number">831</span>  This thread starting.......<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">10</span>.<span class="hljs-number">831</span>  observer： kCFRunLoopEntry...<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">10</span>.<span class="hljs-number">832</span>  observer： kCFRunLoopBeforeTimers...<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">10</span>.<span class="hljs-number">832</span>  observer： kCFRunLoopBeforeSources...<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">10</span>.<span class="hljs-number">833</span>  observer： kCFRunLoopBeforeWaiting...<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">15</span>.<span class="hljs-number">834</span>  observer： kCFRunLoopAfterWaiting...<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">15</span>.<span class="hljs-number">835</span>  timer Fired...<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">15</span>.<span class="hljs-number">835</span>  observer： kCFRunLoopExit...<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">15</span>.<span class="hljs-number">836</span>  kCFRunLoopRunFinished<br><span class="hljs-attribute">23</span>:<span class="hljs-number">48</span>:<span class="hljs-number">15</span>.<span class="hljs-number">836</span>  This thread end.......<br></code></pre></td></tr></table></figure><h2 id="5-事件序列"><a href="#5-事件序列" class="headerlink" title="5.事件序列"></a>5.事件序列</h2><p>1、通知观察者 Runloop 已经启动;</p><p>2、通知观察者 <code>Timers</code> 即将触发;</p><p>3、通知观察者 将要处理 <code>Source0</code>;</p><p>4、触发 <code>Source0</code> 回调;</p><p>5、如果有 <code>Source1</code> 处于 <code>ready</code> 状态，直接进入步骤9处理该 <code>Source1</code>事件;</p><p>6、通知观察者 线程即将休眠;</p><p>7、线程休眠 等待以下情形的唤醒：</p><ul><li>某一事件到达基于端口的源(Source1);</li><li>定时器时间到了;</li><li>Runloop 设置的时间已经超时;</li><li>Runloop 被手动唤醒;</li></ul><p>8、通知观察者线程将被唤醒;</p><p>9、处理唤醒时收到的消息：</p><ul><li>如果消息是<code>Timer</code>类型，则触发该<code>Timer</code>的回调；</li><li>如果消息是 dispatch 到 <code>main_ queue</code> 的block，执行block；</li><li>如果消息是<code>Source1</code>类型，则处理<code>Source1</code>回调；</li></ul><p>10、以下条件中满足时候退出循环，否则从（2）继续循环：</p><ul><li>事件处理完毕，且启动 RunLoop 时参数设置为一次性执行；</li><li>启动 RunLoop 时设置的最大运行时间到期；</li><li>RunLoop 被外部调用强行停止；</li><li>启动 RunLoop 的 mode items为空；</li></ul><p>11、通知观察者 Runloop 结束。</p><p>上面逻辑对应的 <a href="https://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c.auto.html">CFRunLoop.c源码</a> 如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">/// 用DefaultMode启动</span><br>void CFRunLoopRun(void) &#123;<br>CFRunLoopRunSpecific(CFRunLoopGetCurrent(), <br>kCFRunLoopDefaultMode, <span class="hljs-number">1.0</span>e10, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br>int CFRunLoopRunInMode(CFStringRef modeName, <br>CFTimeInterval seconds, Boolean stopAfterHandle) &#123;<br><br>return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), <br>modeName, seconds, returnAfterSourceHandled);<br>&#125;<br><br><span class="hljs-comment">/// RunLoop的实现</span><br>int CFRunLoopRunSpecific(runloop, modeName,<br>seconds, stopAfterHandle) &#123;<br><br><span class="hljs-comment">/// 首先根据modeName找到对应mode</span><br>CFRunLoopModeRef currentMode = <span class="hljs-variable">__CFRunLoopFindMode</span>(runloop, modeName, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">/// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">__CFRunLoopModeIsEmpty</span>(currentMode)) return;<br><br><span class="hljs-comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="hljs-variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopEntry);<br><br><span class="hljs-comment">/// 内部函数，进入loop</span><br><span class="hljs-variable">__CFRunLoopRun</span>(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;<br><br>Boolean sourceHandledThisLoop = NO;<br>int retVal = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br><br><span class="hljs-comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="hljs-variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopBeforeTimers);<br><span class="hljs-comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="hljs-variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopBeforeSources);<br><span class="hljs-comment">/// 处理非延迟的主线程调用</span><br><span class="hljs-variable">__CFRunLoopDoBlocks</span>(runloop, currentMode);<br><br><span class="hljs-comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span><br>sourceHandledThisLoop = <span class="hljs-variable">__CFRunLoopDoSources0</span>(runloop, currentMode, stopAfterHandle);<br><span class="hljs-comment">/// 执行被加入的block</span><br><span class="hljs-variable">__CFRunLoopDoBlocks</span>(runloop, currentMode);<br><br><span class="hljs-comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">__Source0DidDispatchPortLastTime</span>) &#123;<br>Boolean hasMsg = <span class="hljs-variable">__CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg)<br><span class="hljs-keyword">if</span> (hasMsg) <span class="hljs-built_in">goto</span> handle_msg;<br>&#125;<br><br><span class="hljs-comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="hljs-keyword">if</span> (!sourceHandledThisLoop) &#123;<br><span class="hljs-variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopBeforeWaiting);<br>&#125;<br><br><span class="hljs-comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="hljs-comment">/// • 一个基于 port 的Source 的事件。</span><br><span class="hljs-comment">/// • 一个 Timer 到时间了</span><br><span class="hljs-comment">/// • RunLoop 自身的超时时间到了</span><br><span class="hljs-comment">/// • 被其他什么调用者手动唤醒</span><br><span class="hljs-variable">__CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, <span class="hljs-built_in">sizeof</span>(msg_buffer), &amp;livePort) &#123;<br>mach_msg(msg, MACH_RCV_MSG, port); <span class="hljs-comment">// thread wait for receive msg</span><br>&#125;<br><br><span class="hljs-comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="hljs-variable">__CFRunLoopDoObservers</span>(runloop, currentMode, kCFRunLoopAfterWaiting);<br><br><span class="hljs-comment">/// 收到消息，处理消息。</span><br>handle_msg:<br><br><span class="hljs-comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="hljs-keyword">if</span> (msg_is_timer) &#123;<br><span class="hljs-variable">__CFRunLoopDoTimers</span>(runloop, currentMode, mach_absolute_time())<br>&#125;<br><br><span class="hljs-comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg_is_dispatch) &#123;<br><span class="hljs-variable">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);<br>&#125;<br><br><span class="hljs-comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="hljs-keyword">else</span> &#123;<br>CFRunLoopSourceRef source1 = <span class="hljs-variable">__CFRunLoopModeFindSourceForMachPort</span>(runloop,<br>currentMode, livePort);<br><br>sourceHandledThisLoop = <span class="hljs-variable">__CFRunLoopDoSource1</span>(runloop, <br>currentMode, source1, msg);<br><br><span class="hljs-keyword">if</span> (sourceHandledThisLoop) &#123;<br>mach_msg(reply, MACH_SEND_MSG, reply);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/// 执行加入到Loop的block</span><br><span class="hljs-variable">__CFRunLoopDoBlocks</span>(runloop, currentMode);<br><br><br><span class="hljs-keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;<br><span class="hljs-comment">/// 进入loop时参数说处理完事件就返回。</span><br>retVal = kCFRunLoopRunHandledSource;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout) &#123;<br><span class="hljs-comment">/// 超出传入参数标记的超时时间了</span><br>retVal = kCFRunLoopRunTimedOut;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">__CFRunLoopIsStopped</span>(runloop)) &#123;<br><span class="hljs-comment">/// 被外部调用者强制停止了</span><br>retVal = kCFRunLoopRunStopped;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable">__CFRunLoopModeIsEmpty</span>(runloop, currentMode)) &#123;<br><span class="hljs-comment">/// source/timer/observer一个都没有了</span><br>retVal = kCFRunLoopRunFinished;<br>&#125;<br><br><span class="hljs-comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br>&#125; <span class="hljs-keyword">while</span> (retVal == <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">/// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="hljs-variable">__CFRunLoopDoObservers</span>(rl, currentMode, kCFRunLoopExit);<br></code></pre></td></tr></table></figure><p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个<code>do-while</code> 循环。当你调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。RunLoop 的核心是 <code>mach_msg()</code> 函数(见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。</p><h2 id="6-Runloop对象"><a href="#6-Runloop对象" class="headerlink" title="6.Runloop对象"></a>6.Runloop对象</h2><p>Runloop 对象提供了添加输入源、定时器、观察者以及启动 Runloop 的接口。每个线程都有唯一的与之关联的 Runloop对象。Cocoa和 CF 都有相应的接口可以操作 RunLoop：</p><ul><li>Cocoa中对应的是 NSRunLoop；</li><li>CF 中对应的是 CFRunLoopRef；</li></ul><h3 id="1-获取RunLoop"><a href="#1-获取RunLoop" class="headerlink" title="1.获取RunLoop"></a>1.获取RunLoop</h3><ul><li>CFRunLoopRef <a href="https://developer.apple.com/documentation/corefoundation/cfrunloop-rht">（官方文档）</a></li></ul><p>这是 CF 框架提供的，它提供了纯C函数的API，这些API都是线程安全的。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CFRunLoopRef aCFRunloopObjRef <span class="hljs-operator">=</span> CFRunLoopGetCurrent()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>NSRunLoop<a href="https://developer.apple.com/documentation/foundation/nsrunloop">（官方文档）</a></li></ul><p>这是Cocoa框架提供的，它提供了面向对象的 API，是基于CFRunLoopRef的一层封装，但这些API是非线程安全的；苹果官方文档说，我们不能在当前线程中去call另外一个线程中 NSRunLoop 对象的方法，那样很可能会造成意想不到的后果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">NSRunLoop *aRunloopObj <span class="hljs-operator">=</span> [NSRunLoop currentRunLoop]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>不过，两种类型的 Runloop 可以混合使用。鉴于 CFRunLoopRef 是线程安全的，所以，可以通过 NSRunLoop 类的实例方法获取对应的 CFRunLoopRef 对象，进而达到线程安全的目的：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">NSRunLoop *aRunloopObj <span class="hljs-operator">=</span> [NSRunLoop currentRunLoop]<span class="hljs-comment">;</span><br>CFRunLoopRef aCFRunloopObjRef <span class="hljs-operator">=</span> [aRunloopObj getCFRunLoop]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="2-启动RunLoop"><a href="#2-启动RunLoop" class="headerlink" title="2.启动RunLoop"></a>2.启动RunLoop</h3><h4 id="1-NSRunLoop的启动"><a href="#1-NSRunLoop的启动" class="headerlink" title="1.NSRunLoop的启动"></a>1.NSRunLoop的启动</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">- (<span class="hljs-type">void</span>)run; <span class="hljs-comment">//无条件的启动</span><br></code></pre></td></tr></table></figure><p>不建议使用，因为这个接口会导致Run Loop永久性的在NSDefaultRunLoopMode模式。即使用CFRunLoopStop()函数也无法停止Run Loop的运行，除非能移除这个runloop上的所有事件源，不然这个子线程就无法停止，只能永久运行下去。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)runUntilDate:(<span class="hljs-built_in">NSDate</span> *)limitDate;<span class="hljs-comment">//设置超时时间</span><br></code></pre></td></tr></table></figure><p>比上面的接口好点，有个超时时间，可以控制每次 Runloop 的运行时间，也是运行在<code>NSDefaultRunLoopMode</code>模式。这个方法运行 Runloop 一段时间会退出给你检查运行条件的机会，如果需要可以再次运行 Runloop。</p><p>注意：使用这种方式启动runloop时，CFRunLoopStop()函数也无法停止这个runloop。</p><p>#示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua">BOOL finished = NO;<br>    <br><span class="hljs-keyword">while</span>(!finished) &#123;<br>    <span class="hljs-string">[[NSRunLoop currentRunLoop] runUntilDate:</span><br><span class="hljs-string">     [NSDate dateWithTimeIntervalSinceNow: 1]]</span>;<br>    <br>    NSLog(@<span class="hljs-string">&quot;exit runloop ......&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个finished是我们自定义的一个Bool值，用来控制是否还需要开启下一次 Runloop。</p><p>上面例子所做的事：while循环内部有个 RunLoop 每秒循环一次，Runloop 结束后会输出<code>exit Runloop ……</code>。while循环会根据 finished 值来判断是否再去运行 Runloop。</p><p>输出日志如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">20.980211</span>+<span class="hljs-number">0800</span> <span class="hljs-keyword">exit</span> runloop ......<br><span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">21.981915</span>+<span class="hljs-number">0800</span> <span class="hljs-keyword">exit</span> runloop ......<br><span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">22.983668</span>+<span class="hljs-number">0800</span> <span class="hljs-keyword">exit</span> runloop ......<br><span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">23.984748</span>+<span class="hljs-number">0800</span> <span class="hljs-keyword">exit</span> runloop ......<br><span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">24.986541</span>+<span class="hljs-number">0800</span> <span class="hljs-keyword">exit</span> runloop ......<br><span class="hljs-number">21</span>:<span class="hljs-number">20</span>:<span class="hljs-number">25.988267</span>+<span class="hljs-number">0800</span> <span class="hljs-keyword">exit</span> runloop ......<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)runMode:(<span class="hljs-built_in">NSRunLoopMode</span>)mode beforeDate:(<span class="hljs-built_in">NSDate</span> *)limitDate;<span class="hljs-comment">//特定的模式</span><br></code></pre></td></tr></table></figure><p>比上面的方法多了mode参数，不同的是，这种运行方式是可以被<code>CFRunLoopStop()</code>函数停止的。</p><h4 id="2-CFRunLoopRef的启动"><a href="#2-CFRunLoopRef的启动" class="headerlink" title="2.CFRunLoopRef的启动"></a>2.CFRunLoopRef的启动</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CFRunLoopRun</span>()</span>;<br></code></pre></td></tr></table></figure><p>使用这种方式启动后，Runloop 会一直运行，直到显示地调用<code>CFRunLoopStop()</code>才会停止。另外，删除 RunLoop 的所有事件源后，也能停止这个 Runloop。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">SInt32 <span class="hljs-constructor">CFRunLoopRunInMode(<span class="hljs-params">mode</span>, <span class="hljs-params">second</span>, <span class="hljs-params">returnAfterSourceHandled</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li>参数mode：模式；</li><li>参数second：runloop的循环时间；</li><li>参数returnAfterSourceHandled：是否在处理事件后让Run Loop退出返回；</li></ul><p>这种方式启动的 Runloop 也可以使用<code>CFRunLoopStop()</code>来主动停止。NSRunloop 中的第三种启动方式，实质上就是基于这种方式的封装，只不过指定了最后一个<code>returnAfterSourceHandled</code>参数为YES。</p><ul><li>Runloop的返回值</li></ul><p>启动 Runloop 后，代码停在这一行不返回。当有值返回时Runloop就结束了。这个返回值就是Runloop结束原因，枚举如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* Reasons for CFRunLoopRunInMode() to Return */</span><br>typedef CF_ENUM(SInt32, CFRunLoopRunResult) &#123;<br>    kCFRunLoopRunFinished = <span class="hljs-number">1</span>,  <span class="hljs-regexp">//</span>Runloop结束，所有的Sources都已被移除，无事件源可监听；<br>    kCFRunLoopRunStopped = <span class="hljs-number">2</span>,   <span class="hljs-regexp">//</span>Runloop被使用CFRunLoopStop函数停止；<br>    kCFRunLoopRunTimedOut = <span class="hljs-number">3</span>,  <span class="hljs-regexp">//</span>超时；<br>    kCFRunLoopRunHandledSource = <span class="hljs-number">4</span> <span class="hljs-regexp">//</span>Runloop已处理完事件；<br>&#125;;<br></code></pre></td></tr></table></figure><p>回头看看NSRunloop的第三种启动方式：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(Bool)</span>runMode:<span class="hljs-params">(NSString *)</span>mode beforeDate:<span class="hljs-params">(NSDate *)</span>limitDate;<br></code></pre></td></tr></table></figure><p>返回值为一个Bool值，如果是”performSelector” 事件或者其他 Input Source 事件触发并处理完成后，Runloop会退出并返回YES，其他情况下返回NO。</p><h3 id="3-退出RunLoop"><a href="#3-退出RunLoop" class="headerlink" title="3.退出RunLoop"></a>3.退出RunLoop</h3><p>上面也有提到，有三种方法可以让 Runloop 处理事件之前退出:</p><ul><li>指定超时时间：</li></ul><p>这可以使 Runloop 退出前完成所有正常操作，包括发送消息给 Runloop 观察者，如果可以配置的话，推荐使用这种方法。</p><ul><li>使用CFRunLoopStop：</li></ul><p>这可以显式的停止 Runloop，Runloop 会把所有剩余的通知发送出去再退出。</p><ul><li>移除 Runloop 的输入源和定时器：</li></ul><p>尽管这种方式也可能导致 Runloop 退出，但这并不是可靠的退出 Runloop 的方法。一些系统例程会添加输入源到 Runloop 里面来处理所需事件。因为你的代码未必会考虑到这些输入源，这样可能导致你无法移除它们，从而导致退出 Runloop 失败。</p><h2 id="7-应用场景"><a href="#7-应用场景" class="headerlink" title="7.应用场景"></a>7.应用场景</h2><h3 id="1-场景汇总"><a href="#1-场景汇总" class="headerlink" title="1.场景汇总"></a>1.场景汇总</h3><ol><li>开启常驻线程时，需要在当前线程中启动 runloop，如AFN；</li><li>在子线程中使用定时器时，需要在子线程中启动 runloop，定时器才能正常启动；</li><li>创建定时器，在当前 runloop 的特定Mode下执行，如滑动时的定时器；</li><li>在特定Mode下执行任务，default模式下设置图片、加载缓存。</li><li>添加观察者，在 runloop 的特定时刻处理某些事情；</li><li>使用端口或自定义输入源来和其他线程通信；</li></ol><h3 id="2-其他应用"><a href="#2-其他应用" class="headerlink" title="2.其他应用"></a>2.其他应用</h3><p>ibireme的这篇<a href="https://blog.ibireme.com/2015/05/18/runloop/">博客</a>里提到了一些具体的应用场景：</p><ul><li>AutoreleasePool（监听通知以执行自动释放池的push与pop）</li><li>界面更新（beforeWaiting时更新界面）</li><li>事件响应（port-&gt;source1-&gt;source0）</li><li>手势识别</li><li>定时器</li><li>GCD</li><li>网络请求</li></ul><h3 id="3-卡顿检测"><a href="#3-卡顿检测" class="headerlink" title="3.卡顿检测"></a>3.卡顿检测</h3><p>卡顿原理：</p><ol><li>主线程runloop处于beforeSource或afterWaiting状态时表示正在执行任务；</li><li>设置一个卡顿时长阈值<code>T</code>，隔时长<code>T</code>检查一次当前runloop的状态(mode)；</li><li>若多个检查周期中，一直处于以上两种状态，而没有休眠，则说明线程处于卡顿状态；</li><li>获取卡顿时堆栈的情况，记录并上报；</li></ol><p>实现方案：</p><ol><li>监听并记录主线程runloop的mode(状态)；</li><li>开启一个常驻线程，处理检测、上报任务；</li><li>启动定时器，阈值T时间到后比对runloop的状态；</li><li>当阈值T时间内连续检测到状态为beforeSource或afterWaiting，即为卡顿，上报堆栈；</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunLoopMonitor</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;&#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared: <span class="hljs-type">RunLoopMonitor</span> <span class="hljs-operator">=</span> <span class="hljs-type">RunLoopMonitor</span>.<span class="hljs-keyword">init</span>()<br>    <span class="hljs-keyword">var</span> loopObserver: <span class="hljs-type">CFRunLoopObserver</span>?<br>    <span class="hljs-keyword">var</span> loopActivity: <span class="hljs-type">CFRunLoopActivity</span>?<br>    <span class="hljs-keyword">var</span> aSemaphore: <span class="hljs-type">DispatchSemaphore</span>?<br>    <span class="hljs-keyword">var</span> stuckTimes <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment">//出现卡顿的次数</span><br>    <br>    <span class="hljs-comment">/*原理：</span><br><span class="hljs-comment">     线程runloop处于beforeSource或afterWaiting状态时表示正在执行任务；</span><br><span class="hljs-comment">     多个检查周期中，runloop一直处于beforeSource或afterWaiting状态，</span><br><span class="hljs-comment">     而没有休眠，则说明runloop处于卡顿状态。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">startMonitor</span>() &#123;<br>        <span class="hljs-keyword">let</span> uptr <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>.passRetained(<span class="hljs-keyword">self</span>).toOpaque()<br>        <span class="hljs-keyword">let</span> vptr <span class="hljs-operator">=</span> <span class="hljs-type">UnsafeMutableRawPointer</span>(uptr)<br>        <span class="hljs-keyword">var</span> context <span class="hljs-operator">=</span> <span class="hljs-type">CFRunLoopObserverContext</span>.<span class="hljs-keyword">init</span>(version: <span class="hljs-number">0</span>,<br>                                                    info: vptr,<br>                                                    retain: <span class="hljs-literal">nil</span>,<br>                                                    release: <span class="hljs-literal">nil</span>,<br>                                                    copyDescription: <span class="hljs-literal">nil</span>)<br>        <span class="hljs-comment">//创建、添加观察者</span><br>        loopObserver <span class="hljs-operator">=</span> <span class="hljs-type">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,<br>                                                  <span class="hljs-type">CFRunLoopActivity</span>.allActivities.rawValue,<br>                                                  <span class="hljs-literal">true</span>,<br>                                                  <span class="hljs-number">0</span>,<br>                                                  observerCallBack(),<br>                                                  <span class="hljs-operator">&amp;</span>context)<br>        <span class="hljs-type">CFRunLoopAddObserver</span>(<span class="hljs-type">CFRunLoopGetMain</span>(), loopObserver, .commonModes)<br>        <br>        aSemaphore <span class="hljs-operator">=</span> <span class="hljs-type">DispatchSemaphore</span>.<span class="hljs-keyword">init</span>(value: <span class="hljs-number">0</span>)<br>        <br>        <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> &#123;<br>                <span class="hljs-comment">// 方案一：通过单次超时时间判断，如超过250毫秒即为卡顿；</span><br>                <span class="hljs-comment">// 方案二：连续多次短期检测中均超时即为卡顿；</span><br>                <span class="hljs-keyword">let</span> st <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.aSemaphore<span class="hljs-operator">?</span>.wait(timeout: <span class="hljs-type">DispatchTime</span>.now() <span class="hljs-operator">+</span> .milliseconds(<span class="hljs-number">80</span>)) <span class="hljs-comment">//戴铭在GCDFetchFeed中认为连续三次超时80秒就是卡顿</span><br>                <span class="hljs-comment">//80毫秒超时后</span><br>                <span class="hljs-keyword">if</span> st <span class="hljs-operator">==</span> .timedOut &#123;<br>                    <span class="hljs-comment">//指针检测</span><br>                    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">self</span>.loopObserver <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">self</span>.aSemaphore <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>                        <span class="hljs-keyword">self</span>.loopActivity <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>                        <span class="hljs-keyword">self</span>.stuckTimes <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>                        <span class="hljs-keyword">return</span><br>                    &#125;<br>                    <span class="hljs-comment">//如果loop处在“工作”状态，就无法休眠，记录+1</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.loopActivity <span class="hljs-operator">==</span> .afterWaiting <span class="hljs-operator">||</span><br>                       <span class="hljs-keyword">self</span>.loopActivity <span class="hljs-operator">==</span> .beforeSources<br>                    &#123;<br>                        <span class="hljs-comment">//记录一次卡顿</span><br>                        <span class="hljs-keyword">self</span>.stuckTimes <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>                        <span class="hljs-comment">//未超过3次，表示正常</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.stuckTimes <span class="hljs-operator">&lt;</span> <span class="hljs-number">3</span> &#123; <span class="hljs-keyword">continue</span> &#125;<br>                        <span class="hljs-comment">//超过三次，即为出现卡顿</span><br>                        <span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>                            <span class="hljs-comment">//获取当前卡顿时的堆栈 上报</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//观察者回调</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">observerCallBack</span>() -&gt; <span class="hljs-type">CFRunLoopObserverCallBack</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123; (observer, activity, context) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">let</span> weakself <span class="hljs-operator">=</span> <span class="hljs-type">Unmanaged</span>&lt;<span class="hljs-type">RunLoopMonitor</span>&gt;.fromOpaque(context<span class="hljs-operator">!</span>).takeUnretainedValue()<br>            <span class="hljs-comment">//记录runloop的状态</span><br>            weakself.loopActivity <span class="hljs-operator">=</span> activity<br>            weakself.aSemaphore<span class="hljs-operator">?</span>.signal()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//结束监测</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">end</span>() &#123;<br>        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">_</span> <span class="hljs-operator">=</span> loopObserver <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>        <span class="hljs-type">CFRunLoopRemoveObserver</span>(<span class="hljs-type">CFRunLoopGetMain</span>(), loopObserver, .commonModes)<br>        loopObserver <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">©官方文档</a></p><p>#<a href="https://blog.ibireme.com/2015/05/18/runloop/">©ibireme</a></p><p>#<a href="http://blog.csdn.net/u011619283/article/details/53666009">©微信卡顿检测</a></p><p>#<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/">©百度孙源-优化UITableViewCell高度计算的那些事</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runloop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新增类及其成员</title>
    <link href="/2017/09/01/runtime-addClass.html"/>
    <url>/2017/09/01/runtime-addClass.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h3><blockquote><p>To create a new class, start by calling objc_allocateClassPair. Then set the class’s attributes with functions like class_addMethod and class_addIvar. When you are done building the class, call objc_registerClassPair. The new class is now ready for use.<br>Instance methods and instance variables should be added to the class itself. Class methods should be added to the metaclass.</p></blockquote><h4 id="1-1-增加类"><a href="#1-1-增加类" class="headerlink" title="1.1.增加类"></a>1.1.增加类</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Class objc<span class="hljs-constructor">_allocateClassPair(Class <span class="hljs-params">superclass</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">extraBytes</span>)</span>;<br>void objc<span class="hljs-constructor">_registerClassPair(Class <span class="hljs-params">cls</span>)</span><br></code></pre></td></tr></table></figure><p>这两个方法配对使用，在二者之间增加成员变量、属性、实例方法和类方法等。调用第二个方法即注册类，这之后类的结构也就固定下来，不能再向类中增加新的成员变量，但是可以增加属性和方法。其中新增的属性不会自动生成<code>_属性名</code>成员变量，也不会提供setter与getter函数及其实现。</p><h4 id="1-2-增加方法"><a href="#1-2-增加方法" class="headerlink" title="1.2.增加方法"></a>1.2.增加方法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BOOL <span class="hljs-keyword">class</span><span class="hljs-constructor">_addMethod(Class <span class="hljs-params">cls</span>, SEL <span class="hljs-params">name</span>, IMP <span class="hljs-params">imp</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">types</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li>实例方法应该加到当前实例的isa指向的类中；</li><li>类方法则应该加到当前类的元类中；</li></ul><h4 id="1-3-增加成员变量"><a href="#1-3-增加成员变量" class="headerlink" title="1.3.增加成员变量"></a>1.3.增加成员变量</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BOOL <span class="hljs-keyword">class</span><span class="hljs-constructor">_addIvar(Class <span class="hljs-params">cls</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>, <span class="hljs-params">size_t</span> <span class="hljs-params">size</span>, <span class="hljs-params">uint8_t</span> <span class="hljs-params">alignment</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">types</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>This function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.<br>The class must not be a metaclass. Adding an instance variable to a metaclass is not supported.</p></blockquote><p>新增成员变量应该在类注册完成之前进行，类注册完成之后类结构已固定，实例的内存空间已经确定，不能再增加新的成员变量。</p><p>新增加的成员变量应该加到实例对象所属的类中，而不能加到其所属类的元类中。</p><h4 id="1-4-增加属性"><a href="#1-4-增加属性" class="headerlink" title="1.4.增加属性"></a>1.4.增加属性</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">BOOL <span class="hljs-keyword">class</span><span class="hljs-constructor">_addProperty(Class <span class="hljs-params">cls</span>, <span class="hljs-params">const</span> <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">name</span>, <span class="hljs-params">const</span> <span class="hljs-params">objc_property_attribute_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attributes</span>, <span class="hljs-params">unsigned</span> <span class="hljs-params">int</span> <span class="hljs-params">attributeCount</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#import <span class="hljs-string">&quot;AppDelegate.h&quot;</span><br>#import &lt;objc/message.h&gt;<br>#import &lt;objc/runtime.h&gt;<br><br>@implementation AppDelegate<br><br>void learn<span class="hljs-constructor">OnTV(<span class="hljs-params">id</span> <span class="hljs-params">self</span>,SEL <span class="hljs-params">_cmd</span>)</span><br>&#123;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++执行learnOnTV方法&quot;</span>)</span>;<br>&#125;<br><br>void lear<span class="hljs-constructor">OnBook(<span class="hljs-params">id</span> <span class="hljs-params">self</span>,SEL <span class="hljs-params">_cmd</span>)</span><br>&#123;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++执行learOnBook方法&quot;</span>)</span>;<br>&#125;<br><br>- (BOOL)application:(UIApplication *)application<br>didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//创建新的类</span><br>    Class ASDClass = objc<span class="hljs-constructor">_allocateClassPair([NSObject <span class="hljs-params">class</span>], <span class="hljs-string">&quot;ASDClass&quot;</span>, 0)</span>;<br>    <br>    <span class="hljs-comment">//增加成员变量</span><br>    const <span class="hljs-built_in">char</span> *height = <span class="hljs-string">&quot;height&quot;</span>;<br>    BOOL status1 = <span class="hljs-keyword">class</span><span class="hljs-constructor">_addIvar(ASDClass, <span class="hljs-params">height</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">id</span>)</span>, rint(log2(sizeof(id))), @encode(id));<br>    <span class="hljs-keyword">if</span> (status1) &#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++成功添加成员变量&#x27;height&#x27;~&quot;</span>)</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++添加成员变量&#x27;height&#x27;失败~&quot;</span>)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//为类增加属性</span><br>    objc_property_attribute_t <span class="hljs-keyword">type</span>  = &#123;<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;@\&quot;NSString\&quot;&quot;</span>&#125;;<br>    objc_property_attribute_t ownership1 = &#123;<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;&quot;</span>&#125;;      <span class="hljs-comment">// C = copy</span><br>    objc_property_attribute_t ownership2 = &#123; <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;&quot;</span> &#125;;   <span class="hljs-comment">// N = nonatomic</span><br>    objc_property_attribute_t backIvars  = &#123;<span class="hljs-string">&quot;V&quot;</span>,<span class="hljs-string">&quot;_name&quot;</span>&#125;; <span class="hljs-comment">//属性名</span><br>    objc_property_attribute_t atts<span class="hljs-literal">[]</span> = &#123;<span class="hljs-keyword">type</span>,ownership1,ownership2,backIvars&#125;;<br>    BOOL status2 = <span class="hljs-keyword">class</span><span class="hljs-constructor">_addProperty(ASDClass, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-params">atts</span>, 4)</span>;<br>    <span class="hljs-keyword">if</span> (status2) &#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++成功添加属性&#x27;name&#x27;~&quot;</span>)</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++添加属性&#x27;name&#x27;失败~&quot;</span>)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//为类增加方法</span><br>    <span class="hljs-keyword">class</span><span class="hljs-constructor">_addMethod(ASDClass, @<span class="hljs-params">selector</span>(<span class="hljs-params">learn</span>)</span>, (IMP)learnOnTV, <span class="hljs-string">&quot;v@:&quot;</span>);<br>    <span class="hljs-comment">//&quot;v@:&quot;字符，依次表示函数返回值类型和每个参数的类型，这里v表示返回值void，@表示调用者，：表示SEL</span><br>    <br>    <span class="hljs-comment">//注册类</span><br>    objc<span class="hljs-constructor">_registerClassPair(ASDClass)</span>;<br>    <br>    <span class="hljs-comment">//增加成员变量(！！会失败，因为类结构已固定，实例大小已确定)</span><br>    const <span class="hljs-built_in">char</span> *width = <span class="hljs-string">&quot;width&quot;</span>;<br>    BOOL status3 = <span class="hljs-keyword">class</span><span class="hljs-constructor">_addIvar(ASDClass, <span class="hljs-params">width</span>, <span class="hljs-params">sizeof</span>(<span class="hljs-params">id</span>)</span>, rint(log2(sizeof(id))), @encode(id));<br>    <span class="hljs-keyword">if</span> (status3) &#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++成功添加成员变量&#x27;width&#x27;~&quot;</span>)</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++添加成员变量&#x27;width&#x27;失败~&quot;</span>)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//为类增加属性(会成功)</span><br>    objc_property_attribute_t type2  = &#123;<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;@\&quot;NSString\&quot;&quot;</span>&#125;;<br>    objc_property_attribute_t ownership3 = &#123;<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;&quot;</span>&#125;;      <span class="hljs-comment">// C = copy</span><br>    objc_property_attribute_t ownership4 = &#123; <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;&quot;</span> &#125;;   <span class="hljs-comment">// N = nonatomic</span><br>    objc_property_attribute_t backIvars2  = &#123;<span class="hljs-string">&quot;V&quot;</span>,<span class="hljs-string">&quot;_name&quot;</span>&#125;; <span class="hljs-comment">//属性名</span><br>    objc_property_attribute_t atts2<span class="hljs-literal">[]</span> = &#123;type2,ownership3,ownership4,backIvars2&#125;;<br>    BOOL status4 = <span class="hljs-keyword">class</span><span class="hljs-constructor">_addProperty(ASDClass, <span class="hljs-string">&quot;nick&quot;</span>, <span class="hljs-params">atts2</span>, 4)</span>;<br>    <span class="hljs-keyword">if</span> (status4) &#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++成功添加属性&#x27;nick&#x27;~&quot;</span>)</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;+++++添加属性&#x27;nick&#x27;失败~&quot;</span>)</span>;<br>    &#125;<br>    NSArray *ivarsArr = <span class="hljs-literal">[R<span class="hljs-identifier">untimeTool</span> <span class="hljs-identifier">ivarListWithClass</span>:ASDC<span class="hljs-identifier">lass</span>]</span>;<br>    NSArray *propsArr  = <span class="hljs-literal">[R<span class="hljs-identifier">untimeTool</span> <span class="hljs-identifier">propertyListWithClass</span>:ASDC<span class="hljs-identifier">lass</span>]</span>;<br>    NSArray *methodArr = <span class="hljs-literal">[R<span class="hljs-identifier">untimeTool</span> <span class="hljs-identifier">methodListWithClass</span>:ASDC<span class="hljs-identifier">lass</span>]</span>;<br>    <br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++所有成员变量:%@&quot;</span>,<span class="hljs-params">ivarsArr</span>)</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++所有属性:%@&quot;</span>,<span class="hljs-params">propsArr</span>)</span>;<br>    <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++所有方法:%@&quot;</span>,<span class="hljs-params">methodArr</span>)</span>;<br>    <br>    <span class="hljs-comment">//调用learn方法</span><br>    objc<span class="hljs-constructor">_msgSend([ASDClass <span class="hljs-params">new</span>],@<span class="hljs-params">selector</span>(<span class="hljs-params">learn</span>)</span>);<br>    <br>    <span class="hljs-comment">//替换learn方法的实现函数为learOnBook</span><br>    <span class="hljs-keyword">class</span><span class="hljs-constructor">_replaceMethod(ASDClass, @<span class="hljs-params">selector</span>(<span class="hljs-params">learn</span>)</span>, (IMP)learOnBook, <span class="hljs-string">&quot;v@:&quot;</span>);<br>    <br>    <span class="hljs-comment">//再次调用learn方法</span><br>    objc<span class="hljs-constructor">_msgSend([ASDClass <span class="hljs-params">new</span>],@<span class="hljs-params">selector</span>(<span class="hljs-params">learn</span>)</span>);<br>    <br>    return YES;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>RuntimeTool</code>是工具类，用来获取成员变量、属性和方法列表，实现代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;RuntimeTool.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt; //包含对类、成员变量、属性、方法的操作</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/message.h&gt; //包含消息机制</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">RuntimeTool</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">获取类中所有成员变量的名称与类型</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">@param aClass 目标类名</span><br><span class="hljs-comment">@return 返回一个数组，&#123;键：变量名，值：类型&#125;</span><br><span class="hljs-comment">*/</span><br>+ (<span class="hljs-built_in">NSArray</span> *)ivarListWithClass:(Class)aClass<br>&#123;<br>    <span class="hljs-keyword">if</span> (!object_isClass(aClass))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">NSMutableArray</span> *resultArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br><br>    Ivar *ivars = class_copyIvarList([aClass <span class="hljs-keyword">class</span>], &amp;count);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;count; i++)&#123;<br>        Ivar ivar = ivars[i];<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charName = ivar_getName(ivar);<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charType = ivar_getTypeEncoding(ivar);<br><br>        <span class="hljs-built_in">NSString</span> *name = [<span class="hljs-built_in">NSString</span> stringWithCString:charName encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br><br>        <span class="hljs-built_in">NSString</span> *type = [<span class="hljs-built_in">NSString</span> stringWithCString:charType encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br><br>        <span class="hljs-built_in">NSDictionary</span> *dic = @&#123;<span class="hljs-string">@&quot;ivar_name&quot;</span>:name,<span class="hljs-string">@&quot;objc_type&quot;</span>:type&#125;;<br><br>        [resultArr addObject:dic];<br>    &#125;<br><br>    free(ivars);<br><br>    <span class="hljs-keyword">return</span> resultArr;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">获取类中所有属性的名称与类型</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">@param aClass 目标类名</span><br><span class="hljs-comment">@return 返回一个数组，&#123;键：属性名，值：类型&#125;</span><br><span class="hljs-comment">*/</span><br>+ (<span class="hljs-built_in">NSArray</span> *)propertyListWithClass:(Class)aClass<br>&#123;<br>    <span class="hljs-keyword">if</span> (!object_isClass(aClass))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">NSMutableArray</span> *resultArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br><br>    objc_property_t *properties = class_copyPropertyList([aClass <span class="hljs-keyword">class</span>], &amp;count);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;count; i++)&#123;<br>        objc_property_t aProperty = properties[i];<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charName = property_getName(aProperty);<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charType = property_getAttributes(aProperty);<br><br>        <span class="hljs-built_in">NSString</span> *name = [<span class="hljs-built_in">NSString</span> stringWithCString:charName encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br><br>        <span class="hljs-built_in">NSString</span> *type = [<span class="hljs-built_in">NSString</span> stringWithCString:charType encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br><br>        <span class="hljs-built_in">NSDictionary</span> *dic = @&#123;<span class="hljs-string">@&quot;property_name&quot;</span>:name,<span class="hljs-string">@&quot;objc_type&quot;</span>:type&#125;;<br><br>        [resultArr addObject:dic];<br>    &#125;<br><br>    free(properties);<br><br>    <span class="hljs-keyword">return</span> resultArr;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">获取类中所有方法名</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">@param aClass 目标类</span><br><span class="hljs-comment">@return 返回所有方法名组成的一个数组</span><br><span class="hljs-comment">*/</span><br>+ (<span class="hljs-built_in">NSArray</span> *)methodListWithClass:(Class)aClass<br>&#123;<br>    <span class="hljs-keyword">if</span> (!object_isClass(aClass))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>    &#125;<br>    <span class="hljs-built_in">NSMutableArray</span> *methodArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    Method *methods = class_copyMethodList(aClass, &amp;count);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        SEL sel_name = method_getName(methods[i]);<br>        <span class="hljs-built_in">NSString</span> *name = [<span class="hljs-built_in">NSString</span> stringWithCString:sel_getName(sel_name) encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br><br>        [methodArr addObject:name];<br>    &#125;<br>    free(methods);<br><br>    <span class="hljs-keyword">return</span> methodArr;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：直接调用<code>objc_msgSend</code>在编译时会报错，需要在 “Build Setting”中，把“ Enable Strict Checking of objc_msgSend Calls” 关掉。</p><p>示例运行后输出日志：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">+++++成功添加成员变量<span class="hljs-string">&#x27;height&#x27;</span>~<br>+++++成功添加属性<span class="hljs-string">&#x27;name&#x27;</span>~<br>+++++添加成员变量<span class="hljs-string">&#x27;width&#x27;</span>失败~<br>+++++成功添加属性<span class="hljs-string">&#x27;nick&#x27;</span>~<br>++++所有成员变量:(<br>        &#123;<br>        &quot;ivar_name&quot; = height;<br>        &quot;objc_type&quot; = &quot;@&quot;;<br>    &#125;<br>)<br>++++所有属性:(<br>        &#123;<br>        &quot;objc_type&quot; = &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;;<br>        &quot;property_name&quot; = nick;<br>    &#125;,<br>        &#123;<br>        &quot;objc_type&quot; = &quot;T@\&quot;NSString\&quot;,C,N,V_name&quot;;<br>        &quot;property_name&quot; = <span class="hljs-type">name</span>;<br>    &#125;<br>)<br>++++所有方法:(<br>    learn<br>)<br>++++执行learnOnTV方法<br>++++执行learOnBook方法<br></code></pre></td></tr></table></figure><p>从日志中也可以得出结论：</p><p>1、在类<code>allocate</code>与<code>register</code>之间可以添加<code>成员变量</code>、<code>属性</code>和<code>方法</code>；</p><p>2、在<code>register</code>之后，即类结构固定之后<code>不能</code>再添加<code>成员变量</code>，但可以继续添加<code>属性</code>和<code>方法</code>；</p><p>3、动态添加的属性，不会创建对应的以<code>_</code>开头的成员变量，这一步需要由编译器来完成。</p><p>ps: 热更新<code>JSPatch</code>就是在OC的 runtime 基础上实现的，大致原理是：JS传递字符串给OC，OC通过 Runtime 的运行时函数，调用和替换相应的OC方法。待后期慢慢研究。。</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法交换</title>
    <link href="/2017/09/01/runtime-swizzle.html"/>
    <url>/2017/09/01/runtime-swizzle.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-方法交换"><a href="#1-方法交换" class="headerlink" title="1.方法交换"></a>1.方法交换</h3><p>Method Swizzling</p><p>作用：动态交换两个方法的实现(即IMP指针)；</p><p>原理：在类的结构体中有一个<code>methodLists</code>，它存放着 SEL 与 IMP 的映射关系。Method Swizzling 就是对这个列表进行的操作，通过改变这种映射关系，完成两个方法IMP的交换；</p><p>使用场景：</p><ol><li>类的原有方法无法满足新需求，需要扩展并替换。如数组新增对象时，检测对象是否为nil；</li><li>新增页面统计等功能时，需新建父类实现统计业务，再让相关类继承此类，这会造成重复劳动。如果在运行时事先替换各viewDidLoad为自己的统计方法，则只需要一次操作即可；</li></ol><p>其核心代码是runtime的下面两个C语言API：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs smali">/** <br> * Exchanges the implementations of two methods.<br> * <br> * @param m1 Method to exchange with second method.<br> * @param m2 Method to exchange with first method.<br> * <br> * @note This is an atomic version of the following:<br> *  \code <br> *  IMP imp1 = method_getImplementation(m1);<br> *  IMP imp2 = method_getImplementation(m2);<br> *  method_setImplementation(m1, imp2);<br> *  method_setImplementation(m2, imp1);<br> *  \endcode<br> */<br>OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2)<br><br><br>/** <br> * Returns a specified<span class="hljs-built_in"> instance </span>method for a given class.<br> * <br> * @param cls The class you want to inspect.<br> * @param name The selector of the method you want to retrieve.<br> * <br> * @return The method that corresponds to the implementation of the selector specified by <br> *  \e name for the class specified by \e cls,<span class="hljs-built_in"> or </span>\c NULL<span class="hljs-built_in"> if </span>the specified class<span class="hljs-built_in"> or </span>its <br> *  superclasses do<span class="hljs-built_in"> not </span>contain an<span class="hljs-built_in"> instance </span>method with the specified selector.<br> *<br> * @note This function searches superclasses for implementations, whereas \c class_copyMethodList does not.<br> */<br>OBJC_EXPORT Method class_getInstanceMethod(Class cls, SEL name)<br></code></pre></td></tr></table></figure><h3 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h3><p>数组新增对象时检测nil对象，防止闪退。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;NSMutableArray+Extension.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSMutableArray</span> (<span class="hljs-title">Extension</span>)</span><br><br>+(<span class="hljs-type">void</span>)load&#123;<br>    [<span class="hljs-keyword">self</span> swizzle_install];<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)swizzle_install<br>&#123;<br>    Method method1 = class_getInstanceMethod(objc_getClass(<span class="hljs-string">&quot;__NSArrayM&quot;</span>),<br>    <span class="hljs-keyword">@selector</span>(addObject:));<br>    Method method2 = class_getInstanceMethod(objc_getClass(<span class="hljs-string">&quot;__NSArrayM&quot;</span>),<br>    <span class="hljs-keyword">@selector</span>(swizzle_addObject:));<br>    <span class="hljs-comment">// 交换两个方法的实现函数</span><br>    method_exchangeImplementations(method1, method2);<br>&#125;<br><br>-(<span class="hljs-type">void</span>)swizzle_addObject:(<span class="hljs-type">id</span>)anObject<br>&#123;<br>    <span class="hljs-comment">// 发现空对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nil</span> == anObject)<br>    &#123;<br>        <span class="hljs-keyword">@try</span> &#123;<br>            <span class="hljs-comment">// 注意：因为已经交换过方法了，所以这里调用的是数组的addObject:方法。</span><br>            [<span class="hljs-keyword">self</span> swizzle_addObject:anObject];<br>        &#125; <span class="hljs-keyword">@catch</span> (<span class="hljs-built_in">NSException</span> *exception) &#123;<br>            <span class="hljs-comment">// 捕获异常，打印日志，避免闪退。</span><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Crash reason:\n %@&quot;</span>, [exception callStackSymbols]);<br>        &#125; <span class="hljs-keyword">@finally</span> &#123;&#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果对象不为空</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">// 正常调用数组原生的addObject:方法，不捕获异常。</span><br>        [<span class="hljs-keyword">self</span> swizzle_addObject:anObject];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>在APP启动后，运行时会先执行 NSMutableArray 分类中的 <code>+load</code> 函数，这里会调用<code>swizzle_install</code>，启动方法交换：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//添加对象</span><br>    <span class="hljs-built_in">NSMutableArray</span> *array = [<span class="hljs-built_in">NSMutableArray</span> new];<br>    [array addObject:<span class="hljs-literal">nil</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，虽然向数组中加入nil对象，但因为已经对<code>addObject</code>方法做了交换并做了容错处理，所以只是会打印崩溃日志，应用并不会闪退。</p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象关联</title>
    <link href="/2017/08/30/runtime-associate.html"/>
    <url>/2017/08/30/runtime-associate.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://davidlii.nos-eastchina1.126.net/pic_runtime_associate.png" alt="runtime对象关联"></p><h3 id="1-对象关联"><a href="#1-对象关联" class="headerlink" title="1.对象关联"></a>1.对象关联</h3><p>使用关联，我们可以在不修改类定义的前提下，为其对象增加存储空间。</p><p>适合的场景：</p><ol><li>把某对象与特定对象相关联；</li><li>解决分类中属性不会自动生成getter、setter函数，调用时会闪退的问题；</li></ol><h4 id="1-1-创建关联"><a href="#1-1-创建关联" class="headerlink" title="1.1.创建关联"></a>1.1.创建关联</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">OBJC_EXPORT void objc<span class="hljs-constructor">_setAssociatedObject(<span class="hljs-params">id</span> <span class="hljs-params">object</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>, <span class="hljs-params">id</span> <span class="hljs-params">value</span>, <span class="hljs-params">objc_AssociationPolicy</span> <span class="hljs-params">policy</span>)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>object：源对象；</li><li>*key：键；</li><li>value：将关联到源对象中的对象；</li><li>policy：关联策略；</li></ul><p>关联策略字段与声明属性时的关键字类似：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elm">typedef <span class="hljs-type">OBJC_ENUM</span>(uintptr_t, objc_AssociationPolicy) &#123;<br><span class="hljs-type">OBJC_ASSOCIATION_ASSIGN</span> = 0,<br><span class="hljs-type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span> = 1, <br><span class="hljs-type">OBJC_ASSOCIATION_COPY_NONATOMIC</span> = 3,<br><span class="hljs-type">OBJC_ASSOCIATION_RETAIN</span> = 01401,<br><span class="hljs-type">OBJC_ASSOCIATION_COPY</span> = 01403<br>&#125;;<br></code></pre></td></tr></table></figure><p>作用：说明相关的对象是通过赋值、保留引用还是复制的方式进行关联的；还有这种关联是原子的还是非原子的。</p><h4 id="1-2-获取关联"><a href="#1-2-获取关联" class="headerlink" title="1.2.获取关联"></a>1.2.获取关联</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">OBJC_EXPORT id objc<span class="hljs-constructor">_getAssociatedObject(<span class="hljs-params">id</span> <span class="hljs-params">object</span>, <span class="hljs-params">const</span> <span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">key</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="1-3-断开关联"><a href="#1-3-断开关联" class="headerlink" title="1.3.断开关联"></a>1.3.断开关联</h4><p>断开关联可使用<code>objc_setAssociatedObject</code>函数，第三个参数传入nil值即可，此时关联策略也就无所谓了。</p><p><code>objc_removeAssociatedObjects</code>也可以断开关联，但不建议使用这个函数，它会断开所有的关联。只有在需要把对象恢复到原始状态时才推荐使用这个函数。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">OBJC_EXPORT</span> <span class="hljs-variable">void</span> <span class="hljs-function"><span class="hljs-title">objc_removeAssociatedObjects</span>(<span class="hljs-variable">id</span> <span class="hljs-variable"><span class="hljs-class">object</span></span>)</span><br></code></pre></td></tr></table></figure><h4 id="1-4-示例"><a href="#1-4-示例" class="headerlink" title="1.4.示例"></a>1.4.示例</h4><p>#示例1：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">Associate</span>)</span><br><br><span class="hljs-comment">//属性 分类中允许声明属性，但不会自动生成getter、setter函数；</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span> mAssociateObj;<br><br><span class="hljs-comment">//移除关联</span><br>- (<span class="hljs-type">void</span>)removeAssociate;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;NSObject+Associate.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-type">void</span> *mAssociateObjKey = &amp;mAssociateObjKey;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">Associate</span>)</span><br><br><br>- (<span class="hljs-type">void</span>)setMAssociateObj:(<span class="hljs-type">id</span>)obj<br>&#123;<br>    <span class="hljs-comment">//创建关联</span><br>    objc_setAssociatedObject(<span class="hljs-keyword">self</span>, mAssociateObjKey, obj, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br><br>- (<span class="hljs-type">id</span>)mAssociateObj<br>&#123;<br>    <span class="hljs-comment">//获取关联的对象</span><br>    <span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, mAssociateObjKey);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)removeAssociate<br>&#123;<br>    objc_setAssociatedObject(<span class="hljs-keyword">self</span>, mAssociateObjKey, <span class="hljs-literal">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">NSObject *obj = <span class="hljs-literal">[NSO<span class="hljs-identifier">bject</span> <span class="hljs-identifier">new</span>]</span>;<br>obj.mAssociateObj = @<span class="hljs-string">&quot;THIS IS A STRING&quot;</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++关联对象：%@&quot;</span>,<span class="hljs-params">obj</span>.<span class="hljs-params">mAssociateObj</span>)</span>;<br><br><span class="hljs-literal">[<span class="hljs-identifier">obj</span> <span class="hljs-identifier">removeAssociate</span>]</span>;<br><span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;++++移除后的关联对象：%@&quot;</span>,<span class="hljs-params">obj</span>.<span class="hljs-params">mAssociateObj</span>)</span>;<br></code></pre></td></tr></table></figure><p>日志：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">++++关联对象：THIS <span class="hljs-keyword">IS</span> A <span class="hljs-built_in">STRING</span><br>++++移除后的关联对象：(<span class="hljs-keyword">null</span>)<br></code></pre></td></tr></table></figure><p>#示例2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)viewDidAppear:(<span class="hljs-type">BOOL</span>)animated<br>&#123;<br>    [<span class="hljs-variable language_">super</span> viewDidAppear:animated];<br><br>    <span class="hljs-built_in">UIAlertController</span> *alertControler = [<span class="hljs-built_in">UIAlertController</span> <br>        alertControllerWithTitle:<span class="hljs-string">@&quot;Title&quot;</span><br>        message:<span class="hljs-string">@&quot;This is Mess&quot;</span><br>        preferredStyle:<span class="hljs-built_in">UIAlertControllerStyleAlert</span>];<br><br>    <span class="hljs-built_in">UIAlertAction</span> *action = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:<span class="hljs-string">@&quot;OK&quot;</span> <br>        style:<span class="hljs-built_in">UIAlertActionStyleCancel</span> <br>        handler:^(<span class="hljs-built_in">UIAlertAction</span> * _Nonnull action) &#123;<br><br>        <span class="hljs-built_in">NSString</span> *associateObj = objc_getAssociatedObject(alertControler, mAssociateObjKey);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++关联对象：%@&quot;</span>,associateObj);<br>        objc_setAssociatedObject(alertControler, mAssociateObjKey, <span class="hljs-literal">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);<br><br>        <span class="hljs-built_in">NSString</span> *associateObj2 = objc_getAssociatedObject(alertControler, mAssociateObjKey);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++++关联对象：%@&quot;</span>,associateObj2);<br>    &#125;];<br>    [alertControler addAction:action];<br><br>    objc_setAssociatedObject(alertControler, mAssociateObjKey, <span class="hljs-string">@&quot;This is a string obj&quot;</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);<br><br>    [<span class="hljs-keyword">self</span> presentViewController:alertControler animated:<span class="hljs-literal">YES</span> completion:^&#123;<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure><p>点击弹窗之后，输出日志：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">++++关联对象：This <span class="hljs-keyword">is</span> a <span class="hljs-built_in">string</span> obj<br>++++移除关联对象后：(<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><p>需要说明的是：</p><ol><li>通过关联增加属性，只是把属性对象与类对象的实例相关联，并未真正增加类的成员变量；</li><li>关联的对象与被关联的对象，两者的内存空间是分开的；</li></ol><h4 id="1-5-原理"><a href="#1-5-原理" class="headerlink" title="1.5.原理"></a>1.5.原理</h4><p><code>关联</code>可以将对象与某个实例绑定到一起，或者在分类中实现属性值的存取。但是在运行时，被关联的属性并没有添加到 <code>category_t</code> 结构体中，也不会合并到原类对象里，而是存储在一个全局的管理器 <code>AssociationsManager</code> 里。</p><blockquote><p>所有的关联属性、获取关联属性、移除关联属性都是通过一个<code>AssociationsManager</code>来操作，类似于 OC 中 NSFileManager 的角色，通过传递进来的对象作为地址取出这个对象所对应的关联列表，然后通过<code>key</code>取出这个关联列表的关联属性 ObjcAssociation。ObjcAssociation 包含了 <code>关联策略</code> 和 <code>关联值</code>.</p></blockquote><h3 id="2-分类特殊性"><a href="#2-分类特殊性" class="headerlink" title="2.分类特殊性"></a>2.分类特殊性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">Associate</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> aInt;<span class="hljs-comment">//此处编译时会报错：“instance variables may not be placed in categories”</span><br>&#125;<br><span class="hljs-comment">//属性 分类中允许声明属性，但不会自动生成getter、setter函数；</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-type">id</span> mAssociateObj;<br><br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><ul><li>分类中不能声明成员变量；</li><li>分类中允许声明属性，但不会生成属性对应的成员变量及其 getter\setter；</li><li>分类中可以增加新的方法，或者覆盖原类的方法；</li></ul><h4 id="2-1-✘成员变量"><a href="#2-1-✘成员变量" class="headerlink" title="2.1.✘成员变量"></a>2.1.✘成员变量</h4><p>结论：不能通过分类向原类中增加新的成员变量。</p><p>原因分析：OC中的类是一个指向 <code>objc_class</code> 的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_class</span> &#123;<br>Class isa<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !__OBJC2__</span><br>Class super_class <br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name <br><span class="hljs-type">long</span> version<br><span class="hljs-type">long</span> info<br><span class="hljs-type">long</span> instance_size <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_ivar_list</span> *ivars  <span class="hljs-comment">//成员变量列表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_method_list</span> **methodLists <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_cache</span> *cache<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_protocol_list</span> *protocols<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>实例的内存布局在编译期已确定</li></ul><p>增加新成员变量，就需要额外的内存来存储新的值。而类结构在<code>编译时</code>就已经确定了，即类实例的内存空间大小<code>&quot;instance_size&quot;</code>和成员变量列表<code>&quot;ivars&quot;</code>的内容在编译阶段就已经确定。</p><ul><li>分类的加载晚于原类</li></ul><p>分类中的属性和方法是在应用启动的过程中，原类注册完成之后才注册到原类中的，即分类加载时原类的结构早已固定。</p><p>基于以上两点，分类不能向一个已经<code>完成编译和加载</code>的原类中再增加成员变量~</p><p>有人说可以使用<code>class_addIvar()</code>增加成员变量，需要指出的是，这是个<code>运行时</code>函数~且苹果文档中已经明确说明：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs smali">/** <br>* Adds a<span class="hljs-built_in"> new </span>instance variable to a class.<br>* @note This function may only be called after objc_allocateClassPair<br>*      <span class="hljs-built_in"> and </span>before objc_registerClassPair. <br>*       Adding an<span class="hljs-built_in"> instance </span>variable to an existing class is<span class="hljs-built_in"> not </span>supported.<br>* @note The class must<span class="hljs-built_in"> not </span>be a metaclass. <br>*       Adding an<span class="hljs-built_in"> instance </span>variable to a metaclass is<span class="hljs-built_in"> not </span>supported.<br>* @note The<span class="hljs-built_in"> instance </span>variable&#x27;s minimum alignment in bytes is 1&lt;&lt;align. <br>*       The minimum alignment of an<span class="hljs-built_in"> instance </span><br>*       variable depends on the ivar&#x27;s type<span class="hljs-built_in"> and </span>the machine architecture. <br>*       For variables of any pointer type, pass log2(sizeof(pointer_type)).<br>*/<br>OBJC_EXPORT BOOL class_addIvar(Class cls,<span class="hljs-built_in"> const </span>char *name, size_t size, <br>uint8_t alignment,<span class="hljs-built_in"> const </span>char *types)<br></code></pre></td></tr></table></figure><p>这个函数只能在<code>objc_allocateClassPair</code>与<code>objc_registerClassPair</code>之间使用。就是说一旦类的定义完成之后，就不能再增加成员变量。我们用到的类，在编译时其结构就已经固定了。即使在<code>运行时</code>，也不能在<code>objc_registerClassPair()</code>之后再增加成员变量！</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/message.h&gt;</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//创建新的类</span><br>    Class Person = objc_allocateClassPair([<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>], <span class="hljs-string">&quot;Person&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//增加成员变量</span><br>    <span class="hljs-type">BOOL</span> status = class_addIvar(Person, <span class="hljs-string">&quot;nick&quot;</span>,<br>    <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">NSString</span>*), log2(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">NSString</span>*)), <span class="hljs-keyword">@encode</span>(<span class="hljs-built_in">NSString</span>*));<br><br>    <span class="hljs-keyword">if</span> (status)<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++变量nick添加成功&quot;</span>); <span class="hljs-comment">// 成功</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++变量nick添加失败&quot;</span>);<br><br>    <span class="hljs-comment">//注册类</span><br>    objc_registerClassPair(Person);<br><br>    status = class_addIvar(Person, <span class="hljs-string">&quot;city&quot;</span>,<br>    <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">NSString</span>*), log2(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">NSString</span>*)), <span class="hljs-keyword">@encode</span>(<span class="hljs-built_in">NSString</span>*));<br><br>    <span class="hljs-keyword">if</span> (status)<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++变量city添加成功&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++变量city添加失败&quot;</span>); <span class="hljs-comment">// 失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++++</span><span class="hljs-comment">变量nick添加成功</span><br><span class="hljs-literal">+++++</span><span class="hljs-comment">变量city添加失败</span><br></code></pre></td></tr></table></figure><p>示例中在<code>objc_registerClassPair()</code>之后添加成员变量<code>city</code>失败~</p><h4 id="2-2-✔️属性"><a href="#2-2-✔️属性" class="headerlink" title="2.2.✔️属性"></a>2.2.✔️属性</h4><p>结论：分类中可以增加属性，但不会自动生成对应的成员变量和getter&#x2F;setter。</p><p>1、分类为什么可以声明属性呢？</p><p>这是因为分类的结构体中本身就定义了<code>proper_list_t *properties</code>字段，参考<a href="https://www.jianshu.com/p/eebc2acd7da0">这里</a>。</p><p>2、为什么不能自动生成属性对应的成员变量和存取函数呢？</p><p>原类中属性对应的成员变量和存取函数都是由编译器在编译阶段生成的，而分类的则是在应用启动阶段原类加载完成之后才注册到原类中的，所以没法实现属性的@synthesize功能。如果想实现这些功能，我们可以使用上面提到的关联技术。</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/message.h&gt;</span></span><br><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-comment">//创建新的类</span><br>    Class Person = objc_allocateClassPair([<span class="hljs-built_in">NSObject</span> <span class="hljs-keyword">class</span>], <span class="hljs-string">&quot;Person&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">//增加成员变量</span><br>    <span class="hljs-type">BOOL</span> status = class_addIvar(Person, <span class="hljs-string">&quot;nick&quot;</span>,<br>    <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">NSString</span>*), log2(<span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">NSString</span>*)), <span class="hljs-keyword">@encode</span>(<span class="hljs-built_in">NSString</span>*));<br><br>    <span class="hljs-keyword">if</span> (status)<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++变量nick添加成功&quot;</span>); <span class="hljs-comment">// 成功</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++变量nick添加失败&quot;</span>);<br><br>    <span class="hljs-comment">//注册类</span><br>    objc_registerClassPair(Person);<br><br>    <span class="hljs-comment">//为类增加属性</span><br>    objc_property_attribute_t type  = &#123;<span class="hljs-string">&quot;T&quot;</span>,<span class="hljs-string">&quot;@\&quot;NSString\&quot;&quot;</span>&#125;;<br>    objc_property_attribute_t ownership1 = &#123;<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;&quot;</span>&#125;;      <span class="hljs-comment">// C = copy</span><br>    objc_property_attribute_t ownership2 = &#123; <span class="hljs-string">&quot;N&quot;</span>, <span class="hljs-string">&quot;&quot;</span> &#125;;   <span class="hljs-comment">// N = nonatomic</span><br>    objc_property_attribute_t backIvars  = &#123;<span class="hljs-string">&quot;V&quot;</span>,<span class="hljs-string">&quot;_name&quot;</span>&#125;; <span class="hljs-comment">//属性名</span><br>    objc_property_attribute_t atts[] = &#123;type,ownership1,ownership2,backIvars&#125;;<br><br>    status = class_addProperty(Person, <span class="hljs-string">&quot;name&quot;</span>, atts, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (status)<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++属性name添加成功&quot;</span>); <span class="hljs-comment">// 成功</span><br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++++属性name添加成功&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-literal">+++++</span><span class="hljs-comment">变量nick添加成功</span><br><span class="hljs-literal">+++++</span><span class="hljs-comment">属性name添加成功</span><br></code></pre></td></tr></table></figure><p>日志显示，<code>objc_registerClassPair</code>之后是可以动态添加<code>属性</code>的，但是如果你打印此时类的成员变量列表你会发现，并未创建属性对应的以下划线<code>_</code>开头的成员变量。这是因为我们平时所见到的<code>&quot;_属性名&quot;</code>成员变量是由编译器自动创建的，这里的代码是在运行时，并未经过编译器~</p><h4 id="2-3-✔️方法"><a href="#2-3-✔️方法" class="headerlink" title="2.3.✔️方法"></a>2.3.✔️方法</h4><p>结论：分类中可以增加新的方法，也可以覆盖原类的方法。</p><p>类的结构体中，<code>**methodLists</code>是一个指向<code>objc_method_list</code>指针的指针，也就是说<code>**methodLists</code>只是把装方法们的容器的地址保存在类的结构体里。类编译完成后，这个容器的地址不可变了，但是我们可以往这个容器里继续添加元素。因为增加方法不会影响类的内存空间。</p><p>分类中定义的方法也会被加入到原类<code>**methodLists</code>容器中，且分类的方法会在原类的方法之前。也正是因为这样，我们在分类中重写原类的方法时，原类的方法会失效，因为在查找方法的过程中分类的方法靠前而最先被找到，直接终止寻找过程并调用分类中的实现去了。</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 原类头文件</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSCoding</span>&gt;</span><br><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> age;<br><br>- (<span class="hljs-type">void</span>)callMe;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">// 原类m文件</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span><br><br>- (<span class="hljs-type">void</span>)callMe&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++My name is:%@&quot;</span>,<span class="hljs-keyword">self</span>.name);<br>&#125;<br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-comment">// 分类Person+C.m</span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span> (<span class="hljs-title">C</span>)</span><br><br><span class="hljs-comment">// 重写原类的方法并提供新的实现</span><br>- (<span class="hljs-type">void</span>)callMe&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++My name is not:%@&quot;</span>,<span class="hljs-keyword">self</span>.name);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成员变量、属性</title>
    <link href="/2017/08/25/runtime-ivar.html"/>
    <url>/2017/08/25/runtime-ivar.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://davidlii.nos-eastchina1.126.net/pic_runtime_ivars.png" alt="runtime成员变量&amp;属性"></p><h3 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1.成员变量"></a>1.成员变量</h3><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>在<code>objc/runtime.h</code>中，Ivar的描述如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// An opaque type that represents an instance variable.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_ivar</span> *Ivar;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_ivar</span> &#123;<br><span class="hljs-type">char</span> *ivar_name<br><span class="hljs-type">char</span> *ivar_type<br><span class="hljs-type">int</span> ivar_offset<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __LP64__</span><br><span class="hljs-type">int</span> space<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>Ivar，对象的成员变量，是一个指向<code>objc_ivar</code>结构体的指针，包括名字与类型。</p><h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><p>常用操作函数有：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取所有成员变量<br>class_copyIvarList<br><br><span class="hljs-regexp">//</span> 获取成员变量名<br>ivar_getName<br><br><span class="hljs-regexp">//</span> 获取成员变量类型编码<br>ivar_getTypeEncoding<br><br><span class="hljs-regexp">//</span> 获取指定名称的成员变量<br>class_getInstanceVariable<br><br><span class="hljs-regexp">//</span> 获取某个对象成员变量的值<br>object_getIvar<br><br><span class="hljs-regexp">//</span> 设置某个对象成员变量的值<br>object_setIvar<br></code></pre></td></tr></table></figure><h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h3><h4 id="属性的定义"><a href="#属性的定义" class="headerlink" title="属性的定义"></a>属性的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// An opaque type that represents an Objective-C declared property.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_property</span> *<span class="hljs-type">objc_property_t</span>;<br></code></pre></td></tr></table></figure><p>属性，一个指向<code>objc_property</code>结构体，通常以<code>@property</code>关键字来声明。</p><p><code>属性</code>与<code>成员变量</code>是两个独立的结构体，但两者被紧紧关联在了一起，只不过在不同版本的编译器中稍有不同。</p><ul><li><strong>iOS 5以前</strong></li></ul><p><code>iOS5</code>以前，使用属性通常需要三步：</p><ol><li>大括号声明成员变量；</li><li>@property 声明属性；</li><li>@synthesize 手动合成属性与成员变量；</li></ol><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">People</span>()</span><br>&#123;<br>    <span class="hljs-comment">//声明成员变量</span><br>    <span class="hljs-built_in">NSString</span> *_name;<span class="hljs-comment">//以下划线开头的成员变量</span><br>    <span class="hljs-built_in">NSString</span> *nick;<br>&#125;<br><span class="hljs-comment">//声明属性</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *aliasName;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">People</span></span><br><span class="hljs-comment">//合成属性 绑定成员变量到指定的属性上 并在 getter、setter中使用此成员变量赋值</span><br><span class="hljs-keyword">@synthesize</span> name = _name;<br><span class="hljs-keyword">@synthesize</span> aliasName = nick;<br><br>- (<span class="hljs-type">void</span>)test&#123;<br>    <span class="hljs-keyword">self</span>.name = <span class="hljs-string">@&quot;A&quot;</span>;<br>    <span class="hljs-keyword">self</span>.aliasName = <span class="hljs-string">@&quot;B&quot;</span>;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;++self.name=&#x27;%@&#x27;,++self.aliasName=&#x27;%@&#x27;,++_name=&#x27;%@&#x27;,++nick=&#x27;%@&#x27;&quot;</span>,<span class="hljs-keyword">self</span>.name,<span class="hljs-keyword">self</span>.aliasName,_name,nick);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>1.示例中<code>&#123; &#125;</code>里声明成员变量时可以使用下划线<code>_</code>开头，也可以不带下划线；</p><p>2.<code>@property</code>的作用是自动生成属性的 setter\getter 方法的<code>声明</code>，即</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">-</span>(void)setName:(NSString*)aName;<br><span class="hljs-built_in">-</span>(NSString*)name;<br></code></pre></td></tr></table></figure><p>3.<code>@synthesize</code>的作用是指定一个<code>成员变量</code>，将其绑定到属性上。然后实现属性的 getter\setter 并在其中使用此成员变量存取值；</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sqf">- (NSString *)<span class="hljs-built_in">name</span>&#123;<br>    return <span class="hljs-variable">_name</span>;<br>&#125;<br><br>- (void)<span class="hljs-built_in">setName</span>:(NSString *)aName&#123;<br>    <span class="hljs-keyword">if</span> (aName &amp;&amp; <span class="hljs-variable">_name</span> &amp;&amp; ![aName isEqualToString:<span class="hljs-variable">_name</span>]) &#123;<br>        return;<br>    &#125;<br>    <span class="hljs-variable">_name</span> = aName;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>iOS 5以后</strong></li></ul><p>在<code>iOS5以后</code>，苹果将编译器从 GCC 转为 LLVM，以 @property 声明的属性<code>name</code>，编译器会默认为其生成一个以<code>下划线开头的成员变量</code>，同时实现 setter&#x2F;getter 方法并在其中使用<code>&quot;_name&quot;</code>存取值，所以编译器帮我们省去了部分操作。 在.m文件中，我们可以直接使用<code>_name</code>，也可以使用<code>self.name</code>。其中，后者实际上是调用了属性<code>name</code>的 getter\setter 函数。</p><p><strong>ps：</strong>iOS5之后，<code>@synthesize</code>仍可以继续使用。如果<code>@synthesize</code>后为属性指定的这个成员变量并不存在，那么编译器会自动帮我们创建一个新的同类型的成员变量。例如<code>@synthesize aliasName = NotExistIvar;</code>，我们的<code>&#123; &#125;</code>中并未声明此成员变量<code>NotExistIvar</code>，编译器会自动帮我们创建~</p><h4 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h4><p>属性的常用操作函数：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取所有属性<br>class_copyPropertyList<br><br><span class="hljs-regexp">//</span> 获取属性名<br>property_getName<br><br><span class="hljs-regexp">//</span> 获取属性特性描述字符串<br>property_getAttributes<br><br><span class="hljs-regexp">//</span> 获取所有属性特性<br>property_copyAttributeList<br></code></pre></td></tr></table></figure><p>其中，<code>property_getAttributes</code>返回的是一个<code>objc_property_attribute_t</code>结构体列表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// Defines a property attribute</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;           <span class="hljs-comment">/**&lt; The name of the attribute */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *value;          <span class="hljs-comment">/**&lt; The value of the attribute (usually empty) */</span><br>&#125; <span class="hljs-type">objc_property_attribute_t</span>;<br></code></pre></td></tr></table></figure><p>常用的值如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">属性类型  name值：T  value：<span class="hljs-built_in">NSString</span>等<br>编码类型  name值：C(<span class="hljs-keyword">copy</span>)、&amp;(<span class="hljs-keyword">strong</span>\<span class="hljs-keyword">retain</span>)、W(<span class="hljs-keyword">weak</span>)、R(<span class="hljs-keyword">readonly</span>)、空(<span class="hljs-keyword">assign</span>) 等 value：无<br>非/原子性 name值：空(atomic) N(Nonatomic)  value：无<br>属性名称  name值：V  value：自定义的名字<br></code></pre></td></tr></table></figure><h3 id="3-查询示例"><a href="#3-查询示例" class="headerlink" title="3.查询示例"></a>3.查询示例</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//IvarTool.h</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">IvarTool</span> : <span class="hljs-title">NSObject</span></span><br>&#123;<br>    <span class="hljs-type">double</span> ivar_defaultDouble;<span class="hljs-comment">//默认作用域</span><br><span class="hljs-keyword">@package</span><br>    <span class="hljs-type">int</span> ivar_packInt;<br><span class="hljs-keyword">@public</span><br>    <span class="hljs-type">float</span>  ivar_publicFloat;<br><span class="hljs-keyword">@protected</span><br>    <span class="hljs-built_in">NSString</span> *ivar_protectedStr;<br><span class="hljs-keyword">@private</span><br>    <span class="hljs-built_in">NSDictionary</span> *ivar_privateDic;<br>&#125;<br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)  <span class="hljs-built_in">NSString</span> *property_string;<br><span class="hljs-comment">//成员变量列表</span><br>+ (<span class="hljs-type">void</span>)ivarList;<br><span class="hljs-comment">//属性列表</span><br>+ (<span class="hljs-type">void</span>)propertyList;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//IvarTool.m</span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;IvarTool.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">IvarTool</span>()</span><br>&#123;<br>    <span class="hljs-type">int</span> ivar_int;<br><span class="hljs-keyword">@public</span><br>    <span class="hljs-built_in">NSArray</span> *ivar_array;<br>&#125;<br><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSDictionary</span> *property_dic;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">IvarTool</span></span><br><br>+ (<span class="hljs-type">void</span>)ivarList<br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    Ivar *ivars = class_copyIvarList([IvarTool <span class="hljs-keyword">class</span>], &amp;count);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;count; i++)<br>    &#123;<br>        Ivar ivar = ivars[i];<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charName = ivar_getName(ivar);<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charType = ivar_getTypeEncoding(ivar);<br>        <br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Name:%s,Type:%s&quot;</span>,charName,charType);<br>    &#125;<br>    <br>    free(ivars);<br>&#125;<br><br><br>+ (<span class="hljs-type">void</span>)propertyList<br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    objc_property_t *properties = class_copyPropertyList([IvarTool <span class="hljs-keyword">class</span>], &amp;count);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;count; i++)<br>    &#123;<br>        objc_property_t aProperty = properties[i];<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charName = property_getName(aProperty);<br>        <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charType = property_getAttributes(aProperty);<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Name:%s,Type:%s&quot;</span>,charName,charType);<br>    &#125;<br>    <br>    free(properties);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用<code>[IvarTool ivarList]</code>，查看成员变量，输出日志如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Name</span>:ivar_defaultDouble,<span class="hljs-keyword">Type</span>:d<br><span class="hljs-type">Name</span>:ivar_packInt,<span class="hljs-keyword">Type</span>:i<br><span class="hljs-type">Name</span>:ivar_publicFloat,<span class="hljs-keyword">Type</span>:f<br><span class="hljs-type">Name</span>:ivar_protectedStr,<span class="hljs-keyword">Type</span>:@&quot;NSString&quot;<br><span class="hljs-type">Name</span>:ivar_privateDic,<span class="hljs-keyword">Type</span>:@&quot;NSDictionary&quot;<br><span class="hljs-type">Name</span>:ivar_int,<span class="hljs-keyword">Type</span>:i<br><span class="hljs-type">Name</span>:ivar_array,<span class="hljs-keyword">Type</span>:@&quot;NSArray&quot;<br><span class="hljs-type">Name</span>:_property_string,<span class="hljs-keyword">Type</span>:@&quot;NSString&quot;<br><span class="hljs-type">Name</span>:_property_dic,<span class="hljs-keyword">Type</span>:@&quot;NSDictionary&quot;<br></code></pre></td></tr></table></figure><p>调用<code>[IvarTool propertyList]</code>，查看属性列表，输出日志如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">Na</span><span class="hljs-symbol">me:pr</span>operty_dic,Ty<span class="hljs-symbol">pe:T</span>@<span class="hljs-string">&quot;NSDictionary&quot;</span>,&amp;,<span class="hljs-built_in">N</span>,V_property_dic<br><span class="hljs-built_in">Na</span><span class="hljs-symbol">me:pr</span>operty_string,Ty<span class="hljs-symbol">pe:T</span>@<span class="hljs-string">&quot;NSString&quot;</span>,C,<span class="hljs-built_in">N</span>,V_property_string<br></code></pre></td></tr></table></figure><p><strong>小结</strong>：</p><ul><li>编译器会自动为属性生成对应的以下划线开头的成员变量；</li><li>无论成员变量的访问权限如何，是在.h 还是 .m 中声明的，class_copyIvarList 都能获取的到；</li><li>无论属性定义在 .h 还是 .m 中，class_copyPropertyList 能获取全部属性；</li><li>class_copyIvarList 与 class_copyPropertyList 都只能获取到当前类中定义的成员变量或属性，获取不到其父类的中定义的；</li></ul><h3 id="4-访问权限"><a href="#4-访问权限" class="headerlink" title="4.访问权限"></a>4.访问权限</h3><p>关于成员变量的访问权限，<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-SW1">Apple官方</a>描述如下：</p><p>@public: 导入头文件的地方，都能直接访问（<code>.m</code>文件中声明的成员变量除外）；</p><p>@protected: 本类及其子类实例方法中可见；</p><p>@private: 只对本类可见，对其子类不可见；</p><p>@package: 比较特殊，访问范围介于<code>public</code>和<code>private</code>之间，只要处于同一个镜像或可执行文件中时相当于<code>public</code>，在实现其的镜像或可执行文件之外时相当于<code>private</code>，下面是Apple原文中的描述；</p><blockquote><p>Using the modern runtime, an @package instance variable has @public scope inside the executable image that implements the class, but acts like @private outside.<br>The @package scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.<br>This scope is most useful for instance variables in framework classes, where @private may be too restrictive but @protected or @public too permissive.</p></blockquote><p><strong>默认值：</strong></p><p><code>.h</code>中默认为 @protected；</p><p><code>.m</code>中默认为 @private；</p><p>#示例：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">- (BOOL)application:(UIApplication *)application<br>didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>&#123;<br>    IvarTool *tool = [[IvarTool alloc] init];<br>   <br>    <span class="hljs-comment">//下面几个会报错 </span><br>    <span class="hljs-function"><span class="hljs-title">tool</span> -&gt;</span> ivar_defaultDouble;<br>    <span class="hljs-function"><span class="hljs-title">tool</span> -&gt;</span> ivar_protectedStr;<br>    <span class="hljs-function"><span class="hljs-title">tool</span> -&gt;</span> ivar_privateDic;<br>    <span class="hljs-function"><span class="hljs-title">tool</span> -&gt;</span> ivar_int;<br>    <span class="hljs-function"><span class="hljs-title">tool</span> -&gt;</span> ivar_array;<br>    tool.property_dic;<br>    <br>    <span class="hljs-comment">//下面的调用能正常使用</span><br>    <span class="hljs-function"><span class="hljs-title">tool</span> -&gt;</span> ivar_packInt;<br>    <span class="hljs-function"><span class="hljs-title">tool</span> -&gt;</span> ivar_publicFloat;<br>    tool.property_string;<br>    <br>    return YES;<br>&#125;<br></code></pre></td></tr></table></figure><p>若想实现成员变量支持外部访问，需要在头文件的声明中给该成员变量添加<code>@public</code>修饰符，同时在外部访问时使用<code>-&gt;</code>。m文件内即使成员变量添加<code>@public</code>修饰符，外部访问时仍会报错，因为它只对m文件内可见。</p><h3 id="5-快速序列化"><a href="#5-快速序列化" class="headerlink" title="5.快速序列化"></a>5.快速序列化</h3><p>原理：利用<code>runtime</code>提供的函数，遍历<code>model</code>的属性，并对属性进行<code>decode</code>与<code>encode</code>。</p><p>#示例：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs llvm">//ModelSerialiseHelper.h<br><br>#ifndef ModelSerialiseHelper_h<br>#<span class="hljs-keyword">define</span> ModelSerialiseHelper_h<br><br>#import &lt;objc/runtime.h&gt;<br>/*<br> 序列化工具使用示例:<br> <br> <span class="hljs-number">1</span>、TLObject头文件中声明NSCoding协议<br> <br> <span class="hljs-title">@interface</span> TLObject : NSObject&lt;NSCoding&gt;<br> <span class="hljs-title">@property</span> (nonatomic<span class="hljs-punctuation">,</span> copy) NSString *mName<span class="hljs-comment">;</span><br> <span class="hljs-title">@property</span> (nonatomic) BOOL mIsTrue<span class="hljs-comment">;</span><br> <span class="hljs-title">@property</span> (nonatomic) NSInteger mInteger<span class="hljs-comment">;</span><br> <span class="hljs-title">@property</span> (nonatomic) UIImage *mImage<span class="hljs-comment">;</span><br> <span class="hljs-title">@end</span><br> <br> <span class="hljs-number">2</span>、m文件中导入头文件和宏即可<br> <br> #import <span class="hljs-string">&quot;TLObject.h&quot;</span><br> #import <span class="hljs-string">&quot;ModelSerialiseHelper.h&quot;</span><br> <span class="hljs-title">@implementation</span> TLObject<br> <br> ModelCodingProtocol()<br> <br> <span class="hljs-title">@end</span><br> */<br><br><br>#<span class="hljs-keyword">define</span> ModelCodingProtocol()\<br>- (id)initWithCoder:(NSCoder *)coder\<br>&#123;\<br>    Class cls <span class="hljs-operator">=</span> [self class]<span class="hljs-comment">;\</span><br>    while (cls !<span class="hljs-operator">=</span> [NSObject class])\<br>    &#123;\<br>        unsigned int count <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>        Ivar *ivarList <span class="hljs-operator">=</span> class_copyIvarList([cls class]<span class="hljs-punctuation">,</span> &amp;count)<span class="hljs-comment">;\</span><br>        for (int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++)\</span><br>        &#123;\<br>            const char *varName <span class="hljs-operator">=</span> ivar_getName(*(ivarList + i))<span class="hljs-comment">;\</span><br>            NSString *key <span class="hljs-operator">=</span> [NSString stringWithUTF<span class="hljs-number">8</span>String:varName]<span class="hljs-comment">;\</span><br>            NSString *aStr <span class="hljs-operator">=</span> [key substringToIndex:<span class="hljs-number">1</span>]<span class="hljs-comment">;\</span><br>            if ([aStr isEqualToString:@<span class="hljs-string">&quot;_&quot;</span>]) &#123;\<br>                key <span class="hljs-operator">=</span> [key substringFromIndex:<span class="hljs-number">1</span>]<span class="hljs-comment">;\</span><br>            &#125;\<br>            id varValue <span class="hljs-operator">=</span> [coder decodeObjectForKey:key]<span class="hljs-comment">;\</span><br>            if (varValue) &#123;\<br>                [self setValue:varValue forKey:key]<span class="hljs-comment">;\</span><br>            &#125;\<br>        &#125;\<br>        <span class="hljs-keyword">free</span>(ivarList)<span class="hljs-comment">;\</span><br>        cls <span class="hljs-operator">=</span> class_getSuperclass(cls)<span class="hljs-comment">;\</span><br>    &#125;\<br>    return self<span class="hljs-comment">;\</span><br>&#125;\<br>- (void)encodeWithCoder:(NSCoder *)coder\<br>&#123;\<br>    Class cls <span class="hljs-operator">=</span> [self class]<span class="hljs-comment">;\</span><br>    while (cls !<span class="hljs-operator">=</span> [NSObject class])\<br>    &#123;\<br>        unsigned int count <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>        Ivar *ivarList <span class="hljs-operator">=</span> class_copyIvarList([cls class]<span class="hljs-punctuation">,</span> &amp;count)<span class="hljs-comment">;\</span><br>        for (int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++)\</span><br>        &#123;\<br>            const char *varName <span class="hljs-operator">=</span> ivar_getName(*(ivarList + i))<span class="hljs-comment">;\</span><br>            NSString *key <span class="hljs-operator">=</span> [NSString stringWithUTF<span class="hljs-number">8</span>String:varName]<span class="hljs-comment">;\</span><br>            NSString *aStr <span class="hljs-operator">=</span> [key substringToIndex:<span class="hljs-number">1</span>]<span class="hljs-comment">;\</span><br>            if ([aStr isEqualToString:@<span class="hljs-string">&quot;_&quot;</span>]) &#123;\<br>                key <span class="hljs-operator">=</span> [key substringFromIndex:<span class="hljs-number">1</span>]<span class="hljs-comment">;\</span><br>            &#125;\<br>            id varValue <span class="hljs-operator">=</span> [self valueForKey:key]<span class="hljs-comment">;\</span><br>            if (varValue) &#123;\<br>                [coder encodeObject:varValue forKey:key]<span class="hljs-comment">;\</span><br>            &#125;\<br>        &#125;\<br>        <span class="hljs-keyword">free</span>(ivarList)<span class="hljs-comment">;\</span><br>        cls <span class="hljs-operator">=</span> class_getSuperclass(cls)<span class="hljs-comment">;\</span><br>    &#125;\<br>&#125;\<br><br>#<span class="hljs-keyword">define</span> ModelCopyProtocol()\<br>- (id)copyWithZone:(NSZone *)zone\<br>&#123;\<br>    id copy <span class="hljs-operator">=</span> [[[self class] allocWithZone:zone] init]<span class="hljs-comment">;\</span><br>    Class cls <span class="hljs-operator">=</span> [self class]<span class="hljs-comment">;\</span><br>    while (cls !<span class="hljs-operator">=</span> [NSObject class])\<br>    &#123;\<br>        unsigned int count <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;\</span><br>        Ivar *ivarList <span class="hljs-operator">=</span> class_copyIvarList([cls class]<span class="hljs-punctuation">,</span> &amp;count)<span class="hljs-comment">;\</span><br>        for (int i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++)\</span><br>        &#123;\<br>            const char *varName <span class="hljs-operator">=</span> ivar_getName(*(ivarList + i))<span class="hljs-comment">;\</span><br>            NSString *key <span class="hljs-operator">=</span> [NSString stringWithUTF<span class="hljs-number">8</span>String:varName]<span class="hljs-comment">;\</span><br>            NSString *aStr <span class="hljs-operator">=</span> [key substringToIndex:<span class="hljs-number">1</span>]<span class="hljs-comment">;\</span><br>            if ([aStr isEqualToString:@<span class="hljs-string">&quot;_&quot;</span>]) &#123;\<br>                key <span class="hljs-operator">=</span> [key substringFromIndex:<span class="hljs-number">1</span>]<span class="hljs-comment">;\</span><br>            &#125;\<br>            id varValue <span class="hljs-operator">=</span> [self valueForKey:key]<span class="hljs-comment">;\</span><br>            if (varValue) &#123;\<br>                [copy setValue:varValue forKey:key]<span class="hljs-comment">;\</span><br>            &#125;\<br>        &#125;\<br>        <span class="hljs-keyword">free</span>(ivarList)<span class="hljs-comment">;\</span><br>        cls <span class="hljs-operator">=</span> class_getSuperclass(cls)<span class="hljs-comment">;\</span><br>    &#125;\<br>    return copy<span class="hljs-comment">;\</span><br>&#125;\<br><br>#endif /* ModelSerialiseHelper_h */<br></code></pre></td></tr></table></figure><p>上述代码为<code>ModelSerialiseHelper.h</code>，其中：</p><ul><li>ModelCopyProtocol()    封装了copy协议的相关实现代码；</li><li>ModelCodingProtocol()  封装了encode和decode的相关代码；</li></ul><p>在需要实现这两个协议的<code>model</code>中，导入<code>ModelSerialiseHelper.h</code>并引用上述两个宏定义即可。</p><h3 id="6-json字典转Model"><a href="#6-json字典转Model" class="headerlink" title="6.json字典转Model"></a>6.json字典转Model</h3><p>原理：获取模型的<code>属性列表</code>，通过<code>kvc</code>从字典中取值并赋值给对应的属性字段。</p><p>#示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&quot;NSObject+JsonToModel.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">NSObject</span> (<span class="hljs-title">JsonToModel</span>)</span><br><br>- (<span class="hljs-keyword">instancetype</span>)initModelWithDictionary:(<span class="hljs-built_in">NSDictionary</span> *)jsonDic<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">self</span> init])<br>    &#123;<br>        <span class="hljs-built_in">NSMutableArray</span> * keysArr;<br>        <span class="hljs-keyword">if</span> (!jsonDic) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>        &#125;<br>        <br>        keysArr = [<span class="hljs-built_in">NSMutableArray</span> array];<br>        <br>        <span class="hljs-comment">//获取类的属性及属性对应的类型</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;<br>        objc_property_t * properties = class_copyPropertyList([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], &amp;count);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>        &#123;<br>            objc_property_t property = properties[i];<br>            <span class="hljs-comment">//获取属性名</span><br>            <span class="hljs-keyword">const</span> <span class="hljs-type">char</span> *charName = property_getName(property);<br>            <span class="hljs-built_in">NSString</span> *propertyName = [<span class="hljs-built_in">NSString</span> stringWithCString:charName encoding:<span class="hljs-built_in">NSUTF8StringEncoding</span>];<br>            <br>            <span class="hljs-keyword">if</span> (propertyName.length) &#123;<br>                [keysArr addObject:propertyName];<br>            &#125;<br>        &#125;<br>        free(properties);<br>        <br>        <span class="hljs-comment">//给属性赋值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSString</span> * key <span class="hljs-keyword">in</span> keysArr) &#123;<br>            [<span class="hljs-keyword">self</span> setValue:jsonDic[key] forKey:key];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">NSDictionary <span class="hljs-symbol">*</span>dic = <span class="hljs-meta">@&#123;</span><span class="hljs-meta">@&quot;name&quot;:</span><span class="hljs-meta">@&quot;xxx&quot;,</span><span class="hljs-meta">@&quot;sex&quot;:</span><span class="hljs-meta">@(1),</span><span class="hljs-meta">@&quot;age&quot;:</span><span class="hljs-meta">@(20)&#125;;</span><br>PersonModel <span class="hljs-symbol">*</span>person = [[PersonModel alloc] initModelWithDictionary:dic];<br></code></pre></td></tr></table></figure><p>这里的示例只是一个简单的场景，实际应用中可能会有更复杂的需求，视情况做响应修改即可。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocDefiningClasses.html#//apple_ref/doc/uid/TP30001163-CH12-SW1">©Apple</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息机制</title>
    <link href="/2017/08/23/runtime-message.html"/>
    <url>/2017/08/23/runtime-message.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-id"><a href="#1-id" class="headerlink" title="1.id"></a>1.id</h3><p>在<code>objc/objc.h</code>中，id的定义如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">/// Represents an<span class="hljs-built_in"> instance </span>of a class.<br>struct objc_object &#123;<br>Class isa  OBJC_ISA_AVAI<span class="hljs-class">LABILITY;</span><br>&#125;;<br><br>/// A pointer to an<span class="hljs-built_in"> instance </span>of a class.<br>typedef struct objc_object *id;<br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure><p><code>id</code>是一个结构体指针类型，它指向OC中的任何对象。</p><h3 id="2-类（class）"><a href="#2-类（class）" class="headerlink" title="2.类（class）"></a>2.类（class）</h3><p>在<code>objc/runtime.h</code>中，类的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_class</span> &#123;<br>Class isa  OBJC_ISA_AVAILABILITY;       <span class="hljs-comment">//指针</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !__OBJC2__</span><br>Class super_class                       <span class="hljs-comment">//父类;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name                        <span class="hljs-comment">//类名;</span><br><span class="hljs-type">long</span> version                            <span class="hljs-comment">//类的版本信息，默认为0;</span><br><span class="hljs-type">long</span> info                               <span class="hljs-comment">//位标识;</span><br><span class="hljs-type">long</span> instance_size                      <span class="hljs-comment">//类的实例变量大小;</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_ivar_list</span> *ivars            <span class="hljs-comment">//类的成员变量链表;</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_method_list</span> **methodLists   <span class="hljs-comment">//方法定义的链表;</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_cache</span> *cache                <span class="hljs-comment">//方法缓存;</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_protocol_list</span> *protocols    <span class="hljs-comment">//协议链表;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125; OBJC2_UNAVAILABLE;<br></code></pre></td></tr></table></figure><h3 id="3-Method"><a href="#3-Method" class="headerlink" title="3.Method"></a>3.Method</h3><p><code>Method</code>即方法，<code>class</code>结构体的<code>objc_method_list</code>链表中，保存的正是<code>objc_method</code> 对象:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">struct objc_method &#123;<br>    SEL _Nonnull method_name        <span class="hljs-regexp">//</span>方法名称<br>    char * _Nullable method_types   <span class="hljs-regexp">//</span>方法的参数类型和返回值类型<br>    IMP _Nonnull method_imp         <span class="hljs-regexp">//</span>指向该方法的具体实现的函数指针<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSString</span> *)methodNameWithParam1:(<span class="hljs-type">int</span>)intValue param2:(<span class="hljs-type">BOOL</span>)boolvalue<br>&#123;<br>    <span class="hljs-built_in">NSString</span> *result = [<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@&quot;param1:%d, param2:%d&quot;</span>,intValue,boolvalue];<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++result:%@&quot;</span>,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合示例来看三个字段的含义：</p><p>#<strong>SEL:</strong></p><p>表示方法名，运行时中用来代替明文方法名；</p><p>#<strong>method_types:</strong></p><p>表示方法的参数类型和返回值类型，具体到本示例为“@@:iB”：</p><ul><li>第一个<code>@</code>表示方法的返回值为id类型；</li><li>第二个<code>@</code>表示方法的调用者；</li><li><code>:</code>表示方法选择器SEL；</li><li><code>i</code>表示参数1为int类型；</li><li><code>B</code>表示参数2为bool类型；</li></ul><p>详细编码格式可参考官网<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">#Type Encodings</a></p><p>#<strong>IMP:</strong></p><p>表示指向该方法的具体实现的函数指针。</p><h3 id="4-Selectors"><a href="#4-Selectors" class="headerlink" title="4.Selectors"></a>4.Selectors</h3><blockquote><p>In Objective-C, selector has two meanings. It can be used to refer simply to the name of a method when it’s used in a source-code message to an object. It also, though, refers to the unique identifier that replaces the name when the source code is compiled. Compiled selectors are of type SEL. All methods with the same name have the same selector. You can use a selector to invoke a method on an object—this provides the basis for the implementation of the target-action design pattern in Cocoa.</p></blockquote><p><code>selector</code>，方法选择器，分两种情况：</p><ul><li>编译之前，表示一个对象所调用方法的方法名；</li><li>编译之后，表示用来替换方法名的唯一标识符（SEL）；</li></ul><p>相同命名的方法有着相同的selector。</p><h3 id="5-SEL"><a href="#5-SEL" class="headerlink" title="5.SEL"></a>5.SEL</h3><p>在<code>objc/objc.h</code>中，SEL的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// An opaque type that represents a method selector.</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">objc_selector</span> *SEL;<br></code></pre></td></tr></table></figure><blockquote><p>Compiled selectors are assigned to a special type, SEL.</p></blockquote><p><code>SEL</code>是方法名经过编译后，在运行时中的表示形式。<strong>需要注意的是：</strong></p><p>1、一个类中不能同时存在名称和参数个数都相同的两个方法，即使其参数类型和返回值类型不同。</p><p>这是因为参数类型和返回值类型信息都保存在<code>Method</code>结构体的<code>*method_types</code>字段中，如上面提到的“@@:iB”；而SEL是<code>Method</code>的<code>method_name</code>字段，无关参数和返回值的类型。运行时只认SEL，名称相同且参数个数相同的两个方法对应同一个<code>SEL</code>，一旦相同运行时就不知该选哪个。为防止这种情况，Xcode在编译时会报错；</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">void</span>)methodName&#123; <span class="hljs-comment">//实例方法</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)sameName&#123; <span class="hljs-comment">//原方法</span><br>&#125;<br><br>- (<span class="hljs-type">void</span>)sameName:(<span class="hljs-type">int</span>)p1&#123; <span class="hljs-comment">//正常（方法、返回值类型名相同，参数个数不同）</span><br>&#125;<br><br>- (<span class="hljs-type">int</span>)sameName:(<span class="hljs-type">int</span>)p1&#123; <span class="hljs-comment">//报错（方法名、参数类型和个数相同，返回值不同）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>- (<span class="hljs-type">int</span>)sameName:(<span class="hljs-type">int</span>)p1 param2:(<span class="hljs-type">int</span>)p2&#123;<br>&#125;<br><br>- (<span class="hljs-type">int</span>)sameName:(<span class="hljs-type">int</span>)p1 param2:(<span class="hljs-built_in">NSString</span>*)p3&#123; <span class="hljs-comment">// 报错（方法名、返回值类型、参数个数相同，只是参数类型不同）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2、同一个类中，允许存在一对方法名相同的实例方法与类方法。</p><p>虽然二者的SEL相同，但实例方法保存在<code>类对象</code>中，类方法保存在<code>元类对象</code>中，运行时能分清；</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AppDelegate</span> : <span class="hljs-title">UIResponder</span> &lt;<span class="hljs-title">UIApplicationDelegate</span>&gt;</span><br><br><span class="hljs-comment">// 类方法和实例方法名相同</span><br>+ (<span class="hljs-type">void</span>)methodName;<br>- (<span class="hljs-type">void</span>)methodName;<br><br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AppDelegate</span></span><br><br><span class="hljs-comment">//MARK: 允许类方法和实例方法同名</span><br>- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    SEL aSEL = <span class="hljs-keyword">@selector</span>(methodName);<br><br>    <span class="hljs-comment">// 调用相同的SEL</span><br>    [AppDelegate performSelector:aSEL withObject:<span class="hljs-literal">nil</span>]; <span class="hljs-comment">// 调用类方法</span><br>    [<span class="hljs-keyword">self</span> performSelector:aSEL withObject:<span class="hljs-literal">nil</span>]; <span class="hljs-comment">// 调用实例方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)methodName&#123; <span class="hljs-comment">//类方法</span><br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>3、不同的类中，可以存在两个名称相同的方法，这对多态机制和动态绑定至关重要；</p><h3 id="6-映射关系"><a href="#6-映射关系" class="headerlink" title="6.映射关系"></a>6.映射关系</h3><blockquote><p>For efficiency, full ASCII names are not used as method selectors in compiled code. Instead, the compiler writes each method name into a table, then pairs the name with a unique identifier that represents the method at runtime. The runtime system makes sure each identifier is unique: No two selectors are the same, and all methods with the same name have the same selector.</p></blockquote><ul><li>在编译阶段，编译器会将所有方法名写入一张表中；</li><li>在程序运行阶段，运行时使用SEL代表一个方法（method）；</li><li>runtime 会将方法名与SEL进行映射；</li><li>调用方法时，运行时系统根据SEL从相关类的方法列表(methodLists)中查找对应的方法；</li><li>找到了方法即可调用其结构体中的IMP；</li></ul><h3 id="7-IMP"><a href="#7-IMP" class="headerlink" title="7.IMP"></a>7.IMP</h3><p>在<code>objc/objc.h</code>中，IMP的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// A pointer to the function of a method implementation. </span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*IMP)</span><span class="hljs-params">(<span class="hljs-type">void</span> <span class="hljs-comment">/* id, SEL, ... */</span> )</span></span>; <br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">id</span> <span class="hljs-params">(*IMP)</span><span class="hljs-params">(id, SEL, ...)</span></span>; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><code>IMP</code>是一个函数指针，这个被指向的函数包含一个接收消息的对象<code>id</code>, 调用方法的选择器<code>SEL</code>，以及不定个数的方法参数，并返回一个<code>id</code>。<code>IMP</code>是消息最终调用的执行代码，是方法真正的实现。</p><h3 id="8-消息"><a href="#8-消息" class="headerlink" title="8.消息"></a>8.消息</h3><p>在C语言中，函数的调用在编译时就已经决定了。而OC是一种动态语言。对于OC的函数，在编译时并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。所以，你会发现：在编译阶段，只要声明过，OC可以调用任何函数且不会报错，即使这个函数并未实现。相反在C语言中，编译阶段调用未实现的函数则会报错。</p><blockquote><p>OC中，方法调用的本质，就是向对象发送一条消息。</p></blockquote><p>打开<code>objc/message.h</code>文件，可见如下定义：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">OBJC_EXPORT void objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">void</span> <span class="hljs-operator">/</span><span class="hljs-operator">*</span> <span class="hljs-params">id</span> <span class="hljs-params">self</span>, SEL <span class="hljs-params">op</span>, <span class="hljs-operator">...</span> <span class="hljs-operator">*</span><span class="hljs-operator">/</span> )</span><br></code></pre></td></tr></table></figure><h3 id="9-方法调用的过程"><a href="#9-方法调用的过程" class="headerlink" title="9.方法调用的过程"></a>9.方法调用的过程</h3><p>1、调用方法时runtime把方法的调用转化为<code>消息发送</code>，即<code>objc_msgSend(id self, SEL selector, [参数]...)</code>；</p><p>2、其中<code>SEL</code>是运行时根据方法名转化而来的，<code>SEL</code>与调用者一起作为参数传递给<code>objc_msgSend()</code>，后续就是根据<code>SEL</code>来查找方法及其<code>IMP</code>；</p><p>2、方法的调用者会通过<code>isa</code>指针找到其所属的类。在类中有一块最近调用的方法的指针缓存（即cache，参见上面类的定义），出于性能考虑 runtime 会先去<code>cache</code>中根据SEL查找对应的方法;</p><p>3、若<code>cache</code>中没有找到，则去<code>methodLists</code>中查找该方法。找到后通过函数指针跳转到方法结构体中，执行结构体中的<code>IMP</code>，之后将该方法加入到<code>cache</code>中；</p><p>4、若未找到该方法，则通过<code>super_class</code>往上一级父类查找，重复第2、3步；</p><p>5、如果一直到 NSObject 根类都没有找到该方法，在不做特殊处理的情况下（如动态方法决议或消息转发），会报运行时错误：unrecognized selector sent to instance xxx；</p><h3 id="10-动态方法决议"><a href="#10-动态方法决议" class="headerlink" title="10.动态方法决议"></a>10.动态方法决议</h3><p>为防止上述第5种情况下发生的crash，OC提供了动态方法决议，在运行时动态地为一个 <code>selector</code> 提供实现。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">+ (BOOL)resolveClassMethod:(SEL)name;    <span class="hljs-regexp">//</span>类方法<br>+ (BOOL)resolveInstanceMethod:(SEL)name; <span class="hljs-regexp">//</span>实例方法<br></code></pre></td></tr></table></figure><ul><li>name参数，表示需要被动态决议的selector；</li><li>Bool返回值，表示动态决议是否成功；</li></ul><p>这是NSObject类中的两个类方法，执行动态方法决议时，需重写这两个方法，并在其中为指定的selector提供具体的实现（通过调用运行时函数class_addMethod来添加，下面有示例）。</p><p>在不涉及消息转发的情况下：</p><ul><li>若上述两函数内为指定的selector提供实现，无论返回YES或NO，编译运行都会正常；</li><li>若上述两函数内并没有为selector提供实现，无论返回YES或NO，编译运行都会crash；</li></ul><p>#示例1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//DynamicTool头文件如下：</span><br><br>#<span class="hljs-keyword">import</span> &lt;Foundation/Foundation.h&gt;<br><br>@<span class="hljs-keyword">interface</span> <span class="hljs-symbol">DynamicTool</span> : <span class="hljs-symbol">NSObject</span><br><br>@<span class="hljs-symbol">end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//DynamicTool实现文件如下：</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DynamicTool.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><br><span class="hljs-type">void</span> instanceMethod(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>,SEL sel)<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;instance method&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> classMethod(<span class="hljs-type">id</span> <span class="hljs-keyword">self</span>,SEL sel,<span class="hljs-built_in">NSString</span>* str1,<span class="hljs-built_in">NSString</span>* str2)<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;class method param1:%@,param2:%@&quot;</span>,str1,str2);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DynamicTool</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -动态决议</span><br><span class="hljs-comment">//实例方法</span><br>+ (<span class="hljs-type">BOOL</span>)resolveInstanceMethod:(SEL)sel<br>&#123;<br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(instanceMethodSelector)) &#123;<br>        class_addMethod([<span class="hljs-keyword">self</span> <span class="hljs-keyword">class</span>], sel, (IMP)instanceMethod, <span class="hljs-string">&quot;v@:&quot;</span>);<br>        <span class="hljs-comment">/*每个方法都有 self 和_cmd 两个默认的隐藏参数，</span><br><span class="hljs-comment">        self 即接收消息的对象本身，_cmd 即是 selector 选择器；</span><br><span class="hljs-comment">        v表示void返回值；@表示一个对象，这里指self；&quot;:&quot;表示SEL，即_cmd。</span><br><span class="hljs-comment">        其他符号的意义可参考文章底部链接</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><span class="hljs-comment">//类方法</span><br>+(<span class="hljs-type">BOOL</span>)resolveClassMethod:(SEL)sel<br>&#123;<br>    <span class="hljs-keyword">if</span> (sel == <span class="hljs-keyword">@selector</span>(classMethodSelector)) &#123;<br>        class_addMethod(objc_getMetaClass(<span class="hljs-string">&quot;DynamicTool&quot;</span>), sel,<br>        (IMP)classMethod, <span class="hljs-string">&quot;s#:@@&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">DynamicTool *insObj = [DynamicTool <span class="hljs-keyword">new</span>];<br><span class="hljs-type">Class</span> <span class="hljs-variable">classObj</span> <span class="hljs-operator">=</span> NSClassFromString(@<span class="hljs-string">&quot;DynamicTool&quot;</span>);<br><br>[insObj performSelector:<span class="hljs-meta">@selector(instanceMethodSelector)</span>];<br><br>[classObj performSelector:<span class="hljs-meta">@selector(classMethodSelector)</span> <br>withObject:@<span class="hljs-string">&quot;A&quot;</span> withObject:@<span class="hljs-string">&quot;B&quot;</span>];<br></code></pre></td></tr></table></figure><p>DynamicTool 的头文件并未定义实例方法<code>instanceMethodSelector</code> 和类方法<code>classMethodSelector</code>。因此通过 performSelector 调用时，runtime会按照上一小结所述流程从类中查找该方法，因为未定义，所以查找失败并走动态方法决议流程，分别通过<code>resolveInstanceMethod</code>与 <code>resolveClassMethod</code>查找具体的方法实现。</p><h3 id="11-消息转发机制"><a href="#11-消息转发机制" class="headerlink" title="11.消息转发机制"></a>11.消息转发机制</h3><p>如果没有实现动态方法决议机制，或者在动态方法决议时并未为selector提供实现，那么就会发生crash。为防止这种闪退，OC还提供了消息转发机制，以便将消息转发给其他对象。</p><p>如果同时提供了动态方法决议和消息转发，那么动态方法决议先于消息转发，只有当动态方法决议依然无法正确决议selector的实现，才会尝试进行消息转发。</p><ul><li>第一次转发机会</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(id)</span>forwardingTargetForSelector:<span class="hljs-params">(SEL)</span>sel;<br></code></pre></td></tr></table></figure><blockquote><p>Returns the object to which unrecognized messages should first be directed.</p></blockquote><p>返回未识别方法的新接收者。</p><blockquote><p>If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.)</p></blockquote><p>实现此方法并返回非空和非self对象时，此新对象会被作为原方法的接收者，重新开始方法的派发流程。如果在方法中返回了self对象，则代码会陷入无限循环中~</p><ul><li>第二次转发机会</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang">- <span class="hljs-params">(NSMethodSignature *)</span>methodSignatureForSelector:<span class="hljs-params">(SEL)</span>sel；<br>- <span class="hljs-params">(void)</span>forwardInvocation:<span class="hljs-params">(NSInvocation *)</span>invo;<br></code></pre></td></tr></table></figure><blockquote><p>When an object is sent a message for which it has no corresponding method, the runtime system gives the receiver an opportunity to delegate the message to another receiver. It delegates the message by creating an NSInvocation object representing the message and sending the receiver a forwardInvocation: message containing this NSInvocation object as the argument. The receiver’s forwardInvocation: method can then choose to forward the message to another object. (If that object can’t respond to the message either, it too will be given a chance to forward it.)</p></blockquote><p>如果消息的接收者不能响应消息，则运行时会再给接收者一次将消息代理给其他对象的机会。运行时会为消息创建一个<code>NSInvocation</code>对象，随后调用原接收者的forwardInvocation:方法，并传入此<code>NSInvocation</code>作为参数。forwardInvocation:中将此方法转发给其他对象。</p><p>#示例2：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//DynamicTool实现文件如下：</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;DynamicTool.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;objc/runtime.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ForwardTool.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">DynamicTool</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -动态决议</span><br><span class="hljs-comment">//实例方法</span><br>+ (<span class="hljs-type">BOOL</span>)resolveInstanceMethod:(SEL)sel<br>&#123;<br>    <span class="hljs-comment">// 注意：为了展示消息转发的实现，这里没有给SEL提供具体的实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;<br>&#125;<br><span class="hljs-comment">//类方法</span><br>+(<span class="hljs-type">BOOL</span>)resolveClassMethod:(SEL)sel<br>&#123;<br>    <span class="hljs-comment">// 注意：为了展示消息转发的实现，这里没有给SEL提供具体的实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> mark -消息转发</span><br>- (<span class="hljs-type">id</span>)forwardingTargetForSelector:(SEL)sel<br>&#123;<br>    <span class="hljs-comment">//if (sel == @selector(unknownSelector)) &#123;</span><br>    <span class="hljs-comment">//    return [ForwardTool new];</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector<br>&#123;<br>    <span class="hljs-built_in">NSMethodSignature</span> *methodSignature = [<span class="hljs-variable language_">super</span> methodSignatureForSelector:aSelector];<br>    <span class="hljs-keyword">if</span> (!methodSignature) &#123;<br>        methodSignature = [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;v@:*&quot;</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> methodSignature;<br>&#125;<br><br>- (<span class="hljs-type">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation<br>&#123;<br>    <span class="hljs-comment">// 创建一个或多个对象 将消息转发给它们</span><br>    ForwardTool *forwardTool = [ForwardTool new];<br>    <span class="hljs-keyword">if</span> ([forwardTool respondsToSelector:<span class="hljs-keyword">@selector</span>(unknownSelector)]) &#123;<br>        <span class="hljs-comment">//这里可以转发给多个对象，最终的返回值以最后一个调用的返回值为准</span><br>        [anInvocation invokeWithTarget:forwardTool];<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p><code>ForwardTool</code>类的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ForwardTool</span> : <span class="hljs-title">NSObject</span></span><br>- (<span class="hljs-type">void</span>)unknownSelector;<br><span class="hljs-keyword">@end</span><br><br><span class="hljs-comment">//ForwardTool实现文件如下：</span><br><br><span class="hljs-meta">#import <span class="hljs-string">&quot;ForwardTool.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ForwardTool</span></span><br><br>- (<span class="hljs-type">void</span>)unknownSelector<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;消息转发&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><p>调用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">DynamicTool *insObj = [DynamicTool <span class="hljs-keyword">new</span>];<br><span class="hljs-type">Class</span> <span class="hljs-variable">classObj</span> <span class="hljs-operator">=</span> NSClassFromString(@<span class="hljs-string">&quot;DynamicTool&quot;</span>);<br>[insObj performSelector:<span class="hljs-meta">@selector(unknownSelector)</span>];<br></code></pre></td></tr></table></figure><h3 id="12-消息转发的过程"><a href="#12-消息转发的过程" class="headerlink" title="12.消息转发的过程"></a>12.消息转发的过程</h3><p>1、动态方法决议进入<code>resolvexxxMethod</code>方法时，指定是否动态添加方法。若指定了实现函数，则通过<code>class_addMethod</code>函数动态地添加方法，并正常执行作为替代的C函数，如上面示例中的<code>dynamicResolution</code>方法；否则，进入第2步；</p><p>2、如果<code>resolvexxxMethod </code>方法中未指定实现函数，不论返回YES或NO，都会进入消息转发流程，调用<code>forwardingTargetForSelector</code>方法，在这里指定由哪个对象响应这个selector。若返回某个对象，则会调用该对象的方法；若返回nil，进入第3步;</p><p>3、如果上一步<code>forwardingTargetForSelector</code>中返回nil或者返回的转发对象也不能响应此方法，则runtime会给我们第二次转发机会，通过<code>methodSignatureForSelector</code>创建一个方法签名。返回nil表示不处理，程序会crash；返回方法签名，则进入第4步。</p><p>4、<code>methodSignatureForSelector</code>返回方法签名时，会调用<code>forwardInvocation</code>方法。到这个方法中后即使不做任何处理程序也不会闪退，当然也可以通过<code>anInvocation</code>再次将消息转发给多个对象，或者修改实现方法，修改响应对象等。</p><h3 id="13-NSInvocation"><a href="#13-NSInvocation" class="headerlink" title="13.NSInvocation"></a>13.NSInvocation</h3><p>OC中 直接调用类的方法有两种途径：</p><ul><li>通过 NSObject 分类中定义的 <code>-performSelector:withObject:withObject:</code> 方法；</li><li>通过 <code>NSInvocation</code>；</li></ul><p>第一种适合处理参数较少的方法调用；当有多个参数时，就需要使用第二种方式。</p><p>#示例3：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-type">BOOL</span>)application:(<span class="hljs-built_in">UIApplication</span> *)application<br>didFinishLaunchingWithOptions:(<span class="hljs-built_in">NSDictionary</span> *)launchOptions<br>&#123;<br>    <span class="hljs-built_in">NSMethodSignature</span> *signature = [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;@@:@B&quot;</span>];<br>    <span class="hljs-built_in">NSInvocation</span> *invocation = [<span class="hljs-built_in">NSInvocation</span> invocationWithMethodSignature:signature];<br>    invocation.target = <span class="hljs-keyword">self</span>;<br>    invocation.selector = <span class="hljs-keyword">@selector</span>(onSendMessageWithParam1:param2:);<span class="hljs-comment">//方法必须和签名中的方法一致</span><br>    <br>    <span class="hljs-built_in">NSString</span>*str1 = <span class="hljs-string">@&quot;THIS IS A STR~&quot;</span>;<br>    <span class="hljs-type">BOOL</span> boolValue = <span class="hljs-literal">YES</span>;<br><br>    <span class="hljs-comment">//第一个参数为参数对象的指针；</span><br>    <span class="hljs-comment">//第二个参数为参数的索引，注意不能从0开始，因为0已经被self占用，1已经被_cmd占用</span><br>    [invocation setArgument:&amp;str1 atIndex:<span class="hljs-number">2</span>];<br>    [invocation setArgument:&amp;boolValue atIndex:<span class="hljs-number">3</span>];<br>    <br>    [invocation invoke];<span class="hljs-comment">//执行方法</span><br>    <span class="hljs-type">id</span> retLoc = <span class="hljs-literal">nil</span>;<br>    [invocation getReturnValue:&amp;retLoc];<span class="hljs-comment">//获取返回值</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;<br>&#125;<br><br>- (<span class="hljs-built_in">NSString</span> *)onSendMessageWithParam1:(<span class="hljs-built_in">NSString</span>*)str1 param2:(<span class="hljs-type">BOOL</span>)boolvalue<br>&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;+++%@++++%d&quot;</span>,str1,boolvalue);<br>    <span class="hljs-keyword">return</span> str1;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocSelectors.html#//apple_ref/doc/uid/TP30001163-CH23-SW1">©Apple-Selectors</a></p><p>#<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">©Apple-Type Encodings</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>元类</title>
    <link href="/2017/08/22/runtime-metaclass.html"/>
    <url>/2017/08/22/runtime-metaclass.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-runtime"><a href="#1-runtime" class="headerlink" title="1.runtime"></a>1.runtime</h3><p><code>runtime</code>，直译过来是运行时，它是一套底层的C语言API，包含很多强大实用的C语言数据类型和C语言函数。我们的OC代码在运行阶段都是基于runtime环境才能正常运行的。</p><h3 id="2-常用场景"><a href="#2-常用场景" class="headerlink" title="2.常用场景"></a>2.常用场景</h3><ul><li>发送消息；</li><li>读取成员变量；</li><li>动态为某个类增加属性；</li><li>交换类中的方法、动态为某个类添加方法；</li><li>动态创建、删除、修改一个类；</li></ul><h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h3><blockquote><p>OC中，含有isa指针且该指针可以正确指向类的数据结构，都可以视为对象。</p></blockquote><p>下面是<code>objc.h</code>中的相关定义:</p><pre><code class="hljs">#if !OBJC_TYPES_DEFINED/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123;Class isa  OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;#endif</code></pre><p>从<code>objc_object</code>结构体的定义可以看出：对象实质上是一个结构体，其结构体内含有<code>isa</code>指针，指向其所属的类。</p><h3 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h3><p>下面是<code>runtime.h</code>中对<code>类</code>的定义：</p><pre><code class="hljs">struct objc_class &#123;Class isa  OBJC_ISA_AVAILABILITY;       //指针#if !__OBJC2__Class super_class                       //父类;const char *name                        //类名;long version                                             //类的版本信息，默认为0;long info                               //位标识;long instance_size                      //类的实例变量大小;struct objc_ivar_list *ivars            //类的成员变量链表;struct objc_method_list **methodLists   //方法定义的链表;struct objc_cache *cache                //方法缓存;struct objc_protocol_list *protocols    //协议链表;#endif&#125; OBJC2_UNAVAILABLE;</code></pre><p>从结构体的定义来看，类也是以<code>isa</code>开始并指向类的数据结构。OC中类与元类在运行时都是<code>objc_class</code>类型，所以，<strong>类和元类也是一种对象</strong>。</p><h3 id="5-元类"><a href="#5-元类" class="headerlink" title="5.元类"></a>5.元类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Objc"><span class="hljs-built_in">NSObject</span> *obj = [<span class="hljs-built_in">NSObject</span> alloc];<br></code></pre></td></tr></table></figure><h4 id="5-1-实例对象"><a href="#5-1-实例对象" class="headerlink" title="5.1.实例对象"></a>5.1.实例对象</h4><p><code>实例对象</code>，instance object，是指从某个类实例化而来的对象，如示例中的<code>obj</code>。</p><h4 id="5-2-类对象"><a href="#5-2-类对象" class="headerlink" title="5.2.类对象"></a>5.2.类对象</h4><p><code>类对象</code>，Class object，是指类作为对象时，称之为类对象。调用一个 “类方法” ，如 [NSObject alloc]，实质上是向它的类对象(NSObject)发送了一个消息。类对象是由编译器创建的，任何继承自NSObject的类，它的实例对象中都有一个isa指针，指向它的类对象。</p><h4 id="5-3-元类"><a href="#5-3-元类" class="headerlink" title="5.3.元类"></a>5.3.元类</h4><p><code>元类</code>，Metaclass，是<code>类对象</code>的isa指针所指向的类，类对象是元类的实例。</p><p>区分类对象与元类：</p><ul><li>类对象中保存的是关于其实例对象的信息(变量，实例方法、遵守的协议等)；</li><li>元类中保存的是关于类的信息(类方法，类的版本，名字等)；</li></ul><p>借用网上的一张图，演示元类与继承的封闭循环：</p><p><img src="https://davidlii.nos-eastchina1.126.net/pic_metaclass.png" alt="isa与superclass"></p><p>图中实线是 super_class 指针，虚线是<code>isa</code>指针。</p><ul><li>实例对象是类的实例；</li><li>类作为对象又是元类的实例;</li><li>元类作为对象是根元类的实例；</li><li>根元类是其自身的实例；</li><li>根类的 superclass 为 nil；</li><li>根元类的 superclass 为根类自己；</li></ul><h3 id="6-isa"><a href="#6-isa" class="headerlink" title="6.isa"></a>6.isa</h3><p>isa 等价于 is kind of：</p><ul><li>实例对象的 isa 指向类对象;</li><li>类对象的 isa 指向元类对象;</li><li>元类对象的 isa 指向根元类;</li><li>根元类对象的 isa 指向其自身;</li></ul><h3 id="7-相关函数"><a href="#7-相关函数" class="headerlink" title="7.相关函数"></a>7.相关函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs OC">-class<br></code></pre></td></tr></table></figure><p>对于实例对象，返回其 isa 指针指向的<code>类</code>；对于类对象，返回其<code>本身</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs OC">object_getClass(id obj)<br></code></pre></td></tr></table></figure><p>返回isa指针指向的内容。对实例对象，返回其 isa 指向的<code>类</code>；对类对象，返回其对应的<code>元类</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs OC">objc_getMetaClass(const char *name)<br></code></pre></td></tr></table></figure><p>返回对应的<code>元类</code>。</p><hr><p>相关参考：</p><p>#<a href="https://developer.apple.com/documentation/objectivec/">©Objective-C Runtime</a></p>]]></content>
    
    
    <categories>
      
      <category>OC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runtime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2017/07/24/helloworld.html"/>
    <url>/2017/07/24/helloworld.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;file name&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FAQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
