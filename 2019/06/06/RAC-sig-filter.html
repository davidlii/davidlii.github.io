<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"> 
  
  <title>
    
      RAC-过滤信号返回的数据 | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>RAC-过滤信号返回的数据</h2>
  <p class="post-date">2019-06-06</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>信号在订阅后就可以接收回调的数据了，有时候我们需要对收到的数据进行过滤或者转换后才能继续使用。<br>&emsp;</p>
<p>例如发送按钮的<code>userInteractionEnabled</code>状态需要依请求的<code>isFnished</code>状态而定：请求发送后未完成则按钮不可点击，请求成功返回后按钮可点击。这种场景下我们只需要创建一个信号监听请求的<code>isFnished</code>属性，并对信号返回的结果进行取反即可。<br>&emsp;</p>
<p>再比如修改昵称时一般不能前后输入一样的昵称，这时候我们可以通过信号监听文本框的内容，遇到前后一致的文本时自动过滤掉即可。<br>&emsp;</p>
<p>这样需要对信号返回的结果进行过滤或修改的场景还有很多，为了处理这些常见的使用场景，RAC同样也提供了对应的接口。本文将对这些接口进行调用展示和实现分析：</p>
<h3 id="1-bind"><a href="#1-bind" class="headerlink" title="1.bind"></a>1.bind</h3><p>信号的绑定，先讲这个方法是因为其他接口的底层都是通过它来实现的，理清它的实现有助于更好的理解接下来的其他接口。<br>&emsp;</p>
<p>这个方法定义在<code>RACStream.h</code>中，被多个子类重写，这里就看看<code>RACSignal.h</code>中的接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1 bind方法的定义</span><br><span class="line">/// Lazily binds a block to the values in the receiver.</span><br><span class="line">///</span><br><span class="line">/// This should only be used if you need to terminate the bind early, or close</span><br><span class="line">/// over some state. -flattenMap: is more appropriate for all other cases.</span><br><span class="line">///</span><br><span class="line">/// block - A block returning a RACSignalBindBlock. This block will be invoked</span><br><span class="line">///         each time the bound signal is re-evaluated. This block must not be</span><br><span class="line">///         nil or return nil.</span><br><span class="line">///</span><br><span class="line">/// Returns a new signal which represents the combined result of all lazy</span><br><span class="line">/// applications of `block`.</span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block RAC_WARN_UNUSED_RESULT;</span><br><span class="line"></span><br><span class="line">//2.block的返回值BindBlock的定义</span><br><span class="line">/// A block which accepts a value from a RACSignal and returns a new signal.</span><br><span class="line">///</span><br><span class="line">/// Setting `stop` to `YES` will cause the bind to terminate after the returned</span><br><span class="line">/// value. Returning `nil` will result in immediate termination.</span><br><span class="line">typedef RACSignal * _Nullable (^RACSignalBindBlock)(ValueType _Nullable value, BOOL *stop);</span><br></pre></td></tr></table></figure>
<ul>
<li>方法的参数：一个“RACSignalBindBlock (^)(void)”类型的<code>block</code>；</li>
<li>方法的返回值：一个新的信号对象。</li>
</ul>
<p><strong>作用</strong>：将<code>block</code>绑定到方法接收者的值中，即把<code>block</code>参数保存在返回的信号中。<br>&emsp;</p>
<p>所以，<code>bind</code>的主要目的就是将任务以 block 的形式保存到返回的信号中，以期在将来进行处理。</p>
<p>&emsp;</p>
<p>#<strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)callBind &#123;</span><br><span class="line">    //bind的作用：将block绑定到信号2中，订阅信号1并创建新的信号2，收到信号1的数据后，修改数据并通过新创建的信号2发送新数据)</span><br><span class="line">    // 1.信号1</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        // 5.信号1发送数据1</span><br><span class="line">        [subscriber sendNext:@&quot;1&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    // 2.信号2</span><br><span class="line">    RACSignal *bindSignal2 = [signal1 bind:^RACSignalBindBlock&#123;</span><br><span class="line">        // 4.bind回调</span><br><span class="line">        NSLog(@&quot;+++This is BindBlock callback&quot;);</span><br><span class="line">        RACSignalBindBlock aBindBlock = ^RACSignal*(id value, BOOL *stop)&#123;</span><br><span class="line">            // 6.bindBlock内修改数据</span><br><span class="line">            NSLog(@&quot;+++ori value:%@&quot;,value);</span><br><span class="line">            value = @&quot;2&quot;;</span><br><span class="line">            return [RACReturnSignal return:value];// 信号3</span><br><span class="line">        &#125;;</span><br><span class="line">        return aBindBlock;</span><br><span class="line">    &#125;];</span><br><span class="line">    // 3.订阅信号2</span><br><span class="line">    [bindSignal2 subscribeNext:^(id x) &#123;</span><br><span class="line">        // 7.接收数据</span><br><span class="line">        NSLog(@&quot;++++bindSignal return Value:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++This is BindBlock callback</span><br><span class="line">+++ori value:1</span><br><span class="line">++++bindSignal return Value:2</span><br></pre></td></tr></table></figure>
<p>示例中<code>信号1</code>调用了绑定方法，将一个修改数据的 block 绑定到返回值<code>信号2</code>中。<br>&emsp;</p>
<p>订阅<code>信号2</code>之后<code>信号1</code>发送了数据<code>1</code>，但最终<code>信号2</code>订阅者接收到的是修改后的数据<code>2</code>。<br>&emsp;</p>
<p>下面就来看看调用<code>bind</code>方法后都发生了什么：<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(void))block &#123;</span><br><span class="line">	NSCParameterAssert(block != NULL);//为空校验</span><br><span class="line"></span><br><span class="line">	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;//创建信号2 ^didSubscribe2</span><br><span class="line">		</span><br><span class="line">		// 1.调用bind的block参数，返回BindBlock</span><br><span class="line">		RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">		__block volatile int32_t signalCount = 1;   // indicates self</span><br><span class="line"></span><br><span class="line">		RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">		// 创建完成block</span><br><span class="line">		void (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">			if (OSAtomicDecrement32Barrier(&amp;signalCount) == 0) &#123;</span><br><span class="line">				[subscriber sendCompleted];</span><br><span class="line">				[compoundDisposable dispose];</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				[compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		// 创建信号处理block</span><br><span class="line">		void (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">			OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line"></span><br><span class="line">			RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">			[compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">			// 5.订阅传进来的信号</span><br><span class="line">			RACDisposable *disposable = [signal subscribeNext:^(id x) &#123;// ^sendNext3</span><br><span class="line">				// 6.向信号2发送数据</span><br><span class="line">				[subscriber sendNext:x];</span><br><span class="line">			&#125; error:^(NSError *error) &#123;</span><br><span class="line">				[compoundDisposable dispose];</span><br><span class="line">				[subscriber sendError:error];</span><br><span class="line">			&#125; completed:^&#123;</span><br><span class="line">				@autoreleasepool &#123;</span><br><span class="line">					completeSignal(selfDisposable);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;];</span><br><span class="line"></span><br><span class="line">			selfDisposable.disposable = disposable;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		@autoreleasepool &#123;</span><br><span class="line">			RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">			[compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">			// 2.订阅信号1</span><br><span class="line">			RACDisposable *bindingDisposable = [self subscribeNext:^(id x) &#123;// ^sendNext1</span><br><span class="line">				// Manually check disposal to handle synchronous errors.</span><br><span class="line">				if (compoundDisposable.disposed) return;</span><br><span class="line"></span><br><span class="line">				BOOL stop = NO;</span><br><span class="line">				// 3.调用 aBindBlock，返回一个信号3</span><br><span class="line">				id signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line">				@autoreleasepool &#123;</span><br><span class="line">					// 4.信号3作为参数 调用addSignal()</span><br><span class="line">					if (signal != nil) addSignal(signal);</span><br><span class="line">					if (signal == nil || stop) &#123;</span><br><span class="line">						[selfDisposable dispose];</span><br><span class="line">						completeSignal(selfDisposable);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; error:^(NSError *error) &#123;</span><br><span class="line">				[compoundDisposable dispose];</span><br><span class="line">				[subscriber sendError:error];</span><br><span class="line">			&#125; completed:^&#123;</span><br><span class="line">				@autoreleasepool &#123;</span><br><span class="line">					completeSignal(selfDisposable);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;];</span><br><span class="line"></span><br><span class="line">			selfDisposable.disposable = bindingDisposable;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return compoundDisposable;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -bind:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.调用<code>bind</code>方法后方法体内只做了block为空的校验，之后返回了一个信号，即我们示例中的<code>信号2</code>。所以关键点在这个<code>信号2</code>的实现中。示例的最后我们订阅了<code>信号2</code>，所以就会触发其<code>^didSubscribe</code>回调，也就是<code>bind</code>方法中返回值的那个大的 block，在上面的代码注释中我将它命名为<code>^didSubscribe2</code>；<br>&emsp;</p>
<p>2.<code>^didSubscribe2</code>中先调用<code>bind</code>方法的<code>block</code>参数。这个<code>block</code>就是我们在示例中定义好的，其实什么都没做，只是返回了一个比较特殊的<code>aBindBlock</code>；<br>&emsp;</p>
<p>3.<code>^didSubscribe2</code>紧接着定义了两个block，然后订阅了<code>信号1</code>，触发<code>^didSubscribe1</code>，即示例1中<code>信号1</code>的 block；<br>&emsp;</p>
<p>4.<code>^didSubscribe1</code>中向订阅者发送了数据<code>1</code>；触发<code>bind</code>方法内的<code>^sendNext1</code>；<br>&emsp;</p>
<p>5.<code>^sendNext1</code>内调用<code>aBindBlock</code>，参数为数据<code>1</code>，返回一个新的信号，将其命名为<code>信号3</code>；<code>aBindBlock</code>本身也是一个 block，内部定义了处理数据的逻辑，返回值是一个特殊类型(RACReturnSignal)的<code>信号3</code>，这种信号的特点是被订阅之后会立刻将自己接收的参数作为数据发送出去，而这个参数就是我们修改之后的数据<code>2</code>；<br>&emsp;</p>
<p>6.<code>^sendNext1</code>内接着将<code>信号3</code>作为参数调用了<code>^addSignal</code>；<code>^addSignal</code>内订阅了<code>信号3</code>，上面说过<code>信号3</code>的特点，所以被订阅后立刻触发了<code>^sendNext3</code>；<br>&emsp;</p>
<p>7.<code>^sendNext3</code>内向<code>信号2</code>的订阅者发送数据<code>2</code>；<br>&emsp;</p>
<p>8.示例中<code>信号2</code>的订阅者接收到回来的数据<code>2</code>。<br>&emsp;</p>
<p>时序图整理如下：<br><img src="https://davidlii.nos-eastchina1.126.net/pic_signal_bind2.jpg" alt="信号绑定时序图"></p>
<p>&emsp;<br><strong>小结</strong>：信号的绑定给了我们一个在其<code>BindBlock</code>中修改源信号返回值的机会，但这么直接使用<code>bind</code>显得有点麻烦，通常在使用RAC时我们都会选择下面这些基于<code>bind</code>的更便捷的语法。</p>
<h3 id="2-take"><a href="#2-take" class="headerlink" title="2.take"></a>2.take</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/// Returns a signal of the first `count` values in the receiver. If `count` is</span><br><span class="line">/// greater than or equal to the number of values in the signal, a signal</span><br><span class="line">/// equivalent to the receiver is returned.</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)take:(NSUInteger)count RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：返回一个新的信号，订阅后只接收指定的<code>前N次</code>源信号的数据。</p>
<p>&emsp;</p>
<p>#<strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)take &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1.1&quot;]; // 第1次发送数据</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;1.2&quot;];// 第2次发送数据</span><br><span class="line">            //[subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:5 schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;1.3&quot;];// 第3次发送数据</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[signal1 take:2] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++received Value:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++received Value:1.1</span><br><span class="line">+++received Value:1.2</span><br></pre></td></tr></table></figure>
<p>可以看到，虽然示例中三次<code>sendNext:</code>，但最终新信号的订阅回调中只收到了前两次的数据~<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)take:(NSUInteger)count &#123;</span><br><span class="line">	Class class = self.class;</span><br><span class="line">	</span><br><span class="line">	if (count == 0) return class.empty;</span><br><span class="line"></span><br><span class="line">	return [[self bind:^&#123;</span><br><span class="line">		__block NSUInteger taken = 0;</span><br><span class="line"></span><br><span class="line">		return ^ id (id value, BOOL *stop) &#123;</span><br><span class="line">			if (taken &lt; count) &#123;</span><br><span class="line">				++taken;</span><br><span class="line">				if (taken == count) *stop = YES;</span><br><span class="line">				return [class return:value];</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return nil;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -take: %lu&quot;, self.name, (unsigned long)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.<code>take:</code>方法的内部是通过<code>bind</code>来实现的，所以其核心逻辑也是在<code>BindBlock</code>中；<br>&emsp;</p>
<p>2.<code>take:</code>方法的内部持有一个局部变量<code>taken</code>用于计算<code>BindBlock</code>被调用了几次;<br>&emsp;</p>
<p>3.上面<code>bind</code>方法的分析中提到过<code>BindBlock</code>的触发机制，所以<code>信号1</code>每发送一次数据，<code>taken</code>就自动加1;<br>&emsp;</p>
<p>4.当<code>taken</code>超过指定的次数时<code>BindBlock</code>返回一个空信号，不再继续接收新数据。<br>&emsp;</p>
<p><strong>ps</strong>：如果源信号在第N次之前被<code>sendCompleted</code>，那么后续也不会再产生新数据。</p>
<h3 id="3-skip"><a href="#3-skip" class="headerlink" title="3.skip"></a>3.skip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// Skips the first `skipCount` values in the receiver.</span><br><span class="line">///</span><br><span class="line">/// Returns the receiver after skipping the first `skipCount` values. If</span><br><span class="line">/// `skipCount` is greater than the number of values in the signal, an empty</span><br><span class="line">/// signal is returned.</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)skip:(NSUInteger)skipCount RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：跳过<code>前N次</code>的数据回调。<br>&emsp;</p>
<p>它跟<code>take</code>有点反着来的意思~所以可以想见，它的实现逻辑刚好与<code>take</code>相反。</p>
<p>&emsp;</p>
<p>#<strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)skip &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1.1&quot;]; // 第1次发送数据</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;1.2&quot;]; // 第2次发送数据</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:5 schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;1.3&quot;]; // 第3次发送数据</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[signal1 skip:2] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++received Value:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++received Value:1.3</span><br></pre></td></tr></table></figure>
<p>日志显示，自动跳过前2次数据，只接收到了最后一次数据<code>1.3</code>。<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skip:(NSUInteger)skipCount &#123;</span><br><span class="line">	Class class = self.class;</span><br><span class="line">	</span><br><span class="line">	return [[self bind:^&#123;</span><br><span class="line">		__block NSUInteger skipped = 0;</span><br><span class="line"></span><br><span class="line">		return ^(id value, BOOL *stop) &#123;</span><br><span class="line">			if (skipped &gt;= skipCount) return [class return:value];</span><br><span class="line"></span><br><span class="line">			skipped++;</span><br><span class="line">			return class.empty;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -skip: %lu&quot;, self.name, (unsigned long)skipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>skip</code>的实现与<code>take</code>相似，都是通过<code>BindBlock</code>中的数值型局部变量来控制接收信号的次数，只不过二者逻辑相反。</p>
<h3 id="4-distinctUntilChanged"><a href="#4-distinctUntilChanged" class="headerlink" title="4.distinctUntilChanged"></a>4.distinctUntilChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// Returns a signal of values for which -isEqual: returns NO when compared to the</span><br><span class="line">/// previous value.</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)distinctUntilChanged RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：过滤源信号的数据，相同的数据出现时订阅者不会收到回调，直到不同的数据出现。</p>
<p>&emsp;</p>
<p>#<strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)distinct &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;1&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;3&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[signal1 distinctUntilChanged] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++received Value:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++received Value:1</span><br><span class="line">+++received Value:3</span><br></pre></td></tr></table></figure>
<p>前两次的数据相同，所以只接收了第1次的数据，第2次数据自动过滤掉了~<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)distinctUntilChanged &#123;</span><br><span class="line">	Class class = self.class;</span><br><span class="line"></span><br><span class="line">	return [[self bind:^&#123;</span><br><span class="line">		__block id lastValue = nil;</span><br><span class="line">		__block BOOL initial = YES;</span><br><span class="line"></span><br><span class="line">		return ^(id x, BOOL *stop) &#123;</span><br><span class="line">			if (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) return [class empty];</span><br><span class="line"></span><br><span class="line">			initial = NO;</span><br><span class="line">			lastValue = x;</span><br><span class="line">			return [class return:x];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -distinctUntilChanged&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>BindBlock</code>中将当前数据与上次返回的数据对比，数据的地址相同或者<code>isEqual</code>返回<code>YES</code>时，则返回空信号；否则正常接收。<br>&emsp;</p>
<p><strong>ps</strong>：当使用自定义的对象类型时你可能需要重写其<code>isEqual</code>方法。</p>
<h3 id="5-flattenMap"><a href="#5-flattenMap" class="headerlink" title="5.flattenMap"></a>5.flattenMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/// Maps `block` across the values in the receiver and flattens the result.</span><br><span class="line">///</span><br><span class="line">/// Note that operators applied _after_ -flattenMap: behave differently from</span><br><span class="line">/// operators _within_ -flattenMap:. See the Examples section below.</span><br><span class="line">///</span><br><span class="line">/// This corresponds to the `SelectMany` method in Rx.</span><br><span class="line">///</span><br><span class="line">/// block - A block which accepts the values in the receiver and returns a new</span><br><span class="line">///         instance of the receiver&apos;s class. Returning `nil` from this block is</span><br><span class="line">///         equivalent to returning an empty signal.</span><br><span class="line">///</span><br><span class="line">/// Examples</span><br><span class="line">///</span><br><span class="line">///   [signal flattenMap:^(id x) &#123;</span><br><span class="line">///       // Logs each time a returned signal completes.</span><br><span class="line">///       return [[RACSignal return:x] logCompleted];</span><br><span class="line">///   &#125;];</span><br><span class="line">///</span><br><span class="line">///   [[signal</span><br><span class="line">///       flattenMap:^(id x) &#123;</span><br><span class="line">///           return [RACSignal return:x];</span><br><span class="line">///       &#125;]</span><br><span class="line">///       // Logs only once, when all of the signals complete.</span><br><span class="line">///       logCompleted];</span><br><span class="line">///</span><br><span class="line">/// Returns a new signal which represents the combined signals resulting from</span><br><span class="line">/// mapping `block`.</span><br><span class="line">- (RACSignal *)flattenMap:(__kindof RACSignal * _Nullable (^)(ValueType _Nullable value))block RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：将源信号的数据映射成新的<code>信号</code>，即根据源信号的数据生成新的<code>信号</code>。<br>&emsp;</p>
<p>#<strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)RACBinder&#123;</span><br><span class="line">    @weakify(self);</span><br><span class="line">    </span><br><span class="line">    //设置返回按钮</span><br><span class="line">    UIButton *btn1 = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    [btn1 setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];</span><br><span class="line">    [btn1 setTitle:@&quot;返回&quot; forState:UIControlStateNormal];</span><br><span class="line">    [btn1 sizeToFit];</span><br><span class="line">    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:btn1];</span><br><span class="line">    </span><br><span class="line">    //添加点击事件逻辑</span><br><span class="line">    [[[btn1 rac_signalForControlEvents:UIControlEventTouchUpInside] // btnSignal</span><br><span class="line">      flattenMap:^RACSignal *(UIControl *value) &#123; // flattenMapBlock</span><br><span class="line">          </span><br><span class="line">          RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">              @strongify(self);//一定要强引用一下，否则VC不会销毁</span><br><span class="line">              [self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">              [subscriber sendNext:@&quot;++Poped~&quot;];</span><br><span class="line">              [subscriber sendCompleted];</span><br><span class="line">              return nil;</span><br><span class="line">          &#125;];</span><br><span class="line">        return signal2;</span><br><span class="line">    &#125;] </span><br><span class="line">    subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++Mess:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在收到按钮的点击事件后，订阅新的<code>信号2</code>以处理导航器的<code>pop</code>操作，之后发出一条已完成的消息。<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(id value))block &#123;</span><br><span class="line">	Class class = self.class;</span><br><span class="line"></span><br><span class="line">	return [[self bind:^&#123;</span><br><span class="line">		return ^(id value, BOOL *stop) &#123;</span><br><span class="line">			id stream = block(value) ?: [class empty];</span><br><span class="line">			NSCAssert([stream isKindOfClass:RACStream.class], @&quot;Value returned from -flattenMap: is not a stream: %@&quot;, stream);</span><br><span class="line"></span><br><span class="line">			return stream;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -flattenMap:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.<code>flattenMap</code>也是由<code>bind</code>实现的，<code>btnSignal</code>调用了<code>flattenMap</code>也就是调用了<code>bind</code>，之后就交给<code>bind</code>来处理；<br>&emsp;</p>
<p>2.<code>bind</code>先在<code>BindBlock</code>中调用了<code>block(value)</code>，这里的<code>block</code>就是<code>flattenMapBlock</code>；<code>value</code>就是源信号发送的数据，即<code>btn1</code>；返回值是我们定义好的处理 pop 业务的<code>信号2</code><br>&emsp;</p>
<p>3.根据之前介绍的<code>bind</code>时序图可知，<code>信号2</code>被<code>BindBlock</code>返回之后即被订阅，继而开始执行其<code>^didSubscribe</code>中的 pop 任务；<br>&emsp;</p>
<p>4.pop之后<code>^didSubscribe</code>发送已完成的消息，订阅者收到数据回调，整个任务执行完成。<br>&emsp;</p>
<p><strong>小结</strong>：<code>flattenMap</code>的主要作用就是接收源信号的数据，并返回一个处理业务的新<code>信号</code>。</p>
<h3 id="6-map"><a href="#6-map" class="headerlink" title="6.map"></a>6.map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// Maps `block` across the values in the receiver.</span><br><span class="line">///</span><br><span class="line">/// This corresponds to the `Select` method in Rx.</span><br><span class="line">///</span><br><span class="line">/// Returns a new signal with the mapped values.</span><br><span class="line">- (RACSignal *)map:(id _Nullable (^)(ValueType _Nullable value))block RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：将源信号的数据映射成新的<code>数据</code>，即根据源信号的数据生成新的<code>数据</code>。<br>&emsp;</p>
<p><strong>#示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)map &#123;</span><br><span class="line">	</span><br><span class="line">    //设置刷新按钮</span><br><span class="line">    UIButton *btn2 = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">    [btn2 setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];</span><br><span class="line">    [btn2 setTitle:@&quot;刷新&quot; forState:UIControlStateNormal];</span><br><span class="line">    [btn2 sizeToFit];</span><br><span class="line">    </span><br><span class="line">    self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:btn2];</span><br><span class="line">    </span><br><span class="line">    //创建信号 监听刷新状态</span><br><span class="line">    RACSignal *mEnableSignal = [RACObserve(self.mViewModel, isRefresh)</span><br><span class="line">                                map:^id (id value) &#123; // mapBlock</span><br><span class="line">                                    return @(![value boolValue]); // 对刷新状态取反</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    btn2.rac_command = [[RACCommand alloc] initWithEnabled:mEnableSignal</span><br><span class="line">                                               signalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">                                                   @strongify(self);</span><br><span class="line">                                                   //business</span><br><span class="line">                                                   [self.mRrefreshControl endRefreshing];</span><br><span class="line">                                                   RACSignal *signalFetch = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                                                       //声明请求参数</span><br><span class="line">                                                       RACTuple *paramsTuple = [RACTuple tupleWithObjects:@(1),@(20), nil];//元组第一个对象表示页码，第二个表示每页数量</span><br><span class="line">                                                       //发起请求</span><br><span class="line">                                                       [self.mRrefreshControl beginRefreshing];</span><br><span class="line">                                                       [self.mViewModel.fetchCommand execute:paramsTuple];</span><br><span class="line">                                                       [subscriber sendCompleted];</span><br><span class="line">                                                       </span><br><span class="line">                                                       return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                                                       &#125;];</span><br><span class="line">                                                   &#125;];</span><br><span class="line">                                                   return signalFetch;</span><br><span class="line">                                               &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.示例中创建<code>RACCommand</code>时需要一个控制其是否执行的信号<code>EnableSignal</code>；<br>&emsp;</p>
<p>2.通过<code>RACObserve()</code>宏监听了<code>VM</code>中表示是否在刷新的属性<code>isRefresh</code>，此监听操作会返回一个信号，取名<code>信号1</code>吧；<br>&emsp;</p>
<p>3.当VM中<code>isRefresh</code>的值变化后，<code>信号1</code>会收到回调并在<code>map</code>内对其值取反，即刷新时回抛<code>NO</code>，不刷新时回抛<code>YES</code>。<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)map:(id (^)(id value))block &#123;</span><br><span class="line">	NSCParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">	Class class = self.class;</span><br><span class="line">	</span><br><span class="line">	return [[self flattenMap:^(id value) &#123; // flattenMapBlock</span><br><span class="line">		//block(value)返回修改之后的新值，然后作为参数传入返回的RACReturnSignal中</span><br><span class="line">		return [class return:block(value)]; </span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -map:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.首先，源信号调用<code>map</code>后，其底层调用了<code>flattenMap</code>并返回一个新的信号，即<code>mEnableSignal</code>；<br>&emsp;</p>
<p>2.<code>flattenMap</code>的<code>flattenMapBlock</code>返回值为一个<code>RACReturnSignal</code>类型的信号；<br>&emsp;</p>
<p>3.此信号的参数通过<code>block(value)</code>获取，即我们在示例的<code>map</code>方法中定义的取反的那个<code>mapBlock</code>，返回修改后的数据。<br>&emsp;</p>
<p>4.<code>bind</code>方法的<code>BindBlock</code>获取到<code>RACReturnSignal</code>信号后随即订阅它；<br>&emsp;</p>
<p>5.<code>RACReturnSignal</code>被订阅后立刻向<code>mEnableSignal</code>的订阅者发送了修改后的数据。<br>&emsp;</p>
<p><strong>小结</strong>：<code>map</code>的主要作用就是对源信号发送的数据进行过滤，从而返回一个新的<code>数据</code>。</p>
<hr>
<p>区分 map 与 flattenMap：</p>
<ul>
<li>map 的 block 中返回的是修改后的新数据；</li>
<li>flattenMap 的 block 中返回的是处理后续业务的新信号；</li>
<li>map 的底层调用了 flattenMap。</li>
</ul>
<p>理解了这些区别，就能更好的区分二者的使用场景了~</p>
<h3 id="7-filter"><a href="#7-filter" class="headerlink" title="7.filter"></a>7.filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// Filters out values in the receiver that don&apos;t pass the given test.</span><br><span class="line">///</span><br><span class="line">/// This corresponds to the `Where` method in Rx.</span><br><span class="line">///</span><br><span class="line">/// Returns a new signal with only those values that passed.</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)filter:(BOOL (^)(ValueType _Nullable value))block RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：过滤信号的数据，只有条件为<code>YES</code>时订阅者才会收到数据。</p>
<p>&emsp;</p>
<p>#<strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)filter &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@(1)];</span><br><span class="line">        [subscriber sendNext:@(2)];</span><br><span class="line">        [subscriber sendNext:@(3)];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[signal1 filter:^BOOL(NSNumber *value) &#123; // filterBlock</span><br><span class="line">        return [value intValue] &gt; 1; // 条件表达式</span><br><span class="line">    &#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++received Value:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++received Value:2</span><br><span class="line">+++received Value:3</span><br></pre></td></tr></table></figure>
<p>自动过滤了小于1的数据。<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)filter:(BOOL (^)(id value))block &#123;</span><br><span class="line">	NSCParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">	Class class = self.class;</span><br><span class="line">	</span><br><span class="line">	return [[self flattenMap:^ id (id value) &#123;</span><br><span class="line">		if (block(value)) &#123;</span><br><span class="line">			return [class return:value];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return class.empty;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -filter:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收到源信号发送的数据时，<code>BindBlock</code>中调用<code>block(value)</code>，即<code>filterBlock</code>中的逻辑，去判断数据是否满足指定的条件。<br>&emsp;</p>
<p><code>filterBlock</code>的返回值为<code>BOOl</code>型，所以我们只需要在其<code>return</code>后定义一个返回<code>BOOL</code>类型的表达式即可~</p>
<h3 id="8-ignore"><a href="#8-ignore" class="headerlink" title="8.ignore"></a>8.ignore</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/// Filters out values in the receiver that equal (via -isEqual:) the provided</span><br><span class="line">/// value.</span><br><span class="line">///</span><br><span class="line">/// value - The value can be `nil`, in which case it ignores `nil` values.</span><br><span class="line">///</span><br><span class="line">/// Returns a new signal containing only the values which did not compare equal</span><br><span class="line">/// to `value`.</span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)ignore:(nullable ValueType)value RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用</strong>：过滤掉源信号发送的特定数据。</p>
<p>&emsp;</p>
<p>#<strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)ignore &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@(1)];</span><br><span class="line">        [subscriber sendNext:@(2)];</span><br><span class="line">        [subscriber sendNext:@(3)];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    [[signal1 ignore:@(2)] subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++received Value:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++received Value:1</span><br><span class="line">+++received Value:3</span><br></pre></td></tr></table></figure>
<p>只接收不为2的数据。<br>&emsp;</p>
<p>#<strong>实现</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)ignore:(id)value &#123;</span><br><span class="line">	return [[self filter:^ BOOL (id innerValue) &#123;</span><br><span class="line">		return innerValue != value &amp;&amp; ![innerValue isEqual:value];</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -ignore: %@&quot;, self.name, RACDescription(value)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部是通过<code>filter</code>实现的，在<code>filter</code>的条件表达式中将信号返回的数据与我们指定的值进行了对比，相同时自动过滤掉~</p>
<h3 id="9-reduce"><a href="#9-reduce" class="headerlink" title="9.reduce"></a>9.reduce</h3><p><strong>作用</strong>：聚合，把多个信号返回的数据聚合到一处，以便对这些值进行相关处理。<br>&emsp;</p>
<p>此方法叫聚合，所以可以想象先要有数据需要它去整合，这些数据是独立的信号们发出的。<br>&emsp;</p>
<p>信号中并没有单独的<code>reduce</code>方法，它通常是与其他组合信号的方法结合使用的。以<code>combineLatest</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/// Combines signals using +combineLatest:, then reduces the resulting tuples</span><br><span class="line">/// into a single value using -reduceEach:.</span><br><span class="line">///</span><br><span class="line">/// signals     - The signals to combine. If this collection is empty, the</span><br><span class="line">///               returned signal will immediately complete upon subscription.</span><br><span class="line">/// reduceBlock - The block which reduces the latest values from all the</span><br><span class="line">///               signals into one value. It must take as many arguments as the</span><br><span class="line">///               number of signals given. Each argument will be an object</span><br><span class="line">///               argument. The return value must be an object. This argument</span><br><span class="line">///               must not be nil.</span><br><span class="line">///</span><br><span class="line">/// Example:</span><br><span class="line">///</span><br><span class="line">///   [RACSignal combineLatest:@[ stringSignal, intSignal ] reduce:^(NSString *string, NSNumber *number) &#123;</span><br><span class="line">///       return [NSString stringWithFormat:@&quot;%@: %@&quot;, string, number];</span><br><span class="line">///   &#125;];</span><br><span class="line">///</span><br><span class="line">/// Returns a signal which sends the results from each invocation of</span><br><span class="line">/// `reduceBlock`.</span><br><span class="line">+ (RACSignal&lt;ValueType&gt; *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(RACGenericReduceBlock)reduceBlock RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><code>combineLatest</code>将两个信号组合成了一个新的信号，新信号返回的数据是一个元组。<br>&emsp;</p>
<p><code>reduce</code>是对元组中的数据进行了聚合，返回值为一个新的字符串数据对象。<br>&emsp;</p>
<p><code>reduce</code>中聚合的数据的数量和类型与源信号的数量和数据类型保持一致。<br>&emsp;</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)reduce &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal2 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;2.1&quot;];</span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;2.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal3 = [RACSignal combineLatest:@[signal1,signal2]</span><br><span class="line">                                           reduce:^(NSString *str1, NSString *str2)&#123; // reduceBlock</span><br><span class="line">                                               return [@[str1,str2] componentsJoinedByString:@&quot;+&quot;];</span><br><span class="line">                                           &#125;];</span><br><span class="line">    </span><br><span class="line">    [signal3 subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++++received data:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++call signal2 block</span><br><span class="line">+++++received data:1+2.1</span><br><span class="line">+++++received data:1+2.2</span><br></pre></td></tr></table></figure>
<p>1.<code>combineLatest</code>将<code>信号1</code>和<code>信号2</code>进行了整合，当二者都发送数据后，这俩数据被整合进一个元组中；<br>&emsp;</p>
<p>2.<code>reduce</code>将元组中的数据聚合到了它的<code>reduceBlock</code>中，这样我们便有机会对这些数据做进一步的过滤和处理。<br>&emsp;</p>
<p>3.处理完的新数据会回调给<code>信号3</code>的订阅者。<br>&emsp;</p>
<p><strong>小结</strong>：信号虽无独立的<code>reduce</code>方法，但它与信号的组合结合时，便给了我们修改数据的机会，这就是我把它列入本章节的原因。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对使用者来说，RAC的这些过滤方法可说是很简单了，而这全仰仗<code>bind</code>方法，所以理解<code>bind</code>很关键。<br>&emsp;</p>
<p>最底层的<code>bidn</code>方法定义在<code>RACStream</code>中，这是一个基类，其内部对<code>bind</code>方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)bind:(RACStreamBindBlock (^)(void))block &#123;</span><br><span class="line">	NSString *reason = [NSString stringWithFormat:@&quot;%@ must be overridden by subclasses&quot;, NSStringFromSelector(_cmd)];</span><br><span class="line">	@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:reason userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是一个抽象的实现，具体的实现方式交给了它的各个子类：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_rac_cluster.png" alt="RAC类簇"></p>
<p>这很好的体现了<code>类簇</code>的思想，值得学习借鉴~<br>&emsp;</p>
<p>另外<code>map</code>、<code>filter</code>、<code>reduce</code>这几个方法在 Swift 中都有同名方法，似乎RAC也借鉴了<code>Swift</code>或者<code>RX</code>的一些理念。</p>
<hr>
<p>相关参考：</p>
<p>#<a href="https://github.com/ReactiveCocoa/ReactiveObjC" target="_blank" rel="noopener">©RAC-Github</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#RAC">
    <span class="tag-code">RAC</span>
  </a>

  <a href="/tags#源码">
    <span class="tag-code">源码</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/06/01/RAC-sig-order.html">
        <span class="nav-arrow">← </span>
        
          RAC-信号的组合
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#前言"><span class="toc-nav-text">前言</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-bind"><span class="toc-nav-text">1.bind</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-take"><span class="toc-nav-text">2.take</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-skip"><span class="toc-nav-text">3.skip</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-distinctUntilChanged"><span class="toc-nav-text">4.distinctUntilChanged</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-flattenMap"><span class="toc-nav-text">5.flattenMap</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-map"><span class="toc-nav-text">6.map</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-filter"><span class="toc-nav-text">7.filter</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-ignore"><span class="toc-nav-text">8.ignore</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-reduce"><span class="toc-nav-text">9.reduce</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#总结"><span class="toc-nav-text">总结</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/06/06/RAC-sig-filter.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "RAC-过滤信号返回的数据",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>