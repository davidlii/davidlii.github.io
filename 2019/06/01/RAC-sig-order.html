<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="This is Davidli&#39;s blog ~">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" type="image/ico" href="/image/logo.png"> 
  
  <title>
    
      RAC-信号的组合 | Davidli
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Davidli</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>RAC-信号的组合</h2>
  <p class="post-date">2019-06-01</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目中往往有多个<code>信号</code>在执行任务，而这些信号之间通常要按照一定的方式或顺序进行<code>组合</code>。比如：</p>
<ul>
<li>先要用户登录成功才能加载通讯录；</li>
<li>请求头像和用户信息都完成后才刷新详情页。</li>
</ul>
<p>RAC 针对诸如这些场景，设计了一套实用的API供我们组合信号：</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// Subscribes to `signal` when the source signal completes.</span><br><span class="line">- (RACSignal *)concat:(RACSignal *)signal RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用:</strong> 拼接信号流，将<code>信号1</code>与<code>信号2</code>拼接成新的信号，<code>信号1</code>状态为完成的时候才开始执行<code>信号2</code>中的任务。无论<code>信号1</code>和<code>信号2</code>谁先发送数据，新信号的订阅者最终都只会按<code>信号1</code>先<code>信号2</code>后的顺序收到回调。<br>&emsp;</p>
<p>#示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)concat &#123;</span><br><span class="line">// concat: concat左边的在前，右边的在后，二者发送数据后按照前后顺序分别触发一次新信号订阅者回调</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;1.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal2 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;2.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;2.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    RACSignal *signal3 = [signal1 concat:signal2];</span><br><span class="line">    [signal3 subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++++received data:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++++received data:1.1</span><br><span class="line">+++++received data:1.2</span><br><span class="line">+++call signal2 block</span><br><span class="line">+++++received data:2.1</span><br><span class="line">+++++received data:2.2</span><br></pre></td></tr></table></figure>
<p>说明:<br>&emsp;</p>
<p>1.<code>信号1</code>和<code>信号2</code>发送几次数据，<code>信号3</code>订阅者就收到几次数据；<br>&emsp;</p>
<p>2.<code>信号3</code>订阅者收到数据的顺序是确定的，按照拼接时的顺序来：<code>信号1</code>先，<code>信号2</code>后；<br>&emsp;</p>
<p>3.<code>concat</code>与<code>NSOperation</code>的依赖关系有点类似，<code>信号2</code>依赖于<code>信号1</code>，所以<code>信号2</code>要知道<code>信号1</code>的状态；<br>&emsp;</p>
<p>4.<code>信号1</code>在发送完数据之后记得<code>sendCompleted</code>，否则<code>信号2</code>的<code>^didSubscribe</code>不会触发，也就不会执行任务；<br>&emsp;</p>
<p>#实现原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)concat:(RACSignal *)signal &#123;</span><br><span class="line">	// 1.拼接时返回新的信号3</span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];</span><br><span class="line">		// 2.订阅信号3时立刻订阅信号1</span><br><span class="line">        RACDisposable *sourceDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line">			// 3.信号1 sendNext 后向信号3 的订阅者发送数据</span><br><span class="line">            [subscriber sendNext:x];</span><br><span class="line">		&#125; error:^(NSError *error) &#123;</span><br><span class="line">			[subscriber sendError:error];</span><br><span class="line">		&#125; completed:^&#123;</span><br><span class="line">			// 4.信号1 sendConpleted 后调用信号2的 didSubscribe()</span><br><span class="line">            RACDisposable *concattedDisposable = [signal subscribe:subscriber];</span><br><span class="line">			[compoundDisposable addDisposable:concattedDisposable];</span><br><span class="line">		&#125;];</span><br><span class="line"></span><br><span class="line">		[compoundDisposable addDisposable:sourceDisposable];</span><br><span class="line">		return compoundDisposable;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -concat: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">	NSCParameterAssert(subscriber != nil);</span><br><span class="line">    ...</span><br><span class="line">	if (self.didSubscribe != NULL) &#123;</span><br><span class="line">		RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">		    // 调用信号2的 didSubscribe()</span><br><span class="line">			RACDisposable *innerDisposable = self.didSubscribe(subscriber);</span><br><span class="line">			[disposable addDisposable:innerDisposable];</span><br><span class="line">		&#125;];</span><br><span class="line">		[disposable addDisposable:schedulingDisposable];</span><br><span class="line">	&#125;</span><br><span class="line">	return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中有注释，具体整理如下：</p>
<p><img src="https://davidlii.nos-eastchina1.126.net/pic_RAC_concat.png" alt="RAC_CONCAT"></p>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// Ignores all `next`s from the receiver, waits for the receiver to complete,</span><br><span class="line">/// then subscribes to a new signal.</span><br><span class="line">///</span><br><span class="line">/// block - A block which will create or obtain a new signal to subscribe to,</span><br><span class="line">///         executed only after the receiver completes. This block must not be</span><br><span class="line">///         nil, and it must not return a nil signal.</span><br><span class="line">///</span><br><span class="line">/// Returns a signal which will pass through the events of the signal created in</span><br><span class="line">/// `block`. If the receiver errors out, the returned signal will error as well.</span><br><span class="line">- (RACSignal *)then:(RACSignal * (^)(void))block RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用:</strong> 先执行<code>信号1</code>但过滤掉<code>信号1</code>的数据，再执行<code>信号2</code>的任务并获取其发送的数据。<br>&emsp;</p>
<p>#示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)then &#123;</span><br><span class="line">    // then：信号1先执行，信号2后执行,最后只获取信号2的数据</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        // 1</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;1.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        // 3</span><br><span class="line">        NSLog(@&quot;+++call signal2 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;2.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;2.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal3 = [signal1 then:^RACSignal * &#123;</span><br><span class="line">        // 2</span><br><span class="line">        NSLog(@&quot;++++call signal3 then&quot;);</span><br><span class="line">        return signal2;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [signal3 subscribeNext:^(id x) &#123;</span><br><span class="line">        // 4</span><br><span class="line">        NSLog(@&quot;++++received data:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">++++call signal3 then</span><br><span class="line">+++call signal2 block</span><br><span class="line">++++received data:2.1</span><br><span class="line">++++received data:2.2</span><br></pre></td></tr></table></figure>
<p>说明：<br>&emsp;</p>
<p>1.<code>信号1</code>发送的数据自动被过滤掉，<code>信号3</code>订阅者不会收到数据<code>信号1</code>的数据回调；<br>&emsp;</p>
<p>2.<code>信号2</code>发送几次数据，<code>信号3</code>的订阅者就收到几次数据；<br>&emsp;</p>
<p>3.<code>信号2</code>总是在<code>信号1</code>完成之后，才会开始执行自己的任务；<br>&emsp;</p>
<p>#实现原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)then:(RACSignal * (^)(void))block &#123;</span><br><span class="line">	NSCParameterAssert(block != nil);</span><br><span class="line"></span><br><span class="line">	return [[[self</span><br><span class="line">		ignoreValues]</span><br><span class="line">		concat:[RACSignal defer:block]]</span><br><span class="line">		setNameWithFormat:@&quot;[%@] -then:&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.先通过<code>ignoreValues</code>对<code>信号1</code>进行了过滤，忽略掉了它的<code>sendNext:</code>事件，只关注其<code>error</code>和<code>completed</code>事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// Ignores all `next`s from the receiver.</span><br><span class="line">///</span><br><span class="line">/// Returns a signal which only passes through `error` or `completed` events from</span><br><span class="line">/// the receiver.</span><br><span class="line">- (RACSignal *)ignoreValues RAC_WARN_UNUSED_RESULT;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)ignoreValues &#123;</span><br><span class="line">	return [[self filter:^(id _) &#123;</span><br><span class="line">		return NO;</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;[%@] -ignoreValues&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.再通过<code>[RACSignal defer:block]]</code>，将<code>信号2</code>封装到一个新信号中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/// Defers creation of a signal until the signal&apos;s actually subscribed to.</span><br><span class="line">///</span><br><span class="line">/// This can be used to effectively turn a hot signal into a cold signal.</span><br><span class="line">+ (RACSignal&lt;ValueType&gt; *)defer:(RACSignal&lt;ValueType&gt; * (^)(void))block RAC_WARN_UNUSED_RESULT;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)defer:(RACSignal&lt;id&gt; * (^)(void))block &#123;</span><br><span class="line">	NSCParameterAssert(block != NULL);</span><br><span class="line"></span><br><span class="line">	return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">		return [block() subscribe:subscriber];</span><br><span class="line">	&#125;] setNameWithFormat:@&quot;+defer:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.最后用<code>concat</code>方法将两个新信号进行拼接，先执行<code>信号1</code>的任务，再开始<code>信号2</code>的任务。</p>
<p>&emsp;<br>所以，从本质上来说，<code>then</code>最终调用的还是<code>concat</code>~</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/// Sends the latest `next` from any of the signals.</span><br><span class="line">///</span><br><span class="line">/// Returns a signal that passes through values from each of the given signals,</span><br><span class="line">/// and sends `completed` when all of them complete. If any signal sends an error,</span><br><span class="line">/// the returned signal sends `error` immediately.</span><br><span class="line">+ (RACSignal&lt;ValueType&gt; *)merge:(id&lt;NSFastEnumeration&gt;)signals RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用:</strong> 将n个信号整合为新<code>信号x</code>，信号之间不存在依赖关系，任何一个信号发送数据，信号x的订阅者都会收到回调，且遵循FIFO原则，谁先发送数据则订阅者就先收到谁的数据。<br>&emsp;</p>
<p>#示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)merge &#123;</span><br><span class="line">    // merge 谁先sendNext就先收到谁的数据</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;1.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal2 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;2.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;2.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal3 = [RACSignal merge:@[signal1,signal2]];</span><br><span class="line">    </span><br><span class="line">    [signal3 subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++++received data:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++++received data:1.1</span><br><span class="line">+++call signal2 block</span><br><span class="line">+++++received data:2.1</span><br><span class="line">+++++received data:1.2</span><br><span class="line">+++++received data:2.2</span><br></pre></td></tr></table></figure>
<p>说明：<br>&emsp;</p>
<p>1.<code>merge</code>将<code>信号1</code>和<code>信号2</code>整合到<code>信号3</code>中，1、2之间不会相互影响；<br>&emsp;</p>
<p>2.<code>信号1</code>和<code>信号2</code>发送新数据时，<code>信号3</code>都能收到新数据；</p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// Zips the values in the given signals to create RACTuples.</span><br><span class="line">///</span><br><span class="line">/// The first value of each signals will be combined, then the second value, and</span><br><span class="line">/// so forth, until at least one of the signals is exhausted.</span><br><span class="line">///</span><br><span class="line">/// signals - The signals to combine. If this collection is empty, the returned</span><br><span class="line">///           signal will be empty.</span><br><span class="line">///</span><br><span class="line">/// Returns a new signal containing RACTuples of the zipped values from the</span><br><span class="line">/// signals.</span><br><span class="line">+ (RACSignal&lt;RACTuple *&gt; *)zip:(id&lt;NSFastEnumeration&gt;)signals RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用:</strong> 将n个信号返回的数据合并到一个<code>元组</code>中，值在元组中的排序按照信号组合时的顺序来。<br>&emsp;</p>
<p>#示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)zip &#123;</span><br><span class="line">    // zip: 合并n个信号的值到一个元组中，哪个信号在前哪个信号的值就在元组中靠前</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal2 block&quot;);</span><br><span class="line">        </span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;2.1&quot;];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;2.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal3 = [RACSignal zip:@[signal1,signal2]];</span><br><span class="line">    </span><br><span class="line">    [signal3 subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++++received data:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+++call signal1 block</span><br><span class="line">+++call signal2 block</span><br><span class="line">+++++received data:&lt;RACTuple: 0x7ff33e4bbab0&gt; (</span><br><span class="line">    1,</span><br><span class="line">    &quot;2.1&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>说明：<br>&emsp;</p>
<p>1.<code>信号3</code>的订阅者要在组合中的信号都<code>sendNext:</code>之后才会收到回调的元组；<br>&emsp;</p>
<p>2.<code>信号3</code>元组中数据的顺序与组合时信号的顺序排列一致；<br>&emsp;</p>
<p>3.<code>信号3</code>的订阅者收到一次数据之后，不论源信号再发送几次数据，它都不再接受新数据。</p>
<h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/// Combines the latest values from the given signals into RACTuples, once all</span><br><span class="line">/// the signals have sent at least one `next`.</span><br><span class="line">///</span><br><span class="line">/// Any additional `next`s will result in a new RACTuple with the latest values</span><br><span class="line">/// from all signals.</span><br><span class="line">///</span><br><span class="line">/// signals - The signals to combine. If this collection is empty, the returned</span><br><span class="line">///           signal will immediately complete upon subscription.</span><br><span class="line">///</span><br><span class="line">/// Returns a signal which sends RACTuples of the combined values, forwards any</span><br><span class="line">/// `error` events, and completes when all input signals complete.</span><br><span class="line">+ (RACSignal&lt;RACTuple *&gt; *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals RAC_WARN_UNUSED_RESULT;</span><br></pre></td></tr></table></figure>
<p><strong>作用:</strong> 将多个信号的<code>最新值</code>组合到新信号的一个<code>元组</code>中，直到所有的信号都<code>sendNext</code>之后，新信号的订阅者才能收到此元组。<br>&emsp;</p>
<p>#示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)combineLatest &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal1 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;1&quot;];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal2 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;2.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;2.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal3 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        NSLog(@&quot;+++call signal3 block&quot;);</span><br><span class="line">        [subscriber sendNext:@&quot;3.1&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@&quot;3.2&quot;];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal4 = [RACSignal combineLatest:@[signal1,signal2,signal3]];</span><br><span class="line">    </span><br><span class="line">    [signal4 subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;+++++received data:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日志:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">2019-06-01 02:30:08.894 +++call signal1 block</span><br><span class="line">2019-06-01 02:30:08.895 +++call signal2 block</span><br><span class="line">2019-06-01 02:30:08.895 +++call signal3 block</span><br><span class="line">2019-06-01 02:30:08.896 +++++received data:&lt;RACTuple: 0x7ff33e49e300&gt; (</span><br><span class="line">    1,</span><br><span class="line">    &quot;2.1&quot;,</span><br><span class="line">    &quot;3.1&quot;</span><br><span class="line">)</span><br><span class="line">2019-06-01 02:30:10.895 +++++received data:&lt;RACTuple: 0x7ff33e4db8d0&gt; (</span><br><span class="line">    1,</span><br><span class="line">    &quot;2.2&quot;,</span><br><span class="line">    &quot;3.1&quot;</span><br><span class="line">)</span><br><span class="line">2019-06-01 02:30:11.094 +++++received data:&lt;RACTuple: 0x7ff33e6e79f0&gt; (</span><br><span class="line">    1,</span><br><span class="line">    &quot;2.2&quot;,</span><br><span class="line">    &quot;3.2&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是：<br>&emsp;</p>
<p>1.<code>信号4</code>订阅者的元组中数据的顺序，是按照组合时的顺序来的；<br>&emsp;</p>
<p>2.<code>信号4</code>的订阅者第一次触发是在所有信号都发送了一遍<code>sendNext:</code>之后；<br>&emsp;</p>
<p>3.之后如果再有某个信号<code>sendNext:</code>，<code>信号4</code>都会再次触发并返回最新值组成的元组；</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>以上就是RAC中几种常用组合信号的方法，使用时可以根据业务需求任意组合操作，很强大、方便。</p>
<hr>
<p>相关参考：</p>
<p>#<a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/BasicOperators.md" target="_blank" rel="noopener">©RAC-Github</a></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#RAC">
    <span class="tag-code">RAC</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/05/25/RAC-async.html">
        <span class="nav-arrow">← </span>
        
          RAC-异步行为
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#前言"><span class="toc-nav-text">前言</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#concat"><span class="toc-nav-text">concat</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#then"><span class="toc-nav-text">then</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#merge"><span class="toc-nav-text">merge</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#zip"><span class="toc-nav-text">zip</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#combineLatest"><span class="toc-nav-text">combineLatest</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#结束语"><span class="toc-nav-text">结束语</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/06/01/RAC-sig-order.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "RAC-信号的组合",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | <a href="https://github.com/davidlii" target="_blank">Davidli</a>
    <br>
    <a href="https://hexo.io" target="_blank">Hexo</a> | Theme-<a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>